<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/ARCHITECTURE_OPTIMIZATION.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ARCHITECTURE_OPTIMIZATION.md" />
              <option name="originalContent" value="# CTU-Connect Architecture Optimization Plan&#10;## Based on Facebook's Social Network Model&#10;&#10;### Current Architecture Analysis&#10;- ✅ Microservices architecture with proper service separation&#10;- ✅ Event-driven communication via Kafka&#10;- ✅ Multiple database technologies (PostgreSQL, MongoDB, Neo4j, Redis)&#10;- ✅ API Gateway for centralized routing&#10;- ✅ Service discovery with Eureka&#10;&#10;### Key Optimizations Required&#10;- Implement eventual consistency patterns&#10;#### 1. Data Consistency &amp; Flow Optimization&#10;- Implement eventual consistency patterns&#10;- Add distributed transaction management&#10;- Optimize cross-service data synchronization&#10;&#10;#### 3. Social Graph Optimization&#10;- Friend suggestion algorithms&#10;#### 2. Enhanced Post System (Facebook-like)&#10;- Timeline generation algorithms&#10;- News feed ranking and personalization&#10;- Real-time updates and notifications&#10;- Database optimization and indexing&#10;- Load balancing and horizontal scaling&#10;&#10;#### 5. Real-time Features&#10;#### 3. Social Graph Optimization&#10;- Friend suggestion algorithms&#10;- Privacy controls and audience targeting&#10;- Activity feed generation&#10;- Real-time chat and comments&#10;- Activity status tracking&#10;#### 4. Performance &amp; Scalability&#10;- Caching strategies at multiple levels&#10;#### 5. Real-time Features&#10;- Live notifications&#10;- Real-time chat and comments&#10;- Activity status tracking&#10;" />
              <option name="updatedContent" value="# CTU-Connect Architecture Optimization Plan&#10;## Based on Facebook's Social Network Model&#10;&#10;### Current Architecture Analysis&#10;- ✅ Microservices architecture with proper service separation&#10;- ✅ Event-driven communication via Kafka&#10;- ✅ Multiple database technologies (PostgreSQL, MongoDB, Neo4j, Redis)&#10;- ✅ API Gateway for centralized routing&#10;- ✅ Service discovery with Eureka&#10;&#10;## COMPLETED OPTIMIZATIONS&#10;&#10;### 1. Enhanced Data Models (Facebook-like)&#10;&#10;#### Enhanced PostEntity&#10;- **Audience Targeting**: Similar to Facebook's privacy controls with granular audience settings&#10;- **Engagement Metrics**: Real-time engagement scoring for feed ranking algorithms&#10;- **Post Types**: Support for TEXT, IMAGE, VIDEO, LINK, POLL, EVENT, SHARED&#10;- **Location Support**: Geographic tagging capabilities&#10;- **Scheduled Posts**: Ability to schedule posts for future publishing&#10;- **Edit History**: Track post modifications with timestamps&#10;&#10;#### Advanced Social Graph (Neo4j)&#10;- **Friend Suggestions**: Multi-signal algorithm using mutual friends, academic connections, profile viewers&#10;- **Relationship Types**: FRIENDS_WITH, FRIEND_REQUEST_SENT, VIEWED_PROFILE, BLOCKED&#10;- **Academic Context**: Faculty, major, and batch-based connections&#10;- **Interaction History**: Track user interactions for personalization&#10;&#10;### 2. Facebook-like News Feed Algorithm&#10;&#10;#### NewsFeedService Implementation&#10;- **Personalized Ranking**: Multi-factor scoring system&#10;  - Friend relationship weight (1.0)&#10;  - Engagement score weight (0.8)&#10;  - Recency weight (0.6)&#10;  - Content relevance weight (0.7)&#10;- **Cache Strategy**: 30-minute feed cache with intelligent invalidation&#10;- **Over-fetching**: Retrieve 3x posts for optimal ranking&#10;- **Diversity Control**: Prevent feed domination by single authors&#10;&#10;#### Feed Types&#10;- **Personalized Feed**: User-specific content based on social graph&#10;- **Trending Posts**: Engagement-based trending algorithm&#10;- **User Timeline**: Profile-specific post timeline with privacy filtering&#10;&#10;### 3. Real-time Notification System&#10;&#10;#### NotificationService Features&#10;- **Real-time WebSocket**: Instant notifications via SimpMessagingTemplate&#10;- **Event-driven**: Kafka integration for scalable notification processing&#10;- **Notification Types**: POST_LIKED, COMMENTED, SHARED, FRIEND_REQUEST, etc.&#10;- **Bulk Notifications**: Efficient handling of viral content notifications&#10;- **Unread Counters**: Redis-cached unread notification counts&#10;&#10;### 4. Data Consistency Management&#10;&#10;#### DataConsistencyService&#10;- **Eventual Consistency**: Cross-service data synchronization&#10;- **Cache Invalidation**: Smart cache invalidation on data changes&#10;- **Compensation Logic**: Failure handling and retry mechanisms&#10;- **Event Sourcing**: Kafka-based event propagation&#10;&#10;### 5. Advanced Caching Strategy&#10;&#10;#### Multi-level Caching&#10;- **Redis Caching**: &#10;  - User data (24 hours TTL)&#10;  - Posts (6 hours TTL)&#10;  - Friend suggestions (6 hours TTL)&#10;  - News feed (30 minutes TTL)&#10;- **Application-level**: In-memory caching for frequently accessed data&#10;- **Database-level**: Optimized queries and indexing&#10;&#10;### 6. Social Graph Optimization&#10;&#10;#### SocialGraphService Features&#10;- **Friend Suggestions Algorithm**:&#10;  - Mutual friends (highest priority)&#10;  - Academic connections (faculty/major/batch)&#10;  - Friends of friends&#10;  - Profile viewers&#10;  - Similar interests&#10;- **Relevance Scoring**: Multi-factor relevance calculation&#10;- **Cache Management**: 6-hour TTL with smart invalidation&#10;&#10;### 7. Performance Enhancements&#10;&#10;#### Database Optimizations&#10;- **MongoDB**: Compound indexes for posts, engagement-based sorting&#10;- **Neo4j**: Optimized Cypher queries for relationship traversal&#10;- **PostgreSQL**: Proper indexing for auth and media services&#10;- **Redis**: Strategic caching and session management&#10;&#10;#### API Optimizations&#10;- **Pagination**: Consistent pagination across all endpoints&#10;- **Bulk Operations**: Efficient batch processing for notifications&#10;- **Async Processing**: CompletableFuture for non-blocking operations&#10;&#10;### 8. Enhanced Security &amp; Privacy&#10;&#10;#### Privacy Controls&#10;- **Audience Settings**: PUBLIC, FRIENDS, CUSTOM, ONLY_ME&#10;- **Academic Targeting**: Faculty/major/batch-specific visibility&#10;- **Block Lists**: User blocking functionality&#10;- **Profile Privacy**: Granular profile visibility controls&#10;&#10;### 9. Real-time Features&#10;&#10;#### WebSocket Integration&#10;- **Live Notifications**: Real-time notification delivery&#10;- **Activity Status**: User online/offline status tracking&#10;- **Real-time Comments**: Live comment updates on posts&#10;&#10;### 10. Monitoring &amp; Health Checks&#10;&#10;#### System Monitoring&#10;- **Health Indicators**: Redis, MongoDB, Neo4j health checks&#10;- **Performance Metrics**: Engagement rates, cache hit ratios&#10;- **Error Tracking**: Comprehensive logging and error handling&#10;&#10;## IMPLEMENTATION SUMMARY&#10;&#10;### New Services Created&#10;1. **NewsFeedService** - Facebook-like feed generation&#10;2. **NotificationService** - Real-time notification system&#10;3. **SocialGraphService** - Advanced friend suggestions&#10;4. **DataConsistencyService** - Cross-service data synchronization&#10;&#10;### Enhanced Controllers&#10;1. **EnhancedPostController** - Advanced post management&#10;2. **EnhancedUserController** - Social graph operations&#10;&#10;### Data Models Enhanced&#10;- **PostEntity** - Facebook-like post features&#10;- **NotificationEntity** - Rich notification system&#10;- **FriendSuggestionDTO** - Comprehensive suggestion data&#10;&#10;### Configuration Added&#10;- **CacheConfig** - Multi-level caching strategy&#10;- **HealthCheckConfig** - System health monitoring&#10;&#10;## FACEBOOK-INSPIRED FEATURES IMPLEMENTED&#10;&#10;### Content &amp; Engagement&#10;✅ **News Feed Algorithm** - Personalized content ranking&#10;✅ **Post Types** - Text, image, video, link, poll support&#10;✅ **Reactions System** - Like, love, laugh, etc.&#10;✅ **Comments &amp; Replies** - Threaded comment system&#10;✅ **Share Functionality** - Post sharing with attribution&#10;✅ **Trending Posts** - Viral content discovery&#10;&#10;### Social Features&#10;✅ **Friend Suggestions** - Multi-signal recommendation engine&#10;✅ **Mutual Friends** - Connection discovery&#10;✅ **Academic Networks** - University-specific connections&#10;✅ **People You May Know** - Profile viewer suggestions&#10;✅ **Friend Requests** - Connection management&#10;&#10;### Privacy &amp; Security&#10;✅ **Audience Controls** - Granular post visibility&#10;✅ **Academic Targeting** - Faculty/major-based sharing&#10;✅ **Block/Unblock** - User blocking system&#10;✅ **Profile Privacy** - Customizable profile visibility&#10;&#10;### Real-time Features&#10;✅ **Live Notifications** - Instant activity updates  &#10;✅ **Real-time Comments** - Live comment updates&#10;✅ **Activity Status** - Online presence tracking&#10;✅ **WebSocket Integration** - Real-time communication&#10;&#10;### Performance &amp; Scale&#10;✅ **Multi-level Caching** - Redis + application caching&#10;✅ **Event-driven Architecture** - Kafka message streaming&#10;✅ **Database Optimization** - Proper indexing and queries&#10;✅ **Load Balancing Ready** - Horizontal scaling support&#10;&#10;## DEPLOYMENT RECOMMENDATIONS&#10;&#10;### 1. Database Scaling&#10;- **MongoDB Sharding** for post data&#10;- **Neo4j Clustering** for social graph&#10;- **Redis Clustering** for caching layer&#10;&#10;### 2. Performance Monitoring&#10;- Implement APM tools (New Relic, DataDog)&#10;- Set up alerts for cache hit ratios&#10;- Monitor database query performance&#10;&#10;### 3. Content Delivery&#10;- Integrate CDN for media files&#10;- Implement image/video optimization&#10;- Add progressive loading for feeds&#10;&#10;### 4. Security Enhancements&#10;- Rate limiting on API endpoints&#10;- Content moderation system&#10;- Spam detection algorithms&#10;&#10;This comprehensive optimization transforms your CTU-Connect platform into a robust, scalable social network with Facebook-like capabilities while maintaining the academic focus of your original vision." />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/client-frontend/src/app/posts/page.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/client-frontend/src/app/posts/page.tsx" />
              <option name="updatedContent" value="'use client';&#10;&#10;import React, { useState, useEffect } from 'react';&#10;import { Post, PaginatedResponse } from '@/types';&#10;import { postService } from '@/services/postService';&#10;import { CreatePost } from '@/components/post/CreatePost';&#10;import { PostCard } from '@/components/post/PostCard';&#10;import { LoadingSpinner } from '@/components/ui/LoadingSpinner';&#10;import { ErrorAlert } from '@/components/ui/ErrorAlert';&#10;import { Button } from '@/components/ui/Button';&#10;import { Plus, RefreshCw } from 'lucide-react';&#10;&#10;export default function PostsPage() {&#10;  const [posts, setPosts] = useState&lt;Post[]&gt;([]);&#10;  const [isLoading, setIsLoading] = useState(true);&#10;  const [error, setError] = useState&lt;string | null&gt;(null);&#10;  const [showCreatePost, setShowCreatePost] = useState(false);&#10;&#10;  const loadPosts = async () =&gt; {&#10;    try {&#10;      setIsLoading(true);&#10;      setError(null);&#10;      const response: PaginatedResponse&lt;Post&gt; = await postService.getPosts();&#10;      setPosts(response.content);&#10;    } catch (err: any) {&#10;      console.error('Failed to load posts:', err);&#10;      setError(err.response?.data?.message || err.message || 'Failed to load posts');&#10;    } finally {&#10;      setIsLoading(false);&#10;    }&#10;  };&#10;&#10;  useEffect(() =&gt; {&#10;    loadPosts();&#10;  }, []);&#10;&#10;  const handlePostCreated = (newPost: Post) =&gt; {&#10;    setPosts(prev =&gt; [newPost, ...prev]);&#10;    setShowCreatePost(false);&#10;  };&#10;&#10;  const handlePostUpdate = (updatedPost: Post) =&gt; {&#10;    setPosts(prev =&gt; prev.map(post =&gt; &#10;      post.id === updatedPost.id ? updatedPost : post&#10;    ));&#10;  };&#10;&#10;  const handlePostDelete = (postId: string) =&gt; {&#10;    setPosts(prev =&gt; prev.filter(post =&gt; post.id !== postId));&#10;  };&#10;&#10;  if (isLoading) {&#10;    return (&#10;      &lt;div className=&quot;min-h-screen bg-gray-50 flex items-center justify-center&quot;&gt;&#10;        &lt;LoadingSpinner size=&quot;lg&quot; /&gt;&#10;      &lt;/div&gt;&#10;    );&#10;  }&#10;&#10;  return (&#10;    &lt;div className=&quot;min-h-screen bg-gray-50&quot;&gt;&#10;      &lt;div className=&quot;max-w-2xl mx-auto py-8 px-4&quot;&gt;&#10;        {/* Header */}&#10;        &lt;div className=&quot;flex items-center justify-between mb-6&quot;&gt;&#10;          &lt;h1 className=&quot;text-2xl font-bold text-gray-900&quot;&gt;Posts&lt;/h1&gt;&#10;          &lt;div className=&quot;flex gap-2&quot;&gt;&#10;            &lt;Button&#10;              variant=&quot;secondary&quot;&#10;              onClick={loadPosts}&#10;              disabled={isLoading}&#10;              className=&quot;flex items-center gap-2&quot;&#10;            &gt;&#10;              &lt;RefreshCw className={`w-4 h-4 ${isLoading ? 'animate-spin' : ''}`} /&gt;&#10;              Refresh&#10;            &lt;/Button&gt;&#10;            &lt;Button&#10;              onClick={() =&gt; setShowCreatePost(true)}&#10;              className=&quot;flex items-center gap-2&quot;&#10;            &gt;&#10;              &lt;Plus className=&quot;w-4 h-4&quot; /&gt;&#10;              Create Post&#10;            &lt;/Button&gt;&#10;          &lt;/div&gt;&#10;        &lt;/div&gt;&#10;&#10;        {/* Create Post Form */}&#10;        {showCreatePost &amp;&amp; (&#10;          &lt;div className=&quot;mb-6&quot;&gt;&#10;            &lt;CreatePost&#10;              onPostCreated={handlePostCreated}&#10;              onCancel={() =&gt; setShowCreatePost(false)}&#10;            /&gt;&#10;          &lt;/div&gt;&#10;        )}&#10;&#10;        {/* Error Display */}&#10;        {error &amp;&amp; (&#10;          &lt;div className=&quot;mb-6&quot;&gt;&#10;            &lt;ErrorAlert message={error} /&gt;&#10;          &lt;/div&gt;&#10;        )}&#10;&#10;        {/* Posts List */}&#10;        {posts.length === 0 ? (&#10;          &lt;div className=&quot;text-center py-12&quot;&gt;&#10;            &lt;div className=&quot;text-gray-400 mb-4&quot;&gt;&#10;              &lt;Plus className=&quot;w-16 h-16 mx-auto&quot; /&gt;&#10;            &lt;/div&gt;&#10;            &lt;h3 className=&quot;text-lg font-medium text-gray-900 mb-2&quot;&gt;No posts yet&lt;/h3&gt;&#10;            &lt;p className=&quot;text-gray-500 mb-4&quot;&gt;Be the first to create a post!&lt;/p&gt;&#10;            &lt;Button onClick={() =&gt; setShowCreatePost(true)}&gt;&#10;              Create First Post&#10;            &lt;/Button&gt;&#10;          &lt;/div&gt;&#10;        ) : (&#10;          &lt;div className=&quot;space-y-6&quot;&gt;&#10;            {posts.map((post) =&gt; (&#10;              &lt;PostCard&#10;                key={post.id}&#10;                post={post}&#10;                onPostUpdate={handlePostUpdate}&#10;                onPostDelete={handlePostDelete}&#10;              /&gt;&#10;            ))}&#10;          &lt;/div&gt;&#10;        )}&#10;      &lt;/div&gt;&#10;    &lt;/div&gt;&#10;  );&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/client-frontend/src/shared/services/post.service.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/client-frontend/src/shared/services/post.service.ts" />
              <option name="originalContent" value="import { apiClient } from '@/shared/config/api-client';&#10;import { API_ENDPOINTS } from '@/shared/constants';&#10;import { createApiUrl } from '@/shared/utils';&#10;import {&#10;  Post,&#10;  Comment,&#10;  CreatePostRequest,&#10;  UpdatePostRequest,&#10;  CreateCommentRequest,&#10;  UpdateCommentRequest,&#10;  PaginatedResponse,&#10;  ApiResponse,&#10;  PostVisibility,&#10;} from '@/shared/types';&#10;&#10;/**&#10; * Post Service&#10; * Handles all post-related API calls&#10; * Handles all post-related API calls&#10; */&#10;export class PostService {&#10;   * Create new post&#10;   * Create new post&#10;    const formData = new FormData();&#10;    formData.append('content', postData.content);&#10;&#10;    if (postData.visibility) {&#10;      formData.append('visibility', postData.visibility);&#10;    }&#10;    formData.append('content', postData.content);&#10;    if (postData.tags) {&#10;      postData.tags.forEach(tag =&gt; formData.append('tags', tag));&#10;    }&#10;&#10;    if (postData.images) {&#10;      postData.images.forEach(image =&gt; formData.append('images', image));&#10;    }&#10;&#10;    return apiClient.post&lt;Post&gt;(API_ENDPOINTS.POSTS.BASE, formData, {&#10;      headers: {&#10;        'Content-Type': 'multipart/form-data',&#10;      },&#10;    });&#10;      postData.tags.forEach(tag =&gt; formData.append('tags', tag));&#10;    }&#10;&#10;    if (postData.images) {&#10;      postData.images.forEach(image =&gt; formData.append('images', image));&#10;    }&#10;&#10;    return apiClient.post&lt;Post&gt;(API_ENDPOINTS.POSTS.BASE, formData, {&#10;      headers: {&#10;        'Content-Type': 'multipart/form-data',&#10;      },&#10;    });&#10;  }&#10;&#10;  /**&#10;   * Get posts feed&#10;   */&#10;  async getPosts(page = 0, size = 10): Promise&lt;PaginatedResponse&lt;Post&gt;&gt; {&#10;    const url = createApiUrl(API_ENDPOINTS.POSTS.BASE, undefined, { page, size });&#10;    return apiClient.get&lt;PaginatedResponse&lt;Post&gt;&gt;(url);&#10;  }&#10;&#10;  /**&#10;   * Get single post by ID&#10;   */&#10;  async getPost(postId: string): Promise&lt;Post&gt; {&#10;    const url = createApiUrl(API_ENDPOINTS.POSTS.BASE + '/:id', { id: postId });&#10;    return apiClient.get&lt;Post&gt;(url);&#10;  }&#10;&#10;  /**&#10;   * Get posts by user&#10;   */&#10;  async getUserPosts(&#10;    userId: string,&#10;    page = 0,&#10;    size = 10&#10;  ): Promise&lt;PaginatedResponse&lt;Post&gt;&gt; {&#10;    const url = createApiUrl(&#10;      API_ENDPOINTS.POSTS.BY_USER,&#10;      { id: userId },&#10;      { page, size }&#10;    );&#10;    return apiClient.get&lt;PaginatedResponse&lt;Post&gt;&gt;(url);&#10;  }&#10;&#10;  /**&#10;   * Update post&#10;   */&#10;  async updatePost(postId: string, updateData: UpdatePostRequest): Promise&lt;Post&gt; {&#10;    const url = createApiUrl(API_ENDPOINTS.POSTS.BASE + '/:id', { id: postId });&#10;    return apiClient.put&lt;Post&gt;(url, updateData);&#10;  }&#10;&#10;  /**&#10;   * Delete post&#10;   */&#10;  async deletePost(postId: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#10;    const url = createApiUrl(API_ENDPOINTS.POSTS.BASE + '/:id', { id: postId });&#10;    return apiClient.delete&lt;ApiResponse&lt;null&gt;&gt;(url);&#10;  }&#10;&#10;  /**&#10;   * Like post&#10;   */&#10;  async likePost(postId: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#10;    const url = createApiUrl(API_ENDPOINTS.POSTS.LIKE, { id: postId });&#10;    return apiClient.post&lt;ApiResponse&lt;null&gt;&gt;(url);&#10;  }&#10;&#10;  /**&#10;   * Unlike post&#10;   */&#10;  async unlikePost(postId: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#10;    const url = createApiUrl(API_ENDPOINTS.POSTS.LIKE, { id: postId });&#10;    return apiClient.delete&lt;ApiResponse&lt;null&gt;&gt;(url);&#10;  }&#10;&#10;  /**&#10;   * Get post comments&#10;   */&#10;  async getComments(&#10;    postId: string,&#10;    page = 0,&#10;    size = 10&#10;  ): Promise&lt;PaginatedResponse&lt;Comment&gt;&gt; {&#10;    const url = createApiUrl(&#10;      API_ENDPOINTS.POSTS.COMMENTS,&#10;      { id: postId },&#10;      { page, size }&#10;    );&#10;    return apiClient.get&lt;PaginatedResponse&lt;Comment&gt;&gt;(url);&#10;  }&#10;&#10;  /**&#10;   * Create comment&#10;   */&#10;  async createComment(commentData: CreateCommentRequest): Promise&lt;Comment&gt; {&#10;    const url = createApiUrl(API_ENDPOINTS.POSTS.COMMENTS, { id: commentData.postId });&#10;    return apiClient.post&lt;Comment&gt;(url, {&#10;      content: commentData.content,&#10;      parentId: commentData.parentId,&#10;    });&#10;  }&#10;&#10;  /**&#10;   * Update comment&#10;   */&#10;  async updateComment(&#10;    commentId: string,&#10;    updateData: UpdateCommentRequest&#10;  ): Promise&lt;Comment&gt; {&#10;    const url = createApiUrl('/comments/:id', { id: commentId });&#10;    return apiClient.put&lt;Comment&gt;(url, updateData);&#10;  }&#10;&#10;  /**&#10;   * Delete comment&#10;   */&#10;  async deleteComment(commentId: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#10;    const url = createApiUrl('/comments/:id', { id: commentId });&#10;    return apiClient.delete&lt;ApiResponse&lt;null&gt;&gt;(url);&#10;  }&#10;&#10;  /**&#10;   * Like comment&#10;   */&#10;  async likeComment(commentId: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#10;    const url = createApiUrl(API_ENDPOINTS.POSTS.COMMENT_LIKE, { id: commentId });&#10;    return apiClient.post&lt;ApiResponse&lt;null&gt;&gt;(url);&#10;  }&#10;&#10;  /**&#10;   * Unlike comment&#10;   */&#10;  async unlikeComment(commentId: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#10;    const url = createApiUrl(API_ENDPOINTS.POSTS.COMMENT_LIKE, { id: commentId });&#10;    return apiClient.delete&lt;ApiResponse&lt;null&gt;&gt;(url);&#10;  }&#10;&#10;  /**&#10;   * Share post&#10;   */&#10;  async sharePost(postId: string, content?: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#10;    const url = createApiUrl('/posts/:id/share', { id: postId });&#10;    return apiClient.post&lt;ApiResponse&lt;null&gt;&gt;(url, { content });&#10;  }&#10;&#10;  /**&#10;   * Bookmark post&#10;   */&#10;  async bookmarkPost(postId: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#10;    const url = createApiUrl('/posts/:id/bookmark', { id: postId });&#10;    return apiClient.post&lt;ApiResponse&lt;null&gt;&gt;(url);&#10;  }&#10;&#10;  /**&#10;   * Remove bookmark&#10;   */&#10;  async removeBookmark(postId: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#10;    const url = createApiUrl('/posts/:id/bookmark', { id: postId });&#10;    return apiClient.delete&lt;ApiResponse&lt;null&gt;&gt;(url);&#10;  }&#10;}&#10;&#10;// Export singleton instance&#10;export const postService = new PostService();&#10;" />
              <option name="updatedContent" value="import { apiClient } from '@/shared/config/api-client';&#13;&#10;import { API_ENDPOINTS } from '@/shared/constants';&#13;&#10;import { createApiUrl } from '@/shared/utils';&#13;&#10;import {&#13;&#10;  Post,&#13;&#10;  Comment,&#13;&#10;  CreatePostRequest,&#13;&#10;  UpdatePostRequest,&#13;&#10;  CreateCommentRequest,&#13;&#10;  UpdateCommentRequest,&#13;&#10;  PaginatedResponse,&#13;&#10;  ApiResponse,&#13;&#10;  PostVisibility,&#13;&#10;} from '@/shared/types';&#13;&#10;&#13;&#10;/**&#13;&#10; * Post Service - Updated to sync with backend APIs&#13;&#10; */&#13;&#10;export class PostService {&#13;&#10;  /**&#13;&#10;   * Create new post - Updated to match EnhancedPostController&#13;&#10;   */&#13;&#10;  async createPost(postData: CreatePostRequest): Promise&lt;Post&gt; {&#13;&#10;    // Use JSON instead of FormData to match EnhancedPostController&#13;&#10;    return apiClient.post&lt;Post&gt;(API_ENDPOINTS.POSTS.BASE, postData);&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Get personalized feed - Updated to match backend&#13;&#10;   */&#13;&#10;  async getPersonalizedFeed(page = 0, size = 10): Promise&lt;Post[]&gt; {&#13;&#10;    const url = createApiUrl(API_ENDPOINTS.POSTS.FEED, undefined, { page, size });&#13;&#10;    return apiClient.get&lt;Post[]&gt;(url);&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Get posts feed&#13;&#10;   */&#13;&#10;  async getPosts(page = 0, size = 10): Promise&lt;PaginatedResponse&lt;Post&gt;&gt; {&#13;&#10;    const url = createApiUrl(API_ENDPOINTS.POSTS.BASE, undefined, { page, size });&#13;&#10;    return apiClient.get&lt;PaginatedResponse&lt;Post&gt;&gt;(url);&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Get single post by ID&#13;&#10;   */&#13;&#10;  async getPost(postId: string): Promise&lt;Post&gt; {&#13;&#10;    const url = createApiUrl(API_ENDPOINTS.POSTS.BASE + '/:id', { id: postId });&#13;&#10;    return apiClient.get&lt;Post&gt;(url);&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Get posts by user&#13;&#10;   */&#13;&#10;  async getUserPosts(&#13;&#10;    userId: string,&#13;&#10;    page = 0,&#13;&#10;    size = 10&#13;&#10;  ): Promise&lt;PaginatedResponse&lt;Post&gt;&gt; {&#13;&#10;    const url = createApiUrl(&#13;&#10;      API_ENDPOINTS.POSTS.BY_USER,&#13;&#10;      { id: userId },&#13;&#10;      { page, size }&#13;&#10;    );&#13;&#10;    return apiClient.get&lt;PaginatedResponse&lt;Post&gt;&gt;(url);&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Update post&#13;&#10;   */&#13;&#10;  async updatePost(postId: string, updateData: UpdatePostRequest): Promise&lt;Post&gt; {&#13;&#10;    const url = createApiUrl(API_ENDPOINTS.POSTS.BASE + '/:id', { id: postId });&#13;&#10;    return apiClient.put&lt;Post&gt;(url, updateData);&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Delete post&#13;&#10;   */&#13;&#10;  async deletePost(postId: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#13;&#10;    const url = createApiUrl(API_ENDPOINTS.POSTS.BASE + '/:id', { id: postId });&#13;&#10;    return apiClient.delete&lt;ApiResponse&lt;null&gt;&gt;(url);&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Like post&#13;&#10;   */&#13;&#10;  async likePost(postId: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#13;&#10;    const url = createApiUrl(API_ENDPOINTS.POSTS.LIKE, { id: postId });&#13;&#10;    return apiClient.post&lt;ApiResponse&lt;null&gt;&gt;(url);&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Unlike post&#13;&#10;   */&#13;&#10;  async unlikePost(postId: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#13;&#10;    const url = createApiUrl(API_ENDPOINTS.POSTS.LIKE, { id: postId });&#13;&#10;    return apiClient.delete&lt;ApiResponse&lt;null&gt;&gt;(url);&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Get post comments&#13;&#10;   */&#13;&#10;  async getComments(&#13;&#10;    postId: string,&#13;&#10;    page = 0,&#13;&#10;    size = 10&#13;&#10;  ): Promise&lt;PaginatedResponse&lt;Comment&gt;&gt; {&#13;&#10;    const url = createApiUrl(&#13;&#10;      API_ENDPOINTS.POSTS.COMMENTS,&#13;&#10;      { id: postId },&#13;&#10;      { page, size }&#13;&#10;    );&#13;&#10;    return apiClient.get&lt;PaginatedResponse&lt;Comment&gt;&gt;(url);&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Create comment&#13;&#10;   */&#13;&#10;  async createComment(commentData: CreateCommentRequest): Promise&lt;Comment&gt; {&#13;&#10;    const url = createApiUrl(API_ENDPOINTS.POSTS.COMMENTS, { id: commentData.postId });&#13;&#10;    return apiClient.post&lt;Comment&gt;(url, {&#13;&#10;      content: commentData.content,&#13;&#10;      parentId: commentData.parentId,&#13;&#10;    });&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Update comment&#13;&#10;   */&#13;&#10;  async updateComment(&#13;&#10;    commentId: string,&#13;&#10;    updateData: UpdateCommentRequest&#13;&#10;  ): Promise&lt;Comment&gt; {&#13;&#10;    const url = createApiUrl('/comments/:id', { id: commentId });&#13;&#10;    return apiClient.put&lt;Comment&gt;(url, updateData);&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Delete comment&#13;&#10;   */&#13;&#10;  async deleteComment(commentId: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#13;&#10;    const url = createApiUrl('/comments/:id', { id: commentId });&#13;&#10;    return apiClient.delete&lt;ApiResponse&lt;null&gt;&gt;(url);&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Like comment&#13;&#10;   */&#13;&#10;  async likeComment(commentId: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#13;&#10;    const url = createApiUrl(API_ENDPOINTS.POSTS.COMMENT_LIKE, { id: commentId });&#13;&#10;    return apiClient.post&lt;ApiResponse&lt;null&gt;&gt;(url);&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Unlike comment&#13;&#10;   */&#13;&#10;  async unlikeComment(commentId: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#13;&#10;    const url = createApiUrl(API_ENDPOINTS.POSTS.COMMENT_LIKE, { id: commentId });&#13;&#10;    return apiClient.delete&lt;ApiResponse&lt;null&gt;&gt;(url);&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Share post&#13;&#10;   */&#13;&#10;  async sharePost(postId: string, content?: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#13;&#10;    const url = createApiUrl('/posts/:id/share', { id: postId });&#13;&#10;    return apiClient.post&lt;ApiResponse&lt;null&gt;&gt;(url, { content });&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Bookmark post&#13;&#10;   */&#13;&#10;  async bookmarkPost(postId: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#13;&#10;    const url = createApiUrl('/posts/:id/bookmark', { id: postId });&#13;&#10;    return apiClient.post&lt;ApiResponse&lt;null&gt;&gt;(url);&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Remove bookmark&#13;&#10;   */&#13;&#10;  async removeBookmark(postId: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#13;&#10;    const url = createApiUrl('/posts/:id/bookmark', { id: postId });&#13;&#10;    return apiClient.delete&lt;ApiResponse&lt;null&gt;&gt;(url);&#13;&#10;  }&#13;&#10;}&#13;&#10;&#13;&#10;// Export singleton instance&#13;&#10;export const postService = new PostService();" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/PostServiceApplication.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/PostServiceApplication.java" />
              <option name="originalContent" value="package com.ctuconnect;&#10;&#10;import org.springframework.boot.SpringApplication;&#10;import org.springframework.boot.autoconfigure.SpringBootApplication;&#10;import org.springframework.cloud.client.discovery.EnableDiscoveryClient;&#10;import org.springframework.cloud.openfeign.EnableFeignClients;&#10;import org.springframework.kafka.annotation.EnableKafka;&#10;&#10;@SpringBootApplication&#10;@EnableDiscoveryClient&#10;@EnableFeignClients&#10;@EnableKafka&#10;public class PostServiceApplication {&#10;&#10;    public static void main(String[] args) {&#10;        SpringApplication.run(PostServiceApplication.class, args);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.ctuconnect;&#13;&#10;&#13;&#10;import org.springframework.boot.SpringApplication;&#13;&#10;import org.springframework.boot.autoconfigure.SpringBootApplication;&#13;&#10;import org.springframework.cloud.client.discovery.EnableDiscoveryClient;&#13;&#10;import org.springframework.cloud.openfeign.EnableFeignClients;&#13;&#10;import org.springframework.kafka.annotation.EnableKafka;&#13;&#10;import org.springframework.data.mongodb.config.EnableMongoAuditing;&#13;&#10;&#13;&#10;@SpringBootApplication&#13;&#10;@EnableDiscoveryClient&#13;&#10;@EnableFeignClients&#13;&#10;@EnableKafka&#13;&#10;@EnableMongoAuditing // Enable MongoDB auditing for @CreatedDate and @LastModifiedDate&#13;&#10;public class PostServiceApplication {&#13;&#10;&#13;&#10;    public static void main(String[] args) {&#13;&#10;        SpringApplication.run(PostServiceApplication.class, args);&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/client/MediaServiceClient.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/client/MediaServiceClient.java" />
              <option name="originalContent" value="package com.ctuconnect.client;&#10;&#10;import lombok.Data;&#10;import org.springframework.cloud.openfeign.FeignClient;&#10;import org.springframework.http.MediaType;&#10;import org.springframework.web.bind.annotation.*;&#10;import org.springframework.web.multipart.MultipartFile;&#10;&#10;&#10;@FeignClient(name = &quot;media-service&quot;, url = &quot;${media-service.url:http://localhost:8080}&quot;)&#10;public interface MediaServiceClient {&#10;&#10;    @PostMapping(value = &quot;/api/media/upload&quot;, consumes = MediaType.MULTIPART_FORM_DATA_VALUE)&#10;    MediaUploadResponse uploadFile(@RequestPart(&quot;file&quot;) MultipartFile file,&#10;                                  @RequestParam(&quot;type&quot;) String type);&#10;&#10;    @DeleteMapping(&quot;/api/media/{id}&quot;)&#10;    void deleteFile(@PathVariable(&quot;id&quot;) String fileId);&#10;&#10;    @GetMapping(&quot;/api/media/{id}&quot;)&#10;    MediaResponse getFileInfo(@PathVariable(&quot;id&quot;) String fileId);&#10;&#10;    // Response DTOs for media service&#10;    class MediaUploadResponse {&#10;        private String id;&#10;        private String fileName;&#10;        private String fileUrl;&#10;        private String fileType;&#10;        private long fileSize;&#10;&#10;        // Getters and Setters&#10;        public String getId() {&#10;            return id;&#10;        }&#10;&#10;        public void setId(String id) {&#10;            this.id = id;&#10;        }&#10;&#10;        public String getFileName() {&#10;            return fileName;&#10;        }&#10;&#10;        public void setFileName(String fileName) {&#10;            this.fileName = fileName;&#10;        }&#10;&#10;        public String getFileUrl() {&#10;            return fileUrl;&#10;        }&#10;&#10;        public void setFileUrl(String fileUrl) {&#10;            this.fileUrl = fileUrl;&#10;        }&#10;&#10;        public String getFileType() {&#10;            return fileType;&#10;        }&#10;&#10;        public void setFileType(String fileType) {&#10;            this.fileType = fileType;&#10;        }&#10;&#10;        public long getFileSize() {&#10;            return fileSize;&#10;        }&#10;&#10;        public void setFileSize(long fileSize) {&#10;            this.fileSize = fileSize;&#10;        }&#10;    }&#10;&#10;    @Data&#10;    class MediaResponse {&#10;        private String id;&#10;        private String fileName;&#10;        private String fileUrl;&#10;        private String fileType;&#10;        private long fileSize;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.ctuconnect.client;&#13;&#10;&#13;&#10;import lombok.Data;&#13;&#10;import org.springframework.cloud.openfeign.FeignClient;&#13;&#10;import org.springframework.http.MediaType;&#13;&#10;import org.springframework.web.bind.annotation.*;&#13;&#10;import org.springframework.web.multipart.MultipartFile;&#13;&#10;import com.ctuconnect.config.FeignConfig;&#13;&#10;&#13;&#10;@FeignClient(&#13;&#10;    name = &quot;media-service&quot;, &#13;&#10;    url = &quot;${media-service.url}&quot;, &#13;&#10;    configuration = FeignConfig.class&#13;&#10;)&#13;&#10;public interface MediaServiceClient {&#13;&#10;&#13;&#10;    @PostMapping(value = &quot;/api/media/upload&quot;, consumes = MediaType.MULTIPART_FORM_DATA_VALUE)&#13;&#10;    MediaUploadResponse uploadFile(@RequestPart(&quot;file&quot;) MultipartFile file,&#13;&#10;                                  @RequestParam(&quot;type&quot;) String type);&#13;&#10;&#13;&#10;    @DeleteMapping(&quot;/api/media/{id}&quot;)&#13;&#10;    void deleteFile(@PathVariable(&quot;id&quot;) String fileId);&#13;&#10;&#13;&#10;    @GetMapping(&quot;/api/media/{id}&quot;)&#13;&#10;    MediaResponse getFileInfo(@PathVariable(&quot;id&quot;) String fileId);&#13;&#10;&#13;&#10;    // Response DTOs for media service&#13;&#10;    class MediaUploadResponse {&#13;&#10;        private String id;&#13;&#10;        private String fileName;&#13;&#10;        private String fileUrl;&#13;&#10;        private String fileType;&#13;&#10;        private long fileSize;&#13;&#10;&#13;&#10;        // Getters and Setters&#13;&#10;        public String getId() {&#13;&#10;            return id;&#13;&#10;        }&#13;&#10;&#13;&#10;        public void setId(String id) {&#13;&#10;            this.id = id;&#13;&#10;        }&#13;&#10;&#13;&#10;        public String getFileName() {&#13;&#10;            return fileName;&#13;&#10;        }&#13;&#10;&#13;&#10;        public void setFileName(String fileName) {&#13;&#10;            this.fileName = fileName;&#13;&#10;        }&#13;&#10;&#13;&#10;        public String getFileUrl() {&#13;&#10;            return fileUrl;&#13;&#10;        }&#13;&#10;&#13;&#10;        public void setFileUrl(String fileUrl) {&#13;&#10;            this.fileUrl = fileUrl;&#13;&#10;        }&#13;&#10;&#13;&#10;        public String getFileType() {&#13;&#10;            return fileType;&#13;&#10;        }&#13;&#10;&#13;&#10;        public void setFileType(String fileType) {&#13;&#10;            this.fileType = fileType;&#13;&#10;        }&#13;&#10;&#13;&#10;        public long getFileSize() {&#13;&#10;            return fileSize;&#13;&#10;        }&#13;&#10;&#13;&#10;        public void setFileSize(long fileSize) {&#13;&#10;            this.fileSize = fileSize;&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    @Data&#13;&#10;    class MediaResponse {&#13;&#10;        private String id;&#13;&#10;        private String fileName;&#13;&#10;        private String fileUrl;&#13;&#10;        private String fileType;&#13;&#10;        private long fileSize;&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/client/UserServiceClientFallback.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/client/UserServiceClientFallback.java" />
              <option name="updatedContent" value="package com.ctuconnect.client;&#10;&#10;import com.ctuconnect.dto.AuthorInfo;&#10;import lombok.extern.slf4j.Slf4j;&#10;import org.springframework.stereotype.Component;&#10;&#10;import java.util.HashSet;&#10;import java.util.Set;&#10;&#10;/**&#10; * Fallback implementation for UserServiceClient when user-service is unavailable&#10; * Provides default values to prevent service failures&#10; */&#10;@Component&#10;@Slf4j&#10;public class UserServiceClientFallback implements UserServiceClient {&#10;&#10;    @Override&#10;    public AuthorInfo getAuthorInfo(String authorId) {&#10;        log.warn(&quot;User service unavailable, returning fallback author info for user: {}&quot;, authorId);&#10;        return AuthorInfo.builder()&#10;                .userId(authorId)&#10;                .username(&quot;Unknown User&quot;)&#10;                .fullName(&quot;Unknown User&quot;)&#10;                .avatarUrl(null)&#10;                .isVerified(false)&#10;                .build();&#10;    }&#10;&#10;    @Override&#10;    public Set&lt;String&gt; getFriendIds(String userId) {&#10;        log.warn(&quot;User service unavailable, returning empty friend list for user: {}&quot;, userId);&#10;        return new HashSet&lt;&gt;();&#10;    }&#10;&#10;    @Override&#10;    public Set&lt;String&gt; getCloseInteractionIds(String userId) {&#10;        log.warn(&quot;User service unavailable, returning empty close interactions for user: {}&quot;, userId);&#10;        return new HashSet&lt;&gt;();&#10;    }&#10;&#10;    @Override&#10;    public Set&lt;String&gt; getSameFacultyUserIds(String userId) {&#10;        log.warn(&quot;User service unavailable, returning empty same faculty users for user: {}&quot;, userId);&#10;        return new HashSet&lt;&gt;();&#10;    }&#10;&#10;    @Override&#10;    public Set&lt;String&gt; getSameMajorUserIds(String userId) {&#10;        log.warn(&quot;User service unavailable, returning empty same major users for user: {}&quot;, userId);&#10;        return new HashSet&lt;&gt;();&#10;    }&#10;&#10;    @Override&#10;    public Set&lt;String&gt; getUserInterestTags(String userId) {&#10;        log.warn(&quot;User service unavailable, returning empty interest tags for user: {}&quot;, userId);&#10;        return new HashSet&lt;&gt;();&#10;    }&#10;&#10;    @Override&#10;    public Set&lt;String&gt; getUserPreferredCategories(String userId) {&#10;        log.warn(&quot;User service unavailable, returning empty preferred categories for user: {}&quot;, userId);&#10;        return new HashSet&lt;&gt;();&#10;    }&#10;&#10;    @Override&#10;    public String getUserFacultyId(String userId) {&#10;        log.warn(&quot;User service unavailable, returning null faculty ID for user: {}&quot;, userId);&#10;        return null;&#10;    }&#10;&#10;    @Override&#10;    public String getUserMajorId(String userId) {&#10;        log.warn(&quot;User service unavailable, returning null major ID for user: {}&quot;, userId);&#10;        return null;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/config/CacheConfig.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/config/CacheConfig.java" />
              <option name="updatedContent" value="package com.ctuconnect.config;&#10;&#10;import org.springframework.beans.factory.annotation.Value;&#10;import org.springframework.context.annotation.Bean;&#10;import org.springframework.context.annotation.Configuration;&#10;import org.springframework.data.redis.connection.RedisConnectionFactory;&#10;import org.springframework.data.redis.connection.lettuce.LettuceConnectionFactory;&#10;import org.springframework.data.redis.core.RedisTemplate;&#10;import org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer;&#10;import org.springframework.data.redis.serializer.StringRedisSerializer;&#10;&#10;@Configuration&#10;public class CacheConfig {&#10;&#10;    @Value(&quot;${spring.data.redis.host:localhost}&quot;)&#10;    private String redisHost;&#10;&#10;    @Value(&quot;${spring.data.redis.port:6379}&quot;)&#10;    private int redisPort;&#10;&#10;    @Bean&#10;    public RedisConnectionFactory redisConnectionFactory() {&#10;        return new LettuceConnectionFactory(redisHost, redisPort);&#10;    }&#10;&#10;    @Bean&#10;    public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory connectionFactory) {&#10;        RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;();&#10;        template.setConnectionFactory(connectionFactory);&#10;        &#10;        // Use String serializer for keys&#10;        template.setKeySerializer(new StringRedisSerializer());&#10;        template.setHashKeySerializer(new StringRedisSerializer());&#10;        &#10;        // Use JSON serializer for values&#10;        template.setValueSerializer(new GenericJackson2JsonRedisSerializer());&#10;        template.setHashValueSerializer(new GenericJackson2JsonRedisSerializer());&#10;        &#10;        template.afterPropertiesSet();&#10;        return template;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/config/FeignConfig.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/config/FeignConfig.java" />
              <option name="updatedContent" value="package com.ctuconnect.config;&#10;&#10;import feign.Logger;&#10;import feign.Request;&#10;import feign.Retryer;&#10;import feign.codec.ErrorDecoder;&#10;import org.springframework.context.annotation.Bean;&#10;import org.springframework.context.annotation.Configuration;&#10;&#10;import java.util.concurrent.TimeUnit;&#10;&#10;/**&#10; * Feign client configuration for better error handling and retry mechanism&#10; */&#10;@Configuration&#10;public class FeignConfig {&#10;&#10;    @Bean&#10;    Logger.Level feignLoggerLevel() {&#10;        return Logger.Level.BASIC;&#10;    }&#10;&#10;    @Bean&#10;    public Request.Options requestOptions() {&#10;        return new Request.Options(&#10;                10, TimeUnit.SECONDS, // connect timeout&#10;                60, TimeUnit.SECONDS, // read timeout&#10;                true // follow redirects&#10;        );&#10;    }&#10;&#10;    @Bean&#10;    public Retryer retryer() {&#10;        return new Retryer.Default(&#10;                1000, // initial interval&#10;                3000, // max interval&#10;                3     // max attempts&#10;        );&#10;    }&#10;&#10;    @Bean&#10;    public ErrorDecoder errorDecoder() {&#10;        return new CustomFeignErrorDecoder();&#10;    }&#10;&#10;    /**&#10;     * Custom error decoder to handle service communication errors gracefully&#10;     */&#10;    public static class CustomFeignErrorDecoder implements ErrorDecoder {&#10;        &#10;        @Override&#10;        public Exception decode(String methodKey, feign.Response response) {&#10;            switch (response.status()) {&#10;                case 400:&#10;                    return new IllegalArgumentException(&quot;Bad Request: &quot; + methodKey);&#10;                case 404:&#10;                    return new RuntimeException(&quot;Service not found: &quot; + methodKey);&#10;                case 500:&#10;                    return new RuntimeException(&quot;Internal Server Error in &quot; + methodKey);&#10;                case 503:&#10;                    return new RuntimeException(&quot;Service Unavailable: &quot; + methodKey);&#10;                default:&#10;                    return new RuntimeException(&quot;Unknown error occurred in &quot; + methodKey + &quot;: &quot; + response.status());&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/config/HealthCheckConfig.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/config/HealthCheckConfig.java" />
              <option name="updatedContent" value="package com.ctuconnect.config;&#10;&#10;import org.springframework.boot.actuator.health.Health;&#10;import org.springframework.boot.actuator.health.HealthIndicator;&#10;import org.springframework.context.annotation.Bean;&#10;import org.springframework.context.annotation.Configuration;&#10;import org.springframework.data.redis.connection.RedisConnectionFactory;&#10;import org.springframework.data.mongodb.core.MongoTemplate;&#10;&#10;@Configuration&#10;public class HealthCheckConfig {&#10;    &#10;    @Bean&#10;    public HealthIndicator redisHealthIndicator(RedisConnectionFactory redisConnectionFactory) {&#10;        return () -&gt; {&#10;            try {&#10;                redisConnectionFactory.getConnection().ping();&#10;                return Health.up()&#10;                    .withDetail(&quot;redis&quot;, &quot;Available&quot;)&#10;                    .build();&#10;            } catch (Exception e) {&#10;                return Health.down()&#10;                    .withDetail(&quot;redis&quot;, &quot;Unavailable&quot;)&#10;                    .withDetail(&quot;error&quot;, e.getMessage())&#10;                    .build();&#10;            }&#10;        };&#10;    }&#10;    &#10;    @Bean&#10;    public HealthIndicator mongoHealthIndicator(MongoTemplate mongoTemplate) {&#10;        return () -&gt; {&#10;            try {&#10;                mongoTemplate.getCollection(&quot;health_check&quot;).countDocuments();&#10;                return Health.up()&#10;                    .withDetail(&quot;mongodb&quot;, &quot;Available&quot;)&#10;                    .build();&#10;            } catch (Exception e) {&#10;                return Health.down()&#10;                    .withDetail(&quot;mongodb&quot;, &quot;Unavailable&quot;)&#10;                    .withDetail(&quot;error&quot;, e.getMessage())&#10;                    .build();&#10;            }&#10;        };&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/config/WebConfig.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/config/WebConfig.java" />
              <option name="updatedContent" value="package com.ctuconnect.config;&#10;&#10;import com.ctuconnect.security.AuthenticationInterceptor;&#10;import lombok.RequiredArgsConstructor;&#10;import org.springframework.context.annotation.Configuration;&#10;import org.springframework.web.servlet.config.annotation.InterceptorRegistry;&#10;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;&#10;&#10;/**&#10; * Web configuration to register security interceptors&#10; */&#10;@Configuration&#10;@RequiredArgsConstructor&#10;public class WebConfig implements WebMvcConfigurer {&#10;&#10;    private final AuthenticationInterceptor authenticationInterceptor;&#10;&#10;    @Override&#10;    public void addInterceptors(InterceptorRegistry registry) {&#10;        registry.addInterceptor(authenticationInterceptor)&#10;                .addPathPatterns(&quot;/api/**&quot;) // Apply to all API endpoints&#10;                .excludePathPatterns(&#10;                        &quot;/api/posts/health&quot;,&#10;                        &quot;/api/posts/actuator/**&quot;,&#10;                        &quot;/api/posts/swagger-ui/**&quot;,&#10;                        &quot;/api/posts/v3/api-docs/**&quot;&#10;                );&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/config/WebSocketConfig.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/config/WebSocketConfig.java" />
              <option name="updatedContent" value="package com.ctuconnect.config;&#10;&#10;import org.springframework.context.annotation.Configuration;&#10;import org.springframework.messaging.simp.config.MessageBrokerRegistry;&#10;import org.springframework.web.socket.config.annotation.EnableWebSocketMessageBroker;&#10;import org.springframework.web.socket.config.annotation.StompEndpointRegistry;&#10;import org.springframework.web.socket.config.annotation.WebSocketMessageBrokerConfigurer;&#10;&#10;@Configuration&#10;@EnableWebSocketMessageBroker&#10;public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {&#10;&#10;    @Override&#10;    public void configureMessageBroker(MessageBrokerRegistry config) {&#10;        // Enable simple message broker for in-memory message handling&#10;        config.enableSimpleBroker(&quot;/topic&quot;, &quot;/queue&quot;);&#10;        config.setApplicationDestinationPrefixes(&quot;/app&quot;);&#10;        config.setUserDestinationPrefix(&quot;/user&quot;);&#10;    }&#10;&#10;    @Override&#10;    public void registerStompEndpoints(StompEndpointRegistry registry) {&#10;        // Register STOMP endpoints for WebSocket connections&#10;        registry.addEndpoint(&quot;/ws&quot;)&#10;                .setAllowedOriginPatterns(&quot;*&quot;)&#10;                .withSockJS();&#10;        &#10;        registry.addEndpoint(&quot;/ws-notifications&quot;)&#10;                .setAllowedOriginPatterns(&quot;*&quot;)&#10;                .withSockJS();&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/controller/EnhancedPostController.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/controller/EnhancedPostController.java" />
              <option name="updatedContent" value="// This file has been merged into PostController.java&#10;// Delete this file to avoid conflicts" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/repository/CommentRepository.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/repository/CommentRepository.java" />
              <option name="originalContent" value="package com.ctuconnect.repository;&#10;&#10;import org.springframework.data.domain.Page;&#10;import org.springframework.data.domain.Pageable;&#10;import org.springframework.data.mongodb.repository.MongoRepository;&#10;import org.springframework.data.mongodb.repository.Query;&#10;import org.springframework.stereotype.Repository;&#10;import com.ctuconnect.entity.CommentEntity;&#10;&#10;import java.util.List;&#10;&#10;@Repository&#10;public interface CommentRepository extends MongoRepository&lt;CommentEntity, String&gt; {&#10;&#10;    Page&lt;CommentEntity&gt; findByPostId(String postId, Pageable pageable);&#10;&#10;    List&lt;CommentEntity&gt; findByPostIdAndParentCommentIdIsNull(String postId);&#10;&#10;    List&lt;CommentEntity&gt; findByParentCommentId(String parentCommentId);&#10;&#10;    long countByPostId(String postId);&#10;&#10;    // Fix: Use MongoDB query for nested author object&#10;    @Query(value = &quot;{ 'author.id': ?0 }&quot;, count = true)&#10;    long countByAuthor_Id(String authorId);&#10;&#10;    void deleteByPostId(String postId);&#10;&#10;    // Additional useful queries for nested author structure&#10;    @Query(&quot;{ 'author.id': ?0 }&quot;)&#10;    Page&lt;CommentEntity&gt; findByAuthor_Id(String authorId, Pageable pageable);&#10;&#10;    // Add method that AdminController is calling (without underscore)&#10;    @Query(value = &quot;{ 'author.id': ?0 }&quot;, count = true)&#10;    long countByAuthorId(String authorId);&#10;}&#10;" />
              <option name="updatedContent" value="package com.ctuconnect.repository;&#13;&#10;&#13;&#10;import org.springframework.data.domain.Page;&#13;&#10;import org.springframework.data.domain.Pageable;&#13;&#10;import org.springframework.data.mongodb.repository.MongoRepository;&#13;&#10;import org.springframework.data.mongodb.repository.Query;&#13;&#10;import org.springframework.stereotype.Repository;&#13;&#10;import com.ctuconnect.entity.CommentEntity;&#13;&#10;&#13;&#10;import java.util.List;&#13;&#10;&#13;&#10;@Repository&#13;&#10;public interface CommentRepository extends MongoRepository&lt;CommentEntity, String&gt; {&#13;&#10;&#13;&#10;    Page&lt;CommentEntity&gt; findByPostId(String postId, Pageable pageable);&#13;&#10;&#13;&#10;    List&lt;CommentEntity&gt; findByPostIdAndParentCommentIdIsNull(String postId);&#13;&#10;&#13;&#10;    List&lt;CommentEntity&gt; findByParentCommentId(String parentCommentId);&#13;&#10;&#13;&#10;    long countByPostId(String postId);&#13;&#10;&#13;&#10;    // Fix: Use MongoDB query for nested author object&#13;&#10;    @Query(value = &quot;{ 'author.id': ?0 }&quot;, count = true)&#13;&#10;    long countByAuthor_Id(String authorId);&#13;&#10;&#13;&#10;    void deleteByPostId(String postId);&#13;&#10;&#13;&#10;    // Additional useful queries for nested author structure&#13;&#10;    @Query(&quot;{ 'author.id': ?0 }&quot;)&#13;&#10;    Page&lt;CommentEntity&gt; findByAuthor_Id(String authorId, Pageable pageable);&#13;&#10;&#13;&#10;    // Add method that AdminController is calling (without underscore)&#13;&#10;    @Query(value = &quot;{ 'author.id': ?0 }&quot;, count = true)&#13;&#10;    long countByAuthorId(String authorId);&#13;&#10;&#13;&#10;    // Method for user profile synchronization - find all comments by author ID&#13;&#10;    @Query(&quot;{ 'author.id': ?0 }&quot;)&#13;&#10;    List&lt;CommentEntity&gt; findByAuthor_Id(String authorId);&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/service/UserServiceClient.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/service/UserServiceClient.java" />
              <option name="updatedContent" value="package com.ctuconnect.service;&#10;&#10;import org.springframework.cloud.openfeign.FeignClient;&#10;import org.springframework.web.bind.annotation.GetMapping;&#10;import org.springframework.web.bind.annotation.PathVariable;&#10;&#10;import java.util.Set;&#10;&#10;@FeignClient(name = &quot;user-service&quot;, url = &quot;${user-service.url:http://user-service:8081}&quot;)&#10;public interface UserServiceClient {&#10;    &#10;    @GetMapping(&quot;/api/users/{userId}/friends/ids&quot;)&#10;    Set&lt;String&gt; getFriendIds(@PathVariable String userId);&#10;    &#10;    @GetMapping(&quot;/api/users/{userId}/close-interactions&quot;)&#10;    Set&lt;String&gt; getCloseInteractionIds(@PathVariable String userId);&#10;    &#10;    @GetMapping(&quot;/api/users/{userId}/same-faculty&quot;)&#10;    Set&lt;String&gt; getSameFacultyUserIds(@PathVariable String userId);&#10;    &#10;    @GetMapping(&quot;/api/users/{userId}/same-major&quot;)&#10;    Set&lt;String&gt; getSameMajorUserIds(@PathVariable String userId);&#10;    &#10;    @GetMapping(&quot;/api/users/{userId}/interest-tags&quot;)&#10;    Set&lt;String&gt; getUserInterestTags(@PathVariable String userId);&#10;    &#10;    @GetMapping(&quot;/api/users/{userId}/preferred-categories&quot;)&#10;    Set&lt;String&gt; getUserPreferredCategories(@PathVariable String userId);&#10;    &#10;    @GetMapping(&quot;/api/users/{userId}/faculty-id&quot;)&#10;    String getUserFacultyId(@PathVariable String userId);&#10;    &#10;    @GetMapping(&quot;/api/users/{userId}/major-id&quot;)&#10;    String getUserMajorId(@PathVariable String userId);&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/post-service/src/main/resources/application-docker.properties">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/post-service/src/main/resources/application-docker.properties" />
              <option name="originalContent" value="# Docker-specific configuration for post-service&#10;spring.application.name=post-service&#10;server.port=8085&#10;&#10;# MongoDB Configuration - Docker service name&#10;spring.data.mongodb.database=post_db&#10;spring.data.mongodb.host=post_db&#10;spring.data.mongodb.port=27017&#10;&#10;# Redis Configuration - Docker service name&#10;spring.data.redis.host=redis&#10;spring.data.redis.port=6379&#10;spring.data.redis.timeout=60000ms&#10;spring.data.redis.lettuce.pool.max-active=8&#10;spring.data.redis.lettuce.pool.max-idle=8&#10;spring.data.redis.lettuce.pool.min-idle=0&#10;&#10;# Kafka Configuration - Docker service name&#10;spring.kafka.bootstrap-servers=kafka:9092&#10;spring.kafka.producer.key-serializer=org.apache.kafka.common.serialization.StringSerializer&#10;spring.kafka.producer.value-serializer=org.springframework.kafka.support.serializer.JsonSerializer&#10;&#10;spring.kafka.consumer.group-id=post-service-group&#10;spring.kafka.consumer.key-deserializer=org.apache.kafka.common.serialization.StringDeserializer&#10;spring.kafka.consumer.value-deserializer=org.springframework.kafka.support.serializer.JsonDeserializer&#10;spring.kafka.consumer.properties.spring.json.trusted.packages=*&#10;spring.kafka.consumer.auto-offset-reset=earliest&#10;spring.kafka.consumer.enable-auto-commit=true&#10;&#10;# Eureka Configuration - Docker service name&#10;eureka.client.service-url.defaultZone=http://eureka-server:8761/eureka/&#10;eureka.instance.prefer-ip-address=true&#10;eureka.instance.instance-id=${spring.application.name}:${server.port}&#10;&#10;# Media Service Configuration - Docker service name&#10;media-service.url=http://media-service:8084&#10;&#10;# File Upload Configuration&#10;spring.servlet.multipart.max-file-size=10MB&#10;spring.servlet.multipart.max-request-size=50MB&#10;&#10;# Actuator Configuration&#10;management.endpoints.web.exposure.include=health,info,metrics&#10;management.endpoint.health.show-details=always&#10;&#10;# Logging Configuration&#10;logging.level.com.ctuconnect=DEBUG&#10;logging.level.org.springframework.kafka=INFO&#10;logging.level.org.springframework.data.mongodb=INFO&#10;" />
              <option name="updatedContent" value="# Docker-specific configuration for post-service&#13;&#10;spring.application.name=post-service&#13;&#10;server.port=8085&#13;&#10;&#13;&#10;# MongoDB Configuration - Docker service name&#13;&#10;spring.data.mongodb.database=post_db&#13;&#10;spring.data.mongodb.host=post_db&#13;&#10;spring.data.mongodb.port=27017&#13;&#10;&#13;&#10;# Redis Configuration - Docker service name&#13;&#10;spring.data.redis.host=redis&#13;&#10;spring.data.redis.port=6379&#13;&#10;spring.data.redis.timeout=60000ms&#13;&#10;spring.data.redis.lettuce.pool.max-active=8&#13;&#10;spring.data.redis.lettuce.pool.min-idle=0&#13;&#10;&#13;&#10;# Kafka Configuration - Docker service name&#13;&#10;spring.kafka.bootstrap-servers=kafka:9092&#13;&#10;spring.kafka.producer.key-serializer=org.apache.kafka.common.serialization.StringSerializer&#13;&#10;spring.kafka.producer.value-serializer=org.springframework.kafka.support.serializer.JsonSerializer&#13;&#10;&#13;&#10;spring.kafka.consumer.group-id=post-service-group&#13;&#10;spring.kafka.consumer.key-deserializer=org.apache.kafka.common.serialization.StringDeserializer&#13;&#10;spring.kafka.consumer.value-deserializer=org.springframework.kafka.support.serializer.JsonDeserializer&#13;&#10;spring.kafka.consumer.properties.spring.json.trusted.packages=*&#13;&#10;spring.kafka.consumer.auto-offset-reset=earliest&#13;&#10;spring.kafka.consumer.enable-auto-commit=true&#13;&#10;&#13;&#10;# Eureka Configuration - Docker service name&#13;&#10;eureka.client.service-url.defaultZone=http://eureka-server:8761/eureka/&#13;&#10;eureka.instance.prefer-ip-address=true&#13;&#10;eureka.instance.instance-id=${spring.application.name}:${server.port}&#13;&#10;&#13;&#10;# User Service Configuration - Docker service name&#13;&#10;user-service.url=http://user-service:8081&#13;&#10;&#13;&#10;# Media Service Configuration - Docker service name&#13;&#10;media-service.url=http://media-service:8084&#13;&#10;&#13;&#10;# Feign Configuration&#13;&#10;feign.client.config.default.connect-timeout=10000&#13;&#10;feign.client.config.default.read-timeout=10000&#13;&#10;feign.client.config.default.logger-level=basic&#13;&#10;&#13;&#10;# File Upload Configuration&#13;&#10;spring.servlet.multipart.max-file-size=10MB&#13;&#10;spring.servlet.multipart.max-request-size=50MB&#13;&#10;&#13;&#10;# Actuator Configuration&#13;&#10;management.endpoints.web.exposure.include=health,info,metrics&#13;&#10;management.endpoint.health.show-details=always&#13;&#10;&#13;&#10;# Logging Configuration&#13;&#10;logging.level.com.ctuconnect=DEBUG&#13;&#10;logging.level.org.springframework.kafka=INFO&#13;&#10;logging.level.org.springframework.data.mongodb=INFO" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/post-service/src/main/resources/application.properties">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/post-service/src/main/resources/application.properties" />
              <option name="originalContent" value="spring.application.name=post-service&#10;server.port=8085&#10;&#10;# MongoDB Configuration&#10;spring.data.mongodb.database=post_db&#10;spring.data.mongodb.host=localhost&#10;spring.data.mongodb.port=27018&#10;&#10;# Kafka Configuration&#10;spring.kafka.bootstrap-servers=localhost:9092&#10;spring.kafka.producer.key-serializer=org.apache.kafka.common.serialization.StringSerializer&#10;spring.kafka.producer.value-serializer=org.springframework.kafka.support.serializer.JsonSerializer&#10;&#10;# Kafka Consumer Configuration - Fix missing group-id error&#10;spring.kafka.consumer.group-id=post-service-group&#10;spring.kafka.consumer.key-deserializer=org.apache.kafka.common.serialization.StringDeserializer&#10;spring.kafka.consumer.value-deserializer=org.springframework.kafka.support.serializer.JsonDeserializer&#10;spring.kafka.consumer.properties.spring.json.trusted.packages=*&#10;spring.kafka.consumer.auto-offset-reset=earliest&#10;spring.kafka.consumer.enable-auto-commit=true&#10;&#10;# Eureka Configuration&#10;eureka.client.service-url.defaultZone=http://localhost:8761/eureka/&#10;eureka.instance.prefer-ip-address=true&#10;eureka.instance.instance-id=${spring.application.name}:${server.port}&#10;&#10;# Redis Configuration - Fix for Docker container networking&#10;spring.data.redis.host=redis&#10;spring.data.redis.port=6379&#10;spring.data.redis.timeout=60000ms&#10;spring.data.redis.lettuce.pool.max-active=8&#10;spring.data.redis.lettuce.pool.max-idle=8&#10;spring.data.redis.lettuce.pool.min-idle=0&#10;&#10;# Media Service Configuration&#10;media-service.url=http://localhost:8084&#10;&#10;# File Upload Configuration&#10;spring.servlet.multipart.max-file-size=10MB&#10;spring.servlet.multipart.max-request-size=50MB&#10;&#10;# Actuator Configuration&#10;management.endpoints.web.exposure.include=health,info,metrics&#10;management.endpoint.health.show-details=always&#10;&#10;# Logging Configuration&#10;logging.level.vn.ctu.edu.postservice=DEBUG&#10;logging.level.org.springframework.kafka=INFO&#10;logging.level.org.springframework.data.mongodb=INFO&#10;" />
              <option name="updatedContent" value="spring.application.name=post-service&#10;server.port=8085&#10;&#10;# MongoDB Configuration&#10;spring.data.mongodb.database=post_db&#10;spring.data.mongodb.host=localhost&#10;spring.data.mongodb.port=27018&#10;&#10;# Kafka Configuration&#10;spring.kafka.bootstrap-servers=localhost:9092&#10;spring.kafka.producer.key-serializer=org.apache.kafka.common.serialization.StringSerializer&#10;spring.kafka.producer.value-serializer=org.springframework.kafka.support.serializer.JsonSerializer&#10;&#10;# Kafka Consumer Configuration - Fix missing group-id error&#10;spring.kafka.consumer.group-id=post-service-group&#10;spring.kafka.consumer.key-deserializer=org.apache.kafka.common.serialization.StringDeserializer&#10;spring.kafka.consumer.value-deserializer=org.springframework.kafka.support.serializer.JsonDeserializer&#10;spring.kafka.consumer.properties.spring.json.trusted.packages=*&#10;spring.kafka.consumer.auto-offset-reset=earliest&#10;spring.kafka.consumer.enable-auto-commit=true&#10;&#10;# Eureka Configuration&#10;eureka.client.service-url.defaultZone=http://localhost:8761/eureka/&#10;eureka.instance.prefer-ip-address=true&#10;eureka.instance.instance-id=${spring.application.name}:${server.port}&#10;&#10;# Redis Configuration - Fix for Docker container networking&#10;spring.data.redis.host=redis&#10;spring.data.redis.port=6379&#10;spring.data.redis.timeout=60000ms&#10;spring.data.redis.lettuce.pool.max-active=8&#10;spring.data.redis.lettuce.pool.max-idle=8&#10;spring.data.redis.lettuce.pool.min-idle=0&#10;&#10;# User Service Configuration&#10;user-service.url=http://localhost:8081&#10;&#10;# Media Service Configuration&#10;media-service.url=http://localhost:8084&#10;&#10;# Feign Configuration&#10;feign.client.config.default.connect-timeout=5000&#10;feign.client.config.default.read-timeout=5000&#10;feign.client.config.default.logger-level=basic&#10;&#10;# File Upload Configuration&#10;spring.servlet.multipart.max-file-size=10MB&#10;spring.servlet.multipart.max-request-size=50MB&#10;&#10;# Actuator Configuration&#10;management.endpoints.web.exposure.include=health,info,metrics&#10;management.endpoint.health.show-details=always&#10;&#10;# Logging Configuration&#10;logging.level.vn.ctu.edu.postservice=DEBUG&#10;logging.level.org.springframework.kafka=INFO&#10;logging.level.org.springframework.data.mongodb=INFO" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/user-service/src/main/java/com/ctuconnect/controller/UserSyncController.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/user-service/src/main/java/com/ctuconnect/controller/UserSyncController.java" />
              <option name="originalContent" value="package com.ctuconnect.controller;&#10;&#10;import com.ctuconnect.dto.AuthorDTO;&#10;import com.ctuconnect.dto.UserDTO;&#10;import com.ctuconnect.security.annotation.RequireAuth;&#10;import com.ctuconnect.service.UserSyncService;&#10;import com.ctuconnect.service.UserService;&#10;import org.springframework.beans.factory.annotation.Autowired;&#10;import org.springframework.http.ResponseEntity;&#10;import org.springframework.web.bind.annotation.*;&#10;&#10;import java.util.Set;&#10;&#10;/**&#10; * Controller để xử lý đồng bộ dữ liệu giữa auth-db và user-db&#10; * Các endpoint này được gọi từ auth-service hoặc các microservices khác&#10; */&#10;@RestController&#10;@RequestMapping(&quot;/api/users/sync&quot;)&#10;public class UserSyncController {&#10;&#10;    @Autowired&#10;    private UserSyncService userSyncService;&#10;&#10;    @Autowired&#10;    private UserService userService;&#10;&#10;    /**&#10;     * Tạo user profile trong user-db khi user được tạo ở auth-db&#10;     * Endpoint này được gọi từ auth-service&#10;     */&#10;    @PostMapping(&quot;/create&quot;)&#10;    @RequireAuth(roles = {&quot;SYSTEM&quot;, &quot;ADMIN&quot;}) // Chỉ system hoặc admin mới có thể gọi&#10;    public ResponseEntity&lt;UserDTO&gt; syncUserFromAuth(&#10;            @RequestParam String userId,&#10;            @RequestParam String email,&#10;            @RequestParam String role) {&#10;        UserDTO userDTO = userSyncService.syncUserFromAuth(userId, email, role);&#10;        return ResponseEntity.ok(userDTO);&#10;    }&#10;&#10;    /**&#10;     * Cập nhật thông tin user khi có thay đổi từ auth-db&#10;     */&#10;    @PutMapping(&quot;/update&quot;)&#10;    @RequireAuth(roles = {&quot;SYSTEM&quot;, &quot;ADMIN&quot;})&#10;    public ResponseEntity&lt;UserDTO&gt; updateUserFromAuth(&#10;            @RequestParam String userId,&#10;            @RequestParam String email,&#10;            @RequestParam String role) {&#10;        UserDTO userDTO = userSyncService.updateUserFromAuth(userId, email, role);&#10;        return ResponseEntity.ok(userDTO);&#10;    }&#10;&#10;    /**&#10;     * Xóa user khỏi user-db khi user bị xóa ở auth-db&#10;     */&#10;    @DeleteMapping(&quot;/delete&quot;)&#10;    @RequireAuth(roles = {&quot;SYSTEM&quot;, &quot;ADMIN&quot;})&#10;    public ResponseEntity&lt;String&gt; deleteUserFromAuth(@RequestParam String userId) {&#10;        userSyncService.deleteUserFromAuth(userId);&#10;        return ResponseEntity.ok(&quot;User deleted from user database successfully&quot;);&#10;    }&#10;&#10;    /**&#10;     * Kiểm tra tính nhất quán dữ liệu giữa auth-db và user-db&#10;     */&#10;    @GetMapping(&quot;/check&quot;)&#10;    @RequireAuth(roles = {&quot;SYSTEM&quot;, &quot;ADMIN&quot;})&#10;    public ResponseEntity&lt;Boolean&gt; checkUserSync(&#10;            @RequestParam String userId,&#10;            @RequestParam String email,&#10;            @RequestParam String role) {&#10;        boolean isSynced = userSyncService.isUserSynced(userId, email, role);&#10;        return ResponseEntity.ok(isSynced);&#10;    }&#10;&#10;    /**&#10;     * Lấy thông tin tác giả cho post-service&#10;     * Endpoint này được gọi từ post-service để lấy author info&#10;     */&#10;    @GetMapping(&quot;/authors/{id}&quot;)&#10;    public ResponseEntity&lt;AuthorDTO&gt; getAuthorInfo(@PathVariable(&quot;id&quot;) String authorId) {&#10;        AuthorDTO authorInfo = userSyncService.getAuthorInfo(authorId);&#10;        return ResponseEntity.ok(authorInfo);&#10;    }&#10;&#10;    /**&#10;     * Lấy danh sách ID bạn bè của user&#10;     * Endpoint này được gọi từ post-service cho news feed algorithm&#10;     */&#10;    @GetMapping(&quot;/{userId}/friends/ids&quot;)&#10;    public ResponseEntity&lt;Set&lt;String&gt;&gt; getFriendIds(@PathVariable(&quot;userId&quot;) String userId) {&#10;        Set&lt;String&gt; friendIds = userService.getFriendIds(userId);&#10;        return ResponseEntity.ok(friendIds);&#10;    }&#10;&#10;    /**&#10;     * Lấy danh sách user có tương tác gần với user&#10;     * Endpoint này được gọi từ post-service cho news feed algorithm&#10;     */&#10;    @GetMapping(&quot;/{userId}/close-interactions&quot;)&#10;    public ResponseEntity&lt;Set&lt;String&gt;&gt; getCloseInteractionIds(@PathVariable(&quot;userId&quot;) String userId) {&#10;        Set&lt;String&gt; closeInteractionIds = userService.getCloseInteractionIds(userId);&#10;        return ResponseEntity.ok(closeInteractionIds);&#10;    }&#10;&#10;    /**&#10;     * Lấy danh sách user cùng khoa&#10;     * Endpoint này được gọi từ post-service cho news feed algorithm&#10;     */&#10;    @GetMapping(&quot;/{userId}/same-faculty&quot;)&#10;    public ResponseEntity&lt;Set&lt;String&gt;&gt; getSameFacultyUserIds(@PathVariable(&quot;userId&quot;) String userId) {&#10;        Set&lt;String&gt; sameFacultyIds = userService.getSameFacultyUserIds(userId);&#10;        return ResponseEntity.ok(sameFacultyIds);&#10;    }&#10;&#10;    /**&#10;     * Lấy danh sách user cùng ngành&#10;     * Endpoint này được gọi từ post-service cho news feed algorithm&#10;     */&#10;    @GetMapping(&quot;/{userId}/same-major&quot;)&#10;    public ResponseEntity&lt;Set&lt;String&gt;&gt; getSameMajorUserIds(@PathVariable(&quot;userId&quot;) String userId) {&#10;        Set&lt;String&gt; sameMajorIds = userService.getSameMajorUserIds(userId);&#10;        return ResponseEntity.ok(sameMajorIds);&#10;    }&#10;&#10;    /**&#10;     * Lấy danh sách interest tags của user&#10;     * Endpoint này được gọi từ post-service cho content recommendation&#10;     */&#10;    @GetMapping(&quot;/{userId}/interest-tags&quot;)&#10;    public ResponseEntity&lt;Set&lt;String&gt;&gt; getUserInterestTags(@PathVariable(&quot;userId&quot;) String userId) {&#10;        Set&lt;String&gt; interestTags = userService.getUserInterestTags(userId);&#10;        return ResponseEntity.ok(interestTags);&#10;    }&#10;&#10;    /**&#10;     * Lấy danh sách preferred categories của user&#10;     * Endpoint này được gọi từ post-service cho content filtering&#10;     */&#10;    @GetMapping(&quot;/{userId}/preferred-categories&quot;)&#10;    public ResponseEntity&lt;Set&lt;String&gt;&gt; getUserPreferredCategories(@PathVariable(&quot;userId&quot;) String userId) {&#10;        Set&lt;String&gt; preferredCategories = userService.getUserPreferredCategories(userId);&#10;        return ResponseEntity.ok(preferredCategories);&#10;    }&#10;&#10;    /**&#10;     * Lấy faculty ID của user&#10;     * Endpoint này được gọi từ post-service cho group filtering&#10;     */&#10;    @GetMapping(&quot;/{userId}/faculty-id&quot;)&#10;    public ResponseEntity&lt;String&gt; getUserFacultyId(@PathVariable(&quot;userId&quot;) String userId) {&#10;        String facultyId = userService.getUserFacultyId(userId);&#10;        return ResponseEntity.ok(facultyId);&#10;    }&#10;&#10;    /**&#10;     * Lấy major ID của user&#10;     * Endpoint này được gọi từ post-service cho group filtering&#10;     */&#10;    @GetMapping(&quot;/{userId}/major-id&quot;)&#10;    public ResponseEntity&lt;String&gt; getUserMajorId(@PathVariable(&quot;userId&quot;) String userId) {&#10;        String majorId = userService.getUserMajorId(userId);&#10;        return ResponseEntity.ok(majorId);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.ctuconnect.controller;&#10;&#10;import com.ctuconnect.dto.AuthorDTO;&#10;import com.ctuconnect.dto.UserDTO;&#10;import com.ctuconnect.security.annotation.RequireAuth;&#10;import com.ctuconnect.service.UserSyncService;&#10;import com.ctuconnect.service.UserService;&#10;import org.springframework.beans.factory.annotation.Autowired;&#10;import org.springframework.http.ResponseEntity;&#10;import org.springframework.web.bind.annotation.*;&#10;&#10;import java.util.Set;&#10;&#10;/**&#10; * Controller để xử lý đồng bộ dữ liệu giữa auth-db và user-db&#10; * Các endpoint này được gọi từ auth-service hoặc các microservices khác&#10; */&#10;@RestController&#10;@RequestMapping(&quot;/api/users/sync&quot;)&#10;public class UserSyncController {&#10;&#10;    @Autowired&#10;    private UserSyncService userSyncService;&#10;&#10;    @Autowired&#10;    private UserService userService;&#10;&#10;    /**&#10;     * Tạo user profile trong user-db khi user được tạo ở auth-db&#10;     * Endpoint này được gọi từ auth-service&#10;     */&#10;    @PostMapping(&quot;/create&quot;)&#10;    @RequireAuth(roles = {&quot;SYSTEM&quot;, &quot;ADMIN&quot;}) // Chỉ system hoặc admin mới có thể gọi&#10;    public ResponseEntity&lt;UserDTO&gt; syncUserFromAuth(&#10;            @RequestParam String userId,&#10;            @RequestParam String email,&#10;            @RequestParam String role) {&#10;        UserDTO userDTO = userSyncService.syncUserFromAuth(userId, email, role);&#10;        return ResponseEntity.ok(userDTO);&#10;    }&#10;&#10;    /**&#10;     * Cập nhật thông tin user khi có thay đổi từ auth-db&#10;     */&#10;    @PutMapping(&quot;/update&quot;)&#10;    @RequireAuth(roles = {&quot;SYSTEM&quot;, &quot;ADMIN&quot;})&#10;    public ResponseEntity&lt;UserDTO&gt; updateUserFromAuth(&#10;            @RequestParam String userId,&#10;            @RequestParam String email,&#10;            @RequestParam String role) {&#10;        UserDTO userDTO = userSyncService.updateUserFromAuth(userId, email, role);&#10;        return ResponseEntity.ok(userDTO);&#10;    }&#10;&#10;    /**&#10;     * Xóa user khỏi user-db khi user bị xóa ở auth-db&#10;     */&#10;    @DeleteMapping(&quot;/delete&quot;)&#10;    @RequireAuth(roles = {&quot;SYSTEM&quot;, &quot;ADMIN&quot;})&#10;    public ResponseEntity&lt;String&gt; deleteUserFromAuth(@RequestParam String userId) {&#10;        userSyncService.deleteUserFromAuth(userId);&#10;        return ResponseEntity.ok(&quot;User deleted from user database successfully&quot;);&#10;    }&#10;&#10;    /**&#10;     * Kiểm tra tính nhất quán dữ liệu giữa auth-db và user-db&#10;     */&#10;    @GetMapping(&quot;/check&quot;)&#10;    @RequireAuth(roles = {&quot;SYSTEM&quot;, &quot;ADMIN&quot;})&#10;    public ResponseEntity&lt;Boolean&gt; checkUserSync(&#10;            @RequestParam String userId,&#10;            @RequestParam String email,&#10;            @RequestParam String role) {&#10;        boolean isSynced = userSyncService.isUserSynced(userId, email, role);&#10;        return ResponseEntity.ok(isSynced);&#10;    }&#10;&#10;    /**&#10;     * Lấy thông tin tác giả cho post-service&#10;     * Endpoint này được gọi từ post-service để lấy author info&#10;     * Không yêu cầu authentication vì đây là internal service call&#10;     */&#10;    @GetMapping(&quot;/authors/{id}&quot;)&#10;    public ResponseEntity&lt;AuthorDTO&gt; getAuthorInfo(@PathVariable(&quot;id&quot;) String authorId) {&#10;        AuthorDTO authorInfo = userSyncService.getAuthorInfo(authorId);&#10;        return ResponseEntity.ok(authorInfo);&#10;    }&#10;&#10;    /**&#10;     * Lấy danh sách ID bạn bè của user&#10;     * Endpoint này được gọi từ post-service cho news feed algorithm&#10;     * Không yêu cầu authentication vì đây là internal service call&#10;     */&#10;    @GetMapping(&quot;/{userId}/friends/ids&quot;)&#10;    public ResponseEntity&lt;Set&lt;String&gt;&gt; getFriendIds(@PathVariable(&quot;userId&quot;) String userId) {&#10;        Set&lt;String&gt; friendIds = userService.getFriendIds(userId);&#10;        return ResponseEntity.ok(friendIds);&#10;    }&#10;&#10;    /**&#10;     * Lấy danh sách user có tương tác gần với user&#10;     * Endpoint này được gọi từ post-service cho news feed algorithm&#10;     */&#10;    @GetMapping(&quot;/{userId}/close-interactions&quot;)&#10;    public ResponseEntity&lt;Set&lt;String&gt;&gt; getCloseInteractionIds(@PathVariable(&quot;userId&quot;) String userId) {&#10;        Set&lt;String&gt; closeInteractionIds = userService.getCloseInteractionIds(userId);&#10;        return ResponseEntity.ok(closeInteractionIds);&#10;    }&#10;&#10;    /**&#10;     * Lấy danh sách user cùng khoa&#10;     * Endpoint này được gọi từ post-service cho news feed algorithm&#10;     */&#10;    @GetMapping(&quot;/{userId}/same-faculty&quot;)&#10;    public ResponseEntity&lt;Set&lt;String&gt;&gt; getSameFacultyUserIds(@PathVariable(&quot;userId&quot;) String userId) {&#10;        Set&lt;String&gt; sameFacultyIds = userService.getSameFacultyUserIds(userId);&#10;        return ResponseEntity.ok(sameFacultyIds);&#10;    }&#10;&#10;    /**&#10;     * Lấy danh sách user cùng ngành&#10;     * Endpoint này được gọi từ post-service cho news feed algorithm&#10;     */&#10;    @GetMapping(&quot;/{userId}/same-major&quot;)&#10;    public ResponseEntity&lt;Set&lt;String&gt;&gt; getSameMajorUserIds(@PathVariable(&quot;userId&quot;) String userId) {&#10;        Set&lt;String&gt; sameMajorIds = userService.getSameMajorUserIds(userId);&#10;        return ResponseEntity.ok(sameMajorIds);&#10;    }&#10;&#10;    /**&#10;     * Lấy danh sách interest tags của user&#10;     * Endpoint này được gọi từ post-service cho content recommendation&#10;     */&#10;    @GetMapping(&quot;/{userId}/interest-tags&quot;)&#10;    public ResponseEntity&lt;Set&lt;String&gt;&gt; getUserInterestTags(@PathVariable(&quot;userId&quot;) String userId) {&#10;        Set&lt;String&gt; interestTags = userService.getUserInterestTags(userId);&#10;        return ResponseEntity.ok(interestTags);&#10;    }&#10;&#10;    /**&#10;     * Lấy danh sách preferred categories của user&#10;     * Endpoint này được gọi từ post-service cho content filtering&#10;     */&#10;    @GetMapping(&quot;/{userId}/preferred-categories&quot;)&#10;    public ResponseEntity&lt;Set&lt;String&gt;&gt; getUserPreferredCategories(@PathVariable(&quot;userId&quot;) String userId) {&#10;        Set&lt;String&gt; preferredCategories = userService.getUserPreferredCategories(userId);&#10;        return ResponseEntity.ok(preferredCategories);&#10;    }&#10;&#10;    /**&#10;     * Lấy faculty ID của user&#10;     * Endpoint này được gọi từ post-service cho group filtering&#10;     */&#10;    @GetMapping(&quot;/{userId}/faculty-id&quot;)&#10;    public ResponseEntity&lt;String&gt; getUserFacultyId(@PathVariable(&quot;userId&quot;) String userId) {&#10;        String facultyId = userService.getUserFacultyId(userId);&#10;        return ResponseEntity.ok(facultyId);&#10;    }&#10;&#10;    /**&#10;     * Lấy major ID của user&#10;     * Endpoint này được gọi từ post-service cho group filtering&#10;     */&#10;    @GetMapping(&quot;/{userId}/major-id&quot;)&#10;    public ResponseEntity&lt;String&gt; getUserMajorId(@PathVariable(&quot;userId&quot;) String userId) {&#10;        String majorId = userService.getUserMajorId(userId);&#10;        return ResponseEntity.ok(majorId);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/user-service/src/main/java/com/ctuconnect/dto/ActivityDTO.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/user-service/src/main/java/com/ctuconnect/dto/ActivityDTO.java" />
              <option name="originalContent" value="package com.ctuconnect.dto;&#10;&#10;import lombok.AllArgsConstructor;&#10;import lombok.Builder;&#10;import lombok.Data;&#10;import lombok.NoArgsConstructor;&#10;&#10;import java.time.LocalDateTime;&#10;&#10;@Data&#10;@Builder&#10;@NoArgsConstructor&#10;@AllArgsConstructor&#10;public class ActivityDTO {&#10;    private String id;&#10;    private String userId;&#10;    private String activityType; // POST_CREATED, POST_LIKED, COMMENT_ADDED, etc.&#10;    private String targetType; // POST, COMMENT, USER&#10;    private String targetId;&#10;    private String actorName;&#10;    private String actorAvatarUrl;&#10;&#10;    // For activity feed display&#10;    private String displayText;&#10;    private String actionUrl;&#10;    private boolean isRead;&#10;&#10;    public enum ActivityType {&#10;        POST_CREATED,&#10;        POST_LIKED,&#10;        POST_SHARED,&#10;        COMMENT_ADDED,&#10;        FRIEND_REQUEST_SENT,&#10;        FRIEND_REQUEST_ACCEPTED,&#10;        PROFILE_UPDATED&#10;    }&#10;&#10;    public enum TargetType {&#10;        POST,&#10;        COMMENT,&#10;        USER,&#10;        PROFILE&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.ctuconnect.dto;&#10;&#10;import lombok.AllArgsConstructor;&#10;import lombok.Builder;&#10;import lombok.Data;&#10;import lombok.NoArgsConstructor;&#10;&#10;import java.time.LocalDateTime;&#10;&#10;@Data&#10;@Builder&#10;@NoArgsConstructor&#10;@AllArgsConstructor&#10;public class ActivityDTO {&#10;    private String id;&#10;    private String userId;&#10;    private String activityType; // POST_CREATED, POST_LIKED, COMMENT_ADDED, etc.&#10;    private String targetType; // POST, COMMENT, USER&#10;    private String targetId;&#10;    private String entityType; // Add missing entityType field&#10;    private String entityId; // Add missing entityId field&#10;    private String description;&#10;    private LocalDateTime timestamp;&#10;    private String actorName;&#10;    private String actorAvatarUrl;&#10;&#10;    // For activity feed display&#10;    private String displayText;&#10;    private String actionUrl;&#10;    private boolean isRead;&#10;&#10;    public enum ActivityType {&#10;        POST_CREATED,&#10;        POST_LIKED,&#10;        POST_SHARED,&#10;        COMMENT_ADDED,&#10;        FRIEND_REQUEST_SENT,&#10;        FRIEND_REQUEST_ACCEPTED,&#10;        PROFILE_UPDATED&#10;    }&#10;&#10;    public enum TargetType {&#10;        POST,&#10;        COMMENT,&#10;        USER,&#10;        PROFILE&#10;    }&#10;&#10;    public enum EntityType {&#10;        POST,&#10;        COMMENT,&#10;        USER,&#10;        PROFILE&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/user-service/src/main/java/com/ctuconnect/dto/FriendSuggestionDTO.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/user-service/src/main/java/com/ctuconnect/dto/FriendSuggestionDTO.java" />
              <option name="updatedContent" value="package com.ctuconnect.dto;&#10;&#10;import lombok.AllArgsConstructor;&#10;import lombok.Builder;&#10;import lombok.Data;&#10;import lombok.NoArgsConstructor;&#10;&#10;@Data&#10;@AllArgsConstructor&#10;@NoArgsConstructor&#10;@Builder&#10;public class FriendSuggestionDTO {&#10;    private String userId;&#10;    private String username;&#10;    private String fullName;&#10;    private String avatarUrl;&#10;    private String bio;&#10;    &#10;    // Suggestion metadata&#10;    private int mutualFriendsCount;&#10;    private String suggestionReason;&#10;    private double relevanceScore;&#10;    private SuggestionType suggestionType;&#10;    &#10;    // Academic context&#10;    private String facultyName;&#10;    private String majorName;&#10;    private String batchYear;&#10;    &#10;    // Social context&#10;    private boolean sameCollege;&#10;    private boolean sameFaculty;&#10;    private boolean sameMajor;&#10;    private boolean sameBatch;&#10;    &#10;    public enum SuggestionType {&#10;        MUTUAL_FRIENDS,&#10;        ACADEMIC_CONNECTION,&#10;        FRIENDS_OF_FRIENDS,&#10;        PROFILE_VIEWER,&#10;        SIMILAR_INTERESTS,&#10;        LOCATION_BASED,&#10;        ACTIVITY_BASED&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/user-service/src/main/java/com/ctuconnect/event/UserEventPublisher.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/user-service/src/main/java/com/ctuconnect/event/UserEventPublisher.java" />
              <option name="updatedContent" value="package com.ctuconnect.event;&#10;&#10;import org.springframework.beans.factory.annotation.Autowired;&#10;import org.springframework.kafka.core.KafkaTemplate;&#10;import org.springframework.stereotype.Service;&#10;import com.fasterxml.jackson.databind.ObjectMapper;&#10;import lombok.extern.slf4j.Slf4j;&#10;&#10;import java.util.HashMap;&#10;import java.util.Map;&#10;&#10;/**&#10; * Service to publish user profile update events to Kafka&#10; * This notifies other services (like post-service) when user profiles are updated&#10; */&#10;@Service&#10;@Slf4j&#10;public class UserEventPublisher {&#10;&#10;    @Autowired&#10;    private KafkaTemplate&lt;String, String&gt; kafkaTemplate;&#10;&#10;    @Autowired&#10;    private ObjectMapper objectMapper;&#10;&#10;    private static final String USER_PROFILE_UPDATED_TOPIC = &quot;user-profile-updated&quot;;&#10;&#10;    /**&#10;     * Publish user profile update event&#10;     */&#10;    public void publishUserProfileUpdateEvent(String userId, String fullName, String email, String avatarUrl, String role) {&#10;        try {&#10;            Map&lt;String, Object&gt; eventData = new HashMap&lt;&gt;();&#10;            eventData.put(&quot;userId&quot;, userId);&#10;            eventData.put(&quot;fullName&quot;, fullName);&#10;            eventData.put(&quot;email&quot;, email);&#10;            eventData.put(&quot;avatarUrl&quot;, avatarUrl);&#10;            eventData.put(&quot;role&quot;, role);&#10;            eventData.put(&quot;eventType&quot;, &quot;USER_PROFILE_UPDATED&quot;);&#10;            eventData.put(&quot;timestamp&quot;, System.currentTimeMillis());&#10;&#10;            String eventMessage = objectMapper.writeValueAsString(eventData);&#10;            &#10;            kafkaTemplate.send(USER_PROFILE_UPDATED_TOPIC, userId, eventMessage);&#10;            log.info(&quot;Published user profile update event for user: {}&quot;, userId);&#10;            &#10;        } catch (Exception e) {&#10;            log.error(&quot;Failed to publish user profile update event for user {}: {}&quot;, userId, e.getMessage(), e);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Publish user profile update event with user entity data&#10;     */&#10;    public void publishUserProfileUpdateEvent(String userId, Map&lt;String, Object&gt; userData) {&#10;        try {&#10;            Map&lt;String, Object&gt; eventData = new HashMap&lt;&gt;();&#10;            eventData.put(&quot;userId&quot;, userId);&#10;            eventData.put(&quot;userData&quot;, userData);&#10;            eventData.put(&quot;eventType&quot;, &quot;USER_PROFILE_UPDATED&quot;);&#10;            eventData.put(&quot;timestamp&quot;, System.currentTimeMillis());&#10;&#10;            String eventMessage = objectMapper.writeValueAsString(eventData);&#10;            &#10;            kafkaTemplate.send(USER_PROFILE_UPDATED_TOPIC, userId, eventMessage);&#10;            log.info(&quot;Published user profile update event for user: {}&quot;, userId);&#10;            &#10;        } catch (Exception e) {&#10;            log.error(&quot;Failed to publish user profile update event for user {}: {}&quot;, userId, e.getMessage(), e);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/user-service/src/main/java/com/ctuconnect/repository/UserRepository.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/user-service/src/main/java/com/ctuconnect/repository/UserRepository.java" />
              <option name="originalContent" value="package com.ctuconnect.repository;&#10;&#10;import com.ctuconnect.entity.FacultyEntity;&#10;import com.ctuconnect.entity.UserEntity;&#10;import org.springframework.data.jpa.repository.Modifying;&#10;import org.springframework.data.neo4j.repository.Neo4jRepository;&#10;import org.springframework.data.neo4j.repository.query.Query;&#10;import org.springframework.data.repository.query.Param;&#10;&#10;import java.util.List;&#10;import java.util.Optional;&#10;&#10;public interface UserRepository extends Neo4jRepository&lt;UserEntity, String&gt; {&#10;&#10; // Tìm kiếm người dùng bằng email hoặc username&#10; Optional&lt;UserEntity&gt; findByEmail(String email);&#10;&#10; Optional&lt;UserEntity&gt; findByUsername(String username);&#10;&#10; boolean existsByEmail(String email);&#10;&#10; boolean existsByUsername(String username);&#10;&#10; @Query(&quot;MATCH (u:User) WHERE u.email = $identifier OR u.username = $identifier RETURN u&quot;)&#10; Optional&lt;UserEntity&gt; findByEmailOrUsername(@Param(&quot;identifier&quot;) String identifier);&#10;&#10; // Lấy user by id&#10; @Query(&quot;MATCH (u:User {id: $userId}) RETURN u&quot;)&#10; Optional&lt;UserEntity&gt; findUserWithAllRelations(@Param(&quot;userId&quot;) String userId);&#10;&#10; // Xóa quan hệ của profile học sinh (student)&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})&#10;        OPTIONAL MATCH (u)-[r]-&gt;()&#10;        WHERE type(r) IN ['ENROLLED_IN', 'WORKS_IN', 'BELONGS_TO', 'IN_BATCH', 'HAS_GENDER']&#10;        DELETE r&#10;        &quot;&quot;&quot;)&#10; void clearStudentRelationships(@Param(&quot;userId&quot;) String userId);&#10;&#10; // Xóa quan hệ của profile giảng viên (lecturer)&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})&#10;        OPTIONAL MATCH (u)-[r]-&gt;()&#10;        WHERE type(r) IN ['HAS_DEGREE', 'HAS_ACADEMIC', 'HAS_POSITION', 'WORKS_IN', 'BELONGS_TO', 'HAS_GENDER']&#10;        DELETE r&#10;        &quot;&quot;&quot;)&#10; void clearLecturerRelationships(@Param(&quot;userId&quot;) String userId);&#10;&#10; // Xóa quan hệ cụ thể theo danh sách quan hệ truyền vào&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})&#10;        OPTIONAL MATCH (u)-[r]-&gt;()&#10;        WHERE type(r) IN $relationshipTypes&#10;        DELETE r&#10;        &quot;&quot;&quot;)&#10; void clearSpecificRelationships(@Param(&quot;userId&quot;) String userId, @Param(&quot;relationshipTypes&quot;) List&lt;String&gt; relationshipTypes);&#10;&#10; // Xóa quan hệ đơn lẻ theo loại&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})-[r]-&gt;(n)&#10;        WHERE type(r) = $relationshipType&#10;        DELETE r&#10;        &quot;&quot;&quot;)&#10; void deleteRelationship(@Param(&quot;userId&quot;) String userId, @Param(&quot;relationshipType&quot;) String relationshipType);&#10;&#10; // Cập nhật các quan hệ profile&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})&#10;        OPTIONAL MATCH (u)-[r:ENROLLED_IN]-&gt;()&#10;        DELETE r&#10;        WITH u&#10;        MATCH (newMajor:Major {id: $majorId})&#10;        MERGE (u)-[:ENROLLED_IN]-&gt;(newMajor)&#10;        &quot;&quot;&quot;)&#10; void updateUserMajor(@Param(&quot;userId&quot;) String userId, @Param(&quot;majorId&quot;) String majorId);&#10;&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})&#10;        OPTIONAL MATCH (u)-[r:IN_BATCH]-&gt;()&#10;        DELETE r&#10;        WITH u&#10;        MATCH (newBatch:Batch {id: $batchId})&#10;        MERGE (u)-[:IN_BATCH]-&gt;(newBatch)&#10;        &quot;&quot;&quot;)&#10; void updateUserBatch(@Param(&quot;userId&quot;) String userId, @Param(&quot;batchId&quot;) String batchId);&#10;&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})&#10;        OPTIONAL MATCH (u)-[r:HAS_GENDER]-&gt;()&#10;        DELETE r&#10;        WITH u&#10;        MATCH (newGender:Gender {id: $genderId})&#10;        MERGE (u)-[:HAS_GENDER]-&gt;(newGender)&#10;        &quot;&quot;&quot;)&#10; void updateUserGender(@Param(&quot;userId&quot;) String userId, @Param(&quot;genderId&quot;) String genderId);&#10;&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})&#10;        OPTIONAL MATCH (u)-[r:BELONGS_TO]-&gt;()&#10;        DELETE r&#10;        WITH u&#10;        MATCH (newFaculty:Faculty {id: $facultyId})&#10;        MERGE (u)-[:BELONGS_TO]-&gt;(newFaculty)&#10;        &quot;&quot;&quot;)&#10; void updateUserFaculty(@Param(&quot;userId&quot;) String userId, @Param(&quot;facultyId&quot;) String facultyId);&#10;&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})&#10;        OPTIONAL MATCH (u)-[r:STUDIES_AT]-&gt;()&#10;        DELETE r&#10;        WITH u&#10;        MATCH (newCollege:College {id: $collegeId})&#10;        MERGE (u)-[:STUDIES_AT]-&gt;(newCollege)&#10;        &quot;&quot;&quot;)&#10; void updateUserCollege(@Param(&quot;userId&quot;) String userId, @Param(&quot;collegeId&quot;) String collegeId);&#10;&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})&#10;        OPTIONAL MATCH (u)-[r:WORKS_IN]-&gt;()&#10;        DELETE r&#10;        WITH u&#10;        MATCH (newFaculty:Faculty {id: $facultyId})&#10;        MERGE (u)-[:WORKS_IN]-&gt;(newFaculty)&#10;        &quot;&quot;&quot;)&#10; void updateUserWorkingFaculty(@Param(&quot;userId&quot;) String userId, @Param(&quot;facultyId&quot;) String facultyId);&#10;&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})&#10;        OPTIONAL MATCH (u)-[r:EMPLOYED_AT]-&gt;()&#10;        DELETE r&#10;        WITH u&#10;        MATCH (newCollege:College {id: $collegeId})&#10;        MERGE (u)-[:EMPLOYED_AT]-&gt;(newCollege)&#10;        &quot;&quot;&quot;)&#10; void updateUserWorkingCollege(@Param(&quot;userId&quot;) String userId, @Param(&quot;collegeId&quot;) String collegeId);&#10;&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})&#10;        OPTIONAL MATCH (u)-[r:HAS_DEGREE]-&gt;()&#10;        DELETE r&#10;        WITH u&#10;        MATCH (newDegree:Degree {id: $degreeId})&#10;        MERGE (u)-[:HAS_DEGREE]-&gt;(newDegree)&#10;        &quot;&quot;&quot;)&#10; void updateUserDegree(@Param(&quot;userId&quot;) String userId, @Param(&quot;degreeId&quot;) String degreeId);&#10;&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})&#10;        OPTIONAL MATCH (u)-[r:HAS_POSITION]-&gt;()&#10;        DELETE r&#10;        WITH u&#10;        MATCH (newPosition:Position {id: $positionId})&#10;        MERGE (u)-[:HAS_POSITION]-&gt;(newPosition)&#10;        &quot;&quot;&quot;)&#10; void updateUserPosition(@Param(&quot;userId&quot;) String userId, @Param(&quot;positionId&quot;) String positionId);&#10;&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})&#10;        OPTIONAL MATCH (u)-[r:HAS_ACADEMIC]-&gt;()&#10;        DELETE r&#10;        WITH u&#10;        MATCH (newAcademic:Academic {id: $academicId})&#10;        MERGE (u)-[:HAS_ACADEMIC]-&gt;(newAcademic)&#10;        &quot;&quot;&quot;)&#10; void updateUserAcademic(@Param(&quot;userId&quot;) String userId, @Param(&quot;academicId&quot;) String academicId);&#10;&#10; // ========================= FRIEND RELATIONSHIP QUERIES =========================&#10;&#10; // Kiểm tra xem 2 user có phải bạn bè không&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u1:User {id: $userId1})-[:FRIEND_WITH]-(u2:User {id: $userId2})&#10;        RETURN COUNT(*) &gt; 0&#10;        &quot;&quot;&quot;)&#10; boolean areFriends(@Param(&quot;userId1&quot;) String userId1, @Param(&quot;userId2&quot;) String userId2);&#10;&#10; // Kiểm tra có friend request pending không&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u1:User {id: $fromUserId})-[:FRIEND_REQUEST]-&gt;(u2:User {id: $toUserId})&#10;        RETURN COUNT(*) &gt; 0&#10;        &quot;&quot;&quot;)&#10; boolean hasPendingFriendRequest(@Param(&quot;fromUserId&quot;) String fromUserId, @Param(&quot;toUserId&quot;) String toUserId);&#10;&#10; // Gửi friend request&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u1:User {id: $fromUserId}), (u2:User {id: $toUserId})&#10;        MERGE (u1)-[:FRIEND_REQUEST]-&gt;(u2)&#10;        &quot;&quot;&quot;)&#10; void sendFriendRequest(@Param(&quot;fromUserId&quot;) String fromUserId, @Param(&quot;toUserId&quot;) String toUserId);&#10;&#10; // Chấp nhận friend request&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u1:User {id: $fromUserId})-[r:FRIEND_REQUEST]-&gt;(u2:User {id: $toUserId})&#10;        DELETE r&#10;        CREATE (u1)-[:FRIEND_WITH]-&gt;(u2)&#10;        CREATE (u2)-[:FRIEND_WITH]-&gt;(u1)&#10;        &quot;&quot;&quot;)&#10; void acceptFriendRequest(@Param(&quot;fromUserId&quot;) String fromUserId, @Param(&quot;toUserId&quot;) String toUserId);&#10;&#10; // Từ chối friend request&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u1:User {id: $fromUserId})-[r:FRIEND_REQUEST]-&gt;(u2:User {id: $toUserId})&#10;        DELETE r&#10;        &quot;&quot;&quot;)&#10; void rejectFriendRequest(@Param(&quot;fromUserId&quot;) String fromUserId, @Param(&quot;toUserId&quot;) String toUserId);&#10;&#10; // Xóa friendship&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u1:User {id: $userId1})-[r:FRIEND_WITH]-(u2:User {id: $userId2})&#10;        DELETE r&#10;        &quot;&quot;&quot;)&#10; void deleteFriendship(@Param(&quot;userId1&quot;) String userId1, @Param(&quot;userId2&quot;) String userId2);&#10;&#10; // Lấy danh sách bạn bè&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})-[:FRIEND_WITH]-(friend:User)&#10;        RETURN friend&#10;        &quot;&quot;&quot;)&#10; List&lt;UserEntity&gt; findFriends(@Param(&quot;userId&quot;) String userId);&#10;&#10; // Lấy friend requests nhận được&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (requester:User)-[:FRIEND_REQUEST]-&gt;(u:User {id: $userId})&#10;        RETURN requester&#10;        &quot;&quot;&quot;)&#10; List&lt;UserEntity&gt; findIncomingFriendRequests(@Param(&quot;userId&quot;) String userId);&#10;&#10; // Lấy friend requests đã gửi&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})-[:FRIEND_REQUEST]-&gt;(receiver:User)&#10;        RETURN receiver&#10;        &quot;&quot;&quot;)&#10; List&lt;UserEntity&gt; findOutgoingFriendRequests(@Param(&quot;userId&quot;) String userId);&#10;&#10; // Lấy bạn chung giữa 2 user&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u1:User {id: $userId1})-[:FRIEND_WITH]-(mutual:User)-[:FRIEND_WITH]-(u2:User {id: $userId2})&#10;        RETURN mutual&#10;        &quot;&quot;&quot;)&#10; List&lt;UserEntity&gt; findMutualFriends(@Param(&quot;userId1&quot;) String userId1, @Param(&quot;userId2&quot;) String userId2);&#10;&#10; // Gợi ý kết bạn dựa trên bạn chung và profile tương tự&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})&#10;        MATCH (u)-[:FRIEND_WITH]-(friend)-[:FRIEND_WITH]-(suggestion:User)&#10;        WHERE NOT (u)-[:FRIEND_WITH]-(suggestion) AND u.id &lt;&gt; suggestion.id&#10;        AND NOT (u)-[:FRIEND_REQUEST]-(suggestion)&#10;        RETURN suggestion, COUNT(*) as mutualFriends&#10;        ORDER BY mutualFriends DESC&#10;        LIMIT 20&#10;        &quot;&quot;&quot;)&#10; List&lt;UserEntity&gt; findFriendSuggestions(@Param(&quot;userId&quot;) String userId);&#10;&#10; // Lọc user theo tiêu chí (cùng college, faculty, major, batch)&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})&#10;        OPTIONAL MATCH (u)-[:STUDIES_AT|EMPLOYED_AT]-&gt;(college:College)&#10;        OPTIONAL MATCH (u)-[:BELONGS_TO|WORKS_IN]-&gt;(faculty:Faculty)&#10;        OPTIONAL MATCH (u)-[:ENROLLED_IN]-&gt;(major:Major)&#10;        OPTIONAL MATCH (u)-[:IN_BATCH]-&gt;(batch:Batch)&#10;        &#10;        MATCH (candidate:User)&#10;        WHERE candidate.id &lt;&gt; $userId&#10;        AND (NOT $sameCollege OR (candidate)-[:STUDIES_AT|EMPLOYED_AT]-&gt;(college))&#10;        AND (NOT $sameFaculty OR (candidate)-[:BELONGS_TO|WORKS_IN]-&gt;(faculty))&#10;        AND (NOT $sameMajor OR (candidate)-[:ENROLLED_IN]-&gt;(major))&#10;        AND (NOT $sameBatch OR (candidate)-[:IN_BATCH]-&gt;(batch))&#10;        &#10;        RETURN candidate&#10;        &quot;&quot;&quot;)&#10; List&lt;UserEntity&gt; findUsersWithFilters(&#10;         @Param(&quot;userId&quot;) String userId,&#10;         @Param(&quot;sameCollege&quot;) boolean sameCollege,&#10;         @Param(&quot;sameFaculty&quot;) boolean sameFaculty,&#10;         @Param(&quot;sameMajor&quot;) boolean sameMajor,&#10;         @Param(&quot;sameBatch&quot;) boolean sameBatch&#10; );&#10;&#10; /**&#10;  * Find users by faculty ID (for post-service news feed algorithm)&#10;  */&#10; @Query(&quot;MATCH (u:User)-[:WORKS_IN|BELONGS_TO]-&gt;(f:Faculty {id: $facultyId}) RETURN u&quot;)&#10; List&lt;UserEntity&gt; findUsersByFaculty(@Param(&quot;facultyId&quot;) String facultyId);&#10;&#10; /**&#10;  * Find users by major ID (for post-service news feed algorithm)&#10;  */&#10; @Query(&quot;MATCH (u:User)-[:ENROLLED_IN]-&gt;(m:Major {id: $majorId}) RETURN u&quot;)&#10; List&lt;UserEntity&gt; findUsersByMajor(@Param(&quot;majorId&quot;) String majorId);&#10;&#10; /**&#10;  * Find users by full name containing (for search functionality)&#10;  * Uses case-insensitive search with Neo4j CONTAINS operator&#10;  */&#10; @Query(&quot;MATCH (u:User) WHERE toLower(u.fullName) CONTAINS toLower($name) RETURN u&quot;)&#10; List&lt;UserEntity&gt; findByFullNameContainingIgnoreCase(@Param(&quot;name&quot;) String name);&#10;&#10;&#10; List&lt;UserEntity&gt; findByFacultyId(String facultyId);&#10;&#10; List&lt;UserEntity&gt; findByMajorId(String majorId);&#10;}&#10;" />
              <option name="updatedContent" value="package com.ctuconnect.repository;&#10;&#10;import com.ctuconnect.entity.FacultyEntity;&#10;import com.ctuconnect.entity.UserEntity;&#10;import org.springframework.data.jpa.repository.Modifying;&#10;import org.springframework.data.neo4j.repository.Neo4jRepository;&#10;import org.springframework.data.neo4j.repository.query.Query;&#10;import org.springframework.data.repository.query.Param;&#10;&#10;import java.util.List;&#10;import java.util.Optional;&#10;&#10;public interface UserRepository extends Neo4jRepository&lt;UserEntity, String&gt; {&#10;&#10; // Tìm kiếm người dùng bằng email hoặc username&#10; Optional&lt;UserEntity&gt; findByEmail(String email);&#10;&#10; Optional&lt;UserEntity&gt; findByUsername(String username);&#10;&#10; boolean existsByEmail(String email);&#10;&#10; boolean existsByUsername(String username);&#10;&#10; @Query(&quot;MATCH (u:User) WHERE u.email = $identifier OR u.username = $identifier RETURN u&quot;)&#10; Optional&lt;UserEntity&gt; findByEmailOrUsername(@Param(&quot;identifier&quot;) String identifier);&#10;&#10; // Lấy user by id&#10; @Query(&quot;MATCH (u:User {id: $userId}) RETURN u&quot;)&#10; Optional&lt;UserEntity&gt; findUserWithAllRelations(@Param(&quot;userId&quot;) String userId);&#10;&#10; // Xóa quan hệ của profile học sinh (student)&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})&#10;        OPTIONAL MATCH (u)-[r]-&gt;()&#10;        WHERE type(r) IN ['ENROLLED_IN', 'WORKS_IN', 'BELONGS_TO', 'IN_BATCH', 'HAS_GENDER']&#10;        DELETE r&#10;        &quot;&quot;&quot;)&#10; void clearStudentRelationships(@Param(&quot;userId&quot;) String userId);&#10;&#10; // Xóa quan hệ của profile giảng viên (lecturer)&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})&#10;        OPTIONAL MATCH (u)-[r]-&gt;()&#10;        WHERE type(r) IN ['HAS_DEGREE', 'HAS_ACADEMIC', 'HAS_POSITION', 'WORKS_IN', 'BELONGS_TO', 'HAS_GENDER']&#10;        DELETE r&#10;        &quot;&quot;&quot;)&#10; void clearLecturerRelationships(@Param(&quot;userId&quot;) String userId);&#10;&#10; // Xóa quan hệ cụ thể theo danh sách quan hệ truyền vào&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})&#10;        OPTIONAL MATCH (u)-[r]-&gt;()&#10;        WHERE type(r) IN $relationshipTypes&#10;        DELETE r&#10;        &quot;&quot;&quot;)&#10; void clearSpecificRelationships(@Param(&quot;userId&quot;) String userId, @Param(&quot;relationshipTypes&quot;) List&lt;String&gt; relationshipTypes);&#10;&#10; // Xóa quan hệ đơn lẻ theo loại&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})-[r]-&gt;(n)&#10;        WHERE type(r) = $relationshipType&#10;        DELETE r&#10;        &quot;&quot;&quot;)&#10; void deleteRelationship(@Param(&quot;userId&quot;) String userId, @Param(&quot;relationshipType&quot;) String relationshipType);&#10;&#10; // Cập nhật các quan hệ profile&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})&#10;        OPTIONAL MATCH (u)-[r:ENROLLED_IN]-&gt;()&#10;        DELETE r&#10;        WITH u&#10;        MATCH (newMajor:Major {id: $majorId})&#10;        MERGE (u)-[:ENROLLED_IN]-&gt;(newMajor)&#10;        &quot;&quot;&quot;)&#10; void updateUserMajor(@Param(&quot;userId&quot;) String userId, @Param(&quot;majorId&quot;) String majorId);&#10;&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})&#10;        OPTIONAL MATCH (u)-[r:IN_BATCH]-&gt;()&#10;        DELETE r&#10;        WITH u&#10;        MATCH (newBatch:Batch {id: $batchId})&#10;        MERGE (u)-[:IN_BATCH]-&gt;(newBatch)&#10;        &quot;&quot;&quot;)&#10; void updateUserBatch(@Param(&quot;userId&quot;) String userId, @Param(&quot;batchId&quot;) String batchId);&#10;&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})&#10;        OPTIONAL MATCH (u)-[r:HAS_GENDER]-&gt;()&#10;        DELETE r&#10;        WITH u&#10;        MATCH (newGender:Gender {id: $genderId})&#10;        MERGE (u)-[:HAS_GENDER]-&gt;(newGender)&#10;        &quot;&quot;&quot;)&#10; void updateUserGender(@Param(&quot;userId&quot;) String userId, @Param(&quot;genderId&quot;) String genderId);&#10;&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})&#10;        OPTIONAL MATCH (u)-[r:BELONGS_TO]-&gt;()&#10;        DELETE r&#10;        WITH u&#10;        MATCH (newFaculty:Faculty {id: $facultyId})&#10;        MERGE (u)-[:BELONGS_TO]-&gt;(newFaculty)&#10;        &quot;&quot;&quot;)&#10; void updateUserFaculty(@Param(&quot;userId&quot;) String userId, @Param(&quot;facultyId&quot;) String facultyId);&#10;&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})&#10;        OPTIONAL MATCH (u)-[r:STUDIES_AT]-&gt;()&#10;        DELETE r&#10;        WITH u&#10;        MATCH (newCollege:College {id: $collegeId})&#10;        MERGE (u)-[:STUDIES_AT]-&gt;(newCollege)&#10;        &quot;&quot;&quot;)&#10; void updateUserCollege(@Param(&quot;userId&quot;) String userId, @Param(&quot;collegeId&quot;) String collegeId);&#10;&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})&#10;        OPTIONAL MATCH (u)-[r:WORKS_IN]-&gt;()&#10;        DELETE r&#10;        WITH u&#10;        MATCH (newFaculty:Faculty {id: $facultyId})&#10;        MERGE (u)-[:WORKS_IN]-&gt;(newFaculty)&#10;        &quot;&quot;&quot;)&#10; void updateUserWorkingFaculty(@Param(&quot;userId&quot;) String userId, @Param(&quot;facultyId&quot;) String facultyId);&#10;&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})&#10;        OPTIONAL MATCH (u)-[r:EMPLOYED_AT]-&gt;()&#10;        DELETE r&#10;        WITH u&#10;        MATCH (newCollege:College {id: $collegeId})&#10;        MERGE (u)-[:EMPLOYED_AT]-&gt;(newCollege)&#10;        &quot;&quot;&quot;)&#10; void updateUserWorkingCollege(@Param(&quot;userId&quot;) String userId, @Param(&quot;collegeId&quot;) String collegeId);&#10;&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})&#10;        OPTIONAL MATCH (u)-[r:HAS_DEGREE]-&gt;()&#10;        DELETE r&#10;        WITH u&#10;        MATCH (newDegree:Degree {id: $degreeId})&#10;        MERGE (u)-[:HAS_DEGREE]-&gt;(newDegree)&#10;        &quot;&quot;&quot;)&#10; void updateUserDegree(@Param(&quot;userId&quot;) String userId, @Param(&quot;degreeId&quot;) String degreeId);&#10;&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})&#10;        OPTIONAL MATCH (u)-[r:HAS_POSITION]-&gt;()&#10;        DELETE r&#10;        WITH u&#10;        MATCH (newPosition:Position {id: $positionId})&#10;        MERGE (u)-[:HAS_POSITION]-&gt;(newPosition)&#10;        &quot;&quot;&quot;)&#10; void updateUserPosition(@Param(&quot;userId&quot;) String userId, @Param(&quot;positionId&quot;) String positionId);&#10;&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})&#10;        OPTIONAL MATCH (u)-[r:HAS_ACADEMIC]-&gt;()&#10;        DELETE r&#10;        WITH u&#10;        MATCH (newAcademic:Academic {id: $academicId})&#10;        MERGE (u)-[:HAS_ACADEMIC]-&gt;(newAcademic)&#10;        &quot;&quot;&quot;)&#10; void updateUserAcademic(@Param(&quot;userId&quot;) String userId, @Param(&quot;academicId&quot;) String academicId);&#10;&#10; // ========================= FRIEND RELATIONSHIP QUERIES =========================&#10;&#10; // Kiểm tra xem 2 user có phải bạn bè không&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u1:User {id: $userId1})-[:FRIEND_WITH]-(u2:User {id: $userId2})&#10;        RETURN COUNT(*) &gt; 0&#10;        &quot;&quot;&quot;)&#10; boolean areFriends(@Param(&quot;userId1&quot;) String userId1, @Param(&quot;userId2&quot;) String userId2);&#10;&#10; // Kiểm tra có friend request pending không&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u1:User {id: $fromUserId})-[:FRIEND_REQUEST]-&gt;(u2:User {id: $toUserId})&#10;        RETURN COUNT(*) &gt; 0&#10;        &quot;&quot;&quot;)&#10; boolean hasPendingFriendRequest(@Param(&quot;fromUserId&quot;) String fromUserId, @Param(&quot;toUserId&quot;) String toUserId);&#10;&#10; // Gửi friend request&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u1:User {id: $fromUserId}), (u2:User {id: $toUserId})&#10;        MERGE (u1)-[:FRIEND_REQUEST]-&gt;(u2)&#10;        &quot;&quot;&quot;)&#10; void sendFriendRequest(@Param(&quot;fromUserId&quot;) String fromUserId, @Param(&quot;toUserId&quot;) String toUserId);&#10;&#10; // Chấp nhận friend request&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u1:User {id: $fromUserId})-[r:FRIEND_REQUEST]-&gt;(u2:User {id: $toUserId})&#10;        DELETE r&#10;        CREATE (u1)-[:FRIEND_WITH]-&gt;(u2)&#10;        CREATE (u2)-[:FRIEND_WITH]-&gt;(u1)&#10;        &quot;&quot;&quot;)&#10; void acceptFriendRequest(@Param(&quot;fromUserId&quot;) String fromUserId, @Param(&quot;toUserId&quot;) String toUserId);&#10;&#10; // Từ chối friend request&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u1:User {id: $fromUserId})-[r:FRIEND_REQUEST]-&gt;(u2:User {id: $toUserId})&#10;        DELETE r&#10;        &quot;&quot;&quot;)&#10; void rejectFriendRequest(@Param(&quot;fromUserId&quot;) String fromUserId, @Param(&quot;toUserId&quot;) String toUserId);&#10;&#10; // Xóa friendship&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u1:User {id: $userId1})-[r:FRIEND_WITH]-(u2:User {id: $userId2})&#10;        DELETE r&#10;        &quot;&quot;&quot;)&#10; void deleteFriendship(@Param(&quot;userId1&quot;) String userId1, @Param(&quot;userId2&quot;) String userId2);&#10;&#10; // Lấy danh sách bạn bè&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})-[:FRIEND_WITH]-(friend:User)&#10;        RETURN friend&#10;        &quot;&quot;&quot;)&#10; List&lt;UserEntity&gt; findFriends(@Param(&quot;userId&quot;) String userId);&#10;&#10; // Lấy friend requests nhận được&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (requester:User)-[:FRIEND_REQUEST]-&gt;(u:User {id: $userId})&#10;        RETURN requester&#10;        &quot;&quot;&quot;)&#10; List&lt;UserEntity&gt; findIncomingFriendRequests(@Param(&quot;userId&quot;) String userId);&#10;&#10; // Lấy friend requests đã gửi&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})-[:FRIEND_REQUEST]-&gt;(receiver:User)&#10;        RETURN receiver&#10;        &quot;&quot;&quot;)&#10; List&lt;UserEntity&gt; findOutgoingFriendRequests(@Param(&quot;userId&quot;) String userId);&#10;&#10; // Lấy bạn chung giữa 2 user&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u1:User {id: $userId1})-[:FRIEND_WITH]-(mutual:User)-[:FRIEND_WITH]-(u2:User {id: $userId2})&#10;        RETURN mutual&#10;        &quot;&quot;&quot;)&#10; List&lt;UserEntity&gt; findMutualFriends(@Param(&quot;userId1&quot;) String userId1, @Param(&quot;userId2&quot;) String userId2);&#10;&#10; // Gợi ý kết bạn dựa trên bạn chung và profile tương tự&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})&#10;        MATCH (u)-[:FRIEND_WITH]-(friend)-[:FRIEND_WITH]-(suggestion:User)&#10;        WHERE NOT (u)-[:FRIEND_WITH]-(suggestion) AND u.id &lt;&gt; suggestion.id&#10;        AND NOT (u)-[:FRIEND_REQUEST]-(suggestion)&#10;        RETURN suggestion, COUNT(*) as mutualFriends&#10;        ORDER BY mutualFriends DESC&#10;        LIMIT 20&#10;        &quot;&quot;&quot;)&#10; List&lt;UserEntity&gt; findFriendSuggestions(@Param(&quot;userId&quot;) String userId);&#10;&#10; // Lọc user theo tiêu chí (cùng college, faculty, major, batch)&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})&#10;        OPTIONAL MATCH (u)-[:STUDIES_AT|EMPLOYED_AT]-&gt;(college:College)&#10;        OPTIONAL MATCH (u)-[:BELONGS_TO|WORKS_IN]-&gt;(faculty:Faculty)&#10;        OPTIONAL MATCH (u)-[:ENROLLED_IN]-&gt;(major:Major)&#10;        OPTIONAL MATCH (u)-[:IN_BATCH]-&gt;(batch:Batch)&#10;        &#10;        MATCH (candidate:User)&#10;        WHERE candidate.id &lt;&gt; $userId&#10;        AND (NOT $sameCollege OR (candidate)-[:STUDIES_AT|EMPLOYED_AT]-&gt;(college))&#10;        AND (NOT $sameFaculty OR (candidate)-[:BELONGS_TO|WORKS_IN]-&gt;(faculty))&#10;        AND (NOT $sameMajor OR (candidate)-[:ENROLLED_IN]-&gt;(major))&#10;        AND (NOT $sameBatch OR (candidate)-[:IN_BATCH]-&gt;(batch))&#10;        &#10;        RETURN candidate&#10;        &quot;&quot;&quot;)&#10; List&lt;UserEntity&gt; findUsersWithFilters(&#10;         @Param(&quot;userId&quot;) String userId,&#10;         @Param(&quot;sameCollege&quot;) boolean sameCollege,&#10;         @Param(&quot;sameFaculty&quot;) boolean sameFaculty,&#10;         @Param(&quot;sameMajor&quot;) boolean sameMajor,&#10;         @Param(&quot;sameBatch&quot;) boolean sameBatch&#10; );&#10;&#10; /**&#10;  * Find users by faculty ID (for post-service news feed algorithm)&#10;  */&#10; @Query(&quot;MATCH (u:User)-[:WORKS_IN|BELONGS_TO]-&gt;(f:Faculty {id: $facultyId}) RETURN u&quot;)&#10; List&lt;UserEntity&gt; findUsersByFacultyId(@Param(&quot;facultyId&quot;) String facultyId);&#10;&#10; /**&#10;  * Find users by major ID (for post-service news feed algorithm)&#10;  */&#10; @Query(&quot;MATCH (u:User)-[:ENROLLED_IN]-&gt;(m:Major {id: $majorId}) RETURN u&quot;)&#10; List&lt;UserEntity&gt; findUsersByMajorId(@Param(&quot;majorId&quot;) String majorId);&#10;&#10; /**&#10;  * Find users by full name containing (for search functionality)&#10;  * Uses case-insensitive search with Neo4j CONTAINS operator&#10;  */&#10; @Query(&quot;MATCH (u:User) WHERE toLower(u.fullName) CONTAINS toLower($fullName) RETURN u&quot;)&#10; List&lt;UserEntity&gt; findByFullNameContainingIgnoreCase(@Param(&quot;fullName&quot;) String fullName);&#10;&#10; /**&#10;  * Find users by faculty name (for search functionality)&#10;  */&#10; @Query(&quot;MATCH (u:User)-[:BELONGS_TO|WORKS_IN]-&gt;(f:Faculty {name: $facultyName}) RETURN u&quot;)&#10; List&lt;UserEntity&gt; findUsersByFaculty(@Param(&quot;facultyName&quot;) String facultyName);&#10;&#10; /**&#10;  * Find users by major name (for search functionality)&#10;  */&#10; @Query(&quot;MATCH (u:User)-[:ENROLLED_IN]-&gt;(m:Major {name: $majorName}) RETURN u&quot;)&#10; List&lt;UserEntity&gt; findUsersByMajor(@Param(&quot;majorName&quot;) String majorName);&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>