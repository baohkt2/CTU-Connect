<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/ARCHITECTURE_OPTIMIZATION.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ARCHITECTURE_OPTIMIZATION.md" />
              <option name="originalContent" value="# CTU-Connect Architecture Optimization Plan&#10;## Based on Facebook's Social Network Model&#10;&#10;### Current Architecture Analysis&#10;- ✅ Microservices architecture with proper service separation&#10;- ✅ Event-driven communication via Kafka&#10;- ✅ Multiple database technologies (PostgreSQL, MongoDB, Neo4j, Redis)&#10;- ✅ API Gateway for centralized routing&#10;- ✅ Service discovery with Eureka&#10;&#10;### Key Optimizations Required&#10;- Implement eventual consistency patterns&#10;#### 1. Data Consistency &amp; Flow Optimization&#10;- Implement eventual consistency patterns&#10;- Add distributed transaction management&#10;- Optimize cross-service data synchronization&#10;&#10;#### 3. Social Graph Optimization&#10;- Friend suggestion algorithms&#10;#### 2. Enhanced Post System (Facebook-like)&#10;- Timeline generation algorithms&#10;- News feed ranking and personalization&#10;- Real-time updates and notifications&#10;- Database optimization and indexing&#10;- Load balancing and horizontal scaling&#10;&#10;#### 5. Real-time Features&#10;#### 3. Social Graph Optimization&#10;- Friend suggestion algorithms&#10;- Privacy controls and audience targeting&#10;- Activity feed generation&#10;- Real-time chat and comments&#10;- Activity status tracking&#10;#### 4. Performance &amp; Scalability&#10;- Caching strategies at multiple levels&#10;#### 5. Real-time Features&#10;- Live notifications&#10;- Real-time chat and comments&#10;- Activity status tracking&#10;" />
              <option name="updatedContent" value="# CTU-Connect Architecture Optimization Plan&#10;## Based on Facebook's Social Network Model&#10;&#10;### Current Architecture Analysis&#10;- ✅ Microservices architecture with proper service separation&#10;- ✅ Event-driven communication via Kafka&#10;- ✅ Multiple database technologies (PostgreSQL, MongoDB, Neo4j, Redis)&#10;- ✅ API Gateway for centralized routing&#10;- ✅ Service discovery with Eureka&#10;&#10;## COMPLETED OPTIMIZATIONS&#10;&#10;### 1. Enhanced Data Models (Facebook-like)&#10;&#10;#### Enhanced PostEntity&#10;- **Audience Targeting**: Similar to Facebook's privacy controls with granular audience settings&#10;- **Engagement Metrics**: Real-time engagement scoring for feed ranking algorithms&#10;- **Post Types**: Support for TEXT, IMAGE, VIDEO, LINK, POLL, EVENT, SHARED&#10;- **Location Support**: Geographic tagging capabilities&#10;- **Scheduled Posts**: Ability to schedule posts for future publishing&#10;- **Edit History**: Track post modifications with timestamps&#10;&#10;#### Advanced Social Graph (Neo4j)&#10;- **Friend Suggestions**: Multi-signal algorithm using mutual friends, academic connections, profile viewers&#10;- **Relationship Types**: FRIENDS_WITH, FRIEND_REQUEST_SENT, VIEWED_PROFILE, BLOCKED&#10;- **Academic Context**: Faculty, major, and batch-based connections&#10;- **Interaction History**: Track user interactions for personalization&#10;&#10;### 2. Facebook-like News Feed Algorithm&#10;&#10;#### NewsFeedService Implementation&#10;- **Personalized Ranking**: Multi-factor scoring system&#10;  - Friend relationship weight (1.0)&#10;  - Engagement score weight (0.8)&#10;  - Recency weight (0.6)&#10;  - Content relevance weight (0.7)&#10;- **Cache Strategy**: 30-minute feed cache with intelligent invalidation&#10;- **Over-fetching**: Retrieve 3x posts for optimal ranking&#10;- **Diversity Control**: Prevent feed domination by single authors&#10;&#10;#### Feed Types&#10;- **Personalized Feed**: User-specific content based on social graph&#10;- **Trending Posts**: Engagement-based trending algorithm&#10;- **User Timeline**: Profile-specific post timeline with privacy filtering&#10;&#10;### 3. Real-time Notification System&#10;&#10;#### NotificationService Features&#10;- **Real-time WebSocket**: Instant notifications via SimpMessagingTemplate&#10;- **Event-driven**: Kafka integration for scalable notification processing&#10;- **Notification Types**: POST_LIKED, COMMENTED, SHARED, FRIEND_REQUEST, etc.&#10;- **Bulk Notifications**: Efficient handling of viral content notifications&#10;- **Unread Counters**: Redis-cached unread notification counts&#10;&#10;### 4. Data Consistency Management&#10;&#10;#### DataConsistencyService&#10;- **Eventual Consistency**: Cross-service data synchronization&#10;- **Cache Invalidation**: Smart cache invalidation on data changes&#10;- **Compensation Logic**: Failure handling and retry mechanisms&#10;- **Event Sourcing**: Kafka-based event propagation&#10;&#10;### 5. Advanced Caching Strategy&#10;&#10;#### Multi-level Caching&#10;- **Redis Caching**: &#10;  - User data (24 hours TTL)&#10;  - Posts (6 hours TTL)&#10;  - Friend suggestions (6 hours TTL)&#10;  - News feed (30 minutes TTL)&#10;- **Application-level**: In-memory caching for frequently accessed data&#10;- **Database-level**: Optimized queries and indexing&#10;&#10;### 6. Social Graph Optimization&#10;&#10;#### SocialGraphService Features&#10;- **Friend Suggestions Algorithm**:&#10;  - Mutual friends (highest priority)&#10;  - Academic connections (faculty/major/batch)&#10;  - Friends of friends&#10;  - Profile viewers&#10;  - Similar interests&#10;- **Relevance Scoring**: Multi-factor relevance calculation&#10;- **Cache Management**: 6-hour TTL with smart invalidation&#10;&#10;### 7. Performance Enhancements&#10;&#10;#### Database Optimizations&#10;- **MongoDB**: Compound indexes for posts, engagement-based sorting&#10;- **Neo4j**: Optimized Cypher queries for relationship traversal&#10;- **PostgreSQL**: Proper indexing for auth and media services&#10;- **Redis**: Strategic caching and session management&#10;&#10;#### API Optimizations&#10;- **Pagination**: Consistent pagination across all endpoints&#10;- **Bulk Operations**: Efficient batch processing for notifications&#10;- **Async Processing**: CompletableFuture for non-blocking operations&#10;&#10;### 8. Enhanced Security &amp; Privacy&#10;&#10;#### Privacy Controls&#10;- **Audience Settings**: PUBLIC, FRIENDS, CUSTOM, ONLY_ME&#10;- **Academic Targeting**: Faculty/major/batch-specific visibility&#10;- **Block Lists**: User blocking functionality&#10;- **Profile Privacy**: Granular profile visibility controls&#10;&#10;### 9. Real-time Features&#10;&#10;#### WebSocket Integration&#10;- **Live Notifications**: Real-time notification delivery&#10;- **Activity Status**: User online/offline status tracking&#10;- **Real-time Comments**: Live comment updates on posts&#10;&#10;### 10. Monitoring &amp; Health Checks&#10;&#10;#### System Monitoring&#10;- **Health Indicators**: Redis, MongoDB, Neo4j health checks&#10;- **Performance Metrics**: Engagement rates, cache hit ratios&#10;- **Error Tracking**: Comprehensive logging and error handling&#10;&#10;## IMPLEMENTATION SUMMARY&#10;&#10;### New Services Created&#10;1. **NewsFeedService** - Facebook-like feed generation&#10;2. **NotificationService** - Real-time notification system&#10;3. **SocialGraphService** - Advanced friend suggestions&#10;4. **DataConsistencyService** - Cross-service data synchronization&#10;&#10;### Enhanced Controllers&#10;1. **EnhancedPostController** - Advanced post management&#10;2. **EnhancedUserController** - Social graph operations&#10;&#10;### Data Models Enhanced&#10;- **PostEntity** - Facebook-like post features&#10;- **NotificationEntity** - Rich notification system&#10;- **FriendSuggestionDTO** - Comprehensive suggestion data&#10;&#10;### Configuration Added&#10;- **CacheConfig** - Multi-level caching strategy&#10;- **HealthCheckConfig** - System health monitoring&#10;&#10;## FACEBOOK-INSPIRED FEATURES IMPLEMENTED&#10;&#10;### Content &amp; Engagement&#10;✅ **News Feed Algorithm** - Personalized content ranking&#10;✅ **Post Types** - Text, image, video, link, poll support&#10;✅ **Reactions System** - Like, love, laugh, etc.&#10;✅ **Comments &amp; Replies** - Threaded comment system&#10;✅ **Share Functionality** - Post sharing with attribution&#10;✅ **Trending Posts** - Viral content discovery&#10;&#10;### Social Features&#10;✅ **Friend Suggestions** - Multi-signal recommendation engine&#10;✅ **Mutual Friends** - Connection discovery&#10;✅ **Academic Networks** - University-specific connections&#10;✅ **People You May Know** - Profile viewer suggestions&#10;✅ **Friend Requests** - Connection management&#10;&#10;### Privacy &amp; Security&#10;✅ **Audience Controls** - Granular post visibility&#10;✅ **Academic Targeting** - Faculty/major-based sharing&#10;✅ **Block/Unblock** - User blocking system&#10;✅ **Profile Privacy** - Customizable profile visibility&#10;&#10;### Real-time Features&#10;✅ **Live Notifications** - Instant activity updates  &#10;✅ **Real-time Comments** - Live comment updates&#10;✅ **Activity Status** - Online presence tracking&#10;✅ **WebSocket Integration** - Real-time communication&#10;&#10;### Performance &amp; Scale&#10;✅ **Multi-level Caching** - Redis + application caching&#10;✅ **Event-driven Architecture** - Kafka message streaming&#10;✅ **Database Optimization** - Proper indexing and queries&#10;✅ **Load Balancing Ready** - Horizontal scaling support&#10;&#10;## DEPLOYMENT RECOMMENDATIONS&#10;&#10;### 1. Database Scaling&#10;- **MongoDB Sharding** for post data&#10;- **Neo4j Clustering** for social graph&#10;- **Redis Clustering** for caching layer&#10;&#10;### 2. Performance Monitoring&#10;- Implement APM tools (New Relic, DataDog)&#10;- Set up alerts for cache hit ratios&#10;- Monitor database query performance&#10;&#10;### 3. Content Delivery&#10;- Integrate CDN for media files&#10;- Implement image/video optimization&#10;- Add progressive loading for feeds&#10;&#10;### 4. Security Enhancements&#10;- Rate limiting on API endpoints&#10;- Content moderation system&#10;- Spam detection algorithms&#10;&#10;This comprehensive optimization transforms your CTU-Connect platform into a robust, scalable social network with Facebook-like capabilities while maintaining the academic focus of your original vision." />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/client-frontend/src/app/posts/page.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/client-frontend/src/app/posts/page.tsx" />
              <option name="updatedContent" value="'use client';&#10;&#10;import React, { useState, useEffect } from 'react';&#10;import { Post, PaginatedResponse } from '@/types';&#10;import { postService } from '@/services/postService';&#10;import { CreatePost } from '@/components/post/CreatePost';&#10;import { PostCard } from '@/components/post/PostCard';&#10;import { LoadingSpinner } from '@/components/ui/LoadingSpinner';&#10;import { ErrorAlert } from '@/components/ui/ErrorAlert';&#10;import { Button } from '@/components/ui/Button';&#10;import { Plus, RefreshCw } from 'lucide-react';&#10;&#10;export default function PostsPage() {&#10;  const [posts, setPosts] = useState&lt;Post[]&gt;([]);&#10;  const [isLoading, setIsLoading] = useState(true);&#10;  const [error, setError] = useState&lt;string | null&gt;(null);&#10;  const [showCreatePost, setShowCreatePost] = useState(false);&#10;&#10;  const loadPosts = async () =&gt; {&#10;    try {&#10;      setIsLoading(true);&#10;      setError(null);&#10;      const response: PaginatedResponse&lt;Post&gt; = await postService.getPosts();&#10;      setPosts(response.content);&#10;    } catch (err: any) {&#10;      console.error('Failed to load posts:', err);&#10;      setError(err.response?.data?.message || err.message || 'Failed to load posts');&#10;    } finally {&#10;      setIsLoading(false);&#10;    }&#10;  };&#10;&#10;  useEffect(() =&gt; {&#10;    loadPosts();&#10;  }, []);&#10;&#10;  const handlePostCreated = (newPost: Post) =&gt; {&#10;    setPosts(prev =&gt; [newPost, ...prev]);&#10;    setShowCreatePost(false);&#10;  };&#10;&#10;  const handlePostUpdate = (updatedPost: Post) =&gt; {&#10;    setPosts(prev =&gt; prev.map(post =&gt; &#10;      post.id === updatedPost.id ? updatedPost : post&#10;    ));&#10;  };&#10;&#10;  const handlePostDelete = (postId: string) =&gt; {&#10;    setPosts(prev =&gt; prev.filter(post =&gt; post.id !== postId));&#10;  };&#10;&#10;  if (isLoading) {&#10;    return (&#10;      &lt;div className=&quot;min-h-screen bg-gray-50 flex items-center justify-center&quot;&gt;&#10;        &lt;LoadingSpinner size=&quot;lg&quot; /&gt;&#10;      &lt;/div&gt;&#10;    );&#10;  }&#10;&#10;  return (&#10;    &lt;div className=&quot;min-h-screen bg-gray-50&quot;&gt;&#10;      &lt;div className=&quot;max-w-2xl mx-auto py-8 px-4&quot;&gt;&#10;        {/* Header */}&#10;        &lt;div className=&quot;flex items-center justify-between mb-6&quot;&gt;&#10;          &lt;h1 className=&quot;text-2xl font-bold text-gray-900&quot;&gt;Posts&lt;/h1&gt;&#10;          &lt;div className=&quot;flex gap-2&quot;&gt;&#10;            &lt;Button&#10;              variant=&quot;secondary&quot;&#10;              onClick={loadPosts}&#10;              disabled={isLoading}&#10;              className=&quot;flex items-center gap-2&quot;&#10;            &gt;&#10;              &lt;RefreshCw className={`w-4 h-4 ${isLoading ? 'animate-spin' : ''}`} /&gt;&#10;              Refresh&#10;            &lt;/Button&gt;&#10;            &lt;Button&#10;              onClick={() =&gt; setShowCreatePost(true)}&#10;              className=&quot;flex items-center gap-2&quot;&#10;            &gt;&#10;              &lt;Plus className=&quot;w-4 h-4&quot; /&gt;&#10;              Create Post&#10;            &lt;/Button&gt;&#10;          &lt;/div&gt;&#10;        &lt;/div&gt;&#10;&#10;        {/* Create Post Form */}&#10;        {showCreatePost &amp;&amp; (&#10;          &lt;div className=&quot;mb-6&quot;&gt;&#10;            &lt;CreatePost&#10;              onPostCreated={handlePostCreated}&#10;              onCancel={() =&gt; setShowCreatePost(false)}&#10;            /&gt;&#10;          &lt;/div&gt;&#10;        )}&#10;&#10;        {/* Error Display */}&#10;        {error &amp;&amp; (&#10;          &lt;div className=&quot;mb-6&quot;&gt;&#10;            &lt;ErrorAlert message={error} /&gt;&#10;          &lt;/div&gt;&#10;        )}&#10;&#10;        {/* Posts List */}&#10;        {posts.length === 0 ? (&#10;          &lt;div className=&quot;text-center py-12&quot;&gt;&#10;            &lt;div className=&quot;text-gray-400 mb-4&quot;&gt;&#10;              &lt;Plus className=&quot;w-16 h-16 mx-auto&quot; /&gt;&#10;            &lt;/div&gt;&#10;            &lt;h3 className=&quot;text-lg font-medium text-gray-900 mb-2&quot;&gt;No posts yet&lt;/h3&gt;&#10;            &lt;p className=&quot;text-gray-500 mb-4&quot;&gt;Be the first to create a post!&lt;/p&gt;&#10;            &lt;Button onClick={() =&gt; setShowCreatePost(true)}&gt;&#10;              Create First Post&#10;            &lt;/Button&gt;&#10;          &lt;/div&gt;&#10;        ) : (&#10;          &lt;div className=&quot;space-y-6&quot;&gt;&#10;            {posts.map((post) =&gt; (&#10;              &lt;PostCard&#10;                key={post.id}&#10;                post={post}&#10;                onPostUpdate={handlePostUpdate}&#10;                onPostDelete={handlePostDelete}&#10;              /&gt;&#10;            ))}&#10;          &lt;/div&gt;&#10;        )}&#10;      &lt;/div&gt;&#10;    &lt;/div&gt;&#10;  );&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/client-frontend/src/components/post/CreatePost.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/client-frontend/src/components/post/CreatePost.tsx" />
              <option name="originalContent" value="'use client';&#10;&#10;import React, { useState, useRef } from 'react';&#10;import { Button } from '@/components/ui/Button';&#10;import { Textarea } from '@/components/ui/Textarea';&#10;import { Input } from '@/components/ui/Input';&#10;import { LoadingSpinner } from '@/components/ui/LoadingSpinner';&#10;import { ErrorAlert } from '@/components/ui/ErrorAlert';&#10;import { postService } from '@/services/postService';&#10;import { CreatePostRequest } from '@/types';&#10;import { X, Image, Hash, Globe, Users, Lock } from 'lucide-react';&#10;&#10;interface CreatePostProps {&#10;  onPostCreated?: (post: any) =&gt; void;&#10;  onCancel?: () =&gt; void;&#10;  className?: string;&#10;}&#10;&#10;export const CreatePost: React.FC&lt;CreatePostProps&gt; = ({&#10;  onPostCreated,&#10;  onCancel,&#10;  className = ''&#10;}) =&gt; {&#10;  const [formData, setFormData] = useState&lt;CreatePostRequest&gt;({&#10;    title: '',&#10;    content: '',&#10;    tags: [],&#10;    category: '',&#10;    visibility: 'PUBLIC'&#10;  });&#10;&#10;  const [files, setFiles] = useState&lt;File[]&gt;([]);&#10;  const [tagInput, setTagInput] = useState('');&#10;  const [isLoading, setIsLoading] = useState(false);&#10;  const [error, setError] = useState&lt;string | null&gt;(null);&#10;  const fileInputRef = useRef&lt;HTMLInputElement&gt;(null);&#10;&#10;  const handleInputChange = (field: keyof CreatePostRequest, value: string) =&gt; {&#10;    setFormData(prev =&gt; ({&#10;      ...prev,&#10;      [field]: value&#10;    }));&#10;  };&#10;&#10;  const handleAddTag = () =&gt; {&#10;    if (tagInput.trim() &amp;&amp; !formData.tags?.includes(tagInput.trim())) {&#10;      setFormData(prev =&gt; ({&#10;        ...prev,&#10;        tags: [...(prev.tags || []), tagInput.trim()]&#10;      }));&#10;      setTagInput('');&#10;    }&#10;  };&#10;&#10;  const handleRemoveTag = (tagToRemove: string) =&gt; {&#10;    setFormData(prev =&gt; ({&#10;      ...prev,&#10;      tags: prev.tags?.filter(tag =&gt; tag !== tagToRemove) || []&#10;    }));&#10;  };&#10;&#10;  const handleTagInputKeyDown = (e: React.KeyboardEvent) =&gt; {&#10;    if (e.key === 'Enter' || e.key === ',') {&#10;      e.preventDefault();&#10;      handleAddTag();&#10;    }&#10;  };&#10;&#10;  const handleFileSelect = (selectedFiles: File[]) =&gt; {&#10;    setFiles(selectedFiles);&#10;  };&#10;&#10;  const handleRemoveFile = (index: number) =&gt; {&#10;    setFiles(prev =&gt; prev.filter((_, i) =&gt; i !== index));&#10;  };&#10;&#10;  const handleSubmit = async (e: React.FormEvent) =&gt; {&#10;    e.preventDefault();&#10;&#10;    if (!formData.content.trim()) {&#10;      setError('Content is required');&#10;      return;&#10;    }&#10;&#10;    setIsLoading(true);&#10;    setError(null);&#10;&#10;    try {&#10;      const post = await postService.createPost(formData, files.length &gt; 0 ? files : undefined);&#10;&#10;      // Reset form&#10;      setFormData({&#10;        title: '',&#10;        content: '',&#10;        tags: [],&#10;        category: '',&#10;        visibility: 'PUBLIC'&#10;      });&#10;      setFiles([]);&#10;      setTagInput('');&#10;&#10;      onPostCreated?.(post);&#10;      setError(err.response?.data?.message || err.message || 'Failed to create post');&#10;      console.error('Failed to create post:', err);&#10;      setError(err.response?.data?.message || err.message || 'Failed to create post');&#10;      setIsLoading(false);&#10;    }&#10;  };&#10;&#10;  const visibilityOptions = [&#10;    { value: 'PUBLIC', label: 'Public', icon: Globe },&#10;    { value: 'FRIENDS', label: 'Friends', icon: Users },&#10;    { value: 'PRIVATE', label: 'Private', icon: Lock }&#10;  ];&#10;&#10;  return (&#10;    &lt;div className={`bg-white rounded-lg shadow p-6 ${className}`}&gt;&#10;      &lt;form onSubmit={handleSubmit} className=&quot;space-y-4&quot;&gt;&#10;        {error &amp;&amp; &lt;ErrorAlert message={error} /&gt;}&#10;    &lt;div className={`bg-white rounded-lg shadow p-6 ${className}`}&gt;&#10;        {error &amp;&amp; &lt;ErrorAlert message={error} /&gt;}&#10;&#10;        {/* Title */}&#10;        &lt;div&gt;&#10;          &lt;Input&#10;            placeholder=&quot;Post title (optional)&quot;&#10;            value={formData.title || ''}&#10;            onChange={(e) =&gt; handleInputChange('title', e.target.value)}&#10;            className=&quot;w-full&quot;&#10;          /&gt;&#10;        &lt;/div&gt;&#10;            required&#10;            className=&quot;w-full resize-none min-h-[100px]&quot;&#10;          /&gt;&#10;          &lt;div className=&quot;text-right text-sm text-gray-500 mt-1&quot;&gt;&#10;            {formData.content.length}/5000&#10;          &lt;/div&gt;&#10;        &lt;/div&gt;&#10;&#10;        {/* File Preview */}&#10;        {files.length &gt; 0 &amp;&amp; (&#10;          &lt;div className=&quot;space-y-2&quot;&gt;&#10;        {/* Content */}&#10;        &lt;div&gt;&#10;          &lt;Textarea&#10;            placeholder=&quot;What's on your mind?&quot;&#10;            value={formData.content}&#10;            onChange={(e) =&gt; handleInputChange('content', e.target.value)}&#10;            required&#10;            className=&quot;w-full resize-none min-h-[100px]&quot;&#10;          /&gt;&#10;          &lt;div className=&quot;text-right text-sm text-gray-500 mt-1&quot;&gt;&#10;            {formData.content.length}/5000&#10;          &lt;/div&gt;&#10;        &lt;/div&gt;&#10;              className=&quot;flex-1&quot;&#10;&#10;        {/* File Preview */}&#10;        {files.length &gt; 0 &amp;&amp; (&#10;              variant=&quot;secondary&quot;&#10;            &lt;div className=&quot;grid grid-cols-2 md:grid-cols-3 gap-2&quot;&gt;&#10;              {files.map((file, index) =&gt; (&#10;              &lt;Hash className=&quot;w-4 h-4&quot; /&gt;&#10;                  &lt;div className=&quot;border rounded-lg p-2 bg-gray-50&quot;&gt;&#10;                    {file.type.startsWith('image/') ? (&#10;                      &lt;img&#10;&#10;                        className=&quot;w-full h-20 object-cover rounded&quot;&#10;                      /&gt;&#10;                    ) : (&#10;                      &lt;div className=&quot;flex items-center justify-center h-20 bg-gray-200 rounded&quot;&gt;&#10;                        &lt;span className=&quot;text-xs text-gray-600 truncate&quot;&gt;&#10;                  className=&quot;inline-flex items-center gap-1 px-2 py-1 bg-blue-100 text-blue-800 rounded-full text-sm&quot;&#10;                        &lt;/span&gt;&#10;                      &lt;/div&gt;&#10;                    )}&#10;                    &lt;button&#10;                      type=&quot;button&quot;&#10;                      onClick={() =&gt; handleRemoveFile(index)}&#10;                    className=&quot;hover:bg-blue-200 rounded-full p-0.5&quot;&#10;                    &gt;&#10;                    &lt;X className=&quot;w-3 h-3&quot; /&gt;&#10;                    &lt;/button&gt;&#10;                  &lt;/div&gt;&#10;                &lt;/div&gt;&#10;        {/* Tags */}&#10;        &lt;div className=&quot;space-y-2&quot;&gt;&#10;          &lt;div className=&quot;flex gap-2&quot;&gt;&#10;        {/* Category */}&#10;        &lt;div&gt;&#10;          &lt;Input&#10;            placeholder=&quot;Category (optional)&quot;&#10;            value={formData.category || ''}&#10;            onChange={(e) =&gt; handleInputChange('category', e.target.value)}&#10;        &lt;div className=&quot;space-y-2&quot;&gt;&#10;          &lt;div className=&quot;flex gap-2&quot;&gt;&#10;          /&gt;&#10;                  &lt;button&#10;                    type=&quot;button&quot;&#10;                    onClick={() =&gt; handleRemoveTag(tag)}&#10;                    className=&quot;hover:bg-blue-200 rounded-full p-0.5&quot;&#10;                  &gt;&#10;                    &lt;X className=&quot;w-3 h-3&quot; /&gt;&#10;                  &lt;/button&gt;&#10;                &lt;/span&gt;&#10;              ))}&#10;            &lt;/div&gt;&#10;          )}&#10;        &lt;/div&gt;&#10;&#10;        {/* Category */}&#10;        &lt;div&gt;&#10;          &lt;Input&#10;            placeholder=&quot;Category (optional)&quot;&#10;            value={formData.category || ''}&#10;            onChange={(e) =&gt; handleInputChange('category', e.target.value)}&#10;            className=&quot;w-full&quot;&#10;          /&gt;&#10;        {/* Visibility */}&#10;&#10;        {/* Visibility */}&#10;        &lt;div&gt;&#10;          &lt;label className=&quot;block text-sm font-medium mb-2&quot;&gt;Visibility&lt;/label&gt;&#10;          &lt;div className=&quot;flex gap-2&quot;&gt;&#10;            {visibilityOptions.map(({ value, label, icon: Icon }) =&gt; (&#10;              &lt;button&#10;                key={value}&#10;                type=&quot;button&quot;&#10;                onClick={() =&gt; handleInputChange('visibility', value)}&#10;                className={`flex items-center gap-2 px-3 py-2 rounded-lg border transition-colors ${&#10;                  formData.visibility === value&#10;                    ? 'bg-blue-50 border-blue-500 text-blue-700'&#10;                    : 'bg-white border-gray-300 text-gray-700 hover:bg-gray-50'&#10;                }`}&#10;              &gt;&#10;                &lt;Icon className=&quot;w-4 h-4&quot; /&gt;&#10;                {label}&#10;              &lt;/button&gt;&#10;            ))}&#10;          &lt;/div&gt;&#10;        &lt;/div&gt;&#10;&#10;        {/* Actions */}&#10;        &lt;div className=&quot;flex items-center justify-between pt-4 border-t&quot;&gt;&#10;          &lt;label className=&quot;block text-sm font-medium mb-2&quot;&gt;Visibility&lt;/label&gt;&#10;              type=&quot;file&quot;&#10;              multiple&#10;              accept=&quot;image/*,video/*,audio/*,.pdf&quot;&#10;              onChange={(e) =&gt; handleFileSelect(Array.from(e.target.files || []))}&#10;              className=&quot;hidden&quot;&#10;            /&gt;&#10;                className={`flex items-center gap-2 px-3 py-2 rounded-lg border transition-colors ${&#10;              type=&quot;button&quot;&#10;              variant=&quot;secondary&quot;&#10;              onClick={() =&gt; fileInputRef.current?.click()}&#10;                    ? 'bg-blue-50 border-blue-500 text-blue-700'&#10;            &gt;&#10;              &lt;Image className=&quot;w-4 h-4&quot; /&gt;&#10;              Add Media&#10;                &lt;Icon className=&quot;w-4 h-4&quot; /&gt;&#10;          &lt;/div&gt;&#10;&#10;          &lt;div className=&quot;flex gap-2&quot;&gt;&#10;            {onCancel &amp;&amp; (&#10;              &lt;Button&#10;                type=&quot;button&quot;&#10;        {/* Actions */}&#10;        &lt;div className=&quot;flex items-center justify-between pt-4 border-t&quot;&gt;&#10;          &lt;div className=&quot;flex gap-2&quot;&gt;&#10;            &lt;input&#10;              ref={fileInputRef}&#10;              type=&quot;file&quot;&#10;              multiple&#10;              accept=&quot;image/*,video/*,audio/*,.pdf&quot;&#10;              onChange={(e) =&gt; handleFileSelect(Array.from(e.target.files || []))}&#10;              className=&quot;hidden&quot;&#10;            /&gt;&#10;            &lt;Button&#10;              type=&quot;button&quot;&#10;              variant=&quot;secondary&quot;&#10;              onClick={() =&gt; fileInputRef.current?.click()}&#10;              className=&quot;flex items-center gap-2&quot;&#10;            &gt;&#10;              &lt;Image className=&quot;w-4 h-4&quot; /&gt;&#10;              Add Media&#10;            &lt;/Button&gt;&#10;          &lt;/div&gt;&#10;&#10;          &lt;div className=&quot;flex gap-2&quot;&gt;&#10;            {onCancel &amp;&amp; (&#10;              &lt;Button&#10;                type=&quot;button&quot;&#10;                variant=&quot;secondary&quot;&#10;                onClick={onCancel}&#10;              &gt;&#10;                Cancel&#10;              &lt;/Button&gt;&#10;            )}&#10;            &lt;Button&#10;              type=&quot;submit&quot;&#10;              disabled={isLoading || !formData.content.trim()}&#10;              className=&quot;flex items-center gap-2&quot;&#10;            &gt;&#10;              {isLoading &amp;&amp; &lt;LoadingSpinner /&gt;}&#10;              {isLoading ? 'Creating...' : 'Create Post'}&#10;            &lt;/Button&gt;&#10;          &lt;/div&gt;&#10;};&#10;" />
              <option name="updatedContent" value="'use client';&#10;&#10;import React, { useState, useRef } from 'react';&#10;import { Button } from '@/components/ui/Button';&#10;import { Textarea } from '@/components/ui/Textarea';&#10;import { Input } from '@/components/ui/Input';&#10;import { LoadingSpinner } from '@/components/ui/LoadingSpinner';&#10;import { ErrorAlert } from '@/components/ui/ErrorAlert';&#10;import { postService } from '@/services/postService';&#10;import { CreatePostRequest } from '@/types';&#10;import { X, Image, Hash, Globe, Users, Lock } from 'lucide-react';&#10;&#10;interface CreatePostProps {&#10;  onPostCreated?: (post: any) =&gt; void;&#10;  onCancel?: () =&gt; void;&#10;  className?: string;&#10;}&#10;&#10;export const CreatePost: React.FC&lt;CreatePostProps&gt; = ({&#10;  onPostCreated,&#10;  onCancel,&#10;  className = ''&#10;}) =&gt; {&#10;  const [formData, setFormData] = useState&lt;CreatePostRequest&gt;({&#10;    title: '',&#10;    content: '',&#10;    tags: [],&#10;    category: '',&#10;    visibility: 'PUBLIC'&#10;  });&#10;&#10;  const [files, setFiles] = useState&lt;File[]&gt;([]);&#10;  const [tagInput, setTagInput] = useState('');&#10;  const [isLoading, setIsLoading] = useState(false);&#10;  const [error, setError] = useState&lt;string | null&gt;(null);&#10;  const fileInputRef = useRef&lt;HTMLInputElement&gt;(null);&#10;&#10;  const handleInputChange = (field: keyof CreatePostRequest, value: string) =&gt; {&#10;    setFormData(prev =&gt; ({&#10;      ...prev,&#10;      [field]: value&#10;    }));&#10;  };&#10;&#10;  const handleAddTag = () =&gt; {&#10;    if (tagInput.trim() &amp;&amp; !formData.tags?.includes(tagInput.trim())) {&#10;      setFormData(prev =&gt; ({&#10;        ...prev,&#10;        tags: [...(prev.tags || []), tagInput.trim()]&#10;      }));&#10;      setTagInput('');&#10;    }&#10;  };&#10;&#10;  const handleRemoveTag = (tagToRemove: string) =&gt; {&#10;    setFormData(prev =&gt; ({&#10;      ...prev,&#10;      tags: prev.tags?.filter(tag =&gt; tag !== tagToRemove) || []&#10;    }));&#10;  };&#10;&#10;  const handleTagInputKeyDown = (e: React.KeyboardEvent) =&gt; {&#10;    if (e.key === 'Enter' || e.key === ',') {&#10;      e.preventDefault();&#10;      handleAddTag();&#10;    }&#10;  };&#10;&#10;  const handleFileSelect = (selectedFiles: File[]) =&gt; {&#10;    setFiles(selectedFiles);&#10;  };&#10;&#10;  const handleRemoveFile = (index: number) =&gt; {&#10;    setFiles(prev =&gt; prev.filter((_, i) =&gt; i !== index));&#10;  };&#10;&#10;  const handleSubmit = async (e: React.FormEvent) =&gt; {&#10;    e.preventDefault();&#10;&#10;    if (!formData.content.trim()) {&#10;      setError('Content is required');&#10;      return;&#10;    }&#10;&#10;    setIsLoading(true);&#10;    setError(null);&#10;&#10;    try {&#10;      const post = await postService.createPost(formData, files.length &gt; 0 ? files : undefined);&#10;&#10;      // Reset form&#10;      setFormData({&#10;        title: '',&#10;        content: '',&#10;        tags: [],&#10;        category: '',&#10;        visibility: 'PUBLIC'&#10;      });&#10;      setFiles([]);&#10;      setTagInput('');&#10;&#10;      if (onPostCreated) {&#10;        onPostCreated(post);&#10;      }&#10;    } catch (err: any) {&#10;      setError(err.response?.data?.message || 'Failed to create post');&#10;    } finally {&#10;      setIsLoading(false);&#10;    }&#10;  };&#10;&#10;  const visibilityOptions = [&#10;    { value: 'PUBLIC', label: 'Public', icon: Globe },&#10;    { value: 'FRIENDS', label: 'Friends', icon: Users },&#10;    { value: 'PRIVATE', label: 'Private', icon: Lock }&#10;  ];&#10;&#10;  return (&#10;    &lt;div className={`bg-white rounded-lg shadow-md p-6 ${className}`}&gt;&#10;      &lt;h3 className=&quot;text-lg font-semibold mb-4&quot;&gt;Create Post&lt;/h3&gt;&#10;      &#10;      {error &amp;&amp; (&#10;        &lt;ErrorAlert &#10;          message={error} &#10;          onClose={() =&gt; setError(null)} &#10;          className=&quot;mb-4&quot;&#10;        /&gt;&#10;      )}&#10;&#10;      &lt;form onSubmit={handleSubmit} className=&quot;space-y-4&quot;&gt;&#10;        {/* Title Input */}&#10;        &lt;Input&#10;          placeholder=&quot;Post title (optional)&quot;&#10;          value={formData.title || ''}&#10;          onChange={(e) =&gt; handleInputChange('title', e.target.value)}&#10;        /&gt;&#10;&#10;        {/* Content Textarea */}&#10;        &lt;Textarea&#10;          placeholder=&quot;What's on your mind?&quot;&#10;          value={formData.content}&#10;          onChange={(e) =&gt; handleInputChange('content', e.target.value)}&#10;          rows={4}&#10;          required&#10;        /&gt;&#10;&#10;        {/* Tags Input */}&#10;        &lt;div&gt;&#10;          &lt;div className=&quot;flex items-center gap-2 mb-2&quot;&gt;&#10;            &lt;Hash className=&quot;h-4 w-4 text-gray-500&quot; /&gt;&#10;            &lt;Input&#10;              placeholder=&quot;Add tags (press Enter or comma to add)&quot;&#10;              value={tagInput}&#10;              onChange={(e) =&gt; setTagInput(e.target.value)}&#10;              onKeyDown={handleTagInputKeyDown}&#10;            /&gt;&#10;            &lt;Button&#10;              type=&quot;button&quot;&#10;              variant=&quot;outline&quot;&#10;              size=&quot;sm&quot;&#10;              onClick={handleAddTag}&#10;              disabled={!tagInput.trim()}&#10;            &gt;&#10;              Add&#10;            &lt;/Button&gt;&#10;          &lt;/div&gt;&#10;          &#10;          {/* Display Tags */}&#10;          {formData.tags &amp;&amp; formData.tags.length &gt; 0 &amp;&amp; (&#10;            &lt;div className=&quot;flex flex-wrap gap-2&quot;&gt;&#10;              {formData.tags.map((tag, index) =&gt; (&#10;                &lt;span&#10;                  key={index}&#10;                  className=&quot;inline-flex items-center px-2 py-1 bg-blue-100 text-blue-800 text-sm rounded-full&quot;&#10;                &gt;&#10;                  #{tag}&#10;                  &lt;button&#10;                    type=&quot;button&quot;&#10;                    onClick={() =&gt; handleRemoveTag(tag)}&#10;                    className=&quot;ml-1 text-blue-600 hover:text-blue-800&quot;&#10;                  &gt;&#10;                    &lt;X className=&quot;h-3 w-3&quot; /&gt;&#10;                  &lt;/button&gt;&#10;                &lt;/span&gt;&#10;              ))}&#10;            &lt;/div&gt;&#10;          )}&#10;        &lt;/div&gt;&#10;&#10;        {/* Category Input */}&#10;        &lt;Input&#10;          placeholder=&quot;Category (optional)&quot;&#10;          value={formData.category || ''}&#10;          onChange={(e) =&gt; handleInputChange('category', e.target.value)}&#10;        /&gt;&#10;&#10;        {/* File Upload */}&#10;        &lt;div&gt;&#10;          &lt;input&#10;            ref={fileInputRef}&#10;            type=&quot;file&quot;&#10;            multiple&#10;            accept=&quot;image/*,video/*&quot;&#10;            onChange={(e) =&gt; {&#10;              const selectedFiles = Array.from(e.target.files || []);&#10;              handleFileSelect(selectedFiles);&#10;            }}&#10;            className=&quot;hidden&quot;&#10;          /&gt;&#10;          &#10;          &lt;Button&#10;            type=&quot;button&quot;&#10;            variant=&quot;outline&quot;&#10;            onClick={() =&gt; fileInputRef.current?.click()}&#10;            className=&quot;w-full&quot;&#10;          &gt;&#10;            &lt;Image className=&quot;h-4 w-4 mr-2&quot; /&gt;&#10;            Add Photos/Videos&#10;          &lt;/Button&gt;&#10;&#10;          {/* Display Selected Files */}&#10;          {files.length &gt; 0 &amp;&amp; (&#10;            &lt;div className=&quot;mt-2 space-y-2&quot;&gt;&#10;              {files.map((file, index) =&gt; (&#10;                &lt;div&#10;                  key={index}&#10;                  className=&quot;flex items-center justify-between p-2 bg-gray-50 rounded&quot;&#10;                &gt;&#10;                  &lt;span className=&quot;text-sm text-gray-700&quot;&gt;{file.name}&lt;/span&gt;&#10;                  &lt;button&#10;                    type=&quot;button&quot;&#10;                    onClick={() =&gt; handleRemoveFile(index)}&#10;                    className=&quot;text-red-500 hover:text-red-700&quot;&#10;                  &gt;&#10;                    &lt;X className=&quot;h-4 w-4&quot; /&gt;&#10;                  &lt;/button&gt;&#10;                &lt;/div&gt;&#10;              ))}&#10;            &lt;/div&gt;&#10;          )}&#10;        &lt;/div&gt;&#10;&#10;        {/* Visibility Selector */}&#10;        &lt;div&gt;&#10;          &lt;label className=&quot;block text-sm font-medium text-gray-700 mb-2&quot;&gt;&#10;            Visibility&#10;          &lt;/label&gt;&#10;          &lt;div className=&quot;flex gap-2&quot;&gt;&#10;            {visibilityOptions.map(({ value, label, icon: Icon }) =&gt; (&#10;              &lt;button&#10;                key={value}&#10;                type=&quot;button&quot;&#10;                onClick={() =&gt; handleInputChange('visibility', value)}&#10;                className={`flex items-center px-3 py-2 rounded-md border transition-colors ${&#10;                  formData.visibility === value&#10;                    ? 'bg-blue-50 border-blue-300 text-blue-700'&#10;                    : 'bg-white border-gray-300 text-gray-700 hover:bg-gray-50'&#10;                }`}&#10;              &gt;&#10;                &lt;Icon className=&quot;h-4 w-4 mr-2&quot; /&gt;&#10;                {label}&#10;              &lt;/button&gt;&#10;            ))}&#10;          &lt;/div&gt;&#10;        &lt;/div&gt;&#10;&#10;        {/* Action Buttons */}&#10;        &lt;div className=&quot;flex justify-end gap-2 pt-4&quot;&gt;&#10;          {onCancel &amp;&amp; (&#10;            &lt;Button&#10;              type=&quot;button&quot;&#10;              variant=&quot;outline&quot;&#10;              onClick={onCancel}&#10;              disabled={isLoading}&#10;            &gt;&#10;              Cancel&#10;            &lt;/Button&gt;&#10;          )}&#10;          &lt;Button&#10;            type=&quot;submit&quot;&#10;            disabled={isLoading || !formData.content.trim()}&#10;            loading={isLoading}&#10;          &gt;&#10;            {isLoading ? 'Creating...' : 'Create Post'}&#10;          &lt;/Button&gt;&#10;        &lt;/div&gt;&#10;      &lt;/form&gt;&#10;    &lt;/div&gt;&#10;  );&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/client-frontend/src/components/post/PostFeed.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/client-frontend/src/components/post/PostFeed.tsx" />
              <option name="originalContent" value="'use client';&#10;&#10;import React, { useState, useEffect, useCallback } from 'react';&#10;import { Post, PaginatedResponse } from '@/types';&#10;import { postService } from '@/services/postService';&#10;import  PostCard  from './PostCard';&#10;import  CreatePost  from './CreatePost';&#10;import  LoadingSpinner  from '@/components/ui/LoadingSpinner';&#10;import  ErrorAlert  from '@/components/ui/ErrorAlert';&#10;import  Button  from '@/components/ui/Button';&#10;import { RefreshCw, Plus, TrendingUp, Eye, Heart } from 'lucide-react';&#10;&#10;interface PostFeedProps {&#10;  authorId?: string;&#10;  category?: string;&#10;  search?: string;&#10;  className?: string;&#10;}&#10;&#10;export const PostFeed: React.FC&lt;PostFeedProps&gt; = ({&#10;  authorId,&#10;  category,&#10;  search,&#10;  className = ''&#10;}) =&gt; {&#10;  const [posts, setPosts] = useState&lt;Post[]&gt;([]);&#10;  const [isLoading, setIsLoading] = useState(true);&#10;  const [isLoadingMore, setIsLoadingMore] = useState(false);&#10;  const [error, setError] = useState&lt;string | null&gt;(null);&#10;  const [hasMore, setHasMore] = useState(true);&#10;  const [currentPage, setCurrentPage] = useState(0);&#10;  const [showCreatePost, setShowCreatePost] = useState(false);&#10;  const [activeTab, setActiveTab] = useState&lt;'latest' | 'trending' | 'top-liked'&gt;('latest');&#10;&#10;  const loadPosts = useCallback(async (page = 0, append = false) =&gt; {&#10;    try {&#10;      if (!append) {&#10;        setIsLoading(true);&#10;        setError(null);&#10;      } else {&#10;        setIsLoadingMore(true);&#10;      }&#10;&#10;      let response: PaginatedResponse&lt;Post&gt;;&#10;&#10;      if (activeTab === 'trending') {&#10;        const trendingPosts = await postService.getTopViewedPosts();&#10;        response = {&#10;          content: trendingPosts,&#10;          totalElements: trendingPosts.length,&#10;          totalPages: 1,&#10;          size: trendingPosts.length,&#10;          number: 0,&#10;          first: true,&#10;          last: true&#10;        };&#10;      } else if (activeTab === 'top-liked') {&#10;        const topLikedPosts = await postService.getTopLikedPosts();&#10;        response = {&#10;          content: topLikedPosts,&#10;          totalElements: topLikedPosts.length,&#10;          totalPages: 1,&#10;          size: topLikedPosts.length,&#10;          number: 0,&#10;          first: true,&#10;          last: true&#10;        };&#10;      } else {&#10;        response = await postService.getPosts(&#10;          10,&#10;          10,&#10;          'createdAt',&#10;          'desc',&#10;          'desc',&#10;          authorId,&#10;          category,&#10;          search&#10;        );&#10;      }&#10;&#10;      if (append) {&#10;        setPosts(prev =&gt; [...prev, ...response.content]);&#10;      } else {&#10;        setPosts(response.content);&#10;      }&#10;      setCurrentPage(page);&#10;      setHasMore(!response.last &amp;&amp; response.content.length &gt; 0);&#10;      console.error('Failed to load posts:', err);&#10;      setError(err.response?.data?.message || err.message || 'Failed to load posts');&#10;    } catch (err: any) {&#10;      console.error('Failed to load posts:', err);&#10;      setError(err.response?.data?.message || err.message || 'Failed to load posts');&#10;    } finally {&#10;      setIsLoading(false);&#10;      setIsLoadingMore(false);&#10;    setCurrentPage(0);&#10;  // Initial load and reload when filters change&#10;    }&#10;  }, [authorId, category, search, activeTab]);&#10;&#10;  // Initial load and reload when filters change&#10;  useEffect(() =&gt; {&#10;    setCurrentPage(0);&#10;    loadPosts(0, false);&#10;  }, [loadPosts]);&#10;&#10;  const handleLoadMore = () =&gt; {&#10;    if (hasMore &amp;&amp; !isLoadingMore) {&#10;      loadPosts(currentPage + 1, true);&#10;    }&#10;  };&#10;&#10;  const handlePostCreated = (newPost: Post) =&gt; {&#10;    setPosts(prev =&gt; [newPost, ...prev]);&#10;    setShowCreatePost(false);&#10;    setPosts(prev =&gt; prev.map(post =&gt;&#10;&#10;  const handlePostUpdate = (updatedPost: Post) =&gt; {&#10;    setPosts(prev =&gt; prev.map(post =&gt;&#10;      post.id === updatedPost.id ? updatedPost : post&#10;    ));&#10;  };&#10;&#10;  const handlePostDelete = (postId: string) =&gt; {&#10;    setPosts(prev =&gt; prev.filter(post =&gt; post.id !== postId));&#10;  };&#10;&#10;  const handleTabChange = (tab: 'latest' | 'trending' | 'top-liked') =&gt; {&#10;    setActiveTab(tab);&#10;  const handleTabChange = (tab: 'latest' | 'trending' | 'top-liked') =&gt; {&#10;    setActiveTab(tab);&#10;    setCurrentPage(0);&#10;  };&#10;      &lt;div className=&quot;flex justify-center py-8&quot;&gt;&#10;  if (isLoading) {&#10;      &lt;/div&gt;&#10;    );&#10;      &lt;div className=&quot;flex justify-center py-8&quot;&gt;&#10;&#10;  return (&#10;    &lt;div className={`post-feed ${className}`}&gt;&#10;      {/* Feed Header */}&#10;      &lt;div className=&quot;bg-white rounded-lg shadow-sm border p-4 mb-6&quot;&gt;&#10;        &lt;div className=&quot;flex items-center justify-between mb-4&quot;&gt;&#10;    &lt;div className={`post-feed ${className}`}&gt;&#10;      {/* Feed Header */}&#10;      &lt;div className=&quot;bg-white rounded-lg shadow-sm border p-4 mb-6&quot;&gt;&#10;             authorId ? 'User Posts' : 'Latest Posts'}&#10;          &lt;h2 className=&quot;text-xl font-semibold&quot;&gt;&#10;            {search ? `Search results for &quot;${search}&quot;` :&#10;             category ? `Posts in ${category}` :&#10;             authorId ? 'User Posts' : 'Latest Posts'}&#10;          &lt;/h2&gt;&#10;                size=&quot;sm&quot;&#10;          &lt;div className=&quot;flex items-center gap-2&quot;&gt;&#10;                className=&quot;flex items-center gap-2&quot;&#10;              &gt;&#10;                &lt;Plus className=&quot;w-4 h-4&quot; /&gt;&#10;                Create Post&#10;              &lt;/Button&gt;&#10;            )}&#10;          &lt;/div&gt;&#10;        &lt;/div&gt;&#10;&#10;        {/* Feed Tabs */}&#10;        {!search &amp;&amp; !category &amp;&amp; !authorId &amp;&amp; (&#10;          &lt;div className=&quot;flex gap-2&quot;&gt;&#10;              variant=&quot;secondary&quot;&#10;              variant={activeTab === 'latest' ? 'primary' : 'secondary'}&#10;              size=&quot;sm&quot;&#10;              onClick={() =&gt; handleTabChange('latest')}&#10;              className=&quot;flex items-center gap-2&quot;&#10;              className=&quot;flex items-center gap-2&quot;&#10;              &lt;RefreshCw className={`w-4 h-4 ${isLoading ? 'animate-spin' : ''}`} /&gt;&#10;              &lt;RefreshCw className=&quot;w-4 h-4&quot; /&gt;&#10;&#10;            {!authorId &amp;&amp; (&#10;              &lt;Button&#10;                size=&quot;sm&quot;&#10;                onClick={() =&gt; setShowCreatePost(true)}&#10;                className=&quot;flex items-center gap-2&quot;&#10;              &gt;&#10;                &lt;Plus className=&quot;w-4 h-4&quot; /&gt;&#10;                Create Post&#10;              &lt;/Button&gt;&#10;            )}&#10;              &lt;Eye className=&quot;w-4 h-4&quot; /&gt;&#10;              Trending&#10;            &lt;/Button&gt;&#10;        {/* Feed Tabs */}&#10;        {!search &amp;&amp; !category &amp;&amp; !authorId &amp;&amp; (&#10;          &lt;div className=&quot;flex gap-2&quot;&gt;&#10;            &lt;Button&#10;              variant={activeTab === 'latest' ? 'primary' : 'secondary'}&#10;              size=&quot;sm&quot;&#10;              onClick={() =&gt; handleTabChange('latest')}&#10;              className=&quot;flex items-center gap-2&quot;&#10;            &gt;&#10;              &lt;RefreshCw className=&quot;w-4 h-4&quot; /&gt;&#10;        &lt;div className=&quot;bg-white rounded-lg shadow-sm border p-6 mb-6&quot;&gt;&#10;          &lt;div className=&quot;flex items-center justify-between mb-4&quot;&gt;&#10;            &lt;h3 className=&quot;text-lg font-semibold&quot;&gt;Create New Post&lt;/h3&gt;&#10;            &lt;Button&#10;              variant=&quot;ghost&quot;&#10;              size=&quot;sm&quot;&#10;              onClick={() =&gt; setShowCreatePost(false)}&#10;            &gt;&#10;        &lt;div className=&quot;mb-6&quot;&gt;&#10;          &lt;ErrorAlert message={error} /&gt;&#10;        &lt;/div&gt;&#10;            onPostCreated={handlePostCreated}&#10;            onCancel={() =&gt; setShowCreatePost(false)}&#10;          /&gt;&#10;      {posts.length === 0 ? (&#10;        &lt;div className=&quot;text-center py-12&quot;&gt;&#10;          &lt;div className=&quot;text-gray-400 mb-4&quot;&gt;&#10;            &lt;TrendingUp className=&quot;w-16 h-16 mx-auto&quot; /&gt;&#10;          &lt;/div&gt;&#10;          &lt;h3 className=&quot;text-lg font-medium text-gray-900 mb-2&quot;&gt;No posts found&lt;/h3&gt;&#10;          &lt;p className=&quot;text-gray-500 mb-4&quot;&gt;&#10;            {search ? 'Try adjusting your search terms' :&#10;             category ? 'No posts in this category yet' :&#10;             'Be the first to create a post!'}&#10;          &lt;/p&gt;&#10;          {!authorId &amp;&amp; !search &amp;&amp; !category &amp;&amp; (&#10;            &lt;Button onClick={() =&gt; setShowCreatePost(true)}&gt;&#10;              Create First Post&#10;            &lt;/Button&gt;&#10;          )}&#10;        &lt;/div&gt;&#10;      ) : (&#10;        &lt;div className=&quot;space-y-6&quot;&gt;&#10;          {posts.map((post) =&gt; (&#10;&#10;      {/* Create Post Modal/Inline */}&#10;      {showCreatePost &amp;&amp; (&#10;        &lt;div className=&quot;bg-white rounded-lg shadow-sm border p-6 mb-6&quot;&gt;&#10;          &lt;div className=&quot;flex items-center justify-between mb-4&quot;&gt;&#10;            &lt;h3 className=&quot;text-lg font-semibold&quot;&gt;Create New Post&lt;/h3&gt;&#10;            &lt;Button&#10;          ))}&#10;            &gt;&#10;              Cancel&#10;            &lt;/Button&gt;&#10;          {/* Load More Button */}&#10;          {hasMore &amp;&amp; (&#10;            &lt;div className=&quot;text-center py-6&quot;&gt;&#10;              &lt;Button&#10;                variant=&quot;secondary&quot;&#10;                onClick={handleLoadMore}&#10;                disabled={isLoadingMore}&#10;                className=&quot;flex items-center gap-2&quot;&#10;              &gt;&#10;                {isLoadingMore &amp;&amp; &lt;LoadingSpinner size=&quot;sm&quot; /&gt;}&#10;                {isLoadingMore ? 'Loading...' : 'Load More Posts'}&#10;              &lt;/Button&gt;&#10;            &lt;/div&gt;&#10;          )}&#10;      )}&#10;&#10;      {/* Posts List */}&#10;          {/* End of Feed Message */}&#10;          {!hasMore &amp;&amp; posts.length &gt; 0 &amp;&amp; (&#10;            &lt;div className=&quot;text-center py-6 text-gray-500&quot;&gt;&#10;              &lt;p&gt;You've reached the end of the feed&lt;/p&gt;&#10;            &lt;/div&gt;&#10;          )}&#10;          &lt;/div&gt;&#10;          &lt;h3 className=&quot;text-lg font-medium text-gray-900 mb-2&quot;&gt;No posts found&lt;/h3&gt;&#10;          &lt;p className=&quot;text-gray-500 mb-4&quot;&gt;&#10;            {search ? 'Try adjusting your search terms' :&#10;             category ? 'No posts in this category yet' :&#10;             'Be the first to create a post!'}&#10;          &lt;/p&gt;&#10;          {!authorId &amp;&amp; !search &amp;&amp; !category &amp;&amp; (&#10;            &lt;Button onClick={() =&gt; setShowCreatePost(true)}&gt;&#10;              Create First Post&#10;            &lt;/Button&gt;&#10;          )}&#10;        &lt;/div&gt;&#10;      ) : (&#10;        &lt;div className=&quot;space-y-6&quot;&gt;&#10;          {posts.map((post) =&gt; (&#10;            &lt;PostCard&#10;              key={post.id}&#10;              post={post}&#10;              onPostUpdate={handlePostUpdate}&#10;              onPostDelete={handlePostDelete}&#10;            /&gt;&#10;          ))}&#10;&#10;          {/* Load More Button */}&#10;          {hasMore &amp;&amp; (&#10;            &lt;div className=&quot;text-center py-6&quot;&gt;&#10;              &lt;Button&#10;                variant=&quot;secondary&quot;&#10;                onClick={handleLoadMore}&#10;                disabled={isLoadingMore}&#10;                className=&quot;flex items-center gap-2&quot;&#10;              &gt;&#10;                {isLoadingMore &amp;&amp; &lt;LoadingSpinner size=&quot;sm&quot; /&gt;}&#10;                {isLoadingMore ? 'Loading...' : 'Load More Posts'}&#10;              &lt;/Button&gt;&#10;            &lt;/div&gt;&#10;          )}&#10;&#10;          {/* End of Feed Message */}&#10;          {!hasMore &amp;&amp; posts.length &gt; 0 &amp;&amp; (&#10;            &lt;div className=&quot;text-center py-6 text-gray-500&quot;&gt;&#10;              &lt;p&gt;You've reached the end of the feed&lt;/p&gt;&#10;            &lt;/div&gt;&#10;          )}&#10;        &lt;/div&gt;&#10;      )}&#10;    &lt;/div&gt;&#10;  );&#10;};&#10;" />
              <option name="updatedContent" value="'use client';&#10;&#10;import React, { useState, useEffect, useCallback } from 'react';&#10;import { Post, PaginatedResponse } from '@/types';&#10;import { postService } from '@/services/postService';&#10;import { PostCard } from './PostCard';&#10;import { CreatePost } from './CreatePost';&#10;import { LoadingSpinner } from '@/components/ui/LoadingSpinner';&#10;import { ErrorAlert } from '@/components/ui/ErrorAlert';&#10;import { Button } from '@/components/ui/Button';&#10;import { RefreshCw, Plus, TrendingUp, Eye, Heart } from 'lucide-react';&#10;&#10;interface PostFeedProps {&#10;  authorId?: string;&#10;  category?: string;&#10;  search?: string;&#10;  className?: string;&#10;}&#10;&#10;export const PostFeed: React.FC&lt;PostFeedProps&gt; = ({&#10;  authorId,&#10;  category,&#10;  search,&#10;  className = ''&#10;}) =&gt; {&#10;  const [posts, setPosts] = useState&lt;Post[]&gt;([]);&#10;  const [isLoading, setIsLoading] = useState(true);&#10;  const [isLoadingMore, setIsLoadingMore] = useState(false);&#10;  const [error, setError] = useState&lt;string | null&gt;(null);&#10;  const [hasMore, setHasMore] = useState(true);&#10;  const [currentPage, setCurrentPage] = useState(0);&#10;  const [showCreatePost, setShowCreatePost] = useState(false);&#10;  const [activeTab, setActiveTab] = useState&lt;'latest' | 'trending' | 'top-liked'&gt;('latest');&#10;&#10;  const loadPosts = useCallback(async (page = 0, append = false) =&gt; {&#10;    try {&#10;      if (!append) {&#10;        setIsLoading(true);&#10;        setError(null);&#10;      } else {&#10;        setIsLoadingMore(true);&#10;      }&#10;&#10;      let response: PaginatedResponse&lt;Post&gt;;&#10;&#10;      if (activeTab === 'trending') {&#10;        const trendingPosts = await postService.getTopViewedPosts();&#10;        response = {&#10;          content: trendingPosts,&#10;          totalElements: trendingPosts.length,&#10;          totalPages: 1,&#10;          size: trendingPosts.length,&#10;          number: 0,&#10;          first: true,&#10;          last: true&#10;        };&#10;      } else if (activeTab === 'top-liked') {&#10;        const topLikedPosts = await postService.getTopLikedPosts();&#10;        response = {&#10;          content: topLikedPosts,&#10;          totalElements: topLikedPosts.length,&#10;          totalPages: 1,&#10;          size: topLikedPosts.length,&#10;          number: 0,&#10;          first: true,&#10;          last: true&#10;        };&#10;      } else {&#10;        // Latest posts&#10;        response = await postService.getPosts({&#10;          page,&#10;          size: 10,&#10;          authorId,&#10;          category,&#10;          search&#10;        });&#10;      }&#10;&#10;      if (append) {&#10;        setPosts(prev =&gt; [...prev, ...response.content]);&#10;      } else {&#10;        setPosts(response.content);&#10;      }&#10;&#10;      setHasMore(!response.last &amp;&amp; response.content.length &gt; 0);&#10;      setCurrentPage(response.number);&#10;    } catch (err: any) {&#10;      setError(err.response?.data?.message || 'Failed to load posts');&#10;    } finally {&#10;      setIsLoading(false);&#10;      setIsLoadingMore(false);&#10;    }&#10;  }, [authorId, category, search, activeTab]);&#10;&#10;  useEffect(() =&gt; {&#10;    loadPosts(0, false);&#10;  }, [loadPosts]);&#10;&#10;  const handleLoadMore = () =&gt; {&#10;    if (hasMore &amp;&amp; !isLoadingMore) {&#10;      loadPosts(currentPage + 1, true);&#10;    }&#10;  };&#10;&#10;  const handleRefresh = () =&gt; {&#10;    setCurrentPage(0);&#10;    loadPosts(0, false);&#10;  };&#10;&#10;  const handleTabChange = (tab: 'latest' | 'trending' | 'top-liked') =&gt; {&#10;    setActiveTab(tab);&#10;    setCurrentPage(0);&#10;  };&#10;&#10;  const handlePostCreated = (newPost: Post) =&gt; {&#10;    setPosts(prev =&gt; [newPost, ...prev]);&#10;    setShowCreatePost(false);&#10;  };&#10;&#10;  const handlePostUpdate = (updatedPost: Post) =&gt; {&#10;    setPosts(prev =&gt; prev.map(post =&gt; &#10;      post.id === updatedPost.id ? updatedPost : post&#10;    ));&#10;  };&#10;&#10;  const handlePostDelete = (postId: string) =&gt; {&#10;    setPosts(prev =&gt; prev.filter(post =&gt; post.id !== postId));&#10;  };&#10;&#10;  const tabs = [&#10;    { key: 'latest', label: 'Latest', icon: RefreshCw },&#10;    { key: 'trending', label: 'Trending', icon: TrendingUp },&#10;    { key: 'top-liked', label: 'Most Liked', icon: Heart }&#10;  ];&#10;&#10;  if (isLoading &amp;&amp; posts.length === 0) {&#10;    return (&#10;      &lt;div className=&quot;flex justify-center items-center min-h-64&quot;&gt;&#10;        &lt;LoadingSpinner size=&quot;lg&quot; /&gt;&#10;      &lt;/div&gt;&#10;    );&#10;  }&#10;&#10;  return (&#10;    &lt;div className={`space-y-6 ${className}`}&gt;&#10;      {/* Header with tabs and create button */}&#10;      &lt;div className=&quot;bg-white rounded-lg shadow-sm p-4&quot;&gt;&#10;        &lt;div className=&quot;flex items-center justify-between mb-4&quot;&gt;&#10;          &lt;div className=&quot;flex space-x-1&quot;&gt;&#10;            {tabs.map(({ key, label, icon: Icon }) =&gt; (&#10;              &lt;button&#10;                key={key}&#10;                onClick={() =&gt; handleTabChange(key as any)}&#10;                className={`flex items-center px-4 py-2 rounded-md transition-colors ${&#10;                  activeTab === key&#10;                    ? 'bg-blue-100 text-blue-700 border border-blue-200'&#10;                    : 'text-gray-600 hover:bg-gray-100'&#10;                }`}&#10;              &gt;&#10;                &lt;Icon className=&quot;h-4 w-4 mr-2&quot; /&gt;&#10;                {label}&#10;              &lt;/button&gt;&#10;            ))}&#10;          &lt;/div&gt;&#10;&#10;          &lt;div className=&quot;flex gap-2&quot;&gt;&#10;            &lt;Button&#10;              variant=&quot;outline&quot;&#10;              size=&quot;sm&quot;&#10;              onClick={handleRefresh}&#10;              disabled={isLoading}&#10;            &gt;&#10;              &lt;RefreshCw className={`h-4 w-4 mr-2 ${isLoading ? 'animate-spin' : ''}`} /&gt;&#10;              Refresh&#10;            &lt;/Button&gt;&#10;            &#10;            &lt;Button&#10;              size=&quot;sm&quot;&#10;              onClick={() =&gt; setShowCreatePost(!showCreatePost)}&#10;            &gt;&#10;              &lt;Plus className=&quot;h-4 w-4 mr-2&quot; /&gt;&#10;              Create Post&#10;            &lt;/Button&gt;&#10;          &lt;/div&gt;&#10;        &lt;/div&gt;&#10;&#10;        {/* Search/Filter Info */}&#10;        {(search || category || authorId) &amp;&amp; (&#10;          &lt;div className=&quot;text-sm text-gray-600 mb-2&quot;&gt;&#10;            Showing posts&#10;            {search &amp;&amp; ` matching &quot;${search}&quot;`}&#10;            {category &amp;&amp; ` in category &quot;${category}&quot;`}&#10;            {authorId &amp;&amp; ` by author`}&#10;          &lt;/div&gt;&#10;        )}&#10;      &lt;/div&gt;&#10;&#10;      {/* Create Post Form */}&#10;      {showCreatePost &amp;&amp; (&#10;        &lt;CreatePost&#10;          onPostCreated={handlePostCreated}&#10;          onCancel={() =&gt; setShowCreatePost(false)}&#10;        /&gt;&#10;      )}&#10;&#10;      {/* Error Alert */}&#10;      {error &amp;&amp; (&#10;        &lt;ErrorAlert &#10;          message={error} &#10;          onClose={() =&gt; setError(null)} &#10;        /&gt;&#10;      )}&#10;&#10;      {/* Posts List */}&#10;      &lt;div className=&quot;space-y-4&quot;&gt;&#10;        {posts.length === 0 &amp;&amp; !isLoading ? (&#10;          &lt;div className=&quot;text-center py-12 bg-white rounded-lg shadow-sm&quot;&gt;&#10;            &lt;div className=&quot;text-gray-500 mb-4&quot;&gt;&#10;              &lt;Eye className=&quot;h-12 w-12 mx-auto mb-2 opacity-50&quot; /&gt;&#10;              &lt;p className=&quot;text-lg font-medium&quot;&gt;No posts found&lt;/p&gt;&#10;              &lt;p className=&quot;text-sm&quot;&gt;&#10;                {search || category &#10;                  ? 'Try adjusting your search criteria' &#10;                  : 'Be the first to share something!'&#10;                }&#10;              &lt;/p&gt;&#10;            &lt;/div&gt;&#10;            {!search &amp;&amp; !category &amp;&amp; !authorId &amp;&amp; (&#10;              &lt;Button onClick={() =&gt; setShowCreatePost(true)}&gt;&#10;                &lt;Plus className=&quot;h-4 w-4 mr-2&quot; /&gt;&#10;                Create Your First Post&#10;              &lt;/Button&gt;&#10;            )}&#10;          &lt;/div&gt;&#10;        ) : (&#10;          posts.map((post) =&gt; (&#10;            &lt;PostCard&#10;              key={post.id}&#10;              post={post}&#10;              onPostUpdate={handlePostUpdate}&#10;              onPostDelete={handlePostDelete}&#10;            /&gt;&#10;          ))&#10;        )}&#10;      &lt;/div&gt;&#10;&#10;      {/* Load More Button */}&#10;      {hasMore &amp;&amp; posts.length &gt; 0 &amp;&amp; (&#10;        &lt;div className=&quot;flex justify-center pt-4&quot;&gt;&#10;          &lt;Button&#10;            variant=&quot;outline&quot;&#10;            onClick={handleLoadMore}&#10;            disabled={isLoadingMore}&#10;            loading={isLoadingMore}&#10;          &gt;&#10;            {isLoadingMore ? 'Loading...' : 'Load More Posts'}&#10;          &lt;/Button&gt;&#10;        &lt;/div&gt;&#10;      )}&#10;&#10;      {/* Loading indicator for infinite scroll */}&#10;      {isLoadingMore &amp;&amp; (&#10;        &lt;div className=&quot;flex justify-center py-4&quot;&gt;&#10;          &lt;LoadingSpinner /&gt;&#10;        &lt;/div&gt;&#10;      )}&#10;    &lt;/div&gt;&#10;  );&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/client-frontend/src/components/ui/Button.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/client-frontend/src/components/ui/Button.tsx" />
              <option name="originalContent" value="import React, { ButtonHTMLAttributes, forwardRef } from 'react';&#10;import { cn } from '@/utils/helpers';&#10;&#10;interface ButtonProps extends ButtonHTMLAttributes&lt;HTMLButtonElement&gt; {&#10;  variant?: 'primary' | 'secondary' | 'outline' | 'ghost' | 'danger';&#10;  size?: 'sm' | 'md' | 'lg';&#10;  loading?: boolean;&#10;}&#10;&#10;const Button = forwardRef&lt;HTMLButtonElement, ButtonProps&gt;(&#10;  ({ className, variant = 'primary', size = 'md', loading, children, disabled, ...props }, ref) =&gt; {&#10;    const baseStyles = 'inline-flex items-center justify-center rounded-md font-medium transition-colors focus:outline-none focus:ring-2 focus:ring-offset-2 disabled:opacity-50 disabled:cursor-not-allowed';&#10;&#10;    const variants = {&#10;      primary: 'bg-indigo-600 text-white hover:bg-indigo-700 focus:ring-indigo-500',&#10;      secondary: 'bg-gray-200 text-gray-900 hover:bg-gray-300 focus:ring-gray-500',&#10;      outline: 'border border-gray-300 bg-white text-gray-700 hover:bg-gray-50 focus:ring-indigo-500',&#10;      ghost: 'text-gray-700 hover:bg-gray-100 focus:ring-gray-500',&#10;      danger: 'bg-red-600 text-white hover:bg-red-700 focus:ring-red-500',&#10;    };&#10;&#10;    const sizes = {&#10;      sm: 'px-3 py-1.5 text-sm',&#10;      md: 'px-4 py-2 text-base',&#10;      lg: 'px-6 py-3 text-lg',&#10;    };&#10;&#10;    return (&#10;      &lt;button&#10;        className={cn(baseStyles, variants[variant], sizes[size], className)}&#10;        disabled={disabled || loading}&#10;        ref={ref}&#10;        {...props}&#10;      &gt;&#10;        {loading &amp;&amp; (&#10;          &lt;svg className=&quot;animate-spin -ml-1 mr-3 h-4 w-4 text-white&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; fill=&quot;none&quot; viewBox=&quot;0 0 24 24&quot;&gt;&#10;            &lt;circle className=&quot;opacity-25&quot; cx=&quot;12&quot; cy=&quot;12&quot; r=&quot;10&quot; stroke=&quot;currentColor&quot; strokeWidth=&quot;4&quot;&gt;&lt;/circle&gt;&#10;            &lt;path className=&quot;opacity-75&quot; fill=&quot;currentColor&quot; d=&quot;M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z&quot;&gt;&lt;/path&gt;&#10;          &lt;/svg&gt;&#10;        )}&#10;        {children}&#10;      &lt;/button&gt;&#10;    );&#10;  }&#10;);&#10;&#10;Button.displayName = 'Button';&#10;&#10;" />
              <option name="updatedContent" value="import React, { ButtonHTMLAttributes, forwardRef } from 'react';&#13;&#10;import { cn } from '@/utils/helpers';&#13;&#10;&#13;&#10;interface ButtonProps extends ButtonHTMLAttributes&lt;HTMLButtonElement&gt; {&#13;&#10;  variant?: 'primary' | 'secondary' | 'outline' | 'ghost' | 'danger';&#13;&#10;  size?: 'sm' | 'md' | 'lg';&#13;&#10;  loading?: boolean;&#13;&#10;}&#13;&#10;&#13;&#10;const Button = forwardRef&lt;HTMLButtonElement, ButtonProps&gt;(&#13;&#10;  ({ className, variant = 'primary', size = 'md', loading, children, disabled, ...props }, ref) =&gt; {&#13;&#10;    const baseStyles = 'inline-flex items-center justify-center rounded-md font-medium transition-colors focus:outline-none focus:ring-2 focus:ring-offset-2 disabled:opacity-50 disabled:cursor-not-allowed';&#13;&#10;&#13;&#10;    const variants = {&#13;&#10;      primary: 'bg-indigo-600 text-white hover:bg-indigo-700 focus:ring-indigo-500',&#13;&#10;      secondary: 'bg-gray-200 text-gray-900 hover:bg-gray-300 focus:ring-gray-500',&#13;&#10;      outline: 'border border-gray-300 bg-white text-gray-700 hover:bg-gray-50 focus:ring-indigo-500',&#13;&#10;      ghost: 'text-gray-700 hover:bg-gray-100 focus:ring-gray-500',&#13;&#10;      danger: 'bg-red-600 text-white hover:bg-red-700 focus:ring-red-500',&#13;&#10;    };&#13;&#10;&#13;&#10;    const sizes = {&#13;&#10;      sm: 'px-3 py-1.5 text-sm',&#13;&#10;      md: 'px-4 py-2 text-base',&#13;&#10;      lg: 'px-6 py-3 text-lg',&#13;&#10;    };&#13;&#10;&#13;&#10;    return (&#13;&#10;      &lt;button&#13;&#10;        className={cn(baseStyles, variants[variant], sizes[size], className)}&#13;&#10;        disabled={disabled || loading}&#13;&#10;        ref={ref}&#13;&#10;        {...props}&#13;&#10;      &gt;&#13;&#10;        {loading &amp;&amp; (&#13;&#10;          &lt;svg className=&quot;animate-spin -ml-1 mr-3 h-4 w-4 text-white&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; fill=&quot;none&quot; viewBox=&quot;0 0 24 24&quot;&gt;&#13;&#10;            &lt;circle className=&quot;opacity-25&quot; cx=&quot;12&quot; cy=&quot;12&quot; r=&quot;10&quot; stroke=&quot;currentColor&quot; strokeWidth=&quot;4&quot;&gt;&lt;/circle&gt;&#13;&#10;            &lt;path className=&quot;opacity-75&quot; fill=&quot;currentColor&quot; d=&quot;M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z&quot;&gt;&lt;/path&gt;&#13;&#10;          &lt;/svg&gt;&#13;&#10;        )}&#13;&#10;        {children}&#13;&#10;      &lt;/button&gt;&#13;&#10;    );&#13;&#10;  }&#13;&#10;);&#13;&#10;&#13;&#10;Button.displayName = 'Button';&#13;&#10;&#13;&#10;export { Button };&#13;&#10;export default Button;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/client-frontend/src/components/ui/Card.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/client-frontend/src/components/ui/Card.tsx" />
              <option name="originalContent" value="import React, { HTMLAttributes, forwardRef, ReactNode } from 'react';&#10;import { cn } from '@/utils/helpers';&#10;&#10;interface CardProps extends HTMLAttributes&lt;HTMLDivElement&gt; {&#10;  variant?: 'default' | 'outlined' | 'elevated';&#10;  children: ReactNode;&#10;  className?: string;&#10;  padding?: 'none' | 'sm' | 'md' | 'lg';&#10;  hover?: boolean;&#10;}&#10;&#10;const Card = forwardRef&lt;HTMLDivElement, CardProps&gt;(&#10;  (&#10;    {&#10;      className,&#10;      variant = 'default',&#10;      children,&#10;      padding = 'md',&#10;      hover = false,&#10;      ...props&#10;    },&#10;    ref&#10;  ) =&gt; {&#10;    const baseStyles = 'bg-white rounded-lg';&#10;&#10;    const variants = {&#10;      default: 'shadow-md',&#10;      outlined: 'border border-gray-200',&#10;      elevated: 'shadow-lg',&#10;    };&#10;&#10;    const paddings = {&#10;      none: '',&#10;      sm: 'p-3',&#10;      md: 'p-6',&#10;      lg: 'p-8',&#10;    };&#10;&#10;    return (&#10;      &lt;div&#10;        className={cn(&#10;          baseStyles,&#10;          variants[variant],&#10;          paddings[padding],&#10;          hover &amp;&amp; 'hover:shadow-md transition-shadow',&#10;          className&#10;        )}&#10;        ref={ref}&#10;        {...props}&#10;      &gt;&#10;        {children}&#10;      &lt;/div&gt;&#10;    );&#10;  }&#10;);&#10;&#10;Card.displayName = 'Card';&#10;&#10;" />
              <option name="updatedContent" value="import React, { HTMLAttributes, forwardRef, ReactNode } from 'react';&#13;&#10;import { cn } from '@/utils/helpers';&#13;&#10;&#13;&#10;interface CardProps extends HTMLAttributes&lt;HTMLDivElement&gt; {&#13;&#10;  variant?: 'default' | 'outlined' | 'elevated';&#13;&#10;  children: ReactNode;&#13;&#10;  className?: string;&#13;&#10;  padding?: 'none' | 'sm' | 'md' | 'lg';&#13;&#10;  hover?: boolean;&#13;&#10;}&#13;&#10;&#13;&#10;const Card = forwardRef&lt;HTMLDivElement, CardProps&gt;(&#13;&#10;  (&#13;&#10;    {&#13;&#10;      className,&#13;&#10;      variant = 'default',&#13;&#10;      children,&#13;&#10;      padding = 'md',&#13;&#10;      hover = false,&#13;&#10;      ...props&#13;&#10;    },&#13;&#10;    ref&#13;&#10;  ) =&gt; {&#13;&#10;    const baseStyles = 'bg-white rounded-lg';&#13;&#10;&#13;&#10;    const variants = {&#13;&#10;      default: 'shadow-md',&#13;&#10;      outlined: 'border border-gray-200',&#13;&#10;      elevated: 'shadow-lg',&#13;&#10;    };&#13;&#10;&#13;&#10;    const paddings = {&#13;&#10;      none: '',&#13;&#10;      sm: 'p-3',&#13;&#10;      md: 'p-6',&#13;&#10;      lg: 'p-8',&#13;&#10;    };&#13;&#10;&#13;&#10;    return (&#13;&#10;      &lt;div&#13;&#10;        className={cn(&#13;&#10;          baseStyles,&#13;&#10;          variants[variant],&#13;&#10;          paddings[padding],&#13;&#10;          hover &amp;&amp; 'hover:shadow-md transition-shadow',&#13;&#10;          className&#13;&#10;        )}&#13;&#10;        ref={ref}&#13;&#10;        {...props}&#13;&#10;      &gt;&#13;&#10;        {children}&#13;&#10;      &lt;/div&gt;&#13;&#10;    );&#13;&#10;  }&#13;&#10;);&#13;&#10;&#13;&#10;Card.displayName = 'Card';&#13;&#10;&#13;&#10;export { Card };&#13;&#10;export default Card;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/client-frontend/src/components/ui/Input.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/client-frontend/src/components/ui/Input.tsx" />
              <option name="originalContent" value="import React, { InputHTMLAttributes, forwardRef } from 'react';&#10;import { cn } from '@/utils/helpers';&#10;&#10;interface InputProps extends InputHTMLAttributes&lt;HTMLInputElement&gt; {&#10;  label?: string;&#10;  error?: string;&#10;  helperText?: string;&#10;}&#10;&#10;const Input = forwardRef&lt;HTMLInputElement, InputProps&gt;(&#10;  ({ className, label, error, helperText, ...props }, ref) =&gt; {&#10;    return (&#10;      &lt;div className=&quot;w-full&quot;&gt;&#10;        {label &amp;&amp; (&#10;          &lt;label className=&quot;block text-sm font-medium text-gray-700 mb-1&quot;&gt;&#10;            {label}&#10;            {props.required &amp;&amp; &lt;span className=&quot;text-red-500 ml-1&quot;&gt;*&lt;/span&gt;}&#10;          &lt;/label&gt;&#10;        )}&#10;        &lt;input&#10;          className={cn(&#10;            'w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 transition-colors',&#10;            error &amp;&amp; 'border-red-500 focus:ring-red-500 focus:border-red-500',&#10;            className&#10;          )}&#10;          ref={ref}&#10;          {...props}&#10;        /&gt;&#10;        {error &amp;&amp; (&#10;          &lt;p className=&quot;mt-1 text-sm text-red-600&quot;&gt;{error}&lt;/p&gt;&#10;        )}&#10;        {helperText &amp;&amp; !error &amp;&amp; (&#10;          &lt;p className=&quot;mt-1 text-sm text-gray-500&quot;&gt;{helperText}&lt;/p&gt;&#10;        )}&#10;      &lt;/div&gt;&#10;    );&#10;  }&#10;);&#10;&#10;Input.displayName = 'Input';&#10;&#10;" />
              <option name="updatedContent" value="import React, { InputHTMLAttributes, forwardRef } from 'react';&#13;&#10;import { cn } from '@/utils/helpers';&#13;&#10;&#13;&#10;interface InputProps extends InputHTMLAttributes&lt;HTMLInputElement&gt; {&#13;&#10;  label?: string;&#13;&#10;  error?: string;&#13;&#10;  helperText?: string;&#13;&#10;}&#13;&#10;&#13;&#10;const Input = forwardRef&lt;HTMLInputElement, InputProps&gt;(&#13;&#10;  ({ className, label, error, helperText, ...props }, ref) =&gt; {&#13;&#10;    return (&#13;&#10;      &lt;div className=&quot;w-full&quot;&gt;&#13;&#10;        {label &amp;&amp; (&#13;&#10;          &lt;label className=&quot;block text-sm font-medium text-gray-700 mb-1&quot;&gt;&#13;&#10;            {label}&#13;&#10;            {props.required &amp;&amp; &lt;span className=&quot;text-red-500 ml-1&quot;&gt;*&lt;/span&gt;}&#13;&#10;          &lt;/label&gt;&#13;&#10;        )}&#13;&#10;        &lt;input&#13;&#10;          className={cn(&#13;&#10;            'w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 transition-colors',&#13;&#10;            error &amp;&amp; 'border-red-500 focus:ring-red-500 focus:border-red-500',&#13;&#10;            className&#13;&#10;          )}&#13;&#10;          ref={ref}&#13;&#10;          {...props}&#13;&#10;        /&gt;&#13;&#10;        {error &amp;&amp; (&#13;&#10;          &lt;p className=&quot;mt-1 text-sm text-red-600&quot;&gt;{error}&lt;/p&gt;&#13;&#10;        )}&#13;&#10;        {helperText &amp;&amp; !error &amp;&amp; (&#13;&#10;          &lt;p className=&quot;mt-1 text-sm text-gray-500&quot;&gt;{helperText}&lt;/p&gt;&#13;&#10;        )}&#13;&#10;      &lt;/div&gt;&#13;&#10;    );&#13;&#10;  }&#13;&#10;);&#13;&#10;&#13;&#10;Input.displayName = 'Input';&#13;&#10;&#13;&#10;export { Input };&#13;&#10;export default Input;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/client-frontend/src/components/ui/LoadingSpinner.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/client-frontend/src/components/ui/LoadingSpinner.tsx" />
              <option name="originalContent" value="interface LoadingSpinnerProps {&#10;  size?: 'sm' | 'md' | 'lg';&#10;  className?: string;&#10;}&#10;&#10;export default function LoadingSpinner({ size = 'md', className = '' }: LoadingSpinnerProps) {&#10;  const sizeClasses = {&#10;    sm: 'h-4 w-4',&#10;    md: 'h-8 w-8',&#10;    lg: 'h-12 w-12'&#10;  };&#10;&#10;  return (&#10;    &lt;div className={`animate-spin rounded-full border-b-2 border-blue-600 ${sizeClasses[size]} ${className}`} /&gt;&#10;  );&#10;}&#10;" />
              <option name="updatedContent" value="interface LoadingSpinnerProps {&#13;&#10;  size?: 'sm' | 'md' | 'lg';&#13;&#10;  className?: string;&#13;&#10;}&#13;&#10;&#13;&#10;function LoadingSpinner({ size = 'md', className = '' }: LoadingSpinnerProps) {&#13;&#10;  const sizeClasses = {&#13;&#10;    sm: 'h-4 w-4',&#13;&#10;    md: 'h-8 w-8',&#13;&#10;    lg: 'h-12 w-12'&#13;&#10;  };&#13;&#10;&#13;&#10;  return (&#13;&#10;    &lt;div className={`animate-spin rounded-full border-b-2 border-blue-600 ${sizeClasses[size]} ${className}`} /&gt;&#13;&#10;  );&#13;&#10;}&#13;&#10;&#13;&#10;export { LoadingSpinner };&#13;&#10;export default LoadingSpinner;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/client-frontend/src/components/ui/Textarea.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/client-frontend/src/components/ui/Textarea.tsx" />
              <option name="originalContent" value="import React, { TextareaHTMLAttributes, forwardRef } from 'react';&#10;import { cn } from '@/utils/helpers';&#10;&#10;interface TextareaProps extends TextareaHTMLAttributes&lt;HTMLTextAreaElement&gt; {&#10;  label?: string;&#10;  error?: string;&#10;  helperText?: string;&#10;}&#10;&#10;const Textarea = forwardRef&lt;HTMLTextAreaElement, TextareaProps&gt;(&#10;  ({ className, label, error, helperText, ...props }, ref) =&gt; {&#10;    return (&#10;      &lt;div className=&quot;w-full&quot;&gt;&#10;        {label &amp;&amp; (&#10;          &lt;label className=&quot;block text-sm font-medium text-gray-700 mb-1&quot;&gt;&#10;            {label}&#10;            {props.required &amp;&amp; &lt;span className=&quot;text-red-500 ml-1&quot;&gt;*&lt;/span&gt;}&#10;          &lt;/label&gt;&#10;        )}&#10;        &lt;textarea&#10;          className={cn(&#10;            'w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition-colors resize-none',&#10;            error &amp;&amp; 'border-red-500 focus:ring-red-500 focus:border-red-500',&#10;            className&#10;          )}&#10;          ref={ref}&#10;          {...props}&#10;        /&gt;&#10;        {error &amp;&amp; (&#10;          &lt;p className=&quot;mt-1 text-sm text-red-600&quot;&gt;{error}&lt;/p&gt;&#10;        )}&#10;        {helperText &amp;&amp; !error &amp;&amp; (&#10;          &lt;p className=&quot;mt-1 text-sm text-gray-500&quot;&gt;{helperText}&lt;/p&gt;&#10;        )}&#10;      &lt;/div&gt;&#10;    );&#10;  }&#10;);&#10;&#10;Textarea.displayName = 'Textarea';&#10;&#10;" />
              <option name="updatedContent" value="import React, { TextareaHTMLAttributes, forwardRef } from 'react';&#13;&#10;import { cn } from '@/utils/helpers';&#13;&#10;&#13;&#10;interface TextareaProps extends TextareaHTMLAttributes&lt;HTMLTextAreaElement&gt; {&#13;&#10;  label?: string;&#13;&#10;  error?: string;&#13;&#10;  helperText?: string;&#13;&#10;}&#13;&#10;&#13;&#10;const Textarea = forwardRef&lt;HTMLTextAreaElement, TextareaProps&gt;(&#13;&#10;  ({ className, label, error, helperText, ...props }, ref) =&gt; {&#13;&#10;    return (&#13;&#10;      &lt;div className=&quot;w-full&quot;&gt;&#13;&#10;        {label &amp;&amp; (&#13;&#10;          &lt;label className=&quot;block text-sm font-medium text-gray-700 mb-1&quot;&gt;&#13;&#10;            {label}&#13;&#10;            {props.required &amp;&amp; &lt;span className=&quot;text-red-500 ml-1&quot;&gt;*&lt;/span&gt;}&#13;&#10;          &lt;/label&gt;&#13;&#10;        )}&#13;&#10;        &lt;textarea&#13;&#10;          className={cn(&#13;&#10;            'w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition-colors resize-none',&#13;&#10;            error &amp;&amp; 'border-red-500 focus:ring-red-500 focus:border-red-500',&#13;&#10;            className&#13;&#10;          )}&#13;&#10;          ref={ref}&#13;&#10;          {...props}&#13;&#10;        /&gt;&#13;&#10;        {error &amp;&amp; (&#13;&#10;          &lt;p className=&quot;mt-1 text-sm text-red-600&quot;&gt;{error}&lt;/p&gt;&#13;&#10;        )}&#13;&#10;        {helperText &amp;&amp; !error &amp;&amp; (&#13;&#10;          &lt;p className=&quot;mt-1 text-sm text-gray-500&quot;&gt;{helperText}&lt;/p&gt;&#13;&#10;        )}&#13;&#10;      &lt;/div&gt;&#13;&#10;    );&#13;&#10;  }&#13;&#10;);&#13;&#10;&#13;&#10;Textarea.displayName = 'Textarea';&#13;&#10;&#13;&#10;export { Textarea };&#13;&#10;export default Textarea;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/client-frontend/src/shared/config/api-client.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/client-frontend/src/shared/config/api-client.ts" />
              <option name="updatedContent" value="import axios, { AxiosInstance, AxiosRequestConfig, AxiosResponse } from 'axios';&#10;import { API_ENDPOINTS } from '../constants';&#10;&#10;// API Client Configuration&#10;export class ApiClient {&#10;  private instance: AxiosInstance;&#10;&#10;  constructor() {&#10;    this.instance = axios.create({&#10;      baseURL: API_ENDPOINTS.BASE_URL,&#10;      timeout: 10000,&#10;      headers: {&#10;        'Content-Type': 'application/json',&#10;      },&#10;    });&#10;&#10;    this.setupInterceptors();&#10;  }&#10;&#10;  private setupInterceptors() {&#10;    // Request interceptor to add auth token&#10;    this.instance.interceptors.request.use(&#10;      (config) =&gt; {&#10;        const token = this.getAuthToken();&#10;        if (token) {&#10;          config.headers.Authorization = `Bearer ${token}`;&#10;        }&#10;        return config;&#10;      },&#10;      (error) =&gt; Promise.reject(error)&#10;    );&#10;&#10;    // Response interceptor for error handling&#10;    this.instance.interceptors.response.use(&#10;      (response) =&gt; response.data,&#10;      (error) =&gt; {&#10;        if (error.response?.status === 401) {&#10;          this.handleUnauthorized();&#10;        }&#10;        return Promise.reject(error);&#10;      }&#10;    );&#10;  }&#10;&#10;  private getAuthToken(): string | null {&#10;    if (typeof window !== 'undefined') {&#10;      return localStorage.getItem('auth_token');&#10;    }&#10;    return null;&#10;  }&#10;&#10;  private handleUnauthorized() {&#10;    if (typeof window !== 'undefined') {&#10;      localStorage.removeItem('auth_token');&#10;      window.location.href = '/auth/login';&#10;    }&#10;  }&#10;&#10;  // HTTP Methods&#10;  async get&lt;T = any&gt;(url: string, config?: AxiosRequestConfig): Promise&lt;T&gt; {&#10;    return this.instance.get(url, config);&#10;  }&#10;&#10;  async post&lt;T = any&gt;(url: string, data?: any, config?: AxiosRequestConfig): Promise&lt;T&gt; {&#10;    return this.instance.post(url, data, config);&#10;  }&#10;&#10;  async put&lt;T = any&gt;(url: string, data?: any, config?: AxiosRequestConfig): Promise&lt;T&gt; {&#10;    return this.instance.put(url, data, config);&#10;  }&#10;&#10;  async patch&lt;T = any&gt;(url: string, data?: any, config?: AxiosRequestConfig): Promise&lt;T&gt; {&#10;    return this.instance.patch(url, data, config);&#10;  }&#10;&#10;  async delete&lt;T = any&gt;(url: string, config?: AxiosRequestConfig): Promise&lt;T&gt; {&#10;    return this.instance.delete(url, config);&#10;  }&#10;}&#10;&#10;// Export singleton instance&#10;export const apiClient = new ApiClient();" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/client-frontend/src/shared/constants/api-endpoints.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/client-frontend/src/shared/constants/api-endpoints.ts" />
              <option name="updatedContent" value="// API Endpoints Constants for Client-Frontend&#10;export const API_ENDPOINTS = {&#10;  // Base URLs for services&#10;  BASE_URL: process.env.NEXT_PUBLIC_API_URL || 'http://localhost:8080',&#10;  &#10;  // Authentication endpoints&#10;  AUTH: {&#10;    BASE: '/api/auth',&#10;    LOGIN: '/api/auth/login',&#10;    REGISTER: '/api/auth/register',&#10;    REFRESH: '/api/auth/refresh',&#10;    LOGOUT: '/api/auth/logout',&#10;    VERIFY_EMAIL: '/api/auth/verify-email',&#10;    FORGOT_PASSWORD: '/api/auth/forgot-password',&#10;    RESET_PASSWORD: '/api/auth/reset-password',&#10;    PROFILE: '/api/auth/profile'&#10;  },&#10;&#10;  // User management endpoints&#10;  USERS: {&#10;    BASE: '/api/users',&#10;    PROFILE: '/api/users/profile',&#10;    BY_ID: '/api/users/:id',&#10;    UPDATE_PROFILE: '/api/users/profile',&#10;    SEARCH: '/api/users/search',&#10;    FRIENDS: '/api/users/:id/friends',&#10;    FRIEND_SUGGESTIONS: '/api/users/friend-suggestions',&#10;    SEND_FRIEND_REQUEST: '/api/users/:id/friend-request',&#10;    ACCEPT_FRIEND_REQUEST: '/api/users/:id/accept-friend',&#10;    MUTUAL_FRIENDS: '/api/users/:id/mutual-friends-count',&#10;    TIMELINE: '/api/users/:id/timeline',&#10;    ACTIVITIES: '/api/users/:id/activities'&#10;  },&#10;&#10;  // Post management endpoints&#10;  POSTS: {&#10;    BASE: '/api/posts',&#10;    BY_ID: '/api/posts/:id',&#10;    BY_USER: '/api/posts/user/:userId',&#10;    FEED: '/api/posts/feed',&#10;    TRENDING: '/api/posts/trending',&#10;    TIMELINE: '/api/posts/timeline/:userId',&#10;    SEARCH: '/api/posts/search',&#10;    LIKE: '/api/posts/:id/interact',&#10;    COMMENTS: '/api/posts/:id/comments',&#10;    COMMENT_LIKE: '/api/posts/comments/:id/like',&#10;    SCHEDULE: '/api/posts/schedule',&#10;    ANALYTICS: '/api/posts/:id/analytics'&#10;  },&#10;&#10;  // Chat endpoints&#10;  CHAT: {&#10;    BASE: '/api/chat',&#10;    ROOMS: '/api/chat/rooms',&#10;    MESSAGES: '/api/chat/rooms/:roomId/messages',&#10;    SEND_MESSAGE: '/api/chat/rooms/:roomId/messages'&#10;  },&#10;&#10;  // Media endpoints&#10;  MEDIA: {&#10;    BASE: '/api/media',&#10;    UPLOAD: '/api/media/upload',&#10;    BY_ID: '/api/media/:id'&#10;  },&#10;&#10;  // Notification endpoints&#10;  NOTIFICATIONS: {&#10;    BASE: '/api/notifications',&#10;    UNREAD_COUNT: '/api/notifications/unread-count',&#10;    MARK_READ: '/api/notifications/:id/read',&#10;    MARK_ALL_READ: '/api/notifications/mark-all-read'&#10;  },&#10;&#10;  // Analytics endpoints&#10;  ANALYTICS: {&#10;    BASE: '/api/analytics',&#10;    USER_STATS: '/api/analytics/users/:id/stats',&#10;    POST_STATS: '/api/analytics/posts/:id/stats'&#10;  }&#10;};&#10;&#10;// API Response types&#10;export interface ApiResponse&lt;T = any&gt; {&#10;  success: boolean;&#10;  data?: T;&#10;  message?: string;&#10;  errors?: string[];&#10;}&#10;&#10;export interface PaginatedResponse&lt;T = any&gt; {&#10;  content: T[];&#10;  totalElements: number;&#10;  totalPages: number;&#10;  size: number;&#10;  number: number;&#10;  first: boolean;&#10;  last: boolean;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/client-frontend/src/shared/constants/index.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/client-frontend/src/shared/constants/index.ts" />
              <option name="updatedContent" value="export * from './api-endpoints';&#10;&#10;// Re-export for backward compatibility&#10;export { API_ENDPOINTS } from './api-endpoints';" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/client-frontend/src/shared/services/post.service.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/client-frontend/src/shared/services/post.service.ts" />
              <option name="originalContent" value="import { apiClient } from '@/shared/config/api-client';&#10;import { API_ENDPOINTS } from '@/shared/constants';&#10;import { createApiUrl } from '@/shared/utils';&#10;import {&#10;  Post,&#10;  Comment,&#10;  CreatePostRequest,&#10;  UpdatePostRequest,&#10;  CreateCommentRequest,&#10;  UpdateCommentRequest,&#10;  PaginatedResponse,&#10;  ApiResponse,&#10;  PostVisibility,&#10;} from '@/shared/types';&#10;&#10;/**&#10; * Post Service&#10; * Handles all post-related API calls&#10; * Handles all post-related API calls&#10; */&#10;export class PostService {&#10;   * Create new post&#10;   * Create new post&#10;    const formData = new FormData();&#10;    formData.append('content', postData.content);&#10;&#10;    if (postData.visibility) {&#10;      formData.append('visibility', postData.visibility);&#10;    }&#10;    formData.append('content', postData.content);&#10;    if (postData.tags) {&#10;      postData.tags.forEach(tag =&gt; formData.append('tags', tag));&#10;    }&#10;&#10;    if (postData.images) {&#10;      postData.images.forEach(image =&gt; formData.append('images', image));&#10;    }&#10;&#10;    return apiClient.post&lt;Post&gt;(API_ENDPOINTS.POSTS.BASE, formData, {&#10;      headers: {&#10;        'Content-Type': 'multipart/form-data',&#10;      },&#10;    });&#10;      postData.tags.forEach(tag =&gt; formData.append('tags', tag));&#10;    }&#10;&#10;    if (postData.images) {&#10;      postData.images.forEach(image =&gt; formData.append('images', image));&#10;    }&#10;&#10;    return apiClient.post&lt;Post&gt;(API_ENDPOINTS.POSTS.BASE, formData, {&#10;      headers: {&#10;        'Content-Type': 'multipart/form-data',&#10;      },&#10;    });&#10;  }&#10;&#10;  /**&#10;   * Get posts feed&#10;   */&#10;  async getPosts(page = 0, size = 10): Promise&lt;PaginatedResponse&lt;Post&gt;&gt; {&#10;    const url = createApiUrl(API_ENDPOINTS.POSTS.BASE, undefined, { page, size });&#10;    return apiClient.get&lt;PaginatedResponse&lt;Post&gt;&gt;(url);&#10;  }&#10;&#10;  /**&#10;   * Get single post by ID&#10;   */&#10;  async getPost(postId: string): Promise&lt;Post&gt; {&#10;    const url = createApiUrl(API_ENDPOINTS.POSTS.BASE + '/:id', { id: postId });&#10;    return apiClient.get&lt;Post&gt;(url);&#10;  }&#10;&#10;  /**&#10;   * Get posts by user&#10;   */&#10;  async getUserPosts(&#10;    userId: string,&#10;    page = 0,&#10;    size = 10&#10;  ): Promise&lt;PaginatedResponse&lt;Post&gt;&gt; {&#10;    const url = createApiUrl(&#10;      API_ENDPOINTS.POSTS.BY_USER,&#10;      { id: userId },&#10;      { page, size }&#10;    );&#10;    return apiClient.get&lt;PaginatedResponse&lt;Post&gt;&gt;(url);&#10;  }&#10;&#10;  /**&#10;   * Update post&#10;   */&#10;  async updatePost(postId: string, updateData: UpdatePostRequest): Promise&lt;Post&gt; {&#10;    const url = createApiUrl(API_ENDPOINTS.POSTS.BASE + '/:id', { id: postId });&#10;    return apiClient.put&lt;Post&gt;(url, updateData);&#10;  }&#10;&#10;  /**&#10;   * Delete post&#10;   */&#10;  async deletePost(postId: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#10;    const url = createApiUrl(API_ENDPOINTS.POSTS.BASE + '/:id', { id: postId });&#10;    return apiClient.delete&lt;ApiResponse&lt;null&gt;&gt;(url);&#10;  }&#10;&#10;  /**&#10;   * Like post&#10;   */&#10;  async likePost(postId: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#10;    const url = createApiUrl(API_ENDPOINTS.POSTS.LIKE, { id: postId });&#10;    return apiClient.post&lt;ApiResponse&lt;null&gt;&gt;(url);&#10;  }&#10;&#10;  /**&#10;   * Unlike post&#10;   */&#10;  async unlikePost(postId: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#10;    const url = createApiUrl(API_ENDPOINTS.POSTS.LIKE, { id: postId });&#10;    return apiClient.delete&lt;ApiResponse&lt;null&gt;&gt;(url);&#10;  }&#10;&#10;  /**&#10;   * Get post comments&#10;   */&#10;  async getComments(&#10;    postId: string,&#10;    page = 0,&#10;    size = 10&#10;  ): Promise&lt;PaginatedResponse&lt;Comment&gt;&gt; {&#10;    const url = createApiUrl(&#10;      API_ENDPOINTS.POSTS.COMMENTS,&#10;      { id: postId },&#10;      { page, size }&#10;    );&#10;    return apiClient.get&lt;PaginatedResponse&lt;Comment&gt;&gt;(url);&#10;  }&#10;&#10;  /**&#10;   * Create comment&#10;   */&#10;  async createComment(commentData: CreateCommentRequest): Promise&lt;Comment&gt; {&#10;    const url = createApiUrl(API_ENDPOINTS.POSTS.COMMENTS, { id: commentData.postId });&#10;    return apiClient.post&lt;Comment&gt;(url, {&#10;      content: commentData.content,&#10;      parentId: commentData.parentId,&#10;    });&#10;  }&#10;&#10;  /**&#10;   * Update comment&#10;   */&#10;  async updateComment(&#10;    commentId: string,&#10;    updateData: UpdateCommentRequest&#10;  ): Promise&lt;Comment&gt; {&#10;    const url = createApiUrl('/comments/:id', { id: commentId });&#10;    return apiClient.put&lt;Comment&gt;(url, updateData);&#10;  }&#10;&#10;  /**&#10;   * Delete comment&#10;   */&#10;  async deleteComment(commentId: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#10;    const url = createApiUrl('/comments/:id', { id: commentId });&#10;    return apiClient.delete&lt;ApiResponse&lt;null&gt;&gt;(url);&#10;  }&#10;&#10;  /**&#10;   * Like comment&#10;   */&#10;  async likeComment(commentId: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#10;    const url = createApiUrl(API_ENDPOINTS.POSTS.COMMENT_LIKE, { id: commentId });&#10;    return apiClient.post&lt;ApiResponse&lt;null&gt;&gt;(url);&#10;  }&#10;&#10;  /**&#10;   * Unlike comment&#10;   */&#10;  async unlikeComment(commentId: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#10;    const url = createApiUrl(API_ENDPOINTS.POSTS.COMMENT_LIKE, { id: commentId });&#10;    return apiClient.delete&lt;ApiResponse&lt;null&gt;&gt;(url);&#10;  }&#10;&#10;  /**&#10;   * Share post&#10;   */&#10;  async sharePost(postId: string, content?: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#10;    const url = createApiUrl('/posts/:id/share', { id: postId });&#10;    return apiClient.post&lt;ApiResponse&lt;null&gt;&gt;(url, { content });&#10;  }&#10;&#10;  /**&#10;   * Bookmark post&#10;   */&#10;  async bookmarkPost(postId: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#10;    const url = createApiUrl('/posts/:id/bookmark', { id: postId });&#10;    return apiClient.post&lt;ApiResponse&lt;null&gt;&gt;(url);&#10;  }&#10;&#10;  /**&#10;   * Remove bookmark&#10;   */&#10;  async removeBookmark(postId: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#10;    const url = createApiUrl('/posts/:id/bookmark', { id: postId });&#10;    return apiClient.delete&lt;ApiResponse&lt;null&gt;&gt;(url);&#10;  }&#10;}&#10;&#10;// Export singleton instance&#10;export const postService = new PostService();&#10;" />
              <option name="updatedContent" value="import { apiClient } from '@/shared/config/api-client';&#13;&#10;import { API_ENDPOINTS } from '@/shared/constants';&#13;&#10;import { createApiUrl } from '@/shared/utils';&#13;&#10;import {&#13;&#10;  Post,&#13;&#10;  Comment,&#13;&#10;  CreatePostRequest,&#13;&#10;  UpdatePostRequest,&#13;&#10;  CreateCommentRequest,&#13;&#10;  UpdateCommentRequest,&#13;&#10;  PaginatedResponse,&#13;&#10;  ApiResponse,&#13;&#10;  PostVisibility,&#13;&#10;} from '@/shared/types';&#13;&#10;&#13;&#10;/**&#13;&#10; * Post Service - Updated to sync with backend APIs&#13;&#10; */&#13;&#10;export class PostService {&#13;&#10;  /**&#13;&#10;   * Create new post - Updated to match EnhancedPostController&#13;&#10;   */&#13;&#10;  async createPost(postData: CreatePostRequest): Promise&lt;Post&gt; {&#13;&#10;    // Use JSON instead of FormData to match EnhancedPostController&#13;&#10;    return apiClient.post&lt;Post&gt;(API_ENDPOINTS.POSTS.BASE, postData);&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Get personalized feed - Updated to match backend&#13;&#10;   */&#13;&#10;  async getPersonalizedFeed(page = 0, size = 10): Promise&lt;Post[]&gt; {&#13;&#10;    const url = createApiUrl(API_ENDPOINTS.POSTS.FEED, undefined, { page, size });&#13;&#10;    return apiClient.get&lt;Post[]&gt;(url);&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Get posts feed&#13;&#10;   */&#13;&#10;  async getPosts(page = 0, size = 10): Promise&lt;PaginatedResponse&lt;Post&gt;&gt; {&#13;&#10;    const url = createApiUrl(API_ENDPOINTS.POSTS.BASE, undefined, { page, size });&#13;&#10;    return apiClient.get&lt;PaginatedResponse&lt;Post&gt;&gt;(url);&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Get single post by ID&#13;&#10;   */&#13;&#10;  async getPost(postId: string): Promise&lt;Post&gt; {&#13;&#10;    const url = createApiUrl(API_ENDPOINTS.POSTS.BASE + '/:id', { id: postId });&#13;&#10;    return apiClient.get&lt;Post&gt;(url);&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Get posts by user&#13;&#10;   */&#13;&#10;  async getUserPosts(&#13;&#10;    userId: string,&#13;&#10;    page = 0,&#13;&#10;    size = 10&#13;&#10;  ): Promise&lt;PaginatedResponse&lt;Post&gt;&gt; {&#13;&#10;    const url = createApiUrl(&#13;&#10;      API_ENDPOINTS.POSTS.BY_USER,&#13;&#10;      { id: userId },&#13;&#10;      { page, size }&#13;&#10;    );&#13;&#10;    return apiClient.get&lt;PaginatedResponse&lt;Post&gt;&gt;(url);&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Update post&#13;&#10;   */&#13;&#10;  async updatePost(postId: string, updateData: UpdatePostRequest): Promise&lt;Post&gt; {&#13;&#10;    const url = createApiUrl(API_ENDPOINTS.POSTS.BASE + '/:id', { id: postId });&#13;&#10;    return apiClient.put&lt;Post&gt;(url, updateData);&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Delete post&#13;&#10;   */&#13;&#10;  async deletePost(postId: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#13;&#10;    const url = createApiUrl(API_ENDPOINTS.POSTS.BASE + '/:id', { id: postId });&#13;&#10;    return apiClient.delete&lt;ApiResponse&lt;null&gt;&gt;(url);&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Like post&#13;&#10;   */&#13;&#10;  async likePost(postId: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#13;&#10;    const url = createApiUrl(API_ENDPOINTS.POSTS.LIKE, { id: postId });&#13;&#10;    return apiClient.post&lt;ApiResponse&lt;null&gt;&gt;(url);&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Unlike post&#13;&#10;   */&#13;&#10;  async unlikePost(postId: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#13;&#10;    const url = createApiUrl(API_ENDPOINTS.POSTS.LIKE, { id: postId });&#13;&#10;    return apiClient.delete&lt;ApiResponse&lt;null&gt;&gt;(url);&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Get post comments&#13;&#10;   */&#13;&#10;  async getComments(&#13;&#10;    postId: string,&#13;&#10;    page = 0,&#13;&#10;    size = 10&#13;&#10;  ): Promise&lt;PaginatedResponse&lt;Comment&gt;&gt; {&#13;&#10;    const url = createApiUrl(&#13;&#10;      API_ENDPOINTS.POSTS.COMMENTS,&#13;&#10;      { id: postId },&#13;&#10;      { page, size }&#13;&#10;    );&#13;&#10;    return apiClient.get&lt;PaginatedResponse&lt;Comment&gt;&gt;(url);&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Create comment&#13;&#10;   */&#13;&#10;  async createComment(commentData: CreateCommentRequest): Promise&lt;Comment&gt; {&#13;&#10;    const url = createApiUrl(API_ENDPOINTS.POSTS.COMMENTS, { id: commentData.postId });&#13;&#10;    return apiClient.post&lt;Comment&gt;(url, {&#13;&#10;      content: commentData.content,&#13;&#10;      parentId: commentData.parentId,&#13;&#10;    });&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Update comment&#13;&#10;   */&#13;&#10;  async updateComment(&#13;&#10;    commentId: string,&#13;&#10;    updateData: UpdateCommentRequest&#13;&#10;  ): Promise&lt;Comment&gt; {&#13;&#10;    const url = createApiUrl('/comments/:id', { id: commentId });&#13;&#10;    return apiClient.put&lt;Comment&gt;(url, updateData);&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Delete comment&#13;&#10;   */&#13;&#10;  async deleteComment(commentId: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#13;&#10;    const url = createApiUrl('/comments/:id', { id: commentId });&#13;&#10;    return apiClient.delete&lt;ApiResponse&lt;null&gt;&gt;(url);&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Like comment&#13;&#10;   */&#13;&#10;  async likeComment(commentId: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#13;&#10;    const url = createApiUrl(API_ENDPOINTS.POSTS.COMMENT_LIKE, { id: commentId });&#13;&#10;    return apiClient.post&lt;ApiResponse&lt;null&gt;&gt;(url);&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Unlike comment&#13;&#10;   */&#13;&#10;  async unlikeComment(commentId: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#13;&#10;    const url = createApiUrl(API_ENDPOINTS.POSTS.COMMENT_LIKE, { id: commentId });&#13;&#10;    return apiClient.delete&lt;ApiResponse&lt;null&gt;&gt;(url);&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Share post&#13;&#10;   */&#13;&#10;  async sharePost(postId: string, content?: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#13;&#10;    const url = createApiUrl('/posts/:id/share', { id: postId });&#13;&#10;    return apiClient.post&lt;ApiResponse&lt;null&gt;&gt;(url, { content });&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Bookmark post&#13;&#10;   */&#13;&#10;  async bookmarkPost(postId: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#13;&#10;    const url = createApiUrl('/posts/:id/bookmark', { id: postId });&#13;&#10;    return apiClient.post&lt;ApiResponse&lt;null&gt;&gt;(url);&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Remove bookmark&#13;&#10;   */&#13;&#10;  async removeBookmark(postId: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#13;&#10;    const url = createApiUrl('/posts/:id/bookmark', { id: postId });&#13;&#10;    return apiClient.delete&lt;ApiResponse&lt;null&gt;&gt;(url);&#13;&#10;  }&#13;&#10;}&#13;&#10;&#13;&#10;// Export singleton instance&#13;&#10;export const postService = new PostService();" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/client-frontend/src/shared/services/user.service.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/client-frontend/src/shared/services/user.service.ts" />
              <option name="originalContent" value="import { apiClient } from '@/shared/config/api-client';&#10;import { API_ENDPOINTS } from '@/shared/constants';&#10;import { createApiUrl } from '@/shared/utils';&#10;import {&#10;  User,&#10;  UpdateUserRequest,&#10;  ApiResponse,&#10;  UserStats,&#10;  UserStats,&#10;  FileUploadResponse,&#10;  FileUploadResponse,&#10;} from '@/shared/types';&#10;&#10;/**&#10; * User Service&#10; * Handles all user-related API calls&#10; * Handles all user-related API calls&#10;   * Get user profile by ID&#10;  async getUserProfile(userId: string): Promise&lt;User&gt; {&#10;    const url = createApiUrl(API_ENDPOINTS.USERS.PROFILE, { id: userId });&#10;  /**&#10;   * Update current user profile&#10;   */&#10;  async updateProfile(userData: UpdateUserRequest): Promise&lt;User&gt; {&#10;   * Update current user profile&#10;   */&#10;  async updateProfile(userData: UpdateUserRequest): Promise&lt;User&gt; {&#10;    return apiClient.put&lt;User&gt;(API_ENDPOINTS.USERS.PROFILE, userData);&#10;  }&#10;&#10;  /**&#10;   * Upload user avatar&#10;  }&#10;&#10;  /**&#10;   * Upload user avatar&#10;   */&#10;  async uploadAvatar(&#10;   * Search users&#10;    onProgress?: (progress: number) =&gt; void&#10;  async uploadAvatar(&#10;    file: File,&#10;    onProgress?: (progress: number) =&gt; void&#10;  ): Promise&lt;FileUploadResponse&gt; {&#10;    return apiClient.uploadFile&lt;FileUploadResponse&gt;(&#10;      API_ENDPOINTS.USERS.AVATAR,&#10;    size = 10&#10;  ): Promise&lt;PaginatedResponse&lt;User&gt;&gt; {&#10;    );&#10;      q: query,&#10;    return apiClient.get&lt;PaginatedResponse&lt;User&gt;&gt;(url);&#10;      page,&#10;      size,&#10;    });&#10;    return apiClient.get&lt;PaginatedResponse&lt;User&gt;&gt;(url);&#10;  }&#10;&#10;  /**&#10;   * Follow user&#10;   */&#10;   * Follow user&#10;    const url = createApiUrl(API_ENDPOINTS.USERS.FOLLOW, { id: userId });&#10;    return apiClient.post&lt;ApiResponse&lt;null&gt;&gt;(url);&#10;  }&#10;&#10;  /**&#10;   * Unfollow user&#10;   */&#10;  async unfollowUser(userId: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#10;    const url = createApiUrl(API_ENDPOINTS.USERS.FOLLOW, { id: userId });&#10;  async followUser(userId: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#10;    const url = createApiUrl(API_ENDPOINTS.USERS.FOLLOW, { id: userId });&#10;&#10;  /**&#10;   * Get user followers&#10;   */&#10;   * Unfollow user&#10;   */&#10;  async unfollowUser(userId: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#10;    const url = createApiUrl(API_ENDPOINTS.USERS.FOLLOW, { id: userId });&#10;    return apiClient.delete&lt;ApiResponse&lt;null&gt;&gt;(url);&#10;  }&#10;&#10;  /**&#10;   * Get users that user is following&#10;    userId: string,&#10;  async getFollowing(&#10;    userId: string,&#10;    page = 0,&#10;    size = 10&#10;  ): Promise&lt;PaginatedResponse&lt;User&gt;&gt; {&#10;    const url = createApiUrl(&#10;      API_ENDPOINTS.USERS.FOLLOWING,&#10;      { id: userId },&#10;  async getFriends(&#10;    userId: string,&#10;    page = 0,&#10;    size = 10&#10;  ): Promise&lt;PaginatedResponse&lt;User&gt;&gt; {&#10;    const url = createApiUrl(&#10;      API_ENDPOINTS.USERS.FRIENDS,&#10;      { id: userId },&#10;  async getUserStats(userId: string): Promise&lt;UserStats&gt; {&#10;    const url = createApiUrl('/users/:id/stats', { id: userId });&#10;    return apiClient.get&lt;UserStats&gt;(url);&#10;    size = 10&#10;  ): Promise&lt;PaginatedResponse&lt;User&gt;&gt; {&#10;    const url = createApiUrl(&#10;   * Check if user is following another user&#10;      { id: userId },&#10;  async isFollowing(userId: string): Promise&lt;boolean&gt; {&#10;    const url = createApiUrl('/users/:id/following/check', { id: userId });&#10;    const response = await apiClient.get&lt;{ isFollowing: boolean }&gt;(url);&#10;    return response.isFollowing;&#10;    const url = createApiUrl(&#10;      API_ENDPOINTS.USERS.FOLLOWERS,&#10;      { id: userId },&#10;   * Get user friends&#10;    );&#10;    return apiClient.get&lt;PaginatedResponse&lt;User&gt;&gt;(url);&#10;  }&#10;&#10;  /**&#10;   * Get users that user is following&#10;   */&#10;  async getFollowing(&#10;    userId: string,&#10;    page = 0,&#10;    size = 10&#10;  ): Promise&lt;PaginatedResponse&lt;User&gt;&gt; {&#10;    const url = createApiUrl(&#10;      API_ENDPOINTS.USERS.FOLLOWING,&#10;      { id: userId },&#10;      { page, size }&#10;    );&#10;    return apiClient.get&lt;PaginatedResponse&lt;User&gt;&gt;(url);&#10;  }&#10;&#10;  /**&#10;   * Get user friends&#10;   */&#10;  async getFriends(&#10;    userId: string,&#10;    page = 0,&#10;    size = 10&#10;  ): Promise&lt;PaginatedResponse&lt;User&gt;&gt; {&#10;    const url = createApiUrl(&#10;      API_ENDPOINTS.USERS.FRIENDS,&#10;      { id: userId },&#10;      { page, size }&#10;    );&#10;    return apiClient.get&lt;PaginatedResponse&lt;User&gt;&gt;(url);&#10;  }&#10;&#10;  /**&#10;   * Get user statistics&#10;   */&#10;  async getUserStats(userId: string): Promise&lt;UserStats&gt; {&#10;    const url = createApiUrl('/users/:id/stats', { id: userId });&#10;    return apiClient.get&lt;UserStats&gt;(url);&#10;  }&#10;&#10;  /**&#10;   * Check if user is following another user&#10;   */&#10;  async isFollowing(userId: string): Promise&lt;boolean&gt; {&#10;    const url = createApiUrl('/users/:id/following/check', { id: userId });&#10;    const response = await apiClient.get&lt;{ isFollowing: boolean }&gt;(url);&#10;    return response.isFollowing;&#10;  }&#10;}&#10;&#10;// Export singleton instance&#10;export const userService = new UserService();&#10;" />
              <option name="updatedContent" value="import { apiClient } from '@/shared/config/api-client';&#13;&#10;import { API_ENDPOINTS } from '@/shared/constants';&#13;&#10;import { createApiUrl } from '@/shared/utils';&#13;&#10;import {&#13;&#10;  User,&#13;&#10;  UserProfile,&#13;&#10;  UpdateProfileRequest,&#13;&#10;  PaginatedResponse,&#13;&#10;  ApiResponse,&#13;&#10;} from '@/shared/types';&#13;&#10;&#13;&#10;/**&#13;&#10; * User Service - Updated to sync with backend APIs&#13;&#10; */&#13;&#10;export class UserService {&#13;&#10;  /**&#13;&#10;   * Get current user profile&#13;&#10;   */&#13;&#10;  async getCurrentUser(): Promise&lt;User&gt; {&#13;&#10;    return apiClient.get&lt;User&gt;(API_ENDPOINTS.USERS.PROFILE);&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Get user by ID&#13;&#10;   */&#13;&#10;  async getUser(userId: string): Promise&lt;User&gt; {&#13;&#10;    const url = createApiUrl(API_ENDPOINTS.USERS.BY_ID, { id: userId });&#13;&#10;    return apiClient.get&lt;User&gt;(url);&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Update user profile&#13;&#10;   */&#13;&#10;  async updateProfile(updateData: UpdateProfileRequest): Promise&lt;User&gt; {&#13;&#10;    return apiClient.put&lt;User&gt;(API_ENDPOINTS.USERS.UPDATE_PROFILE, updateData);&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Search users - Updated to match EnhancedUserController&#13;&#10;   */&#13;&#10;  async searchUsers(&#13;&#10;    query: string,&#13;&#10;    faculty?: string,&#13;&#10;    major?: string,&#13;&#10;    batch?: string,&#13;&#10;    page = 0,&#13;&#10;    size = 20&#13;&#10;  ): Promise&lt;User[]&gt; {&#13;&#10;    const url = createApiUrl(API_ENDPOINTS.USERS.SEARCH, undefined, {&#13;&#10;      query,&#13;&#10;      faculty,&#13;&#10;      major,&#13;&#10;      batch,&#13;&#10;      page,&#13;&#10;      size,&#13;&#10;    });&#13;&#10;    return apiClient.get&lt;User[]&gt;(url);&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Get friend suggestions - Updated to match backend&#13;&#10;   */&#13;&#10;  async getFriendSuggestions(limit = 10): Promise&lt;any[]&gt; {&#13;&#10;    const url = createApiUrl(API_ENDPOINTS.USERS.FRIEND_SUGGESTIONS, undefined, { limit });&#13;&#10;    return apiClient.get&lt;any[]&gt;(url);&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Send friend request - Updated to match backend&#13;&#10;   */&#13;&#10;  async sendFriendRequest(targetUserId: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#13;&#10;    const url = createApiUrl(API_ENDPOINTS.USERS.SEND_FRIEND_REQUEST, { id: targetUserId });&#13;&#10;    return apiClient.post&lt;ApiResponse&lt;null&gt;&gt;(url);&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Accept friend request - Updated to match backend&#13;&#10;   */&#13;&#10;  async acceptFriendRequest(requesterId: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#13;&#10;    const url = createApiUrl(API_ENDPOINTS.USERS.ACCEPT_FRIEND_REQUEST, { id: requesterId });&#13;&#10;    return apiClient.post&lt;ApiResponse&lt;null&gt;&gt;(url);&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Get user's friends&#13;&#10;   */&#13;&#10;  async getFriends(userId: string): Promise&lt;User[]&gt; {&#13;&#10;    const url = createApiUrl(API_ENDPOINTS.USERS.FRIENDS, { id: userId });&#13;&#10;    return apiClient.get&lt;User[]&gt;(url);&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Get mutual friends count - Updated to match backend&#13;&#10;   */&#13;&#10;  async getMutualFriendsCount(targetUserId: string): Promise&lt;number&gt; {&#13;&#10;    const url = createApiUrl(API_ENDPOINTS.USERS.MUTUAL_FRIENDS, { id: targetUserId });&#13;&#10;    return apiClient.get&lt;number&gt;(url);&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Get user timeline - Updated to match backend&#13;&#10;   */&#13;&#10;  async getUserTimeline(userId: string, page = 0, size = 10): Promise&lt;any[]&gt; {&#13;&#10;    const url = createApiUrl(API_ENDPOINTS.USERS.TIMELINE, { id: userId }, { page, size });&#13;&#10;    return apiClient.get&lt;any[]&gt;(url);&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Get user activities - Updated to match backend&#13;&#10;   */&#13;&#10;  async getUserActivities(userId: string, page = 0, size = 10): Promise&lt;any[]&gt; {&#13;&#10;    const url = createApiUrl(API_ENDPOINTS.USERS.ACTIVITIES, { id: userId }, { page, size });&#13;&#10;    return apiClient.get&lt;any[]&gt;(url);&#13;&#10;  }&#13;&#10;}&#13;&#10;&#13;&#10;// Export singleton instance&#13;&#10;export const userService = new UserService();" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/post-service/pom.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/post-service/pom.xml" />
              <option name="originalContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&#10;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&#10;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;&#10;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;&#10;    &lt;parent&gt;&#10;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;&#10;        &lt;version&gt;3.2.0&lt;/version&gt;&#10;        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;&#10;    &lt;/parent&gt;&#10;    &lt;groupId&gt;vn.ctu.edu&lt;/groupId&gt;&#10;    &lt;artifactId&gt;post-service&lt;/artifactId&gt;&#10;    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;&#10;    &lt;name&gt;post-service&lt;/name&gt;&#10;    &lt;description&gt;Post Service for CTU Connect&lt;/description&gt;&#10;&#10;    &lt;properties&gt;&#10;        &lt;java.version&gt;17&lt;/java.version&gt;&#10;        &lt;spring-cloud.version&gt;2023.0.0&lt;/spring-cloud.version&gt;&#10;    &lt;/properties&gt;&#10;&#10;    &lt;dependencies&gt;&#10;        &lt;!-- Spring Boot Starters --&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;            &lt;artifactId&gt;spring-boot-starter-data-mongodb&lt;/artifactId&gt;&#10;        &lt;/dependency&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&#10;        &lt;/dependency&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;            &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt;&#10;        &lt;/dependency&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;!-- Spring Cloud --&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;&#10;            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&#10;        &lt;/dependency&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;&#10;            &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;!-- Kafka --&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.springframework.kafka&lt;/groupId&gt;&#10;            &lt;artifactId&gt;spring-kafka&lt;/artifactId&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;!-- Redis --&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;            &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.springframework.kafka&lt;/groupId&gt;&#10;            &lt;artifactId&gt;spring-kafka-test&lt;/artifactId&gt;&#10;            &lt;scope&gt;test&lt;/scope&gt;&#10;        &lt;/dependency&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;&#10;            &lt;artifactId&gt;spring-cloud-openfeign-core&lt;/artifactId&gt;&#10;        &lt;/dependency&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;&#10;            &lt;artifactId&gt;lombok&lt;/artifactId&gt;&#10;        &lt;/dependency&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;            &lt;artifactId&gt;spring-boot-starter-websocket&lt;/artifactId&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;!-- Remove this as it's included in spring-boot-starter-data-redis&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;            &lt;artifactId&gt;spring-boot-starter-websocket&lt;/artifactId&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;!-- Remove this as it's included in spring-boot-starter-data-redis&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.springframework.data&lt;/groupId&gt;&#10;            &lt;artifactId&gt;spring-data-redis&lt;/artifactId&gt;&#10;        &lt;/dependency&gt;&#10;        --&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.springframework.data&lt;/groupId&gt;&#10;            &lt;artifactId&gt;spring-data-redis&lt;/artifactId&gt;&#10;        &lt;/dependency&gt;&#10;        --&gt;&#10;    &lt;/dependencies&gt;&#10;&#10;    &lt;dependencyManagement&gt;&#10;        &lt;dependencies&gt;&#10;            &lt;dependency&gt;&#10;                &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;&#10;                &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;&#10;                &lt;version&gt;${spring-cloud.version}&lt;/version&gt;&#10;                &lt;type&gt;pom&lt;/type&gt;&#10;                &lt;scope&gt;import&lt;/scope&gt;&#10;            &lt;/dependency&gt;&#10;        &lt;/dependencies&gt;&#10;    &lt;/dependencyManagement&gt;&#10;&#10;    &lt;build&gt;&#10;        &lt;plugins&gt;&#10;            &lt;plugin&gt;&#10;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;&#10;            &lt;/plugin&gt;&#10;        &lt;/plugins&gt;&#10;    &lt;/build&gt;&#10;&lt;/project&gt;&#10;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&#10;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&#10;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;&#10;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;&#10;    &lt;parent&gt;&#10;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;&#10;        &lt;version&gt;3.2.0&lt;/version&gt;&#10;        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;&#10;    &lt;/parent&gt;&#10;    &lt;groupId&gt;vn.ctu.edu&lt;/groupId&gt;&#10;    &lt;artifactId&gt;post-service&lt;/artifactId&gt;&#10;    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;&#10;    &lt;name&gt;post-service&lt;/name&gt;&#10;    &lt;description&gt;Post Service for CTU Connect&lt;/description&gt;&#10;&#10;    &lt;properties&gt;&#10;        &lt;java.version&gt;17&lt;/java.version&gt;&#10;        &lt;spring-cloud.version&gt;2023.0.0&lt;/spring-cloud.version&gt;&#10;    &lt;/properties&gt;&#10;&#10;    &lt;dependencies&gt;&#10;        &lt;!-- Spring Boot Starters --&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;            &lt;artifactId&gt;spring-boot-starter-data-mongodb&lt;/artifactId&gt;&#10;        &lt;/dependency&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&#10;        &lt;/dependency&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;            &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt;&#10;        &lt;/dependency&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;!-- Spring Cloud --&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;&#10;            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&#10;        &lt;/dependency&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;&#10;            &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;!-- Kafka --&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.springframework.kafka&lt;/groupId&gt;&#10;            &lt;artifactId&gt;spring-kafka&lt;/artifactId&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;!-- Redis --&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;            &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;!-- WebSocket for real-time notifications --&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;            &lt;artifactId&gt;spring-boot-starter-websocket&lt;/artifactId&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;!-- Test Dependencies --&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;&#10;            &lt;scope&gt;test&lt;/scope&gt;&#10;        &lt;/dependency&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.springframework.kafka&lt;/groupId&gt;&#10;            &lt;artifactId&gt;spring-kafka-test&lt;/artifactId&gt;&#10;            &lt;scope&gt;test&lt;/scope&gt;&#10;        &lt;/dependency&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;&#10;            &lt;artifactId&gt;spring-cloud-openfeign-core&lt;/artifactId&gt;&#10;        &lt;/dependency&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;&#10;            &lt;artifactId&gt;lombok&lt;/artifactId&gt;&#10;        &lt;/dependency&gt;&#10;    &lt;/dependencies&gt;&#10;&#10;    &lt;dependencyManagement&gt;&#10;        &lt;dependencies&gt;&#10;            &lt;dependency&gt;&#10;                &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;&#10;                &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;&#10;                &lt;version&gt;${spring-cloud.version}&lt;/version&gt;&#10;                &lt;type&gt;pom&lt;/type&gt;&#10;                &lt;scope&gt;import&lt;/scope&gt;&#10;            &lt;/dependency&gt;&#10;        &lt;/dependencies&gt;&#10;    &lt;/dependencyManagement&gt;&#10;&#10;    &lt;build&gt;&#10;        &lt;plugins&gt;&#10;            &lt;plugin&gt;&#10;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;&#10;            &lt;/plugin&gt;&#10;        &lt;/plugins&gt;&#10;    &lt;/build&gt;&#10;&lt;/project&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/client/UserServiceClient.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/client/UserServiceClient.java" />
              <option name="originalContent" value="package com.ctuconnect.client;&#10;&#10;import org.springframework.cloud.openfeign.FeignClient;&#10;import org.springframework.web.bind.annotation.GetMapping;&#10;import org.springframework.web.bind.annotation.PathVariable;&#10;import com.ctuconnect.dto.AuthorInfo;&#10;&#10;import java.util.Set;&#10;&#10;@FeignClient(name = &quot;user-service&quot;, url = &quot;${user-service.url:http://localhost:8080}&quot;)&#10;public interface UserServiceClient {&#10;    @GetMapping(&quot;/api/users/authors/{id}&quot;)&#10;    AuthorInfo getAuthorInfo(@PathVariable(&quot;id&quot;) String authorId);&#10;&#10;    @GetMapping(&quot;/api/users/{userId}/friends/ids&quot;)&#10;    Set&lt;String&gt; getFriendIds(@PathVariable(&quot;userId&quot;) String userId);&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package com.ctuconnect.client;&#13;&#10;&#13;&#10;import org.springframework.cloud.openfeign.FeignClient;&#13;&#10;import org.springframework.web.bind.annotation.GetMapping;&#13;&#10;import org.springframework.web.bind.annotation.PathVariable;&#13;&#10;import com.ctuconnect.dto.AuthorInfo;&#13;&#10;&#13;&#10;import java.util.Set;&#13;&#10;&#13;&#10;@FeignClient(name = &quot;user-service&quot;, url = &quot;${user-service.url:http://localhost:8080}&quot;)&#13;&#10;public interface UserServiceClient {&#13;&#10;    @GetMapping(&quot;/api/users/authors/{id}&quot;)&#13;&#10;    AuthorInfo getAuthorInfo(@PathVariable(&quot;id&quot;) String authorId);&#13;&#10;&#13;&#10;    @GetMapping(&quot;/api/users/{userId}/friends/ids&quot;)&#13;&#10;    Set&lt;String&gt; getFriendIds(@PathVariable(&quot;userId&quot;) String userId);&#13;&#10;    &#13;&#10;    // Additional methods needed by NewsFeedService&#13;&#10;    @GetMapping(&quot;/api/users/{userId}/close-interactions&quot;)&#13;&#10;    Set&lt;String&gt; getCloseInteractionIds(@PathVariable(&quot;userId&quot;) String userId);&#13;&#10;    &#13;&#10;    @GetMapping(&quot;/api/users/{userId}/same-faculty&quot;)&#13;&#10;    Set&lt;String&gt; getSameFacultyUserIds(@PathVariable(&quot;userId&quot;) String userId);&#13;&#10;    &#13;&#10;    @GetMapping(&quot;/api/users/{userId}/same-major&quot;) &#13;&#10;    Set&lt;String&gt; getSameMajorUserIds(@PathVariable(&quot;userId&quot;) String userId);&#13;&#10;    &#13;&#10;    @GetMapping(&quot;/api/users/{userId}/interest-tags&quot;)&#13;&#10;    Set&lt;String&gt; getUserInterestTags(@PathVariable(&quot;userId&quot;) String userId);&#13;&#10;    &#13;&#10;    @GetMapping(&quot;/api/users/{userId}/preferred-categories&quot;)&#13;&#10;    Set&lt;String&gt; getUserPreferredCategories(@PathVariable(&quot;userId&quot;) String userId);&#13;&#10;    &#13;&#10;    @GetMapping(&quot;/api/users/{userId}/faculty-id&quot;)&#13;&#10;    String getUserFacultyId(@PathVariable(&quot;userId&quot;) String userId);&#13;&#10;    &#13;&#10;    @GetMapping(&quot;/api/users/{userId}/major-id&quot;)&#13;&#10;    String getUserMajorId(@PathVariable(&quot;userId&quot;) String userId);&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/config/CacheConfig.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/config/CacheConfig.java" />
              <option name="updatedContent" value="package com.ctuconnect.config;&#10;&#10;import org.springframework.beans.factory.annotation.Value;&#10;import org.springframework.context.annotation.Bean;&#10;import org.springframework.context.annotation.Configuration;&#10;import org.springframework.data.redis.connection.RedisConnectionFactory;&#10;import org.springframework.data.redis.connection.lettuce.LettuceConnectionFactory;&#10;import org.springframework.data.redis.core.RedisTemplate;&#10;import org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer;&#10;import org.springframework.data.redis.serializer.StringRedisSerializer;&#10;&#10;@Configuration&#10;public class CacheConfig {&#10;&#10;    @Value(&quot;${spring.data.redis.host:localhost}&quot;)&#10;    private String redisHost;&#10;&#10;    @Value(&quot;${spring.data.redis.port:6379}&quot;)&#10;    private int redisPort;&#10;&#10;    @Bean&#10;    public RedisConnectionFactory redisConnectionFactory() {&#10;        return new LettuceConnectionFactory(redisHost, redisPort);&#10;    }&#10;&#10;    @Bean&#10;    public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory connectionFactory) {&#10;        RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;();&#10;        template.setConnectionFactory(connectionFactory);&#10;        &#10;        // Use String serializer for keys&#10;        template.setKeySerializer(new StringRedisSerializer());&#10;        template.setHashKeySerializer(new StringRedisSerializer());&#10;        &#10;        // Use JSON serializer for values&#10;        template.setValueSerializer(new GenericJackson2JsonRedisSerializer());&#10;        template.setHashValueSerializer(new GenericJackson2JsonRedisSerializer());&#10;        &#10;        template.afterPropertiesSet();&#10;        return template;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/config/HealthCheckConfig.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/config/HealthCheckConfig.java" />
              <option name="updatedContent" value="package com.ctuconnect.config;&#10;&#10;import org.springframework.boot.actuator.health.Health;&#10;import org.springframework.boot.actuator.health.HealthIndicator;&#10;import org.springframework.context.annotation.Bean;&#10;import org.springframework.context.annotation.Configuration;&#10;import org.springframework.data.redis.connection.RedisConnectionFactory;&#10;import org.springframework.data.mongodb.core.MongoTemplate;&#10;&#10;@Configuration&#10;public class HealthCheckConfig {&#10;    &#10;    @Bean&#10;    public HealthIndicator redisHealthIndicator(RedisConnectionFactory redisConnectionFactory) {&#10;        return () -&gt; {&#10;            try {&#10;                redisConnectionFactory.getConnection().ping();&#10;                return Health.up()&#10;                    .withDetail(&quot;redis&quot;, &quot;Available&quot;)&#10;                    .build();&#10;            } catch (Exception e) {&#10;                return Health.down()&#10;                    .withDetail(&quot;redis&quot;, &quot;Unavailable&quot;)&#10;                    .withDetail(&quot;error&quot;, e.getMessage())&#10;                    .build();&#10;            }&#10;        };&#10;    }&#10;    &#10;    @Bean&#10;    public HealthIndicator mongoHealthIndicator(MongoTemplate mongoTemplate) {&#10;        return () -&gt; {&#10;            try {&#10;                mongoTemplate.getCollection(&quot;health_check&quot;).countDocuments();&#10;                return Health.up()&#10;                    .withDetail(&quot;mongodb&quot;, &quot;Available&quot;)&#10;                    .build();&#10;            } catch (Exception e) {&#10;                return Health.down()&#10;                    .withDetail(&quot;mongodb&quot;, &quot;Unavailable&quot;)&#10;                    .withDetail(&quot;error&quot;, e.getMessage())&#10;                    .build();&#10;            }&#10;        };&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/config/WebSocketConfig.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/config/WebSocketConfig.java" />
              <option name="updatedContent" value="package com.ctuconnect.config;&#10;&#10;import org.springframework.context.annotation.Configuration;&#10;import org.springframework.messaging.simp.config.MessageBrokerRegistry;&#10;import org.springframework.web.socket.config.annotation.EnableWebSocketMessageBroker;&#10;import org.springframework.web.socket.config.annotation.StompEndpointRegistry;&#10;import org.springframework.web.socket.config.annotation.WebSocketMessageBrokerConfigurer;&#10;&#10;@Configuration&#10;@EnableWebSocketMessageBroker&#10;public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {&#10;&#10;    @Override&#10;    public void configureMessageBroker(MessageBrokerRegistry config) {&#10;        // Enable simple message broker for in-memory message handling&#10;        config.enableSimpleBroker(&quot;/topic&quot;, &quot;/queue&quot;);&#10;        config.setApplicationDestinationPrefixes(&quot;/app&quot;);&#10;        config.setUserDestinationPrefix(&quot;/user&quot;);&#10;    }&#10;&#10;    @Override&#10;    public void registerStompEndpoints(StompEndpointRegistry registry) {&#10;        // Register STOMP endpoints for WebSocket connections&#10;        registry.addEndpoint(&quot;/ws&quot;)&#10;                .setAllowedOriginPatterns(&quot;*&quot;)&#10;                .withSockJS();&#10;        &#10;        registry.addEndpoint(&quot;/ws-notifications&quot;)&#10;                .setAllowedOriginPatterns(&quot;*&quot;)&#10;                .withSockJS();&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/controller/EnhancedPostController.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/controller/EnhancedPostController.java" />
              <option name="updatedContent" value="// This file has been merged into PostController.java&#10;// Delete this file to avoid conflicts" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/controller/PostController.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/controller/PostController.java" />
              <option name="originalContent" value="package com.ctuconnect.controller;&#10;&#10;import jakarta.validation.Valid;&#10;import org.springframework.beans.factory.annotation.Autowired;&#10;import org.springframework.data.domain.Page;&#10;import org.springframework.data.domain.PageRequest;&#10;import org.springframework.data.domain.Pageable;&#10;import org.springframework.data.domain.Sort;&#10;import org.springframework.http.HttpStatus;&#10;import org.springframework.http.ResponseEntity;&#10;import org.springframework.web.bind.annotation.*;&#10;import org.springframework.web.multipart.MultipartFile;&#10;import com.ctuconnect.dto.request.CommentRequest;&#10;import com.ctuconnect.dto.request.InteractionRequest;&#10;import com.ctuconnect.dto.request.PostRequest;&#10;import com.ctuconnect.dto.response.CommentResponse;&#10;import com.ctuconnect.dto.response.InteractionResponse;&#10;import com.ctuconnect.dto.response.PostResponse;&#10;import com.ctuconnect.security.SecurityContextHolder;&#10;import com.ctuconnect.security.annotation.RequireAuth;&#10;import com.ctuconnect.service.CommentService;&#10;import com.ctuconnect.service.InteractionService;&#10;import com.ctuconnect.service.PostService;&#10;&#10;import java.util.List;&#10;import java.util.Map;&#10;&#10;@RestController&#10;@RequestMapping(&quot;/api/posts/legacy&quot;) // Change to legacy path to avoid conflicts with EnhancedPostController&#10;public class PostController {&#10;&#10;    @Autowired&#10;    private PostService postService;&#10;&#10;    @Autowired&#10;    private CommentService commentService;&#10;&#10;    @Autowired&#10;    private InteractionService interactionService;&#10;&#10;    // Create post&#10;    @PostMapping(&quot;/legacy&quot;)&#10;    @RequireAuth&#10;    public ResponseEntity&lt;?&gt; createPost(&#10;            @Valid @RequestPart(&quot;post&quot;) PostRequest request,&#10;            @RequestPart(value = &quot;files&quot;, required = false) List&lt;MultipartFile&gt; files) {&#10;&#10;        try {&#10;            String currentUserId = SecurityContextHolder.getCurrentUserIdOrThrow();&#10;            PostResponse response = postService.createPost(request, files, currentUserId);&#10;            return ResponseEntity.status(HttpStatus.CREATED).body(response);&#10;        } catch (SecurityException e) {&#10;            return ResponseEntity.status(HttpStatus.UNAUTHORIZED)&#10;                    .body(Map.of(&quot;error&quot;, &quot;Authentication required&quot;, &quot;message&quot;, e.getMessage()));&#10;        } catch (RuntimeException e) {&#10;            return ResponseEntity.status(HttpStatus.BAD_REQUEST)&#10;                    .body(Map.of(&quot;error&quot;, &quot;Failed to create post&quot;, &quot;message&quot;, e.getMessage()));&#10;        } catch (Exception e) {&#10;            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)&#10;                    .body(Map.of(&quot;error&quot;, &quot;Internal server error&quot;, &quot;message&quot;, &quot;Failed to create post&quot;));&#10;        }&#10;    }&#10;&#10;    // Alternative endpoint for JSON-only post creation (without files)&#10;    @PostMapping(&quot;/simple&quot;)&#10;    @RequireAuth&#10;    public ResponseEntity&lt;?&gt; createSimplePost(@Valid @RequestBody PostRequest request) {&#10;        try {&#10;            String currentUserId = SecurityContextHolder.getCurrentUserIdOrThrow();&#10;            PostResponse response = postService.createPost(request, null, currentUserId);&#10;            return ResponseEntity.status(HttpStatus.CREATED).body(response);&#10;        } catch (SecurityException e) {&#10;            return ResponseEntity.status(HttpStatus.UNAUTHORIZED)&#10;                    .body(Map.of(&quot;error&quot;, &quot;Authentication required&quot;, &quot;message&quot;, e.getMessage()));&#10;        } catch (RuntimeException e) {&#10;            return ResponseEntity.status(HttpStatus.BAD_REQUEST)&#10;                    .body(Map.of(&quot;error&quot;, &quot;Failed to create post&quot;, &quot;message&quot;, e.getMessage()));&#10;        } catch (Exception e) {&#10;            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)&#10;                    .body(Map.of(&quot;error&quot;, &quot;Internal server error&quot;, &quot;message&quot;, &quot;Failed to create post&quot;));&#10;        }&#10;    }&#10;&#10;    // Get all posts with pagination&#10;    @GetMapping&#10;    public ResponseEntity&lt;?&gt; getAllPosts(&#10;            @RequestParam(defaultValue = &quot;0&quot;) int page,&#10;            @RequestParam(defaultValue = &quot;10&quot;) int size,&#10;            @RequestParam(defaultValue = &quot;createdAt&quot;) String sortBy,&#10;            @RequestParam(defaultValue = &quot;desc&quot;) String sortDir,&#10;            @RequestParam(required = false) String authorId,&#10;            @RequestParam(required = false) String category,&#10;            @RequestParam(required = false) String search) {&#10;&#10;        try {&#10;            Sort sort = sortDir.equalsIgnoreCase(&quot;desc&quot;) ?&#10;                Sort.by(sortBy).descending() : Sort.by(sortBy).ascending();&#10;            Pageable pageable = PageRequest.of(page, size, sort);&#10;&#10;            Page&lt;PostResponse&gt; posts;&#10;&#10;            if (search != null &amp;&amp; !search.trim().isEmpty()) {&#10;                posts = postService.searchPosts(search.trim(), pageable);&#10;            } else if (authorId != null &amp;&amp; !authorId.trim().isEmpty()) {&#10;                posts = postService.getPostsByAuthor(authorId.trim(), pageable);&#10;            } else if (category != null &amp;&amp; !category.trim().isEmpty()) {&#10;                posts = postService.getPostsByCategory(category.trim(), pageable);&#10;            } else {&#10;                posts = postService.getAllPosts(pageable);&#10;            }&#10;&#10;            return ResponseEntity.ok(posts);&#10;        } catch (Exception e) {&#10;            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)&#10;                    .body(Map.of(&quot;error&quot;, &quot;Failed to retrieve posts&quot;, &quot;message&quot;, e.getMessage()));&#10;        }&#10;    }&#10;&#10;    // Get post by ID (auto-record VIEW interaction)&#10;    @GetMapping(&quot;/{id}&quot;)&#10;    public ResponseEntity&lt;?&gt; getPostById(@PathVariable String id) {&#10;        try {&#10;            String currentUserId = SecurityContextHolder.getCurrentUserId();&#10;            PostResponse post = postService.getPostById(id, currentUserId);&#10;            return ResponseEntity.ok(post);&#10;        } catch (RuntimeException e) {&#10;            return ResponseEntity.status(HttpStatus.NOT_FOUND)&#10;                    .body(Map.of(&quot;error&quot;, &quot;Post not found&quot;, &quot;message&quot;, e.getMessage()));&#10;        } catch (Exception e) {&#10;            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)&#10;                    .body(Map.of(&quot;error&quot;, &quot;Failed to retrieve post&quot;, &quot;message&quot;, e.getMessage()));&#10;        }&#10;    }&#10;&#10;    // Update post (author only)&#10;    @PutMapping(&quot;/{id}&quot;)&#10;    @RequireAuth&#10;    public ResponseEntity&lt;?&gt; updatePost(&#10;            @PathVariable String id,&#10;            @Valid @RequestBody PostRequest request) {&#10;        try {&#10;            String authorId = SecurityContextHolder.getCurrentUserIdOrThrow();&#10;            PostResponse updatedPost = postService.updatePost(id, request, authorId);&#10;            return ResponseEntity.ok(updatedPost);&#10;        } catch (SecurityException e) {&#10;            return ResponseEntity.status(HttpStatus.UNAUTHORIZED)&#10;                    .body(Map.of(&quot;error&quot;, &quot;Authentication required&quot;, &quot;message&quot;, e.getMessage()));&#10;        } catch (RuntimeException e) {&#10;            String message = e.getMessage();&#10;            if (message.contains(&quot;Only the author&quot;)) {&#10;                return ResponseEntity.status(HttpStatus.FORBIDDEN)&#10;                        .body(Map.of(&quot;error&quot;, &quot;Access denied&quot;, &quot;message&quot;, message));&#10;            }&#10;            return ResponseEntity.status(HttpStatus.NOT_FOUND)&#10;                    .body(Map.of(&quot;error&quot;, &quot;Post not found&quot;, &quot;message&quot;, message));&#10;        } catch (Exception e) {&#10;            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)&#10;                    .body(Map.of(&quot;error&quot;, &quot;Failed to update post&quot;, &quot;message&quot;, e.getMessage()));&#10;        }&#10;    }&#10;&#10;    // Delete post (author only)&#10;    @DeleteMapping(&quot;/{id}&quot;)&#10;    @RequireAuth&#10;    public ResponseEntity&lt;?&gt; deletePost(@PathVariable String id) {&#10;        try {&#10;            String authorId = SecurityContextHolder.getCurrentUserIdOrThrow();&#10;            postService.deletePost(id, authorId);&#10;            return ResponseEntity.noContent().build();&#10;        } catch (SecurityException e) {&#10;            return ResponseEntity.status(HttpStatus.UNAUTHORIZED)&#10;                    .body(Map.of(&quot;error&quot;, &quot;Authentication required&quot;, &quot;message&quot;, e.getMessage()));&#10;        } catch (RuntimeException e) {&#10;            String message = e.getMessage();&#10;            if (message.contains(&quot;Only the author&quot;)) {&#10;                return ResponseEntity.status(HttpStatus.FORBIDDEN)&#10;                        .body(Map.of(&quot;error&quot;, &quot;Access denied&quot;, &quot;message&quot;, message));&#10;            }&#10;            return ResponseEntity.status(HttpStatus.NOT_FOUND)&#10;                    .body(Map.of(&quot;error&quot;, &quot;Post not found&quot;, &quot;message&quot;, message));&#10;        } catch (Exception e) {&#10;            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)&#10;                    .body(Map.of(&quot;error&quot;, &quot;Failed to delete post&quot;, &quot;message&quot;, e.getMessage()));&#10;        }&#10;    }&#10;&#10;    // Add comment to post&#10;    @PostMapping(&quot;/{id}/comments&quot;)&#10;    public ResponseEntity&lt;CommentResponse&gt; addComment(&#10;            @PathVariable String id,&#10;            @Valid @RequestBody CommentRequest request) {&#10;        String currentUserId = SecurityContextHolder.getCurrentUserIdOrThrow();&#10;        try {&#10;            CommentResponse comment = commentService.createComment(id, request, currentUserId);&#10;            return ResponseEntity.status(HttpStatus.CREATED).body(comment);&#10;        } catch (RuntimeException e) {&#10;            return ResponseEntity.badRequest().build();&#10;        }&#10;    }&#10;&#10;    // Get comments for post&#10;    @GetMapping(&quot;/{id}/comments&quot;)&#10;    public ResponseEntity&lt;Page&lt;CommentResponse&gt;&gt; getComments(&#10;            @PathVariable String id,&#10;            @RequestParam(defaultValue = &quot;0&quot;) int page,&#10;            @RequestParam(defaultValue = &quot;10&quot;) int size) {&#10;&#10;        Pageable pageable = PageRequest.of(page, size, Sort.by(&quot;createdAt&quot;).ascending());&#10;        Page&lt;CommentResponse&gt; comments = commentService.getCommentsByPost(id, pageable);&#10;        return ResponseEntity.ok(comments);&#10;    }&#10;&#10;    // Record interaction (LIKE/SHARE/BOOKMARK)&#10;    @PostMapping(&quot;/{id}/interactions&quot;)&#10;    public ResponseEntity&lt;InteractionResponse&gt; recordInteraction(&#10;            @PathVariable String id,&#10;            @Valid @RequestBody InteractionRequest request) {&#10;        String userId = SecurityContextHolder.getCurrentUserIdOrThrow();&#10;        try {&#10;            InteractionResponse interaction = interactionService.createInteraction(id, request, userId);&#10;            if (interaction == null) {&#10;                // Interaction was removed (e.g., unlike)&#10;                return ResponseEntity.noContent().build();&#10;            }&#10;            return ResponseEntity.status(HttpStatus.CREATED).body(interaction);&#10;        } catch (RuntimeException e) {&#10;            return ResponseEntity.badRequest().build();&#10;        }&#10;    }&#10;&#10;    // Check if user has liked post&#10;    @GetMapping(&quot;/{id}/likes/check&quot;)&#10;    public ResponseEntity&lt;Boolean&gt; hasUserLikedPost(&#10;            @PathVariable String id) {&#10;        String userId = SecurityContextHolder.getCurrentUserIdOrThrow();&#10;        boolean hasLiked = interactionService.hasUserReacted(id, userId);&#10;        return ResponseEntity.ok(hasLiked);&#10;    }&#10;&#10;    // Get trending posts - moved to legacy path&#10;    @GetMapping(&quot;/trending&quot;)&#10;    public ResponseEntity&lt;?&gt; getTrendingPosts() {&#10;        try {&#10;            List&lt;PostResponse&gt; posts = postService.getTopViewedPosts();&#10;            return ResponseEntity.ok(posts);&#10;        } catch (Exception e) {&#10;            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)&#10;                    .body(Map.of(&quot;error&quot;, &quot;Failed to retrieve trending posts&quot;, &quot;message&quot;, e.getMessage()));&#10;        }&#10;    }&#10;&#10;    // Get top viewed posts&#10;    @GetMapping(&quot;/top-viewed&quot;)&#10;    public ResponseEntity&lt;?&gt; getTopViewedPosts() {&#10;        try {&#10;            List&lt;PostResponse&gt; posts = postService.getTopViewedPosts();&#10;            return ResponseEntity.ok(posts);&#10;        } catch (Exception e) {&#10;            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)&#10;                    .body(Map.of(&quot;error&quot;, &quot;Failed to retrieve top viewed posts&quot;, &quot;message&quot;, e.getMessage()));&#10;        }&#10;    }&#10;&#10;    // Get top liked posts&#10;    @GetMapping(&quot;/top-liked&quot;)&#10;    public ResponseEntity&lt;?&gt; getTopLikedPosts() {&#10;        try {&#10;            List&lt;PostResponse&gt; posts = postService.getTopLikedPosts();&#10;            return ResponseEntity.ok(posts);&#10;        } catch (Exception e) {&#10;            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)&#10;                    .body(Map.of(&quot;error&quot;, &quot;Failed to retrieve top liked posts&quot;, &quot;message&quot;, e.getMessage()));&#10;        }&#10;    }&#10;&#10;}&#10;" />
              <option name="updatedContent" value="package com.ctuconnect.controller;&#10;&#10;import jakarta.validation.Valid;&#10;import org.springframework.beans.factory.annotation.Autowired;&#10;import org.springframework.data.domain.Page;&#10;import org.springframework.data.domain.PageRequest;&#10;import org.springframework.data.domain.Pageable;&#10;import org.springframework.data.domain.Sort;&#10;import org.springframework.http.HttpStatus;&#10;import org.springframework.http.ResponseEntity;&#10;import org.springframework.web.bind.annotation.*;&#10;import org.springframework.web.multipart.MultipartFile;&#10;import com.ctuconnect.dto.request.CommentRequest;&#10;import com.ctuconnect.dto.request.InteractionRequest;&#10;import com.ctuconnect.dto.request.PostRequest;&#10;import com.ctuconnect.dto.request.ScheduledPostRequest;&#10;import com.ctuconnect.dto.response.CommentResponse;&#10;import com.ctuconnect.dto.response.InteractionResponse;&#10;import com.ctuconnect.dto.response.PostResponse;&#10;import com.ctuconnect.dto.response.PostAnalyticsResponse;&#10;import com.ctuconnect.security.SecurityContextHolder;&#10;import com.ctuconnect.security.annotation.RequireAuth;&#10;import com.ctuconnect.security.AuthenticatedUser;&#10;import com.ctuconnect.service.CommentService;&#10;import com.ctuconnect.service.InteractionService;&#10;import com.ctuconnect.service.PostService;&#10;import com.ctuconnect.service.NewsFeedService;&#10;import com.ctuconnect.service.NotificationService;&#10;&#10;import java.util.List;&#10;import java.util.Map;&#10;&#10;@RestController&#10;@RequestMapping(&quot;/api/posts&quot;)&#10;public class PostController {&#10;&#10;    @Autowired&#10;    private PostService postService;&#10;&#10;    @Autowired&#10;    private CommentService commentService;&#10;&#10;    @Autowired&#10;    private InteractionService interactionService;&#10;&#10;    @Autowired(required = false)&#10;    private NewsFeedService newsFeedService;&#10;&#10;    @Autowired(required = false)&#10;    private NotificationService notificationService;&#10;&#10;    // ========== ENHANCED ENDPOINTS (Primary) ==========&#10;&#10;    /**&#10;     * Create post - Primary endpoint (Enhanced)&#10;     */&#10;    @PostMapping&#10;    @RequireAuth&#10;    public ResponseEntity&lt;?&gt; createPost(@Valid @RequestBody PostRequest request) {&#10;        try {&#10;            String currentUserId = SecurityContextHolder.getCurrentUserIdOrThrow();&#10;            &#10;            // Try enhanced service first, fallback to regular service&#10;            PostResponse response;&#10;            try {&#10;                AuthenticatedUser user = new AuthenticatedUser(currentUserId, null, null);&#10;                response = postService.createEnhancedPost(request, user);&#10;            } catch (Exception e) {&#10;                // Fallback to regular post creation&#10;                response = postService.createPost(request, null, currentUserId);&#10;            }&#10;            &#10;            // Invalidate caches if newsFeedService is available&#10;            if (newsFeedService != null) {&#10;                try {&#10;                    newsFeedService.invalidateFeedCacheForUsers(&#10;                        postService.getAffectedUserIds(response.getId()));&#10;                } catch (Exception e) {&#10;                    // Log error but don't fail the request&#10;                    System.err.println(&quot;Failed to invalidate cache: &quot; + e.getMessage());&#10;                }&#10;            }&#10;            &#10;            return ResponseEntity.status(HttpStatus.CREATED).body(response);&#10;        } catch (SecurityException e) {&#10;            return ResponseEntity.status(HttpStatus.UNAUTHORIZED)&#10;                    .body(Map.of(&quot;error&quot;, &quot;Authentication required&quot;, &quot;message&quot;, e.getMessage()));&#10;        } catch (RuntimeException e) {&#10;            return ResponseEntity.status(HttpStatus.BAD_REQUEST)&#10;                    .body(Map.of(&quot;error&quot;, &quot;Failed to create post&quot;, &quot;message&quot;, e.getMessage()));&#10;        } catch (Exception e) {&#10;            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)&#10;                    .body(Map.of(&quot;error&quot;, &quot;Internal server error&quot;, &quot;message&quot;, &quot;Failed to create post&quot;));&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Facebook-like personalized news feed&#10;     */&#10;    @GetMapping(&quot;/feed&quot;)&#10;    @RequireAuth&#10;    public ResponseEntity&lt;?&gt; getPersonalizedFeed(&#10;            @RequestParam(defaultValue = &quot;0&quot;) int page,&#10;            @RequestParam(defaultValue = &quot;10&quot;) int size) {&#10;        &#10;        try {&#10;            String currentUserId = SecurityContextHolder.getCurrentUserIdOrThrow();&#10;            &#10;            if (newsFeedService != null) {&#10;                List&lt;PostResponse&gt; feed = newsFeedService.generatePersonalizedFeed(&#10;                    currentUserId, page, size);&#10;                return ResponseEntity.ok(feed);&#10;            } else {&#10;                // Fallback to regular posts&#10;                Pageable pageable = PageRequest.of(page, size, Sort.by(&quot;createdAt&quot;).descending());&#10;                Page&lt;PostResponse&gt; posts = postService.getAllPosts(pageable);&#10;                return ResponseEntity.ok(posts.getContent());&#10;            }&#10;        } catch (Exception e) {&#10;            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)&#10;                    .body(Map.of(&quot;error&quot;, &quot;Failed to retrieve feed&quot;, &quot;message&quot;, e.getMessage()));&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get trending posts - Unified endpoint&#10;     */&#10;    @GetMapping(&quot;/trending&quot;)&#10;    public ResponseEntity&lt;?&gt; getTrendingPosts(&#10;            @RequestParam(defaultValue = &quot;0&quot;) int page,&#10;            @RequestParam(defaultValue = &quot;20&quot;) int size) {&#10;        &#10;        try {&#10;            List&lt;PostResponse&gt; posts;&#10;            &#10;            if (newsFeedService != null) {&#10;                posts = newsFeedService.getTrendingPosts(page, size);&#10;            } else {&#10;                // Fallback to top viewed posts&#10;                posts = postService.getTopViewedPosts();&#10;            }&#10;            &#10;            return ResponseEntity.ok(posts);&#10;        } catch (Exception e) {&#10;            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)&#10;                    .body(Map.of(&quot;error&quot;, &quot;Failed to retrieve trending posts&quot;, &quot;message&quot;, e.getMessage()));&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get user timeline (profile posts)&#10;     */&#10;    @GetMapping(&quot;/timeline/{userId}&quot;)&#10;    @RequireAuth&#10;    public ResponseEntity&lt;?&gt; getUserTimeline(&#10;            @PathVariable String userId,&#10;            @RequestParam(defaultValue = &quot;0&quot;) int page,&#10;            @RequestParam(defaultValue = &quot;10&quot;) int size) {&#10;        &#10;        try {&#10;            String currentUserId = SecurityContextHolder.getCurrentUserIdOrThrow();&#10;            &#10;            if (newsFeedService != null) {&#10;                List&lt;PostResponse&gt; timeline = newsFeedService.generateUserTimeline(&#10;                    userId, currentUserId, page, size);&#10;                return ResponseEntity.ok(timeline);&#10;            } else {&#10;                // Fallback to posts by author&#10;                Pageable pageable = PageRequest.of(page, size, Sort.by(&quot;createdAt&quot;).descending());&#10;                Page&lt;PostResponse&gt; posts = postService.getPostsByAuthor(userId, pageable);&#10;                return ResponseEntity.ok(posts.getContent());&#10;            }&#10;        } catch (Exception e) {&#10;            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)&#10;                    .body(Map.of(&quot;error&quot;, &quot;Failed to retrieve timeline&quot;, &quot;message&quot;, e.getMessage()));&#10;        }&#10;    }&#10;&#10;    // ========== LEGACY ENDPOINTS (Maintained for compatibility) ==========&#10;&#10;    /**&#10;     * Create post with file upload support&#10;     */&#10;    @PostMapping(&quot;/upload&quot;)&#10;    @RequireAuth&#10;    public ResponseEntity&lt;?&gt; createPostWithFiles(&#10;            @Valid @RequestPart(&quot;post&quot;) PostRequest request,&#10;            @RequestPart(value = &quot;files&quot;, required = false) List&lt;MultipartFile&gt; files) {&#10;        &#10;        try {&#10;            String currentUserId = SecurityContextHolder.getCurrentUserIdOrThrow();&#10;            PostResponse response = postService.createPost(request, files, currentUserId);&#10;            return ResponseEntity.status(HttpStatus.CREATED).body(response);&#10;        } catch (SecurityException e) {&#10;            return ResponseEntity.status(HttpStatus.UNAUTHORIZED)&#10;                    .body(Map.of(&quot;error&quot;, &quot;Authentication required&quot;, &quot;message&quot;, e.getMessage()));&#10;        } catch (RuntimeException e) {&#10;            return ResponseEntity.status(HttpStatus.BAD_REQUEST)&#10;                    .body(Map.of(&quot;error&quot;, &quot;Failed to create post&quot;, &quot;message&quot;, e.getMessage()));&#10;        } catch (Exception e) {&#10;            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)&#10;                    .body(Map.of(&quot;error&quot;, &quot;Internal server error&quot;, &quot;message&quot;, &quot;Failed to create post&quot;));&#10;        }&#10;    }&#10;&#10;    // ========== COMMON ENDPOINTS ==========&#10;&#10;    /**&#10;     * Get all posts with pagination and filters&#10;     */&#10;    @GetMapping&#10;    public ResponseEntity&lt;?&gt; getAllPosts(&#10;            @RequestParam(defaultValue = &quot;0&quot;) int page,&#10;            @RequestParam(defaultValue = &quot;10&quot;) int size,&#10;            @RequestParam(defaultValue = &quot;createdAt&quot;) String sortBy,&#10;            @RequestParam(defaultValue = &quot;desc&quot;) String sortDir,&#10;            @RequestParam(required = false) String authorId,&#10;            @RequestParam(required = false) String category,&#10;            @RequestParam(required = false) String search) {&#10;&#10;        try {&#10;            Sort sort = sortDir.equalsIgnoreCase(&quot;desc&quot;) ?&#10;                Sort.by(sortBy).descending() : Sort.by(sortBy).ascending();&#10;            Pageable pageable = PageRequest.of(page, size, sort);&#10;&#10;            Page&lt;PostResponse&gt; posts;&#10;&#10;            if (search != null &amp;&amp; !search.trim().isEmpty()) {&#10;                posts = postService.searchPosts(search.trim(), pageable);&#10;            } else if (authorId != null &amp;&amp; !authorId.trim().isEmpty()) {&#10;                posts = postService.getPostsByAuthor(authorId.trim(), pageable);&#10;            } else if (category != null &amp;&amp; !category.trim().isEmpty()) {&#10;                posts = postService.getPostsByCategory(category.trim(), pageable);&#10;            } else {&#10;                posts = postService.getAllPosts(pageable);&#10;            }&#10;&#10;            return ResponseEntity.ok(posts);&#10;        } catch (Exception e) {&#10;            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)&#10;                    .body(Map.of(&quot;error&quot;, &quot;Failed to retrieve posts&quot;, &quot;message&quot;, e.getMessage()));&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get post by ID (auto-record VIEW interaction)&#10;     */&#10;    @GetMapping(&quot;/{id}&quot;)&#10;    public ResponseEntity&lt;?&gt; getPostById(@PathVariable String id) {&#10;        try {&#10;            String currentUserId = SecurityContextHolder.getCurrentUserId();&#10;            PostResponse post = postService.getPostById(id, currentUserId);&#10;            return ResponseEntity.ok(post);&#10;        } catch (RuntimeException e) {&#10;            return ResponseEntity.status(HttpStatus.NOT_FOUND)&#10;                    .body(Map.of(&quot;error&quot;, &quot;Post not found&quot;, &quot;message&quot;, e.getMessage()));&#10;        } catch (Exception e) {&#10;            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)&#10;                    .body(Map.of(&quot;error&quot;, &quot;Failed to retrieve post&quot;, &quot;message&quot;, e.getMessage()));&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Update post (author only)&#10;     */&#10;    @PutMapping(&quot;/{id}&quot;)&#10;    @RequireAuth&#10;    public ResponseEntity&lt;?&gt; updatePost(&#10;            @PathVariable String id,&#10;            @Valid @RequestBody PostRequest request) {&#10;        try {&#10;            String authorId = SecurityContextHolder.getCurrentUserIdOrThrow();&#10;            PostResponse updatedPost = postService.updatePost(id, request, authorId);&#10;            return ResponseEntity.ok(updatedPost);&#10;        } catch (SecurityException e) {&#10;            return ResponseEntity.status(HttpStatus.UNAUTHORIZED)&#10;                    .body(Map.of(&quot;error&quot;, &quot;Authentication required&quot;, &quot;message&quot;, e.getMessage()));&#10;        } catch (RuntimeException e) {&#10;            String message = e.getMessage();&#10;            if (message.contains(&quot;Only the author&quot;)) {&#10;                return ResponseEntity.status(HttpStatus.FORBIDDEN)&#10;                        .body(Map.of(&quot;error&quot;, &quot;Access denied&quot;, &quot;message&quot;, message));&#10;            }&#10;            return ResponseEntity.status(HttpStatus.NOT_FOUND)&#10;                    .body(Map.of(&quot;error&quot;, &quot;Post not found&quot;, &quot;message&quot;, message));&#10;        } catch (Exception e) {&#10;            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)&#10;                    .body(Map.of(&quot;error&quot;, &quot;Failed to update post&quot;, &quot;message&quot;, e.getMessage()));&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Delete post (author only)&#10;     */&#10;    @DeleteMapping(&quot;/{id}&quot;)&#10;    @RequireAuth&#10;    public ResponseEntity&lt;?&gt; deletePost(@PathVariable String id) {&#10;        try {&#10;            String authorId = SecurityContextHolder.getCurrentUserIdOrThrow();&#10;            postService.deletePost(id, authorId);&#10;            return ResponseEntity.noContent().build();&#10;        } catch (SecurityException e) {&#10;            return ResponseEntity.status(HttpStatus.UNAUTHORIZED)&#10;                    .body(Map.of(&quot;error&quot;, &quot;Authentication required&quot;, &quot;message&quot;, e.getMessage()));&#10;        } catch (RuntimeException e) {&#10;            String message = e.getMessage();&#10;            if (message.contains(&quot;Only the author&quot;)) {&#10;                return ResponseEntity.status(HttpStatus.FORBIDDEN)&#10;                        .body(Map.of(&quot;error&quot;, &quot;Access denied&quot;, &quot;message&quot;, message));&#10;            }&#10;            return ResponseEntity.status(HttpStatus.NOT_FOUND)&#10;                    .body(Map.of(&quot;error&quot;, &quot;Post not found&quot;, &quot;message&quot;, message));&#10;        } catch (Exception e) {&#10;            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)&#10;                    .body(Map.of(&quot;error&quot;, &quot;Failed to delete post&quot;, &quot;message&quot;, e.getMessage()));&#10;        }&#10;    }&#10;&#10;    // ========== INTERACTION ENDPOINTS ==========&#10;&#10;    /**&#10;     * Enhanced post interaction (like, comment, share)&#10;     */&#10;    @PostMapping(&quot;/{postId}/interact&quot;)&#10;    @RequireAuth&#10;    public ResponseEntity&lt;?&gt; interactWithPost(&#10;            @PathVariable String postId,&#10;            @RequestParam String action, // LIKE, UNLIKE, SHARE&#10;            @RequestParam(required = false) String reactionType) {&#10;        &#10;        try {&#10;            String userId = SecurityContextHolder.getCurrentUserIdOrThrow();&#10;            &#10;            // Try enhanced interaction first&#10;            try {&#10;                postService.handlePostInteraction(postId, userId, action, reactionType);&#10;                &#10;                // Create notification for post author if services are available&#10;                if (!&quot;UNLIKE&quot;.equals(action) &amp;&amp; notificationService != null) {&#10;                    try {&#10;                        String authorId = postService.getPostAuthorId(postId);&#10;                        notificationService.createNotification(&#10;                            authorId,&#10;                            userId,&#10;                            &quot;POST_&quot; + action,&#10;                            &quot;POST&quot;,&#10;                            postId,&#10;                            &quot;User &quot; + action.toLowerCase() + &quot;d your post&quot;&#10;                        );&#10;                    } catch (Exception e) {&#10;                        // Log error but don't fail the request&#10;                        System.err.println(&quot;Failed to create notification: &quot; + e.getMessage());&#10;                    }&#10;                }&#10;                &#10;                return ResponseEntity.ok().build();&#10;            } catch (Exception e) {&#10;                // Fallback to legacy interaction handling&#10;                InteractionRequest request = new InteractionRequest();&#10;                // Set appropriate interaction type based on action&#10;                request.setType(mapActionToInteractionType(action));&#10;                &#10;                InteractionResponse interaction = interactionService.createInteraction(postId, request, userId);&#10;                if (interaction == null) {&#10;                    return ResponseEntity.noContent().build();&#10;                }&#10;                return ResponseEntity.status(HttpStatus.CREATED).body(interaction);&#10;            }&#10;        } catch (Exception e) {&#10;            return ResponseEntity.status(HttpStatus.BAD_REQUEST)&#10;                    .body(Map.of(&quot;error&quot;, &quot;Failed to process interaction&quot;, &quot;message&quot;, e.getMessage()));&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Add comment to post - Legacy endpoint&#10;     */&#10;    @PostMapping(&quot;/{id}/comments&quot;)&#10;    @RequireAuth&#10;    public ResponseEntity&lt;?&gt; addComment(&#10;            @PathVariable String id,&#10;            @Valid @RequestBody CommentRequest request) {&#10;        &#10;        try {&#10;            String currentUserId = SecurityContextHolder.getCurrentUserIdOrThrow();&#10;            CommentResponse comment = commentService.createComment(id, request, currentUserId);&#10;            &#10;            // Create notification if service is available&#10;            if (notificationService != null) {&#10;                try {&#10;                    String authorId = postService.getPostAuthorId(id);&#10;                    notificationService.createNotification(&#10;                        authorId,&#10;                        currentUserId,&#10;                        &quot;POST_COMMENTED&quot;,&#10;                        &quot;POST&quot;,&#10;                        id,&#10;                        &quot;User commented on your post&quot;&#10;                    );&#10;                } catch (Exception e) {&#10;                    // Log error but don't fail the request&#10;                    System.err.println(&quot;Failed to create notification: &quot; + e.getMessage());&#10;                }&#10;            }&#10;            &#10;            return ResponseEntity.status(HttpStatus.CREATED).body(comment);&#10;        } catch (RuntimeException e) {&#10;            return ResponseEntity.badRequest()&#10;                    .body(Map.of(&quot;error&quot;, &quot;Failed to add comment&quot;, &quot;message&quot;, e.getMessage()));&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Add comment with string content - Enhanced endpoint&#10;     */&#10;    @PostMapping(&quot;/{postId}/comments/simple&quot;)&#10;    @RequireAuth&#10;    public ResponseEntity&lt;?&gt; addSimpleComment(&#10;            @PathVariable String postId,&#10;            @RequestBody String content) {&#10;        &#10;        try {&#10;            String userId = SecurityContextHolder.getCurrentUserIdOrThrow();&#10;            &#10;            // Try enhanced comment service first&#10;            try {&#10;                postService.addComment(postId, userId, content);&#10;                &#10;                // Create notification&#10;                if (notificationService != null) {&#10;                    try {&#10;                        String authorId = postService.getPostAuthorId(postId);&#10;                        notificationService.createNotification(&#10;                            authorId,&#10;                            userId,&#10;                            &quot;POST_COMMENTED&quot;,&#10;                            &quot;POST&quot;,&#10;                            postId,&#10;                            &quot;User commented on your post&quot;&#10;                        );&#10;                    } catch (Exception e) {&#10;                        System.err.println(&quot;Failed to create notification: &quot; + e.getMessage());&#10;                    }&#10;                }&#10;                &#10;                return ResponseEntity.ok().build();&#10;            } catch (Exception e) {&#10;                // Fallback to legacy comment service&#10;                CommentRequest request = new CommentRequest();&#10;                request.setContent(content);&#10;                CommentResponse comment = commentService.createComment(postId, request, userId);&#10;                return ResponseEntity.status(HttpStatus.CREATED).body(comment);&#10;            }&#10;        } catch (Exception e) {&#10;            return ResponseEntity.status(HttpStatus.BAD_REQUEST)&#10;                    .body(Map.of(&quot;error&quot;, &quot;Failed to add comment&quot;, &quot;message&quot;, e.getMessage()));&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get comments for post&#10;     */&#10;    @GetMapping(&quot;/{id}/comments&quot;)&#10;    public ResponseEntity&lt;Page&lt;CommentResponse&gt;&gt; getComments(&#10;            @PathVariable String id,&#10;            @RequestParam(defaultValue = &quot;0&quot;) int page,&#10;            @RequestParam(defaultValue = &quot;10&quot;) int size) {&#10;&#10;        Pageable pageable = PageRequest.of(page, size, Sort.by(&quot;createdAt&quot;).ascending());&#10;        Page&lt;CommentResponse&gt; comments = commentService.getCommentsByPost(id, pageable);&#10;        return ResponseEntity.ok(comments);&#10;    }&#10;&#10;    /**&#10;     * Record interaction (LIKE/SHARE/BOOKMARK) - Legacy endpoint&#10;     */&#10;    @PostMapping(&quot;/{id}/interactions&quot;)&#10;    @RequireAuth&#10;    public ResponseEntity&lt;InteractionResponse&gt; recordInteraction(&#10;            @PathVariable String id,&#10;            @Valid @RequestBody InteractionRequest request) {&#10;        String userId = SecurityContextHolder.getCurrentUserIdOrThrow();&#10;        try {&#10;            InteractionResponse interaction = interactionService.createInteraction(id, request, userId);&#10;            if (interaction == null) {&#10;                // Interaction was removed (e.g., unlike)&#10;                return ResponseEntity.noContent().build();&#10;            }&#10;            return ResponseEntity.status(HttpStatus.CREATED).body(interaction);&#10;        } catch (RuntimeException e) {&#10;            return ResponseEntity.badRequest().build();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Check if user has liked post&#10;     */&#10;    @GetMapping(&quot;/{id}/likes/check&quot;)&#10;    @RequireAuth&#10;    public ResponseEntity&lt;Boolean&gt; hasUserLikedPost(@PathVariable String id) {&#10;        String userId = SecurityContextHolder.getCurrentUserIdOrThrow();&#10;        boolean hasLiked = interactionService.hasUserReacted(id, userId);&#10;        return ResponseEntity.ok(hasLiked);&#10;    }&#10;&#10;    // ========== ANALYTICS &amp; ADVANCED FEATURES ==========&#10;&#10;    /**&#10;     * Get post analytics (for post author)&#10;     */&#10;    @GetMapping(&quot;/{postId}/analytics&quot;)&#10;    @RequireAuth&#10;    public ResponseEntity&lt;?&gt; getPostAnalytics(@PathVariable String postId) {&#10;        try {&#10;            String userId = SecurityContextHolder.getCurrentUserIdOrThrow();&#10;            PostAnalyticsResponse analytics = postService.getPostAnalytics(postId, userId);&#10;            return ResponseEntity.ok(analytics);&#10;        } catch (Exception e) {&#10;            return ResponseEntity.status(HttpStatus.BAD_REQUEST)&#10;                    .body(Map.of(&quot;error&quot;, &quot;Failed to get analytics&quot;, &quot;message&quot;, e.getMessage()));&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Schedule post for later publishing&#10;     */&#10;    @PostMapping(&quot;/schedule&quot;)&#10;    @RequireAuth&#10;    public ResponseEntity&lt;?&gt; schedulePost(@Valid @RequestBody ScheduledPostRequest request) {&#10;        try {&#10;            String userId = SecurityContextHolder.getCurrentUserIdOrThrow();&#10;            AuthenticatedUser user = new AuthenticatedUser(userId, null, null);&#10;            PostResponse scheduledPost = postService.schedulePost(request, user);&#10;            return ResponseEntity.ok(scheduledPost);&#10;        } catch (Exception e) {&#10;            return ResponseEntity.status(HttpStatus.BAD_REQUEST)&#10;                    .body(Map.of(&quot;error&quot;, &quot;Failed to schedule post&quot;, &quot;message&quot;, e.getMessage()));&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Search posts with advanced filters&#10;     */&#10;    @GetMapping(&quot;/search&quot;)&#10;    public ResponseEntity&lt;?&gt; searchPosts(&#10;            @RequestParam String query,&#10;            @RequestParam(required = false) String category,&#10;            @RequestParam(required = false) String faculty,&#10;            @RequestParam(required = false) String dateRange,&#10;            @RequestParam(defaultValue = &quot;0&quot;) int page,&#10;            @RequestParam(defaultValue = &quot;10&quot;) int size) {&#10;&#10;        try {&#10;            // Try enhanced search first&#10;            try {&#10;                List&lt;PostResponse&gt; results = postService.searchPosts(&#10;                    query, category, faculty, dateRange, PageRequest.of(page, size));&#10;                return ResponseEntity.ok(results);&#10;            } catch (Exception e) {&#10;                // Fallback to simple search&#10;                Pageable pageable = PageRequest.of(page, size, Sort.by(&quot;createdAt&quot;).descending());&#10;                Page&lt;PostResponse&gt; results = postService.searchPosts(query, pageable);&#10;                return ResponseEntity.ok(results.getContent());&#10;            }&#10;        } catch (Exception e) {&#10;            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)&#10;                    .body(Map.of(&quot;error&quot;, &quot;Failed to search posts&quot;, &quot;message&quot;, e.getMessage()));&#10;        }&#10;    }&#10;&#10;    // ========== ADDITIONAL ENDPOINTS ==========&#10;&#10;    /**&#10;     * Get top viewed posts&#10;     */&#10;    @GetMapping(&quot;/top-viewed&quot;)&#10;    public ResponseEntity&lt;?&gt; getTopViewedPosts() {&#10;        try {&#10;            List&lt;PostResponse&gt; posts = postService.getTopViewedPosts();&#10;            return ResponseEntity.ok(posts);&#10;        } catch (Exception e) {&#10;            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)&#10;                    .body(Map.of(&quot;error&quot;, &quot;Failed to retrieve top viewed posts&quot;, &quot;message&quot;, e.getMessage()));&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get top liked posts&#10;     */&#10;    @GetMapping(&quot;/top-liked&quot;)&#10;    public ResponseEntity&lt;?&gt; getTopLikedPosts() {&#10;        try {&#10;            List&lt;PostResponse&gt; posts = postService.getTopLikedPosts();&#10;            return ResponseEntity.ok(posts);&#10;        } catch (Exception e) {&#10;            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)&#10;                    .body(Map.of(&quot;error&quot;, &quot;Failed to retrieve top liked posts&quot;, &quot;message&quot;, e.getMessage()));&#10;        }&#10;    }&#10;&#10;    // ========== HELPER METHODS ==========&#10;&#10;    private String mapActionToInteractionType(String action) {&#10;        switch (action.toUpperCase()) {&#10;            case &quot;LIKE&quot;:&#10;                return &quot;LIKE&quot;;&#10;            case &quot;SHARE&quot;:&#10;                return &quot;SHARE&quot;;&#10;            case &quot;BOOKMARK&quot;:&#10;                return &quot;BOOKMARK&quot;;&#10;            default:&#10;                return &quot;LIKE&quot;;&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/dto/AuthorInfo.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/dto/AuthorInfo.java" />
              <option name="originalContent" value="package com.ctuconnect.dto;&#10;&#10;&#10;import lombok.AllArgsConstructor;&#10;import lombok.Builder;&#10;import lombok.Data;&#10;import lombok.NoArgsConstructor;&#10;&#10;@Data&#10;@AllArgsConstructor&#10;@NoArgsConstructor&#10;@Builder&#10;public class AuthorInfo {&#10;    private String id;&#10;    private String name;&#10;    private String avatar;&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package com.ctuconnect.dto;&#13;&#10;&#13;&#10;&#13;&#10;import lombok.AllArgsConstructor;&#13;&#10;import lombok.Builder;&#13;&#10;import lombok.Data;&#13;&#10;import lombok.NoArgsConstructor;&#13;&#10;&#13;&#10;@Data&#13;&#10;@AllArgsConstructor&#13;&#10;@NoArgsConstructor&#13;&#10;@Builder&#13;&#10;public class AuthorInfo {&#13;&#10;    private String id;&#13;&#10;    private String name;&#13;&#10;    private String avatar;&#13;&#10;    private String fullName; // Added for consistency&#13;&#10;    private String avatarUrl; // Added for consistency&#13;&#10;    &#13;&#10;    // Backward compatibility methods&#13;&#10;    public String getFullName() {&#13;&#10;        return fullName != null ? fullName : name;&#13;&#10;    }&#13;&#10;    &#13;&#10;    public String getAvatarUrl() {&#13;&#10;        return avatarUrl != null ? avatarUrl : avatar;&#13;&#10;    }&#13;&#10;    &#13;&#10;    public void setFullName(String fullName) {&#13;&#10;        this.fullName = fullName;&#13;&#10;        this.name = fullName; // Keep both fields in sync&#13;&#10;    }&#13;&#10;    &#13;&#10;    public void setAvatarUrl(String avatarUrl) {&#13;&#10;        this.avatarUrl = avatarUrl;&#13;&#10;        this.avatar = avatarUrl; // Keep both fields in sync&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/dto/NotificationDTO.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/dto/NotificationDTO.java" />
              <option name="updatedContent" value="package com.ctuconnect.dto;&#10;&#10;import lombok.AllArgsConstructor;&#10;import lombok.Builder;&#10;import lombok.Data;&#10;import lombok.NoArgsConstructor;&#10;&#10;import java.time.LocalDateTime;&#10;&#10;@Data&#10;@AllArgsConstructor&#10;@NoArgsConstructor&#10;@Builder&#10;public class NotificationDTO {&#10;    private String id;&#10;    private String recipientId;&#10;    private String actorId;&#10;    private String type;&#10;    private String entityType;&#10;    private String entityId;&#10;    private String message;&#10;    private boolean isRead;&#10;    private LocalDateTime createdAt;&#10;    private LocalDateTime readAt;&#10;    private String imageUrl;&#10;    private String actionUrl;&#10;    &#10;    // Actor information for display&#10;    private String actorName;&#10;    private String actorAvatarUrl;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/dto/request/PostRequest.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/dto/request/PostRequest.java" />
              <option name="originalContent" value="package com.ctuconnect.dto.request;&#10;&#10;import jakarta.validation.constraints.NotBlank;&#10;import jakarta.validation.constraints.Size;&#10;import lombok.AllArgsConstructor;&#10;import lombok.Builder;&#10;import lombok.Data;&#10;import lombok.NoArgsConstructor;&#10;import java.util.ArrayList;&#10;&#10;@Data&#10;@AllArgsConstructor&#10;@NoArgsConstructor&#10;@Builder&#10;public class PostRequest {&#10;    @Size(max = 200, message = &quot;Title cannot exceed 200 characters&quot;)&#10;    private String title;&#10;&#10;    @NotBlank(message = &quot;Content is required&quot;)&#10;    @Size(max = 5000, message = &quot;Content cannot exceed 5000 characters&quot;)&#10;    private String content;&#10;&#10;    @Builder.Default&#10;    private List&lt;String&gt; tags = new ArrayList&lt;&gt;();&#10;&#10;    private String category;&#10;&#10;    private String visibility = &quot;PUBLIC&quot;; // PUBLIC, FRIENDS, PRIVATE&#10;}&#10;" />
              <option name="updatedContent" value="package com.ctuconnect.dto.request;&#10;&#10;import jakarta.validation.constraints.NotBlank;&#10;import jakarta.validation.constraints.Size;&#10;import lombok.AllArgsConstructor;&#10;import lombok.Builder;&#10;import lombok.Data;&#10;import lombok.NoArgsConstructor;&#10;import com.ctuconnect.entity.PostEntity;&#10;&#10;import java.time.LocalDateTime;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;&#10;@Data&#10;@AllArgsConstructor&#10;@NoArgsConstructor&#10;@Builder&#10;public class PostRequest {&#10;    @Size(max = 200, message = &quot;Title cannot exceed 200 characters&quot;)&#10;    private String title;&#10;&#10;    @NotBlank(message = &quot;Content is required&quot;)&#10;    @Size(max = 5000, message = &quot;Content cannot exceed 5000 characters&quot;)&#10;    private String content;&#10;&#10;    @Builder.Default&#10;    private List&lt;String&gt; tags = new ArrayList&lt;&gt;();&#10;&#10;    private String category;&#10;&#10;    private String visibility = &quot;PUBLIC&quot;; // PUBLIC, FRIENDS, PRIVATE&#10;    &#10;    // Enhanced fields for Facebook-like functionality&#10;    @Builder.Default&#10;    private List&lt;String&gt; images = new ArrayList&lt;&gt;();&#10;    &#10;    @Builder.Default&#10;    private List&lt;String&gt; videos = new ArrayList&lt;&gt;();&#10;    &#10;    private String postType; // TEXT, IMAGE, VIDEO, LINK, POLL, EVENT, SHARED&#10;    &#10;    private PostEntity.AudienceSettings audienceSettings;&#10;    &#10;    private LocalDateTime scheduledAt;&#10;    &#10;    private PostEntity.LocationInfo location;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/dto/request/ScheduledPostRequest.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/dto/request/ScheduledPostRequest.java" />
              <option name="updatedContent" value="package com.ctuconnect.dto.request;&#10;&#10;import lombok.AllArgsConstructor;&#10;import lombok.Builder;&#10;import lombok.Data;&#10;import lombok.NoArgsConstructor;&#10;&#10;import java.time.LocalDateTime;&#10;import java.util.List;&#10;&#10;@Data&#10;@AllArgsConstructor&#10;@NoArgsConstructor&#10;@Builder&#10;public class ScheduledPostRequest {&#10;    private String title;&#10;    private String content;&#10;    private List&lt;String&gt; images;&#10;    private List&lt;String&gt; videos;&#10;    private List&lt;String&gt; tags;&#10;    private String category;&#10;    private String visibility;&#10;    private LocalDateTime scheduledAt;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/dto/response/PostAnalyticsResponse.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/dto/response/PostAnalyticsResponse.java" />
              <option name="updatedContent" value="package com.ctuconnect.dto.response;&#10;&#10;import lombok.AllArgsConstructor;&#10;import lombok.Builder;&#10;import lombok.Data;&#10;import lombok.NoArgsConstructor;&#10;import com.ctuconnect.entity.InteractionEntity;&#10;&#10;import java.util.Map;&#10;&#10;@Data&#10;@AllArgsConstructor&#10;@NoArgsConstructor&#10;@Builder&#10;public class PostAnalyticsResponse {&#10;    private String postId;&#10;    private long views;&#10;    private long likes;&#10;    private long comments;&#10;    private long shares;&#10;    private double engagementRate;&#10;    private Map&lt;InteractionEntity.InteractionType.ReactionType, Integer&gt; reactions;&#10;    &#10;    // Additional analytics data&#10;    private long totalEngagements;&#10;    private double clickThroughRate;&#10;    private Map&lt;String, Integer&gt; demographicBreakdown;&#10;    private Map&lt;String, Integer&gt; timeBasedEngagement;&#10;    &#10;    public long getTotalEngagements() {&#10;        return likes + comments + shares;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/dto/response/PostResponse.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/dto/response/PostResponse.java" />
              <option name="originalContent" value="package com.ctuconnect.dto.response;&#10;&#10;import lombok.AllArgsConstructor;&#10;import lombok.Builder;&#10;import lombok.Data;&#10;import com.ctuconnect.entity.PostEntity;&#10;import com.ctuconnect.entity.InteractionEntity;&#10;import com.ctuconnect.entity.PostEntity;&#10;&#10;import java.util.Map;&#10;import java.time.LocalDateTime;&#10;import java.util.List;&#10;import java.util.Map;&#10;&#10;@Data&#10;@Builder&#10;    // Getters and Setters&#10;public class PostResponse {&#10;    // Getters and Setters&#10;    private String id;&#10;    private String title;&#10;    private String authorId;&#10;    private String authorName;&#10;    private String authorAvatar;&#10;    private List&lt;String&gt; tags;&#10;    private String category;&#10;    private String visibility;&#10;    private PostStatsResponse stats;&#10;    private PostStatsResponse stats;&#10;&#10;    public PostResponse(PostEntity post) {&#10;        this.id = post.getId();&#10;        this.title = post.getTitle();&#10;    // Constructors&#10;    public PostResponse() {}&#10;&#10;&#10;        // Handle AuthorInfo properly&#10;        if (post.getAuthor() != null) {&#10;            this.authorId = post.getAuthor().getId();&#10;            this.authorName = post.getAuthor().getName();&#10;            this.authorAvatar = post.getAuthor().getAvatar();&#10;        }&#10;&#10;&#10;        this.category = post.getCategory();&#10;            this.authorName = post.getAuthor().getName();&#10;            this.authorAvatar = post.getAuthor().getAvatar();&#10;        this.createdAt = post.getCreatedAt();&#10;        this.updatedAt = post.getUpdatedAt();&#10;    }&#10;    @Data&#10;    public static class PostStatsResponse {&#10;        // Getters and Setters&#10;        private long views;&#10;        this.stats = new PostStatsResponse(post.getStats());&#10;&#10;        public PostStatsResponse() {}&#10;&#10;        public PostStatsResponse(PostEntity.PostStats stats) {&#10;    @Data&#10;    @Builder&#10;    public static class PostStatsResponse {&#10;        // Getters and Setters&#10;        private long views;&#10;        private long likes;&#10;        private long shares;&#10;        private long comments;&#10;        private long bookmarks;&#10;        private Map&lt;InteractionEntity.InteractionType.ReactionType, Integer&gt; reactions;&#10;&#10;        public PostStatsResponse() {}&#10;&#10;        public PostStatsResponse(PostEntity.PostStats stats) {&#10;            this.views = stats.getViews();&#10;            this.shares = stats.getShares();&#10;            this.comments = stats.getComments();&#10;            this.reactions = stats.getReactions();&#10;&#10;            // Calculate total likes from reactions&#10;            this.likes = reactions.values().stream().mapToInt(Integer::intValue).sum();&#10;&#10;            // Set bookmarks if available&#10;            this.bookmarks = reactions.getOrDefault(&#10;                InteractionEntity.InteractionType.ReactionType.BOOKMARK, 0&#10;            );&#10;        }&#10;&#10;    }&#10;            this.views = stats.getViews();&#10;            this.shares = stats.getShares();&#10;            this.comments = stats.getComments();&#10;            this.reactions = stats.getReactions();&#10;&#10;            // Calculate total likes from reactions&#10;            this.likes = reactions.values().stream().mapToInt(Integer::intValue).sum();&#10;&#10;            // Set bookmarks if available&#10;            this.bookmarks = reactions.getOrDefault(&#10;                InteractionEntity.InteractionType.ReactionType.BOOKMARK, 0&#10;            );&#10;        }&#10;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.ctuconnect.dto.response;&#13;&#10;&#13;&#10;import lombok.AllArgsConstructor;&#13;&#10;import lombok.Builder;&#13;&#10;import lombok.Data;&#13;&#10;import lombok.NoArgsConstructor;&#13;&#10;import com.ctuconnect.entity.PostEntity;&#13;&#10;import com.ctuconnect.dto.AuthorInfo;&#13;&#10;&#13;&#10;import java.time.LocalDateTime;&#13;&#10;import java.util.List;&#13;&#10;&#13;&#10;@Data&#13;&#10;@Builder&#13;&#10;@AllArgsConstructor&#13;&#10;@NoArgsConstructor&#13;&#10;public class PostResponse {&#13;&#10;    private String id;&#13;&#10;    private String title;&#13;&#10;    private String content;&#13;&#10;    private AuthorInfo author;&#13;&#10;    private String authorId;&#13;&#10;    private String authorName;&#13;&#10;    private String authorAvatar;&#13;&#10;    private List&lt;String&gt; images;&#13;&#10;    private List&lt;String&gt; videos; // Added for enhanced functionality&#13;&#10;    private List&lt;String&gt; tags;&#13;&#10;    private String category;&#13;&#10;    private String visibility;&#13;&#10;    private String privacy; // For consistency with PostEntity&#13;&#10;    private String postType; // Added for enhanced functionality&#13;&#10;    private PostEntity.LocationInfo location; // Added for enhanced functionality&#13;&#10;    private PostEntity.PostStats stats;&#13;&#10;    private PostEntity.EngagementMetrics engagement; // Added for enhanced functionality&#13;&#10;    private LocalDateTime createdAt;&#13;&#10;    private LocalDateTime updatedAt;&#13;&#10;&#13;&#10;    // Constructor for backward compatibility&#13;&#10;    public PostResponse(PostEntity post) {&#13;&#10;        this.id = post.getId();&#13;&#10;        this.title = post.getTitle();&#13;&#10;        this.content = post.getContent();&#13;&#10;        this.author = post.getAuthor();&#13;&#10;        &#13;&#10;        // Handle AuthorInfo properly&#13;&#10;        if (post.getAuthor() != null) {&#13;&#10;            this.authorId = post.getAuthor().getId();&#13;&#10;            this.authorName = post.getAuthor().getFullName();&#13;&#10;            this.authorAvatar = post.getAuthor().getAvatarUrl();&#13;&#10;        }&#13;&#10;&#13;&#10;        this.images = post.getImages();&#13;&#10;        this.videos = post.getVideos();&#13;&#10;        this.tags = post.getTags();&#13;&#10;        this.category = post.getCategory();&#13;&#10;        this.visibility = post.getVisibility();&#13;&#10;        this.privacy = post.getPrivacy();&#13;&#10;        this.postType = post.getPostType() != null ? post.getPostType().name() : null;&#13;&#10;        this.location = post.getLocation();&#13;&#10;        this.stats = post.getStats();&#13;&#10;        this.engagement = post.getEngagement();&#13;&#10;        this.createdAt = post.getCreatedAt();&#13;&#10;        this.updatedAt = post.getUpdatedAt();&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/entity/InteractionEntity.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/entity/InteractionEntity.java" />
              <option name="originalContent" value="package com.ctuconnect.entity;&#10;&#10;import lombok.*;&#10;import org.springframework.data.annotation.Id;&#10;import org.springframework.data.mongodb.core.mapping.Document;&#10;import org.springframework.data.mongodb.core.mapping.Field;&#10;import com.ctuconnect.dto.AuthorInfo;&#10;&#10;import java.time.LocalDateTime;&#10;import java.util.HashMap;&#10;import java.util.Map;&#10;&#10;@Data&#10;@NoArgsConstructor&#10;@AllArgsConstructor&#10;@Builder&#10;@Document(collection = &quot;interactions&quot;)&#10;public class InteractionEntity {&#10;&#10;    @Id&#10;    private String id;&#10;&#10;    @Field(&quot;post_id&quot;)&#10;    private String postId;&#10;&#10;    @Field(&quot;author&quot;)&#10;    private AuthorInfo author;&#10;&#10;    private InteractionType type;&#10;&#10;    // Getter for reaction type (backwards compatibility)&#10;    // Add reactionType field for REACTION interactions&#10;    private ReactionType reactionType;&#10;&#10;    private Map&lt;String, Object&gt; metadata = new HashMap&lt;&gt;();&#10;&#10;    @Field(&quot;created_at&quot;)&#10;    private LocalDateTime createdAt;&#10;&#10;    // Constructors&#10;    public InteractionEntity(String postId, AuthorInfo author, InteractionType type) {&#10;        this.postId = postId;&#10;        this.author = author;&#10;        this.type = type;&#10;        this.createdAt = LocalDateTime.now();&#10;        this.metadata = new HashMap&lt;&gt;();&#10;    }&#10;&#10;    // Pre-persist hook&#10;    public void prePersist() {&#10;        if (this.createdAt == null) {&#10;            this.createdAt = LocalDateTime.now();&#10;        }&#10;        if (this.metadata == null) {&#10;            this.metadata = new HashMap&lt;&gt;();&#10;        }&#10;    }&#10;&#10;    // Enum for interaction types&#10;    public enum InteractionType {&#10;        LIKE,&#10;        SHARE,&#10;        BOOKMARK,&#10;        VIEW,&#10;        COMMENT,&#10;        REACTION // Add REACTION type&#10;    }&#10;&#10;    // Enum for reaction types (for REACTION interactions)&#10;    public enum ReactionType {&#10;        LIKE,&#10;        LOVE,&#10;        HAHA,&#10;        WOW,&#10;        SAD,&#10;        ANGRY&#10;    }&#10;&#10;    // Helper methods&#10;    public boolean isReaction() {&#10;        return this.type == InteractionType.REACTION;&#10;    }&#10;&#10;    public boolean isLike() {&#10;        return this.type == InteractionType.LIKE ||&#10;               (this.type == InteractionType.REACTION &amp;&amp; this.reactionType == ReactionType.LIKE);&#10;    }&#10;&#10;    public boolean isView() {&#10;        return this.type == InteractionType.VIEW;&#10;    }&#10;&#10;    public boolean isShare() {&#10;        return this.type == InteractionType.SHARE;&#10;    }&#10;&#10;    public boolean isBookmark() {&#10;        return this.type == InteractionType.BOOKMARK;&#10;    }&#10;&#10;    public boolean isComment() {&#10;        return this.type == InteractionType.COMMENT;&#10;    }&#10;&#10;    // Equals and hashCode&#10;    @Override&#10;    public boolean equals(Object o) {&#10;        if (this == o) return true;&#10;        if (o == null || getClass() != o.getClass()) return false;&#10;        InteractionEntity that = (InteractionEntity) o;&#10;        return Objects.equals(id, that.id) &amp;&amp;&#10;               Objects.equals(postId, that.postId) &amp;&amp;&#10;               Objects.equals(author, that.author) &amp;&amp;&#10;               type == that.type &amp;&amp;&#10;               reactionType == that.reactionType;&#10;    }&#10;&#10;    @Override&#10;    public int hashCode() {&#10;        return Objects.hash(id, postId, author, type, reactionType);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.ctuconnect.entity;&#10;&#10;import lombok.*;&#10;import org.springframework.data.annotation.Id;&#10;import org.springframework.data.mongodb.core.mapping.Document;&#10;import org.springframework.data.mongodb.core.mapping.Field;&#10;import com.ctuconnect.dto.AuthorInfo;&#10;&#10;import java.time.LocalDateTime;&#10;import java.util.HashMap;&#10;import java.util.Map;&#10;import java.util.Objects;&#10;&#10;@Data&#10;@NoArgsConstructor&#10;@AllArgsConstructor&#10;@Builder&#10;@Document(collection = &quot;interactions&quot;)&#10;public class InteractionEntity {&#10;&#10;    @Id&#10;    private String id;&#10;&#10;    @Field(&quot;post_id&quot;)&#10;    private String postId;&#10;&#10;    @Field(&quot;author&quot;)&#10;    private AuthorInfo author;&#10;&#10;    private InteractionType type;&#10;&#10;    // Getter for reaction type (backwards compatibility)&#10;    // Add reactionType field for REACTION interactions&#10;    private ReactionType reactionType;&#10;&#10;    private Map&lt;String, Object&gt; metadata = new HashMap&lt;&gt;();&#10;&#10;    @Field(&quot;created_at&quot;)&#10;    private LocalDateTime createdAt;&#10;&#10;    // Constructors&#10;    public InteractionEntity(String postId, AuthorInfo author, InteractionType type) {&#10;        this.postId = postId;&#10;        this.author = author;&#10;        this.type = type;&#10;        this.createdAt = LocalDateTime.now();&#10;        this.metadata = new HashMap&lt;&gt;();&#10;    }&#10;&#10;    // Pre-persist hook&#10;    public void prePersist() {&#10;        if (this.createdAt == null) {&#10;            this.createdAt = LocalDateTime.now();&#10;        }&#10;        if (this.metadata == null) {&#10;            this.metadata = new HashMap&lt;&gt;();&#10;        }&#10;    }&#10;&#10;    // Enum for interaction types&#10;    public enum InteractionType {&#10;        LIKE,&#10;        SHARE,&#10;        BOOKMARK,&#10;        VIEW,&#10;        COMMENT,&#10;        REACTION // Add REACTION type&#10;    }&#10;&#10;    // Enum for reaction types (for REACTION interactions)&#10;    public enum ReactionType {&#10;        LIKE,&#10;        LOVE,&#10;        HAHA,&#10;        WOW,&#10;        SAD,&#10;        ANGRY&#10;    }&#10;&#10;    // Helper methods&#10;    public boolean isReaction() {&#10;        return this.type == InteractionType.REACTION;&#10;    }&#10;&#10;    public boolean isLike() {&#10;        return this.type == InteractionType.LIKE ||&#10;               (this.type == InteractionType.REACTION &amp;&amp; this.reactionType == ReactionType.LIKE);&#10;    }&#10;&#10;    public boolean isView() {&#10;        return this.type == InteractionType.VIEW;&#10;    }&#10;&#10;    public boolean isShare() {&#10;        return this.type == InteractionType.SHARE;&#10;    }&#10;&#10;    public boolean isBookmark() {&#10;        return this.type == InteractionType.BOOKMARK;&#10;    }&#10;&#10;    public boolean isComment() {&#10;        return this.type == InteractionType.COMMENT;&#10;    }&#10;&#10;    // Equals and hashCode&#10;    @Override&#10;    public boolean equals(Object o) {&#10;        if (this == o) return true;&#10;        if (o == null || getClass() != o.getClass()) return false;&#10;        InteractionEntity that = (InteractionEntity) o;&#10;        return Objects.equals(id, that.id) &amp;&amp;&#10;               Objects.equals(postId, that.postId) &amp;&amp;&#10;               Objects.equals(author, that.author) &amp;&amp;&#10;               type == that.type &amp;&amp;&#10;               reactionType == that.reactionType;&#10;    }&#10;&#10;    @Override&#10;    public int hashCode() {&#10;        return Objects.hash(id, postId, author, type, reactionType);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/entity/NotificationEntity.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/entity/NotificationEntity.java" />
              <option name="updatedContent" value="package com.ctuconnect.entity;&#10;&#10;import lombok.AllArgsConstructor;&#10;import lombok.Builder;&#10;import lombok.Data;&#10;import lombok.NoArgsConstructor;&#10;import org.springframework.data.annotation.CreatedDate;&#10;import org.springframework.data.annotation.Id;&#10;import org.springframework.data.mongodb.core.mapping.Document;&#10;import org.springframework.data.mongodb.core.mapping.Field;&#10;&#10;import java.time.LocalDateTime;&#10;&#10;@Data&#10;@AllArgsConstructor&#10;@NoArgsConstructor&#10;@Builder&#10;@Document(collection = &quot;notifications&quot;)&#10;public class NotificationEntity {&#10;    &#10;    @Id&#10;    private String id;&#10;    &#10;    private String recipientId;&#10;    private String actorId;&#10;    &#10;    private NotificationType type;&#10;    private String entityType; // POST, COMMENT, USER, etc.&#10;    private String entityId;&#10;    &#10;    private String message;&#10;    private boolean isRead;&#10;    &#10;    @Field(&quot;created_at&quot;)&#10;    @CreatedDate&#10;    private LocalDateTime createdAt;&#10;    &#10;    private LocalDateTime readAt;&#10;    &#10;    // Additional metadata for rich notifications&#10;    private String imageUrl;&#10;    private String actionUrl;&#10;    &#10;    public enum NotificationType {&#10;        POST_LIKED,&#10;        POST_COMMENTED,&#10;        POST_SHARED,&#10;        COMMENT_REPLIED,&#10;        FRIEND_REQUEST,&#10;        FRIEND_ACCEPTED,&#10;        MENTION,&#10;        TAG,&#10;        BIRTHDAY,&#10;        EVENT_REMINDER,&#10;        GROUP_INVITATION,&#10;        SYSTEM_NOTIFICATION&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/repository/CommentRepository.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/repository/CommentRepository.java" />
              <option name="originalContent" value="package com.ctuconnect.repository;&#10;&#10;import org.springframework.data.domain.Page;&#10;import org.springframework.data.domain.Pageable;&#10;import org.springframework.data.mongodb.repository.MongoRepository;&#10;import org.springframework.data.mongodb.repository.Query;&#10;import org.springframework.stereotype.Repository;&#10;import com.ctuconnect.entity.CommentEntity;&#10;&#10;import java.util.List;&#10;&#10;@Repository&#10;public interface CommentRepository extends MongoRepository&lt;CommentEntity, String&gt; {&#10;&#10;    Page&lt;CommentEntity&gt; findByPostId(String postId, Pageable pageable);&#10;&#10;    List&lt;CommentEntity&gt; findByPostIdAndParentCommentIdIsNull(String postId);&#10;&#10;    List&lt;CommentEntity&gt; findByParentCommentId(String parentCommentId);&#10;&#10;    long countByPostId(String postId);&#10;&#10;    // Fix: Use MongoDB query for nested author object&#10;    @Query(value = &quot;{ 'author.id': ?0 }&quot;, count = true)&#10;    long countByAuthor_Id(String authorId);&#10;&#10;    void deleteByPostId(String postId);&#10;&#10;    // Additional useful queries for nested author structure&#10;    @Query(&quot;{ 'author.id': ?0 }&quot;)&#10;    Page&lt;CommentEntity&gt; findByAuthor_Id(String authorId, Pageable pageable);&#10;&#10;    @Query(&quot;{ 'author.id': ?0 }&quot;)&#10;    List&lt;CommentEntity&gt; findByAuthor_Id(String authorId);&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package com.ctuconnect.repository;&#13;&#10;&#13;&#10;import org.springframework.data.domain.Page;&#13;&#10;import org.springframework.data.domain.Pageable;&#13;&#10;import org.springframework.data.mongodb.repository.MongoRepository;&#13;&#10;import org.springframework.data.mongodb.repository.Query;&#13;&#10;import org.springframework.stereotype.Repository;&#13;&#10;import com.ctuconnect.entity.CommentEntity;&#13;&#10;&#13;&#10;import java.util.List;&#13;&#10;&#13;&#10;@Repository&#13;&#10;public interface CommentRepository extends MongoRepository&lt;CommentEntity, String&gt; {&#13;&#10;&#13;&#10;    Page&lt;CommentEntity&gt; findByPostId(String postId, Pageable pageable);&#13;&#10;&#13;&#10;    List&lt;CommentEntity&gt; findByPostIdAndParentCommentIdIsNull(String postId);&#13;&#10;&#13;&#10;    List&lt;CommentEntity&gt; findByParentCommentId(String parentCommentId);&#13;&#10;&#13;&#10;    long countByPostId(String postId);&#13;&#10;&#13;&#10;    // Fix: Use MongoDB query for nested author object&#13;&#10;    @Query(value = &quot;{ 'author.id': ?0 }&quot;, count = true)&#13;&#10;    long countByAuthor_Id(String authorId);&#13;&#10;&#13;&#10;    void deleteByPostId(String postId);&#13;&#10;&#13;&#10;    // Additional useful queries for nested author structure&#13;&#10;    @Query(&quot;{ 'author.id': ?0 }&quot;)&#13;&#10;    Page&lt;CommentEntity&gt; findByAuthor_Id(String authorId, Pageable pageable);&#13;&#10;&#13;&#10;    // Add method that AdminController is calling (without underscore)&#13;&#10;    @Query(value = &quot;{ 'author.id': ?0 }&quot;, count = true)&#13;&#10;    long countByAuthorId(String authorId);&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/repository/InteractionRepository.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/repository/InteractionRepository.java" />
              <option name="originalContent" value="package com.ctuconnect.repository;&#10;&#10;import org.springframework.data.domain.Page;&#10;import org.springframework.data.domain.Pageable;&#10;import org.springframework.data.mongodb.repository.MongoRepository;&#10;import org.springframework.data.mongodb.repository.Query;&#10;import org.springframework.stereotype.Repository;&#10;import com.ctuconnect.dto.AuthorInfo;&#10;import com.ctuconnect.entity.InteractionEntity;&#10;&#10;import java.util.List;&#10;import java.util.Optional;&#10;&#10;@Repository&#10;public interface InteractionRepository extends MongoRepository&lt;InteractionEntity, String&gt; {&#10;&#10;    // Find by postId and author.id and type&#10;    @Query(&quot;{ 'postId': ?0, 'author.id': ?1, 'type': ?2 }&quot;)&#10;    Optional&lt;InteractionEntity&gt; findByPostIdAndAuthor_IdAndType(String postId, String authorId, InteractionEntity.InteractionType type);&#10;&#10;    // Find by postId and author object and type&#10;    Optional&lt;InteractionEntity&gt; findByPostIdAndAuthorAndType(String postId, AuthorInfo author, InteractionEntity.InteractionType type);&#10;&#10;    List&lt;InteractionEntity&gt; findByPostId(String postId);&#10;&#10;    @Query(&quot;{ 'author.id': ?0 }&quot;)&#10;    List&lt;InteractionEntity&gt; findByAuthor_Id(String authorId);&#10;&#10;    Page&lt;InteractionEntity&gt; findByPostIdAndType(String postId, InteractionEntity.InteractionType type, Pageable pageable);&#10;&#10;    long countByPostIdAndType(String postId, InteractionEntity.InteractionType type);&#10;&#10;    @Query(value = &quot;{ 'author.id': ?0, 'type': ?1 }&quot;, count = true)&#10;    long countByAuthor_IdAndType(String authorId, InteractionEntity.InteractionType type);&#10;&#10;    void deleteByPostId(String postId);&#10;&#10;    // Additional useful queries&#10;    @Query(&quot;{ 'postId': ?0, 'type': 'LIKE' }&quot;)&#10;    List&lt;InteractionEntity&gt; findLikesByPostId(String postId);&#10;&#10;    @Query(&quot;{ 'author.id': ?0, 'type': 'LIKE' }&quot;)&#10;    List&lt;InteractionEntity&gt; findLikesByAuthor_Id(String authorId);&#10;&#10;    @Query(&quot;{ 'postId': ?0, 'author.id': ?1 }&quot;)&#10;    List&lt;InteractionEntity&gt; findByPostIdAndAuthor_Id(String postId, String authorId);&#10;&#10;    Optional&lt;Object&gt; findByPostIdAndUserIdAndType(String postId, String userId, InteractionEntity.InteractionType interactionType);&#10;}&#10;&#10;&#10;&#10;" />
              <option name="updatedContent" value="package com.ctuconnect.repository;&#13;&#10;&#13;&#10;import org.springframework.data.domain.Page;&#13;&#10;import org.springframework.data.domain.Pageable;&#13;&#10;import org.springframework.data.mongodb.repository.MongoRepository;&#13;&#10;import org.springframework.data.mongodb.repository.Query;&#13;&#10;import org.springframework.stereotype.Repository;&#13;&#10;import com.ctuconnect.dto.AuthorInfo;&#13;&#10;import com.ctuconnect.entity.InteractionEntity;&#13;&#10;&#13;&#10;import java.util.List;&#13;&#10;import java.util.Optional;&#13;&#10;&#13;&#10;@Repository&#13;&#10;public interface InteractionRepository extends MongoRepository&lt;InteractionEntity, String&gt; {&#13;&#10;&#13;&#10;    // Find by postId and author.id and type&#13;&#10;    @Query(&quot;{ 'postId': ?0, 'author.id': ?1, 'type': ?2 }&quot;)&#13;&#10;    Optional&lt;InteractionEntity&gt; findByPostIdAndAuthor_IdAndType(String postId, String authorId, InteractionEntity.InteractionType type);&#13;&#10;&#13;&#10;    // Find by postId and author object and type&#13;&#10;    Optional&lt;InteractionEntity&gt; findByPostIdAndAuthorAndType(String postId, AuthorInfo author, InteractionEntity.InteractionType type);&#13;&#10;&#13;&#10;    List&lt;InteractionEntity&gt; findByPostId(String postId);&#13;&#10;&#13;&#10;    @Query(&quot;{ 'author.id': ?0 }&quot;)&#13;&#10;    List&lt;InteractionEntity&gt; findByAuthor_Id(String authorId);&#13;&#10;&#13;&#10;    Page&lt;InteractionEntity&gt; findByPostIdAndType(String postId, InteractionEntity.InteractionType type, Pageable pageable);&#13;&#10;&#13;&#10;    long countByPostIdAndType(String postId, InteractionEntity.InteractionType type);&#13;&#10;&#13;&#10;    @Query(value = &quot;{ 'author.id': ?0, 'type': ?1 }&quot;, count = true)&#13;&#10;    long countByAuthor_IdAndType(String authorId, InteractionEntity.InteractionType type);&#13;&#10;&#13;&#10;    void deleteByPostId(String postId);&#13;&#10;&#13;&#10;    // Additional useful queries&#13;&#10;    @Query(&quot;{ 'postId': ?0, 'type': 'LIKE' }&quot;)&#13;&#10;    List&lt;InteractionEntity&gt; findLikesByPostId(String postId);&#13;&#10;&#13;&#10;    @Query(&quot;{ 'author.id': ?0, 'type': 'LIKE' }&quot;)&#13;&#10;    List&lt;InteractionEntity&gt; findLikesByAuthor_Id(String authorId);&#13;&#10;&#13;&#10;    @Query(&quot;{ 'postId': ?0, 'author.id': ?1 }&quot;)&#13;&#10;    List&lt;InteractionEntity&gt; findByPostIdAndAuthor_Id(String postId, String authorId);&#13;&#10;&#13;&#10;    Optional&lt;Object&gt; findByPostIdAndUserIdAndType(String postId, String userId, InteractionEntity.InteractionType interactionType);&#13;&#10;&#13;&#10;    // Add method that AdminController is calling (using userId instead of authorId)&#13;&#10;    @Query(value = &quot;{ 'author.id': ?0, 'type': ?1 }&quot;, count = true)&#13;&#10;    long countByUserIdAndType(String userId, InteractionEntity.InteractionType type);&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/repository/NotificationRepository.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/repository/NotificationRepository.java" />
              <option name="updatedContent" value="package com.ctuconnect.repository;&#10;&#10;import com.ctuconnect.entity.NotificationEntity;&#10;import org.springframework.data.domain.Pageable;&#10;import org.springframework.data.mongodb.repository.MongoRepository;&#10;import org.springframework.data.mongodb.repository.Query;&#10;import org.springframework.stereotype.Repository;&#10;&#10;import java.time.LocalDateTime;&#10;import java.util.List;&#10;&#10;@Repository  &#10;public interface NotificationRepository extends MongoRepository&lt;NotificationEntity, String&gt; {&#10;    &#10;    List&lt;NotificationEntity&gt; findByRecipientIdOrderByCreatedAtDesc(String recipientId, Pageable pageable);&#10;    &#10;    List&lt;NotificationEntity&gt; findByRecipientIdAndIsReadFalse(String recipientId);&#10;    &#10;    long countByRecipientIdAndIsReadFalse(String recipientId);&#10;    &#10;    void deleteByCreatedAtBefore(LocalDateTime cutoffDate);&#10;    &#10;    @Query(&quot;{'recipientId': ?0, 'type': ?1}&quot;)&#10;    List&lt;NotificationEntity&gt; findByRecipientIdAndType(String recipientId, NotificationEntity.NotificationType type);&#10;    &#10;    @Query(&quot;{'recipientId': ?0, 'actorId': ?1, 'entityId': ?2}&quot;)&#10;    List&lt;NotificationEntity&gt; findDuplicateNotifications(String recipientId, String actorId, String entityId);&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/repository/PostRepository.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/repository/PostRepository.java" />
              <option name="originalContent" value="package com.ctuconnect.repository;&#10;&#10;import org.springframework.data.domain.Page;&#10;import org.springframework.data.domain.Pageable;&#10;import org.springframework.data.mongodb.repository.MongoRepository;&#10;import org.springframework.data.mongodb.repository.Query;&#10;import org.springframework.stereotype.Repository;&#10;import com.ctuconnect.entity.PostEntity;&#10;&#10;import java.util.List;&#10;&#10;@Repository&#10;public interface PostRepository extends MongoRepository&lt;PostEntity, String&gt; {&#10;&#10;    // Find by author ID (using nested author object)&#10;    @Query(&quot;{ 'author.id': ?0 }&quot;)&#10;    Page&lt;PostEntity&gt; findByAuthor_Id(String authorId, Pageable pageable);&#10;&#10;    // Find all posts by author ID (for data consistency updates)&#10;    @Query(&quot;{ 'author.id': ?0 }&quot;)&#10;    List&lt;PostEntity&gt; findByAuthor_Id(String authorId);&#10;&#10;    Page&lt;PostEntity&gt; findByCategory(String category, Pageable pageable);&#10;&#10;    Page&lt;PostEntity&gt; findByTagsIn(List&lt;String&gt; tags, Pageable pageable);&#10;&#10;    @Query(&quot;{ 'title': { $regex: ?0, $options: 'i' } }&quot;)&#10;    Page&lt;PostEntity&gt; findByTitleContainingIgnoreCase(String title, Pageable pageable);&#10;&#10;    @Query(&quot;{ '$or': [ { 'title': { $regex: ?0, $options: 'i' } }, { 'content': { $regex: ?1, $options: 'i' } } ] }&quot;)&#10;    Page&lt;PostEntity&gt; findByTitleContainingOrContentContaining(String titleTerm, String contentTerm, Pageable pageable);&#10;&#10;    // Enhanced search with category and content filters&#10;    @Query(&quot;{ 'category': ?0, '$or': [ { 'title': { $regex: ?1, $options: 'i' } }, { 'content': { $regex: ?2, $options: 'i' } } ] }&quot;)&#10;    Page&lt;PostEntity&gt; findByCategoryAndTitleContainingOrContentContaining(String category, String titleTerm, String contentTerm, Pageable pageable);&#10;&#10;    // Find by visibility&#10;    Page&lt;PostEntity&gt; findByVisibility(String visibility, Pageable pageable);&#10;&#10;    // Find by author and visibility&#10;    @Query(&quot;{ 'author.id': ?0, 'visibility': ?1 }&quot;)&#10;    Page&lt;PostEntity&gt; findByAuthor_IdAndVisibility(String authorId, String visibility, Pageable pageable);&#10;&#10;    List&lt;PostEntity&gt; findTop10ByOrderByStatsViewsDesc();&#10;&#10;    List&lt;PostEntity&gt; findTop10ByOrderByStatsLikesDesc();&#10;&#10;    @Query(&quot;{ 'author.id': ?0 }&quot;)&#10;    long countByAuthor_Id(String authorId);&#10;&#10;    // Find posts by author ID ordered by creation date (for timeline)&#10;    @Query(&quot;{ 'author.id': ?0 }&quot;)&#10;    List&lt;PostEntity&gt; findByAuthorIdOrderByCreatedAtDesc(String authorId, Pageable pageable);&#10;}&#10;" />
              <option name="updatedContent" value="package com.ctuconnect.repository;&#13;&#10;&#13;&#10;import org.springframework.data.domain.Page;&#13;&#10;import org.springframework.data.domain.Pageable;&#13;&#10;import org.springframework.data.mongodb.repository.MongoRepository;&#13;&#10;import org.springframework.data.mongodb.repository.Query;&#13;&#10;import org.springframework.stereotype.Repository;&#13;&#10;import com.ctuconnect.entity.PostEntity;&#13;&#10;&#13;&#10;import java.util.List;&#13;&#10;&#13;&#10;@Repository&#13;&#10;public interface PostRepository extends MongoRepository&lt;PostEntity, String&gt; {&#13;&#10;&#13;&#10;    // Find by author ID (using nested author object)&#13;&#10;    @Query(&quot;{ 'author.id': ?0 }&quot;)&#13;&#10;    Page&lt;PostEntity&gt; findByAuthor_Id(String authorId, Pageable pageable);&#13;&#10;&#13;&#10;    // Find all posts by author ID (for data consistency updates)&#13;&#10;    @Query(&quot;{ 'author.id': ?0 }&quot;)&#13;&#10;    List&lt;PostEntity&gt; findByAuthor_Id(String authorId);&#13;&#10;&#13;&#10;    Page&lt;PostEntity&gt; findByCategory(String category, Pageable pageable);&#13;&#10;&#13;&#10;    Page&lt;PostEntity&gt; findByTagsIn(List&lt;String&gt; tags, Pageable pageable);&#13;&#10;&#13;&#10;    @Query(&quot;{ 'title': { $regex: ?0, $options: 'i' } }&quot;)&#13;&#10;    Page&lt;PostEntity&gt; findByTitleContainingIgnoreCase(String title, Pageable pageable);&#13;&#10;&#13;&#10;    @Query(&quot;{ '$or': [ { 'title': { $regex: ?0, $options: 'i' } }, { 'content': { $regex: ?1, $options: 'i' } } ] }&quot;)&#13;&#10;    Page&lt;PostEntity&gt; findByTitleContainingOrContentContaining(String titleTerm, String contentTerm, Pageable pageable);&#13;&#10;&#13;&#10;    // Enhanced search with category and content filters&#13;&#10;    @Query(&quot;{ 'category': ?0, '$or': [ { 'title': { $regex: ?1, $options: 'i' } }, { 'content': { $regex: ?2, $options: 'i' } } ] }&quot;)&#13;&#10;    Page&lt;PostEntity&gt; findByCategoryAndTitleContainingOrContentContaining(String category, String titleTerm, String contentTerm, Pageable pageable);&#13;&#10;&#13;&#10;    // Find by visibility&#13;&#10;    Page&lt;PostEntity&gt; findByVisibility(String visibility, Pageable pageable);&#13;&#10;&#13;&#10;    // Find by author and visibility&#13;&#10;    @Query(&quot;{ 'author.id': ?0, 'visibility': ?1 }&quot;)&#13;&#10;    Page&lt;PostEntity&gt; findByAuthor_IdAndVisibility(String authorId, String visibility, Pageable pageable);&#13;&#10;&#13;&#10;    List&lt;PostEntity&gt; findTop10ByOrderByStatsViewsDesc();&#13;&#10;&#13;&#10;    List&lt;PostEntity&gt; findTop10ByOrderByStatsLikesDesc();&#13;&#10;&#13;&#10;    @Query(&quot;{ 'author.id': ?0 }&quot;)&#13;&#10;    long countByAuthor_Id(String authorId);&#13;&#10;&#13;&#10;    // Add method that AdminController is calling (without underscore)&#13;&#10;    @Query(&quot;{ 'author.id': ?0 }&quot;)&#13;&#10;    long countByAuthorId(String authorId);&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/service/NewsFeedService.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/service/NewsFeedService.java" />
              <option name="originalContent" value="package com.ctuconnect.service;&#10;&#10;import com.ctuconnect.entity.PostEntity;&#10;import com.ctuconnect.dto.response.PostResponse;&#10;import com.ctuconnect.repository.PostRepository;&#10;import lombok.Builder;&#10;import lombok.Data;&#10;import lombok.RequiredArgsConstructor;&#10;import lombok.extern.slf4j.Slf4j;&#10;import org.springframework.data.domain.PageRequest;&#10;import org.springframework.data.domain.Pageable;&#10;import org.springframework.data.mongodb.core.MongoTemplate;&#10;import org.springframework.data.mongodb.core.query.Criteria;&#10;import org.springframework.data.mongodb.core.query.Query;&#10;import org.springframework.data.redis.core.RedisTemplate;&#10;import org.springframework.stereotype.Service;&#10;&#10;import java.time.LocalDateTime;&#10;import java.util.*;&#10;import java.util.stream.Collectors;&#10;@Service&#10;@RequiredArgsConstructor&#10;@Slf4j&#10;public class NewsFeedService {&#10;&#10;    private final PostRepository postRepository;&#10;    private final MongoTemplate mongoTemplate;&#10;    private final UserServiceClient userServiceClient;&#10;    private final RedisTemplate&lt;String, Object&gt; redisTemplate;&#10;&#10;    private static final String FEED_CACHE_PREFIX = &quot;user_feed:&quot;;&#10;    private static final int FEED_CACHE_TTL = 1800; // 30 minutes&#10;    private static final int MAX_FEED_SIZE = 50;&#10;    private static final double FRIEND_POST_WEIGHT = 1.0;&#10;    private static final double ENGAGEMENT_WEIGHT = 0.8;&#10;    private static final double RECENCY_WEIGHT = 0.6;&#10;    private static final double RELEVANCE_WEIGHT = 0.7;&#10;&#10;    /**&#10;     * Generate personalized news feed using Facebook-like algorithm&#10;     */&#10;    public List&lt;PostResponse&gt; generatePersonalizedFeed(String userId, int page, int size) {&#10;        String cacheKey = FEED_CACHE_PREFIX + userId + &quot;:&quot; + page;&#10;&#10;        // Try to get from cache first&#10;        List&lt;PostResponse&gt; cachedFeed = getCachedFeed(cacheKey);&#10;        if (cachedFeed != null &amp;&amp; !cachedFeed.isEmpty()) {&#10;            return cachedFeed;&#10;        }&#10;&#10;        // Get user's social context&#10;        UserSocialContext socialContext = getUserSocialContext(userId);&#10;&#10;        // Fetch candidate posts&#10;        List&lt;PostEntity&gt; candidatePosts = fetchCandidatePosts(socialContext, page * size * 3); // Over-fetch for ranking&#10;&#10;        // Apply Facebook-like ranking algorithm&#10;        List&lt;PostEntity&gt; rankedPosts = rankPostsForUser(candidatePosts, socialContext);&#10;&#10;        // Convert to response DTOs&#10;        List&lt;PostResponse&gt; feedPosts = rankedPosts.stream()&#10;                .limit(size)&#10;                .map(this::convertToResponse)&#10;                .collect(Collectors.toList());&#10;&#10;        // Cache the result&#10;        cacheFeed(cacheKey, feedPosts);&#10;&#10;        return feedPosts;&#10;    }&#10;&#10;    /**&#10;     * Facebook-style post ranking algorithm&#10;     */&#10;    private List&lt;PostEntity&gt; rankPostsForUser(List&lt;PostEntity&gt; posts, UserSocialContext context) {&#10;        return posts.stream()&#10;                .filter(post -&gt; post.isVisibleToUser(context.getUserId(), context.getFriendIds()))&#10;                .map(post -&gt; {&#10;                    double score = calculatePostScore(post, context);&#10;                    return new ScoredPost(post, score);&#10;                })&#10;                .sorted((a, b) -&gt; Double.compare(b.getScore(), a.getScore()))&#10;                .map(ScoredPost::getPost)&#10;                .collect(Collectors.toList());&#10;    }&#10;&#10;    /**&#10;     * Calculate post relevance score based on multiple factors&#10;     */&#10;    private double calculatePostScore(PostEntity post, UserSocialContext context) {&#10;        double score = 0.0;&#10;&#10;        // 1. Friend relationship score&#10;        double friendScore = calculateFriendScore(post, context);&#10;        score += friendScore * FRIEND_POST_WEIGHT;&#10;&#10;        // 2. Engagement score (likes, comments, shares)&#10;        double engagementScore = post.calculateEngagementScore();&#10;        score += engagementScore * ENGAGEMENT_WEIGHT;&#10;&#10;        // 3. Recency score (newer posts get higher scores)&#10;        double recencyScore = calculateRecencyScore(post.getCreatedAt());&#10;        score += recencyScore * RECENCY_WEIGHT;&#10;&#10;        // 4. Content relevance (academic interests, tags, etc.)&#10;        double relevanceScore = calculateRelevanceScore(post, context);&#10;        score += relevanceScore * RELEVANCE_WEIGHT;&#10;&#10;        // 5. Diversity penalty (avoid showing too many posts from same author)&#10;        double diversityPenalty = calculateDiversityPenalty(post, context);&#10;        score *= (1.0 - diversityPenalty);&#10;&#10;        return score;&#10;    }&#10;&#10;    private double calculateFriendScore(PostEntity post, UserSocialContext context) {&#10;        String authorId = post.getAuthorId();&#10;&#10;        if (context.getCloseInteractionIds().contains(authorId)) {&#10;            return 3.0; // Close friends get highest priority&#10;        } else if (context.getFriendIds().contains(authorId)) {&#10;            return 2.0; // Regular friends&#10;        } else if (context.getSameFacultyIds().contains(authorId)) {&#10;            return 1.5; // Same faculty&#10;        } else if (context.getSameMajorIds().contains(authorId)) {&#10;            return 1.2; // Same major&#10;        } else {&#10;            return 1.0; // Public posts&#10;        }&#10;    }&#10;&#10;    private double calculateRecencyScore(LocalDateTime createdAt) {&#10;        long hoursOld = java.time.Duration.between(createdAt, LocalDateTime.now()).toHours();&#10;        return Math.exp(-hoursOld / 12.0); // Exponential decay over 12 hours&#10;    }&#10;&#10;    private double calculateRelevanceScore(PostEntity post, UserSocialContext context) {&#10;        double relevance = 0.0;&#10;&#10;        // Tag matching&#10;        long matchingTags = post.getTags().stream()&#10;                .mapToLong(tag -&gt; context.getInterestTags().contains(tag) ? 1 : 0)&#10;                .sum();&#10;        relevance += matchingTags * 0.5;&#10;&#10;        // Category matching&#10;        if (context.getPreferredCategories().contains(post.getCategory())) {&#10;            relevance += 1.0;&#10;        }&#10;&#10;        // Academic context matching&#10;        if (post.getAudienceSettings().getAllowedFaculties().contains(context.getFacultyId()) ||&#10;            post.getAudienceSettings().getAllowedMajors().contains(context.getMajorId())) {&#10;            relevance += 0.8;&#10;        }&#10;&#10;        return relevance;&#10;    }&#10;&#10;    private double calculateDiversityPenalty(PostEntity post, UserSocialContext context) {&#10;        String authorId = post.getAuthorId();&#10;        int recentPostsByAuthor = context.getRecentAuthorCounts().getOrDefault(authorId, 0);&#10;&#10;        // Penalize if we've shown many posts from this author recently&#10;        return Math.min(0.5, recentPostsByAuthor * 0.1);&#10;    }&#10;&#10;    private List&lt;PostEntity&gt; fetchCandidatePosts(UserSocialContext context, int limit) {&#10;        Query query = new Query();&#10;&#10;        // Build criteria for candidate posts&#10;        Criteria criteria = new Criteria();&#10;&#10;        // Time window (last 7 days for active feed)&#10;        LocalDateTime weekAgo = LocalDateTime.now().minusDays(7);&#10;        criteria.and(&quot;createdAt&quot;).gte(weekAgo);&#10;&#10;        // Visibility criteria&#10;        List&lt;Criteria&gt; visibilityCriteria = Arrays.asList(&#10;            Criteria.where(&quot;privacy&quot;).is(&quot;PUBLIC&quot;),&#10;            Criteria.where(&quot;privacy&quot;).is(&quot;FRIENDS&quot;).and(&quot;author.id&quot;).in(context.getFriendIds()),&#10;            Criteria.where(&quot;audienceSettings.allowedUsers&quot;).in(context.getUserId())&#10;        );&#10;        criteria.orOperator(visibilityCriteria.toArray(new Criteria[0]));&#10;&#10;        query.addCriteria(criteria);&#10;        query.limit(limit);&#10;&#10;        return mongoTemplate.find(query, PostEntity.class);&#10;    }&#10;&#10;    private UserSocialContext getUserSocialContext(String userId) {&#10;        // This would typically call the user service to get social graph data&#10;        // For now, returning mock data structure&#10;        return UserSocialContext.builder()&#10;                .userId(userId)&#10;                .friendIds(userServiceClient.getFriendIds(userId))&#10;                .closeInteractionIds(userServiceClient.getCloseInteractionIds(userId))&#10;                .sameFacultyIds(userServiceClient.getSameFacultyUserIds(userId))&#10;                .sameMajorIds(userServiceClient.getSameMajorUserIds(userId))&#10;                .interestTags(userServiceClient.getUserInterestTags(userId))&#10;                .preferredCategories(userServiceClient.getUserPreferredCategories(userId))&#10;                .facultyId(userServiceClient.getUserFacultyId(userId))&#10;                .majorId(userServiceClient.getUserMajorId(userId))&#10;                .recentAuthorCounts(new HashMap&lt;&gt;())&#10;                .build();&#10;    }&#10;&#10;    /**&#10;     * Timeline generation for user profile pages&#10;     */&#10;    public List&lt;PostResponse&gt; generateUserTimeline(String userId, String viewerId, int page, int size) {&#10;        Pageable pageable = PageRequest.of(page, size);&#10;&#10;        List&lt;PostEntity&gt; userPosts = postRepository.findByAuthorIdOrderByCreatedAtDesc(userId, pageable);&#10;&#10;        // Filter based on privacy settings and viewer permissions&#10;        Set&lt;String&gt; viewerFriends = new HashSet&lt;&gt;(userServiceClient.getFriendIds(viewerId));&#10;&#10;        return userPosts.stream()&#10;                .filter(post -&gt; post.isVisibleToUser(viewerId, viewerFriends))&#10;                .map(this::convertToResponse)&#10;                .collect(Collectors.toList());&#10;    }&#10;&#10;    /**&#10;     * Trending posts algorithm&#10;     */&#10;    public List&lt;PostResponse&gt; getTrendingPosts(int page, int size) {&#10;        LocalDateTime last24Hours = LocalDateTime.now().minusDays(1);&#10;&#10;        Query query = new Query();&#10;        query.addCriteria(Criteria.where(&quot;createdAt&quot;).gte(last24Hours));&#10;        query.addCriteria(Criteria.where(&quot;privacy&quot;).is(&quot;PUBLIC&quot;));&#10;&#10;        List&lt;PostEntity&gt; recentPosts = mongoTemplate.find(query, PostEntity.class);&#10;&#10;        // Sort by engagement metrics&#10;        return recentPosts.stream()&#10;                .sorted((a, b) -&gt; Double.compare(b.calculateEngagementScore(), a.calculateEngagementScore()))&#10;                .skip(page * size)&#10;                .limit(size)&#10;                .map(this::convertToResponse)&#10;                .collect(Collectors.toList());&#10;    }&#10;&#10;    /**&#10;     * Invalidate user's feed cache when relevant events occur&#10;     */&#10;    public void invalidateUserFeedCache(String userId) {&#10;        String pattern = FEED_CACHE_PREFIX + userId + &quot;:*&quot;;&#10;        Set&lt;String&gt; keys = redisTemplate.keys(pattern);&#10;        if (!keys.isEmpty()) {&#10;            redisTemplate.delete(keys);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Batch invalidate feed cache for multiple users (e.g., when a popular post is created)&#10;     */&#10;    public void invalidateFeedCacheForUsers(Set&lt;String&gt; userIds) {&#10;        userIds.forEach(this::invalidateUserFeedCache);&#10;    }&#10;&#10;    private List&lt;PostResponse&gt; getCachedFeed(String cacheKey) {&#10;        try {&#10;            return (List&lt;PostResponse&gt;) redisTemplate.opsForValue().get(cacheKey);&#10;        } catch (Exception e) {&#10;            log.warn(&quot;Failed to get cached feed: {}&quot;, e.getMessage());&#10;            return null;&#10;        }&#10;    }&#10;&#10;    private void cacheFeed(String cacheKey, List&lt;PostResponse&gt; feed) {&#10;        try {&#10;            redisTemplate.opsForValue().set(cacheKey, feed, FEED_CACHE_TTL, TimeUnit.SECONDS);&#10;        } catch (Exception e) {&#10;            log.warn(&quot;Failed to cache feed: {}&quot;, e.getMessage());&#10;        }&#10;    }&#10;&#10;    private PostResponse convertToResponse(PostEntity post) {&#10;        // Convert PostEntity to PostResponse DTO&#10;        // Implementation would map all fields appropriately&#10;        return PostResponse.builder()&#10;                .id(post.getId())&#10;                .title(post.getTitle())&#10;                .content(post.getContent())&#10;                .author(post.getAuthor())&#10;                .images(post.getImages())&#10;                .videos(post.getVideos())&#10;                .tags(post.getTags())&#10;                .category(post.getCategory())&#10;                .privacy(post.getPrivacy())&#10;                .postType(post.getPostType().name())&#10;                .location(post.getLocation())&#10;                .stats(post.getStats())&#10;                .engagement(post.getEngagement())&#10;                .createdAt(post.getCreatedAt())&#10;                .updatedAt(post.getUpdatedAt())&#10;                .build();&#10;    }&#10;&#10;    // Helper classes&#10;    @Data&#10;    @Builder&#10;    private static class UserSocialContext {&#10;        private String userId;&#10;        private Set&lt;String&gt; friendIds;&#10;        private Set&lt;String&gt; closeInteractionIds;&#10;        private Set&lt;String&gt; sameFacultyIds;&#10;        private Set&lt;String&gt; sameMajorIds;&#10;        private Set&lt;String&gt; interestTags;&#10;        private Set&lt;String&gt; preferredCategories;&#10;        private String facultyId;&#10;        private String majorId;&#10;        private Map&lt;String, Integer&gt; recentAuthorCounts;&#10;    }&#10;&#10;    @Data&#10;    @AllArgsConstructor&#10;    private static class ScoredPost {&#10;        private PostEntity post;&#10;        private double score;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.ctuconnect.service;&#10;&#10;import com.ctuconnect.entity.PostEntity;&#10;import com.ctuconnect.dto.response.PostResponse;&#10;import com.ctuconnect.repository.PostRepository;&#10;import com.ctuconnect.client.UserServiceClient;&#10;import lombok.AllArgsConstructor;&#10;import lombok.Builder;&#10;import lombok.Data;&#10;import lombok.RequiredArgsConstructor;&#10;import lombok.extern.slf4j.Slf4j;&#10;import org.springframework.data.domain.PageRequest;&#10;import org.springframework.data.domain.Pageable;&#10;import org.springframework.data.mongodb.core.MongoTemplate;&#10;import org.springframework.data.mongodb.core.query.Criteria;&#10;import org.springframework.data.mongodb.core.query.Query;&#10;import org.springframework.data.redis.core.RedisTemplate;&#10;import org.springframework.stereotype.Service;&#10;&#10;import java.time.LocalDateTime;&#10;import java.util.*;&#10;import java.util.concurrent.TimeUnit;&#10;import java.util.stream.Collectors;&#10;&#10;@Service&#10;@RequiredArgsConstructor&#10;@Slf4j&#10;public class NewsFeedService {&#10;&#10;    private final PostRepository postRepository;&#10;    private final MongoTemplate mongoTemplate;&#10;    private final UserServiceClient userServiceClient;&#10;    private final RedisTemplate&lt;String, Object&gt; redisTemplate;&#10;&#10;    private static final String FEED_CACHE_PREFIX = &quot;user_feed:&quot;;&#10;    private static final int FEED_CACHE_TTL = 1800; // 30 minutes&#10;    private static final int MAX_FEED_SIZE = 50;&#10;    private static final double FRIEND_POST_WEIGHT = 1.0;&#10;    private static final double ENGAGEMENT_WEIGHT = 0.8;&#10;    private static final double RECENCY_WEIGHT = 0.6;&#10;    private static final double RELEVANCE_WEIGHT = 0.7;&#10;&#10;    /**&#10;     * Generate personalized news feed using Facebook-like algorithm&#10;     */&#10;    public List&lt;PostResponse&gt; generatePersonalizedFeed(String userId, int page, int size) {&#10;        String cacheKey = FEED_CACHE_PREFIX + userId + &quot;:&quot; + page;&#10;&#10;        // Try to get from cache first&#10;        List&lt;PostResponse&gt; cachedFeed = getCachedFeed(cacheKey);&#10;        if (cachedFeed != null &amp;&amp; !cachedFeed.isEmpty()) {&#10;            return cachedFeed;&#10;        }&#10;&#10;        // Get user's social context&#10;        UserSocialContext socialContext = getUserSocialContext(userId);&#10;&#10;        // Fetch candidate posts&#10;        List&lt;PostEntity&gt; candidatePosts = fetchCandidatePosts(socialContext, page * size * 3); // Over-fetch for ranking&#10;&#10;        // Apply Facebook-like ranking algorithm&#10;        List&lt;PostEntity&gt; rankedPosts = rankPostsForUser(candidatePosts, socialContext);&#10;&#10;        // Convert to response DTOs&#10;        List&lt;PostResponse&gt; feedPosts = rankedPosts.stream()&#10;                .limit(size)&#10;                .map(this::convertToResponse)&#10;                .collect(Collectors.toList());&#10;&#10;        // Cache the result&#10;        cacheFeed(cacheKey, feedPosts);&#10;&#10;        return feedPosts;&#10;    }&#10;&#10;    /**&#10;     * Facebook-style post ranking algorithm&#10;     */&#10;    private List&lt;PostEntity&gt; rankPostsForUser(List&lt;PostEntity&gt; posts, UserSocialContext context) {&#10;        return posts.stream()&#10;                .filter(post -&gt; post.isVisibleToUser(context.getUserId(), context.getFriendIds()))&#10;                .map(post -&gt; {&#10;                    double score = calculatePostScore(post, context);&#10;                    return new ScoredPost(post, score);&#10;                })&#10;                .sorted((a, b) -&gt; Double.compare(b.getScore(), a.getScore()))&#10;                .map(ScoredPost::getPost)&#10;                .collect(Collectors.toList());&#10;    }&#10;&#10;    /**&#10;     * Calculate post relevance score based on multiple factors&#10;     */&#10;    private double calculatePostScore(PostEntity post, UserSocialContext context) {&#10;        double score = 0.0;&#10;&#10;        // 1. Friend relationship score&#10;        double friendScore = calculateFriendScore(post, context);&#10;        score += friendScore * FRIEND_POST_WEIGHT;&#10;&#10;        // 2. Engagement score (likes, comments, shares)&#10;        double engagementScore = post.calculateEngagementScore();&#10;        score += engagementScore * ENGAGEMENT_WEIGHT;&#10;&#10;        // 3. Recency score (newer posts get higher scores)&#10;        double recencyScore = calculateRecencyScore(post.getCreatedAt());&#10;        score += recencyScore * RECENCY_WEIGHT;&#10;&#10;        // 4. Content relevance (academic interests, tags, etc.)&#10;        double relevanceScore = calculateRelevanceScore(post, context);&#10;        score += relevanceScore * RELEVANCE_WEIGHT;&#10;&#10;        // 5. Diversity penalty (avoid showing too many posts from same author)&#10;        double diversityPenalty = calculateDiversityPenalty(post, context);&#10;        score *= (1.0 - diversityPenalty);&#10;&#10;        return score;&#10;    }&#10;&#10;    private double calculateFriendScore(PostEntity post, UserSocialContext context) {&#10;        String authorId = post.getAuthorId();&#10;&#10;        if (context.getCloseInteractionIds().contains(authorId)) {&#10;            return 3.0; // Close friends get highest priority&#10;        } else if (context.getFriendIds().contains(authorId)) {&#10;            return 2.0; // Regular friends&#10;        } else if (context.getSameFacultyIds().contains(authorId)) {&#10;            return 1.5; // Same faculty&#10;        } else if (context.getSameMajorIds().contains(authorId)) {&#10;            return 1.2; // Same major&#10;        } else {&#10;            return 1.0; // Public posts&#10;        }&#10;    }&#10;&#10;    private double calculateRecencyScore(LocalDateTime createdAt) {&#10;        long hoursOld = java.time.Duration.between(createdAt, LocalDateTime.now()).toHours();&#10;        return Math.exp(-hoursOld / 12.0); // Exponential decay over 12 hours&#10;    }&#10;&#10;    private double calculateRelevanceScore(PostEntity post, UserSocialContext context) {&#10;        double relevance = 0.0;&#10;&#10;        // Tag matching&#10;        long matchingTags = post.getTags().stream()&#10;                .mapToLong(tag -&gt; context.getInterestTags().contains(tag) ? 1 : 0)&#10;                .sum();&#10;        relevance += matchingTags * 0.5;&#10;&#10;        // Category matching&#10;        if (context.getPreferredCategories().contains(post.getCategory())) {&#10;            relevance += 1.0;&#10;        }&#10;&#10;        // Academic context matching&#10;        if (post.getAudienceSettings().getAllowedFaculties().contains(context.getFacultyId()) ||&#10;            post.getAudienceSettings().getAllowedMajors().contains(context.getMajorId())) {&#10;            relevance += 0.8;&#10;        }&#10;&#10;        return relevance;&#10;    }&#10;&#10;    private double calculateDiversityPenalty(PostEntity post, UserSocialContext context) {&#10;        String authorId = post.getAuthorId();&#10;        int recentPostsByAuthor = context.getRecentAuthorCounts().getOrDefault(authorId, 0);&#10;&#10;        // Penalize if we've shown many posts from this author recently&#10;        return Math.min(0.5, recentPostsByAuthor * 0.1);&#10;    }&#10;&#10;    private List&lt;PostEntity&gt; fetchCandidatePosts(UserSocialContext context, int limit) {&#10;        Query query = new Query();&#10;&#10;        // Build criteria for candidate posts&#10;        Criteria criteria = new Criteria();&#10;&#10;        // Time window (last 7 days for active feed)&#10;        LocalDateTime weekAgo = LocalDateTime.now().minusDays(7);&#10;        criteria.and(&quot;createdAt&quot;).gte(weekAgo);&#10;&#10;        // Visibility criteria&#10;        List&lt;Criteria&gt; visibilityCriteria = Arrays.asList(&#10;            Criteria.where(&quot;privacy&quot;).is(&quot;PUBLIC&quot;),&#10;            Criteria.where(&quot;privacy&quot;).is(&quot;FRIENDS&quot;).and(&quot;author.id&quot;).in(context.getFriendIds()),&#10;            Criteria.where(&quot;audienceSettings.allowedUsers&quot;).in(context.getUserId())&#10;        );&#10;        criteria.orOperator(visibilityCriteria.toArray(new Criteria[0]));&#10;&#10;        query.addCriteria(criteria);&#10;        query.limit(limit);&#10;&#10;        return mongoTemplate.find(query, PostEntity.class);&#10;    }&#10;&#10;    private UserSocialContext getUserSocialContext(String userId) {&#10;        // This would typically call the user service to get social graph data&#10;        // For now, returning mock data structure&#10;        return UserSocialContext.builder()&#10;                .userId(userId)&#10;                .friendIds(userServiceClient.getFriendIds(userId))&#10;                .closeInteractionIds(userServiceClient.getCloseInteractionIds(userId))&#10;                .sameFacultyIds(userServiceClient.getSameFacultyUserIds(userId))&#10;                .sameMajorIds(userServiceClient.getSameMajorUserIds(userId))&#10;                .interestTags(userServiceClient.getUserInterestTags(userId))&#10;                .preferredCategories(userServiceClient.getUserPreferredCategories(userId))&#10;                .facultyId(userServiceClient.getUserFacultyId(userId))&#10;                .majorId(userServiceClient.getUserMajorId(userId))&#10;                .recentAuthorCounts(new HashMap&lt;&gt;())&#10;                .build();&#10;    }&#10;&#10;    /**&#10;     * Timeline generation for user profile pages&#10;     */&#10;    public List&lt;PostResponse&gt; generateUserTimeline(String userId, String viewerId, int page, int size) {&#10;        Pageable pageable = PageRequest.of(page, size);&#10;&#10;        List&lt;PostEntity&gt; userPosts = postRepository.findByAuthorIdOrderByCreatedAtDesc(userId, pageable);&#10;&#10;        // Filter based on privacy settings and viewer permissions&#10;        Set&lt;String&gt; viewerFriends = new HashSet&lt;&gt;(userServiceClient.getFriendIds(viewerId));&#10;&#10;        return userPosts.stream()&#10;                .filter(post -&gt; post.isVisibleToUser(viewerId, viewerFriends))&#10;                .map(this::convertToResponse)&#10;                .collect(Collectors.toList());&#10;    }&#10;&#10;    /**&#10;     * Trending posts algorithm&#10;     */&#10;    public List&lt;PostResponse&gt; getTrendingPosts(int page, int size) {&#10;        LocalDateTime last24Hours = LocalDateTime.now().minusDays(1);&#10;&#10;        Query query = new Query();&#10;        query.addCriteria(Criteria.where(&quot;createdAt&quot;).gte(last24Hours));&#10;        query.addCriteria(Criteria.where(&quot;privacy&quot;).is(&quot;PUBLIC&quot;));&#10;&#10;        List&lt;PostEntity&gt; recentPosts = mongoTemplate.find(query, PostEntity.class);&#10;&#10;        // Sort by engagement metrics&#10;        return recentPosts.stream()&#10;                .sorted((a, b) -&gt; Double.compare(b.calculateEngagementScore(), a.calculateEngagementScore()))&#10;                .skip(page * size)&#10;                .limit(size)&#10;                .map(this::convertToResponse)&#10;                .collect(Collectors.toList());&#10;    }&#10;&#10;    /**&#10;     * Invalidate user's feed cache when relevant events occur&#10;     */&#10;    public void invalidateUserFeedCache(String userId) {&#10;        String pattern = FEED_CACHE_PREFIX + userId + &quot;:*&quot;;&#10;        Set&lt;String&gt; keys = redisTemplate.keys(pattern);&#10;        if (!keys.isEmpty()) {&#10;            redisTemplate.delete(keys);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Batch invalidate feed cache for multiple users (e.g., when a popular post is created)&#10;     */&#10;    public void invalidateFeedCacheForUsers(Set&lt;String&gt; userIds) {&#10;        userIds.forEach(this::invalidateUserFeedCache);&#10;    }&#10;&#10;    private List&lt;PostResponse&gt; getCachedFeed(String cacheKey) {&#10;        try {&#10;            return (List&lt;PostResponse&gt;) redisTemplate.opsForValue().get(cacheKey);&#10;        } catch (Exception e) {&#10;            log.warn(&quot;Failed to get cached feed: {}&quot;, e.getMessage());&#10;            return null;&#10;        }&#10;    }&#10;&#10;    private void cacheFeed(String cacheKey, List&lt;PostResponse&gt; feed) {&#10;        try {&#10;            redisTemplate.opsForValue().set(cacheKey, feed, FEED_CACHE_TTL, TimeUnit.SECONDS);&#10;        } catch (Exception e) {&#10;            log.warn(&quot;Failed to cache feed: {}&quot;, e.getMessage());&#10;        }&#10;    }&#10;&#10;    private PostResponse convertToResponse(PostEntity post) {&#10;        // Convert PostEntity to PostResponse DTO&#10;        // Implementation would map all fields appropriately&#10;        return PostResponse.builder()&#10;                .id(post.getId())&#10;                .title(post.getTitle())&#10;                .content(post.getContent())&#10;                .author(post.getAuthor())&#10;                .images(post.getImages())&#10;                .videos(post.getVideos())&#10;                .tags(post.getTags())&#10;                .category(post.getCategory())&#10;                .privacy(post.getPrivacy())&#10;                .postType(post.getPostType().name())&#10;                .location(post.getLocation())&#10;                .stats(post.getStats())&#10;                .engagement(post.getEngagement())&#10;                .createdAt(post.getCreatedAt())&#10;                .updatedAt(post.getUpdatedAt())&#10;                .build();&#10;    }&#10;&#10;    // Helper classes&#10;    @Data&#10;    @Builder&#10;    private static class UserSocialContext {&#10;        private String userId;&#10;        private Set&lt;String&gt; friendIds;&#10;        private Set&lt;String&gt; closeInteractionIds;&#10;        private Set&lt;String&gt; sameFacultyIds;&#10;        private Set&lt;String&gt; sameMajorIds;&#10;        private Set&lt;String&gt; interestTags;&#10;        private Set&lt;String&gt; preferredCategories;&#10;        private String facultyId;&#10;        private String majorId;&#10;        private Map&lt;String, Integer&gt; recentAuthorCounts;&#10;    }&#10;&#10;    @Data&#10;    @AllArgsConstructor&#10;    private static class ScoredPost {&#10;        private PostEntity post;&#10;        private double score;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/service/PostService.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/service/PostService.java" />
              <option name="originalContent" value="package com.ctuconnect.service;&#10;&#10;import org.springframework.beans.factory.annotation.Autowired;&#10;import org.springframework.data.domain.Page;&#10;import org.springframework.data.domain.Pageable;&#10;import org.springframework.stereotype.Service;&#10;import org.springframework.web.multipart.MultipartFile;&#10;import com.ctuconnect.client.MediaServiceClient;&#10;import com.ctuconnect.client.UserServiceClient;&#10;import com.ctuconnect.dto.AuthorInfo;&#10;import com.ctuconnect.dto.request.PostRequest;&#10;import com.ctuconnect.dto.response.PostResponse;&#10;import com.ctuconnect.entity.InteractionEntity;&#10;import com.ctuconnect.entity.PostEntity;&#10;import com.ctuconnect.entity.CommentEntity;&#10;import com.ctuconnect.repository.InteractionRepository;&#10;import com.ctuconnect.repository.PostRepository;&#10;import com.ctuconnect.security.AuthenticatedUser;&#10;&#10;import java.util.HashSet;&#10;import java.util.List;&#10;import java.util.Optional;&#10;import java.util.stream.Collectors;&#10;&#10;@Service&#10;    @Autowired&#10;    private PostRepository postRepository;&#10;&#10;    @Autowired&#10;    private CommentRepository commentRepository;&#10;&#10;    @Autowired&#10;    private InteractionRepository interactionRepository;&#10;&#10;    @Autowired&#10;    private MediaServiceClient mediaServiceClient;&#10;&#10;    @Autowired&#10;    private UserServiceClient userServiceClient;&#10;&#10;    @Autowired&#10;    private EventService eventService;&#10;&#10;    public PostResponse createPost(PostRequest request, List&lt;MultipartFile&gt; files, String authorId) {&#10;        AuthorInfo author = userServiceClient.getAuthorInfo(authorId);&#10;        if (author == null) {&#10;            throw new RuntimeException(&quot;Author not found with id: &quot; + authorId);&#10;        }&#10;&#10;        PostEntity post = PostEntity.builder()&#10;                .title(request.getTitle())&#10;                .content(request.getContent())&#10;                .author(author)&#10;                .images(new ArrayList&lt;&gt;())&#10;                .tags(request.getTags() != null ? request.getTags() : new ArrayList&lt;&gt;())&#10;                .category(request.getCategory())&#10;                .privacy(request.getVisibility() != null ? request.getVisibility() : &quot;PUBLIC&quot;)&#10;                .stats(new PostEntity.PostStats())&#10;                .build();&#10;&#10;        // Upload files to media-service&#10;        if (files != null &amp;&amp; !files.isEmpty()) {&#10;            List&lt;String&gt; imageUrls = new ArrayList&lt;&gt;();&#10;            for (MultipartFile file : files) {&#10;                if (!file.isEmpty()) {&#10;                    try {&#10;                        MediaServiceClient.MediaUploadResponse uploadResponse =&#10;                            mediaServiceClient.uploadFile(file, getFileType(file));&#10;                        imageUrls.add(uploadResponse.getFileUrl());&#10;                    } catch (Exception e) {&#10;                        // Log error but continue processing&#10;                        System.err.println(&quot;Failed to upload file: &quot; + e.getMessage());&#10;                    }&#10;                }&#10;            }&#10;            post.setImages(imageUrls);&#10;        }&#10;&#10;        PostEntity savedPost = postRepository.save(post);&#10;&#10;        // Publish event&#10;        eventService.publishPostEvent(&quot;POST_CREATED&quot;, savedPost.getId(), savedPost.getAuthorId(), savedPost);&#10;&#10;        return new PostResponse(savedPost);&#10;    }&#10;&#10;    public Page&lt;PostResponse&gt; getAllPosts(Pageable pageable) {&#10;        return postRepository.findAll(pageable)&#10;                .map(PostResponse::new);&#10;    }&#10;&#10;    public Page&lt;PostResponse&gt; getPostsByAuthor(String authorId, Pageable pageable) {&#10;        return postRepository.findByAuthor_Id(authorId, pageable)&#10;                .map(PostResponse::new);&#10;    }&#10;&#10;    public Page&lt;PostResponse&gt; getPostsByCategory(String category, Pageable pageable) {&#10;        return postRepository.findByCategory(category, pageable)&#10;                .map(PostResponse::new);&#10;    }&#10;&#10;    public Page&lt;PostResponse&gt; searchPosts(String searchTerm, Pageable pageable) {&#10;        return postRepository.findByTitleContainingOrContentContaining(searchTerm, searchTerm, pageable)&#10;                .map(PostResponse::new);&#10;    }&#10;&#10;    public PostResponse getPostById(String id, String currentUserId) {&#10;        Optional&lt;PostEntity&gt; postOpt = postRepository.findById(id);&#10;        if (postOpt.isPresent()) {&#10;            PostEntity post = postOpt.get();&#10;&#10;            // Record view interaction if user is different from author&#10;            if (currentUserId != null &amp;&amp; !currentUserId.equals(post.getAuthorId())) {&#10;                recordViewInteraction(post.getId(), currentUserId);&#10;            }&#10;&#10;            return new PostResponse(post);&#10;        }&#10;        throw new RuntimeException(&quot;Post not found with id: &quot; + id);&#10;    }&#10;&#10;    public PostResponse updatePost(String id, PostRequest request, String authorId) {&#10;        Optional&lt;PostEntity&gt; postOpt = postRepository.findById(id);&#10;        if (postOpt.isPresent()) {&#10;            PostEntity post = postOpt.get();&#10;&#10;            // Check if user is the author&#10;            if (!post.getAuthorId().equals(authorId)) {&#10;                throw new RuntimeException(&quot;Only the author can update this post&quot;);&#10;            }&#10;&#10;            if (request.getTitle() != null) {&#10;                post.setTitle(request.getTitle());&#10;            }&#10;            if (request.getContent() != null) {&#10;                post.setContent(request.getContent());&#10;            }&#10;            if (request.getTags() != null) {&#10;                post.setTags(request.getTags());&#10;            }&#10;            if (request.getCategory() != null) {&#10;                post.setCategory(request.getCategory());&#10;            }&#10;            if (request.getVisibility() != null) {&#10;                post.setVisibility(request.getVisibility());&#10;            }&#10;&#10;            PostEntity savedPost = postRepository.save(post);&#10;&#10;            // Publish event&#10;            eventService.publishPostEvent(&quot;POST_UPDATED&quot;, savedPost.getId(), savedPost.getAuthorId(), savedPost);&#10;&#10;            return new PostResponse(savedPost);&#10;        }&#10;        throw new RuntimeException(&quot;Post not found with id: &quot; + id);&#10;    }&#10;&#10;    public void deletePost(String id, String authorId) {&#10;        Optional&lt;PostEntity&gt; postOpt = postRepository.findById(id);&#10;        if (postOpt.isPresent()) {&#10;            PostEntity post = postOpt.get();&#10;&#10;            // Check if user is the author&#10;            if (!post.getAuthorId().equals(authorId)) {&#10;                throw new RuntimeException(&quot;Only the author can delete this post&quot;);&#10;            }&#10;&#10;            // Delete associated comments and interactions&#10;            commentRepository.deleteByPostId(id);&#10;            interactionRepository.deleteByPostId(id);&#10;&#10;            // Delete the post&#10;            postRepository.deleteById(id);&#10;&#10;            // Publish event&#10;            eventService.publishPostEvent(&quot;POST_DELETED&quot;, id, authorId, post);&#10;        } else {&#10;            throw new RuntimeException(&quot;Post not found with id: &quot; + id);&#10;        }&#10;    }&#10;&#10;    private void recordViewInteraction(String postId, String userId) {&#10;        try {&#10;            AuthorInfo author = userServiceClient.getAuthorInfo(userId);&#10;            if (author == null) return;&#10;&#10;            // Check if user already viewed this post recently (within last hour)&#10;            Optional&lt;InteractionEntity&gt; existingView = interactionRepository&#10;                    .findByPostIdAndAuthor_IdAndType(postId, userId, InteractionEntity.InteractionType.VIEW);&#10;&#10;            if (existingView.isEmpty()) {&#10;                // Create view interaction&#10;                InteractionEntity viewInteraction = new InteractionEntity(postId, author, InteractionEntity.InteractionType.VIEW);&#10;                interactionRepository.save(viewInteraction);&#10;&#10;                // Update post stats&#10;                Optional&lt;PostEntity&gt; postOpt = postRepository.findById(postId);&#10;                if (postOpt.isPresent()) {&#10;                    PostEntity post = postOpt.get();&#10;                    post.getStats().incrementViews();&#10;                    postRepository.save(post);&#10;                }&#10;&#10;                // Publish interaction event&#10;                eventService.publishInteractionEvent(postId, userId, &quot;VIEW&quot;);&#10;            }&#10;        } catch (Exception e) {&#10;            // Log error but don't fail the main operation&#10;            System.err.println(&quot;Failed to record view interaction: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    private String getFileType(MultipartFile file) {&#10;        String contentType = file.getContentType();&#10;        if (contentType != null) {&#10;            if (contentType.startsWith(&quot;image/&quot;)) return &quot;IMAGE&quot;;&#10;            if (contentType.startsWith(&quot;video/&quot;)) return &quot;VIDEO&quot;;&#10;            if (contentType.startsWith(&quot;audio/&quot;)) return &quot;AUDIO&quot;;&#10;            if (contentType.equals(&quot;application/pdf&quot;)) return &quot;PDF&quot;;&#10;        }&#10;        return &quot;DOCUMENT&quot;;&#10;    }&#10;&#10;    public List&lt;PostResponse&gt; getTopViewedPosts() {&#10;        return postRepository.findTop10ByOrderByStatsViewsDesc()&#10;                .stream()&#10;                .map(PostResponse::new)&#10;                .toList();&#10;    }&#10;&#10;    public List&lt;PostResponse&gt; getTopLikedPosts() {&#10;        return postRepository.findTop10ByOrderByStatsLikesDesc()&#10;                .stream()&#10;                .map(PostResponse::new)&#10;                .toList();&#10;    }&#10;&#10;    /**&#10;     * Enhanced post creation with Facebook-like features&#10;     */&#10;    public PostResponse createEnhancedPost(PostRequest request, AuthenticatedUser user) {&#10;" />
              <option name="updatedContent" value="package com.ctuconnect.service;&#13;&#10;&#13;&#10;import org.springframework.beans.factory.annotation.Autowired;&#13;&#10;import org.springframework.data.domain.Page;&#13;&#10;import org.springframework.data.domain.Pageable;&#13;&#10;import org.springframework.stereotype.Service;&#13;&#10;import org.springframework.web.multipart.MultipartFile;&#13;&#10;import com.ctuconnect.client.MediaServiceClient;&#13;&#10;import com.ctuconnect.client.UserServiceClient;&#13;&#10;import com.ctuconnect.dto.AuthorInfo;&#13;&#10;import com.ctuconnect.dto.request.PostRequest;&#13;&#10;import com.ctuconnect.dto.request.ScheduledPostRequest;&#13;&#10;import com.ctuconnect.dto.response.PostResponse;&#13;&#10;import com.ctuconnect.dto.response.PostAnalyticsResponse;&#13;&#10;import com.ctuconnect.entity.InteractionEntity;&#13;&#10;import com.ctuconnect.entity.PostEntity;&#13;&#10;import com.ctuconnect.entity.CommentEntity;&#13;&#10;import com.ctuconnect.repository.CommentRepository;&#13;&#10;import com.ctuconnect.repository.InteractionRepository;&#13;&#10;import com.ctuconnect.repository.PostRepository;&#13;&#10;import com.ctuconnect.security.AuthenticatedUser;&#13;&#10;&#13;&#10;import java.util.ArrayList;&#13;&#10;import java.util.HashSet;&#13;&#10;import java.util.List;&#13;&#10;import java.util.Optional;&#13;&#10;import java.util.Set;&#13;&#10;import java.util.stream.Collectors;&#13;&#10;&#13;&#10;@Service&#13;&#10;public class PostService {&#13;&#10;&#13;&#10;    @Autowired&#13;&#10;    private PostRepository postRepository;&#13;&#10;&#13;&#10;    @Autowired&#13;&#10;    private CommentRepository commentRepository;&#13;&#10;&#13;&#10;    @Autowired&#13;&#10;    private InteractionRepository interactionRepository;&#13;&#10;&#13;&#10;    @Autowired&#13;&#10;    private MediaServiceClient mediaServiceClient;&#13;&#10;&#13;&#10;    @Autowired&#13;&#10;    private UserServiceClient userServiceClient;&#13;&#10;&#13;&#10;    @Autowired&#13;&#10;    private EventService eventService;&#13;&#10;&#13;&#10;    public PostResponse createPost(PostRequest request, List&lt;MultipartFile&gt; files, String authorId) {&#13;&#10;        AuthorInfo author = userServiceClient.getAuthorInfo(authorId);&#13;&#10;        if (author == null) {&#13;&#10;            throw new RuntimeException(&quot;Author not found with id: &quot; + authorId);&#13;&#10;        }&#13;&#10;&#13;&#10;        PostEntity post = PostEntity.builder()&#13;&#10;                .title(request.getTitle())&#13;&#10;                .content(request.getContent())&#13;&#10;                .author(author)&#13;&#10;                .images(new ArrayList&lt;&gt;())&#13;&#10;                .tags(request.getTags() != null ? request.getTags() : new ArrayList&lt;&gt;())&#13;&#10;                .category(request.getCategory())&#13;&#10;                .privacy(request.getVisibility() != null ? request.getVisibility() : &quot;PUBLIC&quot;)&#13;&#10;                .stats(new PostEntity.PostStats())&#13;&#10;                .build();&#13;&#10;&#13;&#10;        // Upload files to media-service&#13;&#10;        if (files != null &amp;&amp; !files.isEmpty()) {&#13;&#10;            List&lt;String&gt; imageUrls = new ArrayList&lt;&gt;();&#13;&#10;            for (MultipartFile file : files) {&#13;&#10;                if (!file.isEmpty()) {&#13;&#10;                    try {&#13;&#10;                        MediaServiceClient.MediaUploadResponse uploadResponse =&#13;&#10;                            mediaServiceClient.uploadFile(file, getFileType(file));&#13;&#10;                        imageUrls.add(uploadResponse.getFileUrl());&#13;&#10;                    } catch (Exception e) {&#13;&#10;                        // Log error but continue processing&#13;&#10;                        System.err.println(&quot;Failed to upload file: &quot; + e.getMessage());&#13;&#10;                    }&#13;&#10;                }&#13;&#10;            }&#13;&#10;            post.setImages(imageUrls);&#13;&#10;        }&#13;&#10;&#13;&#10;        PostEntity savedPost = postRepository.save(post);&#13;&#10;&#13;&#10;        // Publish event&#13;&#10;        eventService.publishPostEvent(&quot;POST_CREATED&quot;, savedPost.getId(), savedPost.getAuthorId(), savedPost);&#13;&#10;&#13;&#10;        return new PostResponse(savedPost);&#13;&#10;    }&#13;&#10;&#13;&#10;    public Page&lt;PostResponse&gt; getAllPosts(Pageable pageable) {&#13;&#10;        return postRepository.findAll(pageable)&#13;&#10;                .map(PostResponse::new);&#13;&#10;    }&#13;&#10;&#13;&#10;    public Page&lt;PostResponse&gt; getPostsByAuthor(String authorId, Pageable pageable) {&#13;&#10;        return postRepository.findByAuthor_Id(authorId, pageable)&#13;&#10;                .map(PostResponse::new);&#13;&#10;    }&#13;&#10;&#13;&#10;    public Page&lt;PostResponse&gt; getPostsByCategory(String category, Pageable pageable) {&#13;&#10;        return postRepository.findByCategory(category, pageable)&#13;&#10;                .map(PostResponse::new);&#13;&#10;    }&#13;&#10;&#13;&#10;    public Page&lt;PostResponse&gt; searchPosts(String searchTerm, Pageable pageable) {&#13;&#10;        return postRepository.findByTitleContainingOrContentContaining(searchTerm, searchTerm, pageable)&#13;&#10;                .map(PostResponse::new);&#13;&#10;    }&#13;&#10;&#13;&#10;    public PostResponse getPostById(String id, String currentUserId) {&#13;&#10;        Optional&lt;PostEntity&gt; postOpt = postRepository.findById(id);&#13;&#10;        if (postOpt.isPresent()) {&#13;&#10;            PostEntity post = postOpt.get();&#13;&#10;&#13;&#10;            // Record view interaction if user is different from author&#13;&#10;            if (currentUserId != null &amp;&amp; !currentUserId.equals(post.getAuthorId())) {&#13;&#10;                recordViewInteraction(post.getId(), currentUserId);&#13;&#10;            }&#13;&#10;&#13;&#10;            return new PostResponse(post);&#13;&#10;        }&#13;&#10;        throw new RuntimeException(&quot;Post not found with id: &quot; + id);&#13;&#10;    }&#13;&#10;&#13;&#10;    public PostResponse updatePost(String id, PostRequest request, String authorId) {&#13;&#10;        Optional&lt;PostEntity&gt; postOpt = postRepository.findById(id);&#13;&#10;        if (postOpt.isPresent()) {&#13;&#10;            PostEntity post = postOpt.get();&#13;&#10;&#13;&#10;            // Check if user is the author&#13;&#10;            if (!post.getAuthorId().equals(authorId)) {&#13;&#10;                throw new RuntimeException(&quot;Only the author can update this post&quot;);&#13;&#10;            }&#13;&#10;&#13;&#10;            if (request.getTitle() != null) {&#13;&#10;                post.setTitle(request.getTitle());&#13;&#10;            }&#13;&#10;            if (request.getContent() != null) {&#13;&#10;                post.setContent(request.getContent());&#13;&#10;            }&#13;&#10;            if (request.getTags() != null) {&#13;&#10;                post.setTags(request.getTags());&#13;&#10;            }&#13;&#10;            if (request.getCategory() != null) {&#13;&#10;                post.setCategory(request.getCategory());&#13;&#10;            }&#13;&#10;            if (request.getVisibility() != null) {&#13;&#10;                post.setVisibility(request.getVisibility());&#13;&#10;            }&#13;&#10;&#13;&#10;            PostEntity savedPost = postRepository.save(post);&#13;&#10;&#13;&#10;            // Publish event&#13;&#10;            eventService.publishPostEvent(&quot;POST_UPDATED&quot;, savedPost.getId(), savedPost.getAuthorId(), savedPost);&#13;&#10;&#13;&#10;            return new PostResponse(savedPost);&#13;&#10;        }&#13;&#10;        throw new RuntimeException(&quot;Post not found with id: &quot; + id);&#13;&#10;    }&#13;&#10;&#13;&#10;    public void deletePost(String id, String authorId) {&#13;&#10;        Optional&lt;PostEntity&gt; postOpt = postRepository.findById(id);&#13;&#10;        if (postOpt.isPresent()) {&#13;&#10;            PostEntity post = postOpt.get();&#13;&#10;&#13;&#10;            // Check if user is the author&#13;&#10;            if (!post.getAuthorId().equals(authorId)) {&#13;&#10;                throw new RuntimeException(&quot;Only the author can delete this post&quot;);&#13;&#10;            }&#13;&#10;&#13;&#10;            // Delete associated comments and interactions&#13;&#10;            commentRepository.deleteByPostId(id);&#13;&#10;            interactionRepository.deleteByPostId(id);&#13;&#10;&#13;&#10;            // Delete the post&#13;&#10;            postRepository.deleteById(id);&#13;&#10;&#13;&#10;            // Publish event&#13;&#10;            eventService.publishPostEvent(&quot;POST_DELETED&quot;, id, authorId, post);&#13;&#10;        } else {&#13;&#10;            throw new RuntimeException(&quot;Post not found with id: &quot; + id);&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    private void recordViewInteraction(String postId, String userId) {&#13;&#10;        try {&#13;&#10;            AuthorInfo author = userServiceClient.getAuthorInfo(userId);&#13;&#10;            if (author == null) return;&#13;&#10;&#13;&#10;            // Check if user already viewed this post recently (within last hour)&#13;&#10;            Optional&lt;InteractionEntity&gt; existingView = interactionRepository&#13;&#10;                    .findByPostIdAndAuthor_IdAndType(postId, userId, InteractionEntity.InteractionType.VIEW);&#13;&#10;&#13;&#10;            if (existingView.isEmpty()) {&#13;&#10;                // Create view interaction&#13;&#10;                InteractionEntity viewInteraction = new InteractionEntity(postId, author, InteractionEntity.InteractionType.VIEW);&#13;&#10;                interactionRepository.save(viewInteraction);&#13;&#10;&#13;&#10;                // Update post stats&#13;&#10;                Optional&lt;PostEntity&gt; postOpt = postRepository.findById(postId);&#13;&#10;                if (postOpt.isPresent()) {&#13;&#10;                    PostEntity post = postOpt.get();&#13;&#10;                    post.getStats().incrementViews();&#13;&#10;                    postRepository.save(post);&#13;&#10;                }&#13;&#10;&#13;&#10;                // Publish interaction event&#13;&#10;                eventService.publishInteractionEvent(postId, userId, &quot;VIEW&quot;);&#13;&#10;            }&#13;&#10;        } catch (Exception e) {&#13;&#10;            // Log error but don't fail the main operation&#13;&#10;            System.err.println(&quot;Failed to record view interaction: &quot; + e.getMessage());&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    private String getFileType(MultipartFile file) {&#13;&#10;        String contentType = file.getContentType();&#13;&#10;        if (contentType != null) {&#13;&#10;            if (contentType.startsWith(&quot;image/&quot;)) return &quot;IMAGE&quot;;&#13;&#10;            if (contentType.startsWith(&quot;video/&quot;)) return &quot;VIDEO&quot;;&#13;&#10;            if (contentType.startsWith(&quot;audio/&quot;)) return &quot;AUDIO&quot;;&#13;&#10;            if (contentType.equals(&quot;application/pdf&quot;)) return &quot;PDF&quot;;&#13;&#10;        }&#13;&#10;        return &quot;DOCUMENT&quot;;&#13;&#10;    }&#13;&#10;&#13;&#10;    public List&lt;PostResponse&gt; getTopViewedPosts() {&#13;&#10;        return postRepository.findTop10ByOrderByStatsViewsDesc()&#13;&#10;                .stream()&#13;&#10;                .map(PostResponse::new)&#13;&#10;                .toList();&#13;&#10;    }&#13;&#10;&#13;&#10;    public List&lt;PostResponse&gt; getTopLikedPosts() {&#13;&#10;        return postRepository.findTop10ByOrderByStatsLikesDesc()&#13;&#10;                .stream()&#13;&#10;                .map(PostResponse::new)&#13;&#10;                .toList();&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Enhanced post creation with Facebook-like features&#13;&#10;     */&#13;&#10;    public PostResponse createEnhancedPost(PostRequest request, AuthenticatedUser user) {&#13;&#10;        AuthorInfo author = userServiceClient.getAuthorInfo(user.getId());&#13;&#10;        if (author == null) {&#13;&#10;            throw new RuntimeException(&quot;Author not found with id: &quot; + user.getId());&#13;&#10;        }&#13;&#10;&#13;&#10;        PostEntity post = PostEntity.builder()&#13;&#10;                .title(request.getTitle())&#13;&#10;                .content(request.getContent())&#13;&#10;                .author(author)&#13;&#10;                .images(request.getImages() != null ? request.getImages() : new ArrayList&lt;&gt;())&#13;&#10;                .videos(request.getVideos() != null ? request.getVideos() : new ArrayList&lt;&gt;())&#13;&#10;                .tags(request.getTags() != null ? request.getTags() : new ArrayList&lt;&gt;())&#13;&#10;                .category(request.getCategory())&#13;&#10;                .privacy(request.getVisibility() != null ? request.getVisibility() : &quot;PUBLIC&quot;)&#13;&#10;                .postType(request.getPostType() != null ? PostEntity.PostType.valueOf(request.getPostType()) : PostEntity.PostType.TEXT)&#13;&#10;                .stats(new PostEntity.PostStats())&#13;&#10;                .audienceSettings(new PostEntity.AudienceSettings())&#13;&#10;                .engagement(new PostEntity.EngagementMetrics())&#13;&#10;                .build();&#13;&#10;&#13;&#10;        // Set audience settings if provided&#13;&#10;        if (request.getAudienceSettings() != null) {&#13;&#10;            post.setAudienceSettings(request.getAudienceSettings());&#13;&#10;        }&#13;&#10;&#13;&#10;        // Handle scheduled posts&#13;&#10;        if (request.getScheduledAt() != null) {&#13;&#10;            post.setScheduledAt(request.getScheduledAt());&#13;&#10;            post.setScheduled(true);&#13;&#10;        }&#13;&#10;&#13;&#10;        PostEntity savedPost = postRepository.save(post);&#13;&#10;&#13;&#10;        // Publish event&#13;&#10;        eventService.publishPostEvent(&quot;POST_CREATED&quot;, savedPost.getId(), savedPost.getAuthorId(), savedPost);&#13;&#10;&#13;&#10;        return new PostResponse(savedPost);&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Get users affected by a post (for cache invalidation)&#13;&#10;     */&#13;&#10;    public Set&lt;String&gt; getAffectedUserIds(String postId) {&#13;&#10;        Optional&lt;PostEntity&gt; postOpt = postRepository.findById(postId);&#13;&#10;        if (postOpt.isPresent()) {&#13;&#10;            PostEntity post = postOpt.get();&#13;&#10;            Set&lt;String&gt; affectedUsers = new HashSet&lt;&gt;();&#13;&#10;&#13;&#10;            // Add author&#13;&#10;            affectedUsers.add(post.getAuthorId());&#13;&#10;&#13;&#10;            // Add friends if post is visible to friends&#13;&#10;            if (&quot;FRIENDS&quot;.equals(post.getPrivacy()) || &quot;PUBLIC&quot;.equals(post.getPrivacy())) {&#13;&#10;                Set&lt;String&gt; authorFriends = userServiceClient.getFriendIds(post.getAuthorId());&#13;&#10;                affectedUsers.addAll(authorFriends);&#13;&#10;            }&#13;&#10;&#13;&#10;            return affectedUsers;&#13;&#10;        }&#13;&#10;        return new HashSet&lt;&gt;();&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Handle post interactions (like, comment, share)&#13;&#10;     */&#13;&#10;    public void handlePostInteraction(String postId, String userId, String action, String reactionType) {&#13;&#10;        Optional&lt;PostEntity&gt; postOpt = postRepository.findById(postId);&#13;&#10;        if (postOpt.isEmpty()) {&#13;&#10;            throw new RuntimeException(&quot;Post not found with id: &quot; + postId);&#13;&#10;        }&#13;&#10;&#13;&#10;        PostEntity post = postOpt.get();&#13;&#10;        AuthorInfo user = userServiceClient.getAuthorInfo(userId);&#13;&#10;        if (user == null) {&#13;&#10;            throw new RuntimeException(&quot;User not found with id: &quot; + userId);&#13;&#10;        }&#13;&#10;&#13;&#10;        switch (action.toUpperCase()) {&#13;&#10;            case &quot;LIKE&quot;:&#13;&#10;                handleLikeInteraction(postId, userId, reactionType, post, user);&#13;&#10;                break;&#13;&#10;            case &quot;UNLIKE&quot;:&#13;&#10;                handleUnlikeInteraction(postId, userId, post);&#13;&#10;                break;&#13;&#10;            case &quot;SHARE&quot;:&#13;&#10;                handleShareInteraction(postId, userId, post, user);&#13;&#10;                break;&#13;&#10;            default:&#13;&#10;                throw new RuntimeException(&quot;Unsupported action: &quot; + action);&#13;&#10;        }&#13;&#10;&#13;&#10;        // Update engagement metrics&#13;&#10;        updateEngagementMetrics(post);&#13;&#10;        postRepository.save(post);&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Get post author ID&#13;&#10;     */&#13;&#10;    public String getPostAuthorId(String postId) {&#13;&#10;        Optional&lt;PostEntity&gt; postOpt = postRepository.findById(postId);&#13;&#10;        if (postOpt.isPresent()) {&#13;&#10;            return postOpt.get().getAuthorId();&#13;&#10;        }&#13;&#10;        throw new RuntimeException(&quot;Post not found with id: &quot; + postId);&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Add comment to post&#13;&#10;     */&#13;&#10;    public void addComment(String postId, String userId, String content) {&#13;&#10;        Optional&lt;PostEntity&gt; postOpt = postRepository.findById(postId);&#13;&#10;        if (postOpt.isEmpty()) {&#13;&#10;            throw new RuntimeException(&quot;Post not found with id: &quot; + postId);&#13;&#10;        }&#13;&#10;&#13;&#10;        AuthorInfo author = userServiceClient.getAuthorInfo(userId);&#13;&#10;        if (author == null) {&#13;&#10;            throw new RuntimeException(&quot;User not found with id: &quot; + userId);&#13;&#10;        }&#13;&#10;&#13;&#10;        CommentEntity comment = CommentEntity.builder()&#13;&#10;                .postId(postId)&#13;&#10;                .author(author)&#13;&#10;                .content(content)&#13;&#10;                .build();&#13;&#10;&#13;&#10;        commentRepository.save(comment);&#13;&#10;&#13;&#10;        // Update post comment count&#13;&#10;        PostEntity post = postOpt.get();&#13;&#10;        post.getStats().incrementComments();&#13;&#10;        updateEngagementMetrics(post);&#13;&#10;        postRepository.save(post);&#13;&#10;&#13;&#10;        // Publish event&#13;&#10;        eventService.publishPostEvent(&quot;COMMENT_ADDED&quot;, postId, userId, comment);&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Get post analytics&#13;&#10;     */&#13;&#10;    public PostAnalyticsResponse getPostAnalytics(String postId, String userId) {&#13;&#10;        Optional&lt;PostEntity&gt; postOpt = postRepository.findById(postId);&#13;&#10;        if (postOpt.isEmpty()) {&#13;&#10;            throw new RuntimeException(&quot;Post not found with id: &quot; + postId);&#13;&#10;        }&#13;&#10;&#13;&#10;        PostEntity post = postOpt.get();&#13;&#10;&#13;&#10;        // Check if user is the post author&#13;&#10;        if (!post.getAuthorId().equals(userId)) {&#13;&#10;            throw new RuntimeException(&quot;Only post author can view analytics&quot;);&#13;&#10;        }&#13;&#10;&#13;&#10;        return PostAnalyticsResponse.builder()&#13;&#10;                .postId(postId)&#13;&#10;                .views(post.getStats().getViews())&#13;&#10;                .likes(post.getStats().getLikes())&#13;&#10;                .comments(post.getStats().getComments())&#13;&#10;                .shares(post.getStats().getShares())&#13;&#10;                .engagementRate(post.getEngagement().getEngagementRate())&#13;&#10;                .reactions(post.getStats().getReactions())&#13;&#10;                .build();&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Schedule post for later publishing&#13;&#10;     */&#13;&#10;    public PostResponse schedulePost(ScheduledPostRequest request, AuthenticatedUser user) {&#13;&#10;        AuthorInfo author = userServiceClient.getAuthorInfo(user.getId());&#13;&#10;        if (author == null) {&#13;&#10;            throw new RuntimeException(&quot;Author not found with id: &quot; + user.getId());&#13;&#10;        }&#13;&#10;&#13;&#10;        PostEntity post = PostEntity.builder()&#13;&#10;                .title(request.getTitle())&#13;&#10;                .content(request.getContent())&#13;&#10;                .author(author)&#13;&#10;                .images(request.getImages() != null ? request.getImages() : new ArrayList&lt;&gt;())&#13;&#10;                .tags(request.getTags() != null ? request.getTags() : new ArrayList&lt;&gt;())&#13;&#10;                .category(request.getCategory())&#13;&#10;                .privacy(request.getVisibility() != null ? request.getVisibility() : &quot;PUBLIC&quot;)&#13;&#10;                .scheduledAt(request.getScheduledAt())&#13;&#10;                .isScheduled(true)&#13;&#10;                .stats(new PostEntity.PostStats())&#13;&#10;                .build();&#13;&#10;&#13;&#10;        PostEntity savedPost = postRepository.save(post);&#13;&#10;        return new PostResponse(savedPost);&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Enhanced search with filters&#13;&#10;     */&#13;&#10;    public List&lt;PostResponse&gt; searchPosts(String query, String category, String faculty,&#13;&#10;                                        String dateRange, Pageable pageable) {&#13;&#10;        // This would need to be implemented with proper MongoDB queries&#13;&#10;        // For now, implementing basic search&#13;&#10;        Page&lt;PostEntity&gt; posts;&#13;&#10;&#13;&#10;        if (category != null &amp;&amp; !category.isEmpty()) {&#13;&#10;            posts = postRepository.findByCategoryAndTitleContainingOrContentContaining(&#13;&#10;                category, query, query, pageable);&#13;&#10;        } else {&#13;&#10;            posts = postRepository.findByTitleContainingOrContentContaining(query, query, pageable);&#13;&#10;        }&#13;&#10;&#13;&#10;        return posts.stream()&#13;&#10;                .map(PostResponse::new)&#13;&#10;                .collect(Collectors.toList());&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Update author information in posts (for data consistency)&#13;&#10;     */&#13;&#10;    public void updateAuthorInfoInPosts(String userId, String fullName, String avatarUrl) {&#13;&#10;        List&lt;PostEntity&gt; userPosts = postRepository.findByAuthor_Id(userId);&#13;&#10;&#13;&#10;        for (PostEntity post : userPosts) {&#13;&#10;            AuthorInfo updatedAuthor = post.getAuthor();&#13;&#10;            updatedAuthor.setFullName(fullName);&#13;&#10;            updatedAuthor.setAvatarUrl(avatarUrl);&#13;&#10;            post.setAuthor(updatedAuthor);&#13;&#10;        }&#13;&#10;&#13;&#10;        if (!userPosts.isEmpty()) {&#13;&#10;            postRepository.saveAll(userPosts);&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    // Helper methods&#13;&#10;    private void handleLikeInteraction(String postId, String userId, String reactionType,&#13;&#10;                                     PostEntity post, AuthorInfo user) {&#13;&#10;        InteractionEntity.ReactionType reaction =&#13;&#10;            reactionType != null ?&#13;&#10;            InteractionEntity.ReactionType.valueOf(reactionType.toUpperCase()) :&#13;&#10;            InteractionEntity.ReactionType.LIKE;&#13;&#10;&#13;&#10;        // Check if user already reacted&#13;&#10;        Optional&lt;InteractionEntity&gt; existingInteraction = interactionRepository&#13;&#10;                .findByPostIdAndAuthor_IdAndType(postId, userId, InteractionEntity.InteractionType.REACTION);&#13;&#10;&#13;&#10;        if (existingInteraction.isEmpty()) {&#13;&#10;            // Create new reaction&#13;&#10;            InteractionEntity interaction = InteractionEntity.builder()&#13;&#10;                    .postId(postId)&#13;&#10;                    .author(user)&#13;&#10;                    .type(InteractionEntity.InteractionType.REACTION)&#13;&#10;                    .reactionType(reaction)&#13;&#10;                    .build();&#13;&#10;&#13;&#10;            interactionRepository.save(interaction);&#13;&#10;            post.getStats().incrementReaction(reaction);&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    private void handleUnlikeInteraction(String postId, String userId, PostEntity post) {&#13;&#10;        Optional&lt;InteractionEntity&gt; existingInteraction = interactionRepository&#13;&#10;                .findByPostIdAndAuthor_IdAndType(postId, userId, InteractionEntity.InteractionType.REACTION);&#13;&#10;&#13;&#10;        if (existingInteraction.isPresent()) {&#13;&#10;            InteractionEntity interaction = existingInteraction.get();&#13;&#10;            post.getStats().decrementReaction(interaction.getReactionType());&#13;&#10;            interactionRepository.delete(interaction);&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    private void handleShareInteraction(String postId, String userId, PostEntity post, AuthorInfo user) {&#13;&#10;        InteractionEntity interaction = InteractionEntity.builder()&#13;&#10;                .postId(postId)&#13;&#10;                .author(user)&#13;&#10;                .type(InteractionEntity.InteractionType.SHARE)&#13;&#10;                .build();&#13;&#10;&#13;&#10;        interactionRepository.save(interaction);&#13;&#10;        post.getStats().incrementShares();&#13;&#10;    }&#13;&#10;&#13;&#10;    private void updateEngagementMetrics(PostEntity post) {&#13;&#10;        PostEntity.EngagementMetrics engagement = post.getEngagement();&#13;&#10;        PostEntity.PostStats stats = post.getStats();&#13;&#10;&#13;&#10;        engagement.updateEngagement(&#13;&#10;            (int) stats.getLikes(),&#13;&#10;            (int) stats.getComments(),&#13;&#10;            (int) stats.getShares(),&#13;&#10;            (int) stats.getViews()&#13;&#10;        );&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/service/UserServiceClient.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/service/UserServiceClient.java" />
              <option name="updatedContent" value="package com.ctuconnect.service;&#10;&#10;import org.springframework.cloud.openfeign.FeignClient;&#10;import org.springframework.web.bind.annotation.GetMapping;&#10;import org.springframework.web.bind.annotation.PathVariable;&#10;&#10;import java.util.Set;&#10;&#10;@FeignClient(name = &quot;user-service&quot;, url = &quot;${user-service.url:http://user-service:8081}&quot;)&#10;public interface UserServiceClient {&#10;    &#10;    @GetMapping(&quot;/api/users/{userId}/friends/ids&quot;)&#10;    Set&lt;String&gt; getFriendIds(@PathVariable String userId);&#10;    &#10;    @GetMapping(&quot;/api/users/{userId}/close-interactions&quot;)&#10;    Set&lt;String&gt; getCloseInteractionIds(@PathVariable String userId);&#10;    &#10;    @GetMapping(&quot;/api/users/{userId}/same-faculty&quot;)&#10;    Set&lt;String&gt; getSameFacultyUserIds(@PathVariable String userId);&#10;    &#10;    @GetMapping(&quot;/api/users/{userId}/same-major&quot;)&#10;    Set&lt;String&gt; getSameMajorUserIds(@PathVariable String userId);&#10;    &#10;    @GetMapping(&quot;/api/users/{userId}/interest-tags&quot;)&#10;    Set&lt;String&gt; getUserInterestTags(@PathVariable String userId);&#10;    &#10;    @GetMapping(&quot;/api/users/{userId}/preferred-categories&quot;)&#10;    Set&lt;String&gt; getUserPreferredCategories(@PathVariable String userId);&#10;    &#10;    @GetMapping(&quot;/api/users/{userId}/faculty-id&quot;)&#10;    String getUserFacultyId(@PathVariable String userId);&#10;    &#10;    @GetMapping(&quot;/api/users/{userId}/major-id&quot;)&#10;    String getUserMajorId(@PathVariable String userId);&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/post-service/src/main/resources/application-docker.properties">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/post-service/src/main/resources/application-docker.properties" />
              <option name="updatedContent" value="# Docker-specific configuration for post-service&#10;spring.application.name=post-service&#10;server.port=8085&#10;&#10;# MongoDB Configuration - Docker service name&#10;spring.data.mongodb.database=post_db&#10;spring.data.mongodb.host=post_db&#10;spring.data.mongodb.port=27017&#10;&#10;# Redis Configuration - Docker service name&#10;spring.data.redis.host=redis&#10;spring.data.redis.port=6379&#10;spring.data.redis.timeout=60000ms&#10;spring.data.redis.lettuce.pool.max-active=8&#10;spring.data.redis.lettuce.pool.max-idle=8&#10;spring.data.redis.lettuce.pool.min-idle=0&#10;&#10;# Kafka Configuration - Docker service name&#10;spring.kafka.bootstrap-servers=kafka:9092&#10;spring.kafka.producer.key-serializer=org.apache.kafka.common.serialization.StringSerializer&#10;spring.kafka.producer.value-serializer=org.springframework.kafka.support.serializer.JsonSerializer&#10;&#10;spring.kafka.consumer.group-id=post-service-group&#10;spring.kafka.consumer.key-deserializer=org.apache.kafka.common.serialization.StringDeserializer&#10;spring.kafka.consumer.value-deserializer=org.springframework.kafka.support.serializer.JsonDeserializer&#10;spring.kafka.consumer.properties.spring.json.trusted.packages=*&#10;spring.kafka.consumer.auto-offset-reset=earliest&#10;spring.kafka.consumer.enable-auto-commit=true&#10;&#10;# Eureka Configuration - Docker service name&#10;eureka.client.service-url.defaultZone=http://eureka-server:8761/eureka/&#10;eureka.instance.prefer-ip-address=true&#10;eureka.instance.instance-id=${spring.application.name}:${server.port}&#10;&#10;# Media Service Configuration - Docker service name&#10;media-service.url=http://media-service:8084&#10;&#10;# File Upload Configuration&#10;spring.servlet.multipart.max-file-size=10MB&#10;spring.servlet.multipart.max-request-size=50MB&#10;&#10;# Actuator Configuration&#10;management.endpoints.web.exposure.include=health,info,metrics&#10;management.endpoint.health.show-details=always&#10;&#10;# Logging Configuration&#10;logging.level.com.ctuconnect=DEBUG&#10;logging.level.org.springframework.kafka=INFO&#10;logging.level.org.springframework.data.mongodb=INFO" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/post-service/src/main/resources/application.properties">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/post-service/src/main/resources/application.properties" />
              <option name="originalContent" value="spring.application.name=post-service&#10;server.port=8085&#10;&#10;# MongoDB Configuration&#10;spring.data.mongodb.database=post_db&#10;spring.data.mongodb.host=localhost&#10;spring.data.mongodb.port=27018&#10;&#10;# Kafka Configuration&#10;spring.kafka.bootstrap-servers=localhost:9092&#10;spring.kafka.producer.key-serializer=org.apache.kafka.common.serialization.StringSerializer&#10;spring.kafka.producer.value-serializer=org.springframework.kafka.support.serializer.JsonSerializer&#10;&#10;# Kafka Consumer Configuration - Fix missing group-id error&#10;spring.kafka.consumer.group-id=post-service-group&#10;spring.kafka.consumer.key-deserializer=org.apache.kafka.common.serialization.StringDeserializer&#10;spring.kafka.consumer.value-deserializer=org.springframework.kafka.support.serializer.JsonDeserializer&#10;spring.kafka.consumer.properties.spring.json.trusted.packages=*&#10;spring.kafka.consumer.auto-offset-reset=earliest&#10;spring.kafka.consumer.enable-auto-commit=true&#10;&#10;# Eureka Configuration&#10;eureka.client.service-url.defaultZone=http://localhost:8761/eureka/&#10;eureka.instance.prefer-ip-address=true&#10;eureka.instance.instance-id=${spring.application.name}:${server.port}&#10;&#10;# Redis Configuration (Missing - needed for caching)&#10;spring.data.redis.host=localhost&#10;spring.data.redis.port=6379&#10;spring.data.redis.timeout=60000ms&#10;spring.data.redis.lettuce.pool.max-active=8&#10;spring.data.redis.lettuce.pool.max-idle=8&#10;spring.data.redis.lettuce.pool.min-idle=0&#10;&#10;# Media Service Configuration&#10;media-service.url=http://localhost:8084&#10;&#10;# File Upload Configuration&#10;spring.servlet.multipart.max-file-size=10MB&#10;spring.servlet.multipart.max-request-size=50MB&#10;&#10;# Actuator Configuration&#10;management.endpoints.web.exposure.include=health,info,metrics&#10;management.endpoint.health.show-details=always&#10;&#10;# Logging Configuration&#10;logging.level.vn.ctu.edu.postservice=DEBUG&#10;logging.level.org.springframework.kafka=INFO&#10;logging.level.org.springframework.data.mongodb=INFO&#10;" />
              <option name="updatedContent" value="spring.application.name=post-service&#10;server.port=8085&#10;&#10;# MongoDB Configuration&#10;spring.data.mongodb.database=post_db&#10;spring.data.mongodb.host=localhost&#10;spring.data.mongodb.port=27018&#10;&#10;# Kafka Configuration&#10;spring.kafka.bootstrap-servers=localhost:9092&#10;spring.kafka.producer.key-serializer=org.apache.kafka.common.serialization.StringSerializer&#10;spring.kafka.producer.value-serializer=org.springframework.kafka.support.serializer.JsonSerializer&#10;&#10;# Kafka Consumer Configuration - Fix missing group-id error&#10;spring.kafka.consumer.group-id=post-service-group&#10;spring.kafka.consumer.key-deserializer=org.apache.kafka.common.serialization.StringDeserializer&#10;spring.kafka.consumer.value-deserializer=org.springframework.kafka.support.serializer.JsonDeserializer&#10;spring.kafka.consumer.properties.spring.json.trusted.packages=*&#10;spring.kafka.consumer.auto-offset-reset=earliest&#10;spring.kafka.consumer.enable-auto-commit=true&#10;&#10;# Eureka Configuration&#10;eureka.client.service-url.defaultZone=http://localhost:8761/eureka/&#10;eureka.instance.prefer-ip-address=true&#10;eureka.instance.instance-id=${spring.application.name}:${server.port}&#10;&#10;# Redis Configuration - Fix for Docker container networking&#10;spring.data.redis.host=redis&#10;spring.data.redis.port=6379&#10;spring.data.redis.timeout=60000ms&#10;spring.data.redis.lettuce.pool.max-active=8&#10;spring.data.redis.lettuce.pool.max-idle=8&#10;spring.data.redis.lettuce.pool.min-idle=0&#10;&#10;# Media Service Configuration&#10;media-service.url=http://localhost:8084&#10;&#10;# File Upload Configuration&#10;spring.servlet.multipart.max-file-size=10MB&#10;spring.servlet.multipart.max-request-size=50MB&#10;&#10;# Actuator Configuration&#10;management.endpoints.web.exposure.include=health,info,metrics&#10;management.endpoint.health.show-details=always&#10;&#10;# Logging Configuration&#10;logging.level.vn.ctu.edu.postservice=DEBUG&#10;logging.level.org.springframework.kafka=INFO&#10;logging.level.org.springframework.data.mongodb=INFO" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/user-service/src/main/java/com/ctuconnect/config/RedisConfig.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/user-service/src/main/java/com/ctuconnect/config/RedisConfig.java" />
              <option name="originalContent" value="package com.ctuconnect.config;&#10;&#10;import org.springframework.context.annotation.Configuration;&#10;import org.springframework.data.redis.connection.RedisConnectionFactory;&#10;import org.springframework.data.redis.connection.lettuce.LettuceConnectionFactory;&#10;import org.springframework.data.redis.core.RedisTemplate;&#10;import org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer;&#10;import org.springframework.data.redis.serializer.StringRedisSerializer;&#10;&#10;@Configuration&#10;public class RedisConfig {&#10;&#10;    @Bean&#10;        RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;();&#10;        template.setConnectionFactory(connectionFactory);&#10;&#10;        return new LettuceConnectionFactory(&quot;localhost&quot;, 6379);&#10;        template.setKeySerializer(new StringRedisSerializer());&#10;        template.setHashKeySerializer(new StringRedisSerializer());&#10;&#10;        // Use JSON serializer for values&#10;        template.setValueSerializer(new GenericJackson2JsonRedisSerializer());&#10;        template.setHashValueSerializer(new GenericJackson2JsonRedisSerializer());&#10;&#10;        template.afterPropertiesSet();&#10;        return template;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.ctuconnect.config;&#13;&#10;&#13;&#10;import org.springframework.beans.factory.annotation.Value;&#13;&#10;import org.springframework.context.annotation.Bean;&#13;&#10;import org.springframework.context.annotation.Configuration;&#13;&#10;import org.springframework.data.redis.connection.RedisConnectionFactory;&#13;&#10;import org.springframework.data.redis.connection.lettuce.LettuceConnectionFactory;&#13;&#10;import org.springframework.data.redis.core.RedisTemplate;&#13;&#10;import org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer;&#13;&#10;import org.springframework.data.redis.serializer.StringRedisSerializer;&#13;&#10;&#13;&#10;@Configuration&#13;&#10;public class RedisConfig {&#13;&#10;&#13;&#10;    @Value(&quot;${spring.data.redis.host:redis}&quot;)&#13;&#10;    private String redisHost;&#13;&#10;&#13;&#10;    @Value(&quot;${spring.data.redis.port:6379}&quot;)&#13;&#10;    private int redisPort;&#13;&#10;&#13;&#10;    @Bean&#13;&#10;    public RedisConnectionFactory redisConnectionFactory() {&#13;&#10;        return new LettuceConnectionFactory(redisHost, redisPort);&#13;&#10;    }&#13;&#10;&#13;&#10;    @Bean&#13;&#10;    public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory connectionFactory) {&#13;&#10;        RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;();&#13;&#10;        template.setConnectionFactory(connectionFactory);&#13;&#10;&#13;&#10;        // Use String serializer for keys&#13;&#10;        template.setKeySerializer(new StringRedisSerializer());&#13;&#10;        template.setHashKeySerializer(new StringRedisSerializer());&#13;&#10;&#13;&#10;        // Use JSON serializer for values&#13;&#10;        template.setValueSerializer(new GenericJackson2JsonRedisSerializer());&#13;&#10;        template.setHashValueSerializer(new GenericJackson2JsonRedisSerializer());&#13;&#10;&#13;&#10;        template.afterPropertiesSet();&#13;&#10;        return template;&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/user-service/src/main/java/com/ctuconnect/dto/ActivityDTO.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/user-service/src/main/java/com/ctuconnect/dto/ActivityDTO.java" />
              <option name="originalContent" value="package com.ctuconnect.dto;&#10;&#10;import lombok.AllArgsConstructor;&#10;import lombok.Builder;&#10;import lombok.Data;&#10;import lombok.NoArgsConstructor;&#10;&#10;import java.time.LocalDateTime;&#10;&#10;@Data&#10;@Builder&#10;@NoArgsConstructor&#10;@AllArgsConstructor&#10;public class ActivityDTO {&#10;    private String id;&#10;    private String userId;&#10;    private String activityType; // POST_CREATED, POST_LIKED, COMMENT_ADDED, etc.&#10;    private String targetType; // POST, COMMENT, USER&#10;    private String targetId;&#10;    private String actorName;&#10;    private String actorAvatarUrl;&#10;&#10;    // For activity feed display&#10;    private String displayText;&#10;    private String actionUrl;&#10;    private boolean isRead;&#10;&#10;    public enum ActivityType {&#10;        POST_CREATED,&#10;        POST_LIKED,&#10;        POST_SHARED,&#10;        COMMENT_ADDED,&#10;        FRIEND_REQUEST_SENT,&#10;        FRIEND_REQUEST_ACCEPTED,&#10;        PROFILE_UPDATED&#10;    }&#10;&#10;    public enum TargetType {&#10;        POST,&#10;        COMMENT,&#10;        USER,&#10;        PROFILE&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.ctuconnect.dto;&#10;&#10;import lombok.AllArgsConstructor;&#10;import lombok.Builder;&#10;import lombok.Data;&#10;import lombok.NoArgsConstructor;&#10;&#10;import java.time.LocalDateTime;&#10;&#10;@Data&#10;@Builder&#10;@NoArgsConstructor&#10;@AllArgsConstructor&#10;public class ActivityDTO {&#10;    private String id;&#10;    private String userId;&#10;    private String activityType; // POST_CREATED, POST_LIKED, COMMENT_ADDED, etc.&#10;    private String targetType; // POST, COMMENT, USER&#10;    private String targetId;&#10;    private String entityType; // Add missing entityType field&#10;    private String entityId; // Add missing entityId field&#10;    private String description;&#10;    private LocalDateTime timestamp;&#10;    private String actorName;&#10;    private String actorAvatarUrl;&#10;&#10;    // For activity feed display&#10;    private String displayText;&#10;    private String actionUrl;&#10;    private boolean isRead;&#10;&#10;    public enum ActivityType {&#10;        POST_CREATED,&#10;        POST_LIKED,&#10;        POST_SHARED,&#10;        COMMENT_ADDED,&#10;        FRIEND_REQUEST_SENT,&#10;        FRIEND_REQUEST_ACCEPTED,&#10;        PROFILE_UPDATED&#10;    }&#10;&#10;    public enum TargetType {&#10;        POST,&#10;        COMMENT,&#10;        USER,&#10;        PROFILE&#10;    }&#10;&#10;    public enum EntityType {&#10;        POST,&#10;        COMMENT,&#10;        USER,&#10;        PROFILE&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/user-service/src/main/java/com/ctuconnect/dto/FriendSuggestionDTO.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/user-service/src/main/java/com/ctuconnect/dto/FriendSuggestionDTO.java" />
              <option name="updatedContent" value="package com.ctuconnect.dto;&#10;&#10;import lombok.AllArgsConstructor;&#10;import lombok.Builder;&#10;import lombok.Data;&#10;import lombok.NoArgsConstructor;&#10;&#10;@Data&#10;@AllArgsConstructor&#10;@NoArgsConstructor&#10;@Builder&#10;public class FriendSuggestionDTO {&#10;    private String userId;&#10;    private String username;&#10;    private String fullName;&#10;    private String avatarUrl;&#10;    private String bio;&#10;    &#10;    // Suggestion metadata&#10;    private int mutualFriendsCount;&#10;    private String suggestionReason;&#10;    private double relevanceScore;&#10;    private SuggestionType suggestionType;&#10;    &#10;    // Academic context&#10;    private String facultyName;&#10;    private String majorName;&#10;    private String batchYear;&#10;    &#10;    // Social context&#10;    private boolean sameCollege;&#10;    private boolean sameFaculty;&#10;    private boolean sameMajor;&#10;    private boolean sameBatch;&#10;    &#10;    public enum SuggestionType {&#10;        MUTUAL_FRIENDS,&#10;        ACADEMIC_CONNECTION,&#10;        FRIENDS_OF_FRIENDS,&#10;        PROFILE_VIEWER,&#10;        SIMILAR_INTERESTS,&#10;        LOCATION_BASED,&#10;        ACTIVITY_BASED&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/user-service/src/main/java/com/ctuconnect/repository/UserRepository.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/user-service/src/main/java/com/ctuconnect/repository/UserRepository.java" />
              <option name="originalContent" value="package com.ctuconnect.repository;&#10;&#10;import com.ctuconnect.entity.UserEntity;&#10;import org.springframework.data.jpa.repository.Modifying;&#10;import org.springframework.data.neo4j.repository.Neo4jRepository;&#10;import org.springframework.data.neo4j.repository.query.Query;&#10;import org.springframework.data.repository.query.Param;&#10;&#10;import java.util.List;&#10;import java.util.Optional;&#10;&#10;public interface UserRepository extends Neo4jRepository&lt;UserEntity, String&gt; {&#10;&#10; // Tìm kiếm người dùng bằng email hoặc username&#10; Optional&lt;UserEntity&gt; findByEmail(String email);&#10;&#10; Optional&lt;UserEntity&gt; findByUsername(String username);&#10;&#10; boolean existsByEmail(String email);&#10;&#10; boolean existsByUsername(String username);&#10;&#10; @Query(&quot;MATCH (u:User) WHERE u.email = $identifier OR u.username = $identifier RETURN u&quot;)&#10; Optional&lt;UserEntity&gt; findByEmailOrUsername(@Param(&quot;identifier&quot;) String identifier);&#10;&#10; // Lấy user by id&#10; @Query(&quot;MATCH (u:User {id: $userId}) RETURN u&quot;)&#10; Optional&lt;UserEntity&gt; findUserWithAllRelations(@Param(&quot;userId&quot;) String userId);&#10;&#10; // Xóa quan hệ của profile học sinh (student)&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})&#10;        OPTIONAL MATCH (u)-[r]-&gt;()&#10;        WHERE type(r) IN ['ENROLLED_IN', 'WORKS_IN', 'BELONGS_TO', 'IN_BATCH', 'HAS_GENDER']&#10;        DELETE r&#10;        &quot;&quot;&quot;)&#10; void clearStudentRelationships(@Param(&quot;userId&quot;) String userId);&#10;&#10; // Xóa quan hệ của profile giảng viên (lecturer)&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})&#10;        OPTIONAL MATCH (u)-[r]-&gt;()&#10;        WHERE type(r) IN ['HAS_DEGREE', 'HAS_ACADEMIC', 'HAS_POSITION', 'WORKS_IN', 'BELONGS_TO', 'HAS_GENDER']&#10;        DELETE r&#10;        &quot;&quot;&quot;)&#10; void clearLecturerRelationships(@Param(&quot;userId&quot;) String userId);&#10;&#10; // Xóa quan hệ cụ thể theo danh sách quan hệ truyền vào&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})&#10;        OPTIONAL MATCH (u)-[r]-&gt;()&#10;        WHERE type(r) IN $relationshipTypes&#10;        DELETE r&#10;        &quot;&quot;&quot;)&#10; void clearSpecificRelationships(@Param(&quot;userId&quot;) String userId, @Param(&quot;relationshipTypes&quot;) List&lt;String&gt; relationshipTypes);&#10;&#10; // Xóa quan hệ đơn lẻ theo loại&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})-[r]-&gt;(n)&#10;        WHERE type(r) = $relationshipType&#10;        DELETE r&#10;        &quot;&quot;&quot;)&#10; void deleteRelationship(@Param(&quot;userId&quot;) String userId, @Param(&quot;relationshipType&quot;) String relationshipType);&#10;&#10; // Cập nhật các quan hệ profile&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})&#10;        OPTIONAL MATCH (u)-[r:ENROLLED_IN]-&gt;()&#10;        DELETE r&#10;        WITH u&#10;        MATCH (newMajor:Major {id: $majorId})&#10;        MERGE (u)-[:ENROLLED_IN]-&gt;(newMajor)&#10;        &quot;&quot;&quot;)&#10; void updateUserMajor(@Param(&quot;userId&quot;) String userId, @Param(&quot;majorId&quot;) String majorId);&#10;&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})&#10;        OPTIONAL MATCH (u)-[r:IN_BATCH]-&gt;()&#10;        DELETE r&#10;        WITH u&#10;        MATCH (newBatch:Batch {id: $batchId})&#10;        MERGE (u)-[:IN_BATCH]-&gt;(newBatch)&#10;        &quot;&quot;&quot;)&#10; void updateUserBatch(@Param(&quot;userId&quot;) String userId, @Param(&quot;batchId&quot;) String batchId);&#10;&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})&#10;        OPTIONAL MATCH (u)-[r:HAS_GENDER]-&gt;()&#10;        DELETE r&#10;        WITH u&#10;        MATCH (newGender:Gender {id: $genderId})&#10;        MERGE (u)-[:HAS_GENDER]-&gt;(newGender)&#10;        &quot;&quot;&quot;)&#10; void updateUserGender(@Param(&quot;userId&quot;) String userId, @Param(&quot;genderId&quot;) String genderId);&#10;&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})&#10;        OPTIONAL MATCH (u)-[r:ENROLLED_IN]-&gt;(:Faculty)&#10;        DELETE r&#10;        WITH u&#10;        MATCH (newFaculty:Faculty {id: $facultyId})&#10;        MERGE (u)-[:ENROLLED_IN]-&gt;(newFaculty)&#10;        &quot;&quot;&quot;)&#10; void updateUserFaculty(@Param(&quot;userId&quot;) String userId, @Param(&quot;facultyId&quot;) String facultyId);&#10;&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})&#10;        OPTIONAL MATCH (u)-[r:ENROLLED_IN]-&gt;(:College)&#10;        DELETE r&#10;        WITH u&#10;        MATCH (newCollege:College {id: $collegeId})&#10;        MERGE (u)-[:ENROLLED_IN]-&gt;(newCollege)&#10;        &quot;&quot;&quot;)&#10; void updateUserCollege(@Param(&quot;userId&quot;) String userId, @Param(&quot;collegeId&quot;) String collegeId);&#10;&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})&#10;        OPTIONAL MATCH (u)-[r:WORKS_IN]-&gt;(:Faculty)&#10;        DELETE r&#10;        WITH u&#10;        MATCH (newFaculty:Faculty {id: $facultyId})&#10;        MERGE (u)-[:WORKS_IN]-&gt;(newFaculty)&#10;        &quot;&quot;&quot;)&#10; void updateUserWorkingFaculty(@Param(&quot;userId&quot;) String userId, @Param(&quot;facultyId&quot;) String facultyId);&#10;&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})&#10;        OPTIONAL MATCH (u)-[r:WORKS_IN]-&gt;(:College)&#10;        DELETE r&#10;        WITH u&#10;        MATCH (newCollege:College {id: $collegeId})&#10;        MERGE (u)-[:WORKS_IN]-&gt;(newCollege)&#10;        &quot;&quot;&quot;)&#10; void updateUserWorkingCollege(@Param(&quot;userId&quot;) String userId, @Param(&quot;collegeId&quot;) String collegeId);&#10;&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})&#10;        OPTIONAL MATCH (u)-[r:HAS_DEGREE]-&gt;()&#10;        DELETE r&#10;        WITH u&#10;        MATCH (newDegree:Degree {id: $degreeId})&#10;        MERGE (u)-[:HAS_DEGREE]-&gt;(newDegree)&#10;        &quot;&quot;&quot;)&#10; void updateUserDegree(@Param(&quot;userId&quot;) String userId, @Param(&quot;degreeId&quot;) String degreeId);&#10;&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})&#10;        OPTIONAL MATCH (u)-[r:HAS_POSITION]-&gt;()&#10;        DELETE r&#10;        WITH u&#10;        MATCH (newPosition:Position {id: $positionId})&#10;        MERGE (u)-[:HAS_POSITION]-&gt;(newPosition)&#10;        &quot;&quot;&quot;)&#10; void updateUserPosition(@Param(&quot;userId&quot;) String userId, @Param(&quot;positionId&quot;) String positionId);&#10;&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})&#10;        OPTIONAL MATCH (u)-[r:HAS_ACADEMIC]-&gt;()&#10;        DELETE r&#10;        WITH u&#10;        MATCH (newAcademic:Academic {id: $academicId})&#10;        MERGE (u)-[:HAS_ACADEMIC]-&gt;(newAcademic)&#10;        &quot;&quot;&quot;)&#10; void updateUserAcademic(@Param(&quot;userId&quot;) String userId, @Param(&quot;academicId&quot;) String academicId);&#10;&#10; // Quan hệ bạn bè (Friendship)&#10;&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})-[:FRIEND]-(friend:User)&#10;        RETURN friend&#10;        &quot;&quot;&quot;)&#10; List&lt;UserEntity&gt; findFriends(@Param(&quot;userId&quot;) String userId);&#10;&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u1:User {id: $userId1})-[:FRIEND]-(friend:User),&#10;              (u2:User {id: $userId2})-[:FRIEND]-(friend)&#10;        WHERE friend.id &lt;&gt; $userId1 AND friend.id &lt;&gt; $userId2&#10;        RETURN DISTINCT friend&#10;        &quot;&quot;&quot;)&#10; List&lt;UserEntity&gt; findMutualFriends(@Param(&quot;userId1&quot;) String userId1, @Param(&quot;userId2&quot;) String userId2);&#10;&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u1:User {id: $userId1}), (u2:User {id: $userId2})&#10;        WHERE u1.id &lt;&gt; u2.id&#10;        MERGE (u1)-[:FRIEND_REQUEST {createdAt: datetime(), status: 'PENDING'}]-&gt;(u2)&#10;        &quot;&quot;&quot;)&#10; void sendFriendRequest(@Param(&quot;userId1&quot;) String userId1, @Param(&quot;userId2&quot;) String userId2);&#10;&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u1:User {id: $userId1})-[r:FRIEND_REQUEST {status: 'PENDING'}]-&gt;(u2:User {id: $userId2})&#10;        DELETE r&#10;        MERGE (u1)-[:FRIEND {since: datetime()}]-(u2)&#10;        &quot;&quot;&quot;)&#10; void acceptFriendRequest(@Param(&quot;userId1&quot;) String userId1, @Param(&quot;userId2&quot;) String userId2);&#10;&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u1:User {id: $userId1})-[r:FRIEND_REQUEST]-&gt;(u2:User {id: $userId2})&#10;        DELETE r&#10;        &quot;&quot;&quot;)&#10; void rejectFriendRequest(@Param(&quot;userId1&quot;) String userId1, @Param(&quot;userId2&quot;) String userId2);&#10;&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u1:User {id: $userId1})-[r:FRIEND]-(u2:User {id: $userId2})&#10;        DELETE r&#10;        &quot;&quot;&quot;)&#10; void deleteFriendship(@Param(&quot;userId1&quot;) String userId1, @Param(&quot;userId2&quot;) String userId2);&#10;&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u1:User {id: $userId1})-[:FRIEND]-(u2:User {id: $userId2})&#10;        RETURN COUNT(*) &gt; 0&#10;        &quot;&quot;&quot;)&#10; boolean areFriends(@Param(&quot;userId1&quot;) String userId1, @Param(&quot;userId2&quot;) String userId2);&#10;&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u1:User {id: $userId1})-[:FRIEND_REQUEST {status: 'PENDING'}]-&gt;(u2:User {id: $userId2})&#10;        RETURN COUNT(*) &gt; 0&#10;        &quot;&quot;&quot;)&#10; boolean hasPendingFriendRequest(@Param(&quot;userId1&quot;) String userId1, @Param(&quot;userId2&quot;) String userId2);&#10;&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (sender:User)-[:FRIEND_REQUEST {status: 'PENDING'}]-&gt;(u:User {id: $userId})&#10;        RETURN sender&#10;        &quot;&quot;&quot;)&#10; List&lt;UserEntity&gt; findIncomingFriendRequests(@Param(&quot;userId&quot;) String userId);&#10;&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})-[:FRIEND_REQUEST {status: 'PENDING'}]-&gt;(receiver:User)&#10;        RETURN receiver&#10;        &quot;&quot;&quot;)&#10; List&lt;UserEntity&gt; findOutgoingFriendRequests(@Param(&quot;userId&quot;) String userId);&#10;&#10; // Tìm bạn bè gợi ý dựa trên bạn chung&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})-[:FRIEND]-(friend:User)-[:FRIEND]-(suggestion:User)&#10;        WHERE u.id &lt;&gt; suggestion.id&#10;          AND NOT (u)-[:FRIEND]-(suggestion)&#10;          AND NOT (u)-[:FRIEND_REQUEST]-(suggestion)&#10;        RETURN suggestion, COUNT(*) AS mutualFriends&#10;        ORDER BY mutualFriends DESC&#10;        LIMIT 10&#10;        &quot;&quot;&quot;)&#10; List&lt;UserEntity&gt; findFriendSuggestions(@Param(&quot;userId&quot;) String userId);&#10;&#10; // Tìm kiếm user theo các bộ lọc&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})&#10;        OPTIONAL MATCH (u)-[:ENROLLED_IN]-&gt;(uMajor:Major)&#10;        OPTIONAL MATCH (u)-[:IN_BATCH]-&gt;(uBatch:Batch)&#10;        OPTIONAL MATCH (uMajor)-[:BELONGS_TO]-&gt;(uFaculty:Faculty)&#10;        OPTIONAL MATCH (uFaculty)-[:PART_OF]-&gt;(uCollege:College)&#10;&#10;        MATCH (other:User)&#10;        OPTIONAL MATCH (other)-[:ENROLLED_IN]-&gt;(oMajor:Major)&#10;        OPTIONAL MATCH (other)-[:IN_BATCH]-&gt;(oBatch:Batch)&#10;        OPTIONAL MATCH (oMajor)-[:BELONGS_TO]-&gt;(oFaculty:Faculty)&#10;        OPTIONAL MATCH (oFaculty)-[:PART_OF]-&gt;(oCollege:College)&#10;&#10;        WHERE u.id &lt;&gt; other.id&#10;          AND ($isSameMajor = false OR uMajor.name = oMajor.name)&#10;          AND ($isSameBatch = false OR uBatch.year = oBatch.year)&#10;          AND ($isSameFaculty = false OR uFaculty.name = oFaculty.name)&#10;          AND ($isSameCollege = false OR uCollege.name = oCollege.name)&#10;&#10;        RETURN DISTINCT other&#10;        &quot;&quot;&quot;)&#10; List&lt;UserEntity&gt; findUsersWithFilters(&#10;         @Param(&quot;userId&quot;) String userId,&#10;         @Param(&quot;isSameCollege&quot;) boolean isSameCollege,&#10;         @Param(&quot;isSameFaculty&quot;) boolean isSameFaculty,&#10;         @Param(&quot;isSameMajor&quot;) boolean isSameMajor,&#10;         @Param(&quot;isSameBatch&quot;) boolean isSameBatch);&#10;&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})-[:FRIEND]-(friend:User)&#10;        OPTIONAL MATCH (u)-[:ENROLLED_IN]-&gt;(uMajor:Major)&#10;        OPTIONAL MATCH (friend)-[:ENROLLED_IN]-&gt;(fMajor:Major)&#10;        OPTIONAL MATCH (uMajor)-[:BELONGS_TO]-&gt;(uFaculty:Faculty)&#10;        OPTIONAL MATCH (fMajor)-[:BELONGS_TO]-&gt;(fFaculty:Faculty)&#10;        OPTIONAL MATCH (uFaculty)-[:PART_OF]-&gt;(uCollege:College)&#10;        OPTIONAL MATCH (fFaculty)-[:PART_OF]-&gt;(fCollege:College)&#10;        OPTIONAL MATCH (u)-[:IN_BATCH]-&gt;(uBatch:Batch)&#10;        OPTIONAL MATCH (friend)-[:IN_BATCH]-&gt;(fBatch:Batch)&#10;&#10;        WHERE ($isSameMajor = false OR uMajor.name = fMajor.name)&#10;          AND ($isSameFaculty = false OR uFaculty.name = fFaculty.name)&#10;          AND ($isSameCollege = false OR uCollege.name = fCollege.name)&#10;          AND ($isSameBatch = false OR uBatch.year = fBatch.year)&#10;&#10;        RETURN DISTINCT friend&#10;        &quot;&quot;&quot;)&#10; List&lt;UserEntity&gt; findFriendsWithFilters(&#10;         @Param(&quot;userId&quot;) String userId,&#10;         @Param(&quot;isSameCollege&quot;) boolean isSameCollege,&#10;         @Param(&quot;isSameFaculty&quot;) boolean isSameFaculty,&#10;         @Param(&quot;isSameMajor&quot;) boolean isSameMajor,&#10;         @Param(&quot;isSameBatch&quot;) boolean isSameBatch);&#10;&#10; // Tìm người dùng theo các thuộc tính cụ thể&#10; @Query(&quot;MATCH (u:User)-[:ENROLLED_IN]-&gt;(m:Major {name: $major}) RETURN u&quot;)&#10; List&lt;UserEntity&gt; findByMajor(@Param(&quot;major&quot;) String major);&#10;&#10; @Query(&quot;MATCH (u:User)-[:IN_BATCH]-&gt;(b:Batch {year: $batch}) RETURN u&quot;)&#10; List&lt;UserEntity&gt; findByBatch(@Param(&quot;batch&quot;) int batch);&#10;&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User)-[:ENROLLED_IN]-&gt;(:Major)-[:BELONGS_TO]-&gt;(:Faculty {name: $faculty})&#10;        RETURN u&#10;        &quot;&quot;&quot;)&#10; List&lt;UserEntity&gt; findByFaculty(@Param(&quot;faculty&quot;) String faculty);&#10;&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User)-[:ENROLLED_IN]-&gt;(:Major)-[:BELONGS_TO]-&gt;(:Faculty)-[:PART_OF]-&gt;(:College {name: $college})&#10;        RETURN u&#10;        &quot;&quot;&quot;)&#10; List&lt;UserEntity&gt; findByCollege(@Param(&quot;college&quot;) String college);&#10;&#10; // Tìm user có cùng thuộc tính&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})-[:ENROLLED_IN]-&gt;(m:Major)&lt;-[:ENROLLED_IN]-(other:User)&#10;        WHERE u.id &lt;&gt; other.id&#10;        RETURN other&#10;        &quot;&quot;&quot;)&#10; List&lt;UserEntity&gt; findUsersWithSameMajor(@Param(&quot;userId&quot;) String userId);&#10;&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})-[:IN_BATCH]-&gt;(b:Batch)&lt;-[:IN_BATCH]-(other:User)&#10;        WHERE u.id &lt;&gt; other.id&#10;        RETURN other&#10;        &quot;&quot;&quot;)&#10; List&lt;UserEntity&gt; findUsersWithSameBatch(@Param(&quot;userId&quot;) String userId);&#10;&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})-[:ENROLLED_IN]-&gt;(:Major)-[:BELONGS_TO]-&gt;(f:Faculty)&#10;        MATCH (other:User)-[:ENROLLED_IN]-&gt;(:Major)-[:BELONGS_TO]-&gt;(f)&#10;        WHERE other.id &lt;&gt; $userId&#10;        RETURN other&#10;        &quot;&quot;&quot;)&#10; List&lt;UserEntity&gt; findUsersWithSameFaculty(@Param(&quot;userId&quot;) String userId);&#10;&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})-[:ENROLLED_IN]-&gt;(:Major)-[:BELONGS_TO]-&gt;(:Faculty)-[:PART_OF]-&gt;(c:College)&#10;        MATCH (other:User)-[:ENROLLED_IN]-&gt;(:Major)-[:BELONGS_TO]-&gt;(:Faculty)-[:PART_OF]-&gt;(c)&#10;        WHERE other.id &lt;&gt; $userId&#10;        RETURN other&#10;        &quot;&quot;&quot;)&#10; List&lt;UserEntity&gt; findUsersWithSameCollege(@Param(&quot;userId&quot;) String userId);&#10;&#10; // Tìm bạn bè chung (duplicate nên đã gộp ở trên)&#10; // Các phương thức tìm kiếm nâng cao, lọc nâng cao và quan hệ bạn bè đều được giữ nguyên.&#10;" />
              <option name="updatedContent" value="package com.ctuconnect.repository;&#10;&#10;import com.ctuconnect.entity.UserEntity;&#10;import org.springframework.data.jpa.repository.Modifying;&#10;import org.springframework.data.neo4j.repository.Neo4jRepository;&#10;import org.springframework.data.neo4j.repository.query.Query;&#10;import org.springframework.data.repository.query.Param;&#10;&#10;import java.util.List;&#10;import java.util.Optional;&#10;&#10;public interface UserRepository extends Neo4jRepository&lt;UserEntity, String&gt; {&#10;&#10; // Tìm kiếm người dùng bằng email hoặc username&#10; Optional&lt;UserEntity&gt; findByEmail(String email);&#10;&#10; Optional&lt;UserEntity&gt; findByUsername(String username);&#10;&#10; boolean existsByEmail(String email);&#10;&#10; boolean existsByUsername(String username);&#10;&#10; @Query(&quot;MATCH (u:User) WHERE u.email = $identifier OR u.username = $identifier RETURN u&quot;)&#10; Optional&lt;UserEntity&gt; findByEmailOrUsername(@Param(&quot;identifier&quot;) String identifier);&#10;&#10; // Lấy user by id&#10; @Query(&quot;MATCH (u:User {id: $userId}) RETURN u&quot;)&#10; Optional&lt;UserEntity&gt; findUserWithAllRelations(@Param(&quot;userId&quot;) String userId);&#10;&#10; // Xóa quan hệ của profile học sinh (student)&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})&#10;        OPTIONAL MATCH (u)-[r]-&gt;()&#10;        WHERE type(r) IN ['ENROLLED_IN', 'WORKS_IN', 'BELONGS_TO', 'IN_BATCH', 'HAS_GENDER']&#10;        DELETE r&#10;        &quot;&quot;&quot;)&#10; void clearStudentRelationships(@Param(&quot;userId&quot;) String userId);&#10;&#10; // Xóa quan hệ của profile giảng viên (lecturer)&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})&#10;        OPTIONAL MATCH (u)-[r]-&gt;()&#10;        WHERE type(r) IN ['HAS_DEGREE', 'HAS_ACADEMIC', 'HAS_POSITION', 'WORKS_IN', 'BELONGS_TO', 'HAS_GENDER']&#10;        DELETE r&#10;        &quot;&quot;&quot;)&#10; void clearLecturerRelationships(@Param(&quot;userId&quot;) String userId);&#10;&#10; // Xóa quan hệ cụ thể theo danh sách quan hệ truyền vào&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})&#10;        OPTIONAL MATCH (u)-[r]-&gt;()&#10;        WHERE type(r) IN $relationshipTypes&#10;        DELETE r&#10;        &quot;&quot;&quot;)&#10; void clearSpecificRelationships(@Param(&quot;userId&quot;) String userId, @Param(&quot;relationshipTypes&quot;) List&lt;String&gt; relationshipTypes);&#10;&#10; // Xóa quan hệ đơn lẻ theo loại&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})-[r]-&gt;(n)&#10;        WHERE type(r) = $relationshipType&#10;        DELETE r&#10;        &quot;&quot;&quot;)&#10; void deleteRelationship(@Param(&quot;userId&quot;) String userId, @Param(&quot;relationshipType&quot;) String relationshipType);&#10;&#10; // Cập nhật các quan hệ profile&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})&#10;        OPTIONAL MATCH (u)-[r:ENROLLED_IN]-&gt;()&#10;        DELETE r&#10;        WITH u&#10;        MATCH (newMajor:Major {id: $majorId})&#10;        MERGE (u)-[:ENROLLED_IN]-&gt;(newMajor)&#10;        &quot;&quot;&quot;)&#10; void updateUserMajor(@Param(&quot;userId&quot;) String userId, @Param(&quot;majorId&quot;) String majorId);&#10;&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})&#10;        OPTIONAL MATCH (u)-[r:IN_BATCH]-&gt;()&#10;        DELETE r&#10;        WITH u&#10;        MATCH (newBatch:Batch {id: $batchId})&#10;        MERGE (u)-[:IN_BATCH]-&gt;(newBatch)&#10;        &quot;&quot;&quot;)&#10; void updateUserBatch(@Param(&quot;userId&quot;) String userId, @Param(&quot;batchId&quot;) String batchId);&#10;&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})&#10;        OPTIONAL MATCH (u)-[r:HAS_GENDER]-&gt;()&#10;        DELETE r&#10;        WITH u&#10;        MATCH (newGender:Gender {id: $genderId})&#10;        MERGE (u)-[:HAS_GENDER]-&gt;(newGender)&#10;        &quot;&quot;&quot;)&#10; void updateUserGender(@Param(&quot;userId&quot;) String userId, @Param(&quot;genderId&quot;) String genderId);&#10;&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})&#10;        OPTIONAL MATCH (u)-[r:ENROLLED_IN]-&gt;(:Faculty)&#10;        DELETE r&#10;        WITH u&#10;        MATCH (newFaculty:Faculty {id: $facultyId})&#10;        MERGE (u)-[:ENROLLED_IN]-&gt;(newFaculty)&#10;        &quot;&quot;&quot;)&#10; void updateUserFaculty(@Param(&quot;userId&quot;) String userId, @Param(&quot;facultyId&quot;) String facultyId);&#10;&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})&#10;        OPTIONAL MATCH (u)-[r:ENROLLED_IN]-&gt;(:College)&#10;        DELETE r&#10;        WITH u&#10;        MATCH (newCollege:College {id: $collegeId})&#10;        MERGE (u)-[:ENROLLED_IN]-&gt;(newCollege)&#10;        &quot;&quot;&quot;)&#10; void updateUserCollege(@Param(&quot;userId&quot;) String userId, @Param(&quot;collegeId&quot;) String collegeId);&#10;&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})&#10;        OPTIONAL MATCH (u)-[r:WORKS_IN]-&gt;(:Faculty)&#10;        DELETE r&#10;        WITH u&#10;        MATCH (newFaculty:Faculty {id: $facultyId})&#10;        MERGE (u)-[:WORKS_IN]-&gt;(newFaculty)&#10;        &quot;&quot;&quot;)&#10; void updateUserWorkingFaculty(@Param(&quot;userId&quot;) String userId, @Param(&quot;facultyId&quot;) String facultyId);&#10;&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})&#10;        OPTIONAL MATCH (u)-[r:WORKS_IN]-&gt;(:College)&#10;        DELETE r&#10;        WITH u&#10;        MATCH (newCollege:College {id: $collegeId})&#10;        MERGE (u)-[:WORKS_IN]-&gt;(newCollege)&#10;        &quot;&quot;&quot;)&#10; void updateUserWorkingCollege(@Param(&quot;userId&quot;) String userId, @Param(&quot;collegeId&quot;) String collegeId);&#10;&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})&#10;        OPTIONAL MATCH (u)-[r:HAS_DEGREE]-&gt;()&#10;        DELETE r&#10;        WITH u&#10;        MATCH (newDegree:Degree {id: $degreeId})&#10;        MERGE (u)-[:HAS_DEGREE]-&gt;(newDegree)&#10;        &quot;&quot;&quot;)&#10; void updateUserDegree(@Param(&quot;userId&quot;) String userId, @Param(&quot;degreeId&quot;) String degreeId);&#10;&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})&#10;        OPTIONAL MATCH (u)-[r:HAS_POSITION]-&gt;()&#10;        DELETE r&#10;        WITH u&#10;        MATCH (newPosition:Position {id: $positionId})&#10;        MERGE (u)-[:HAS_POSITION]-&gt;(newPosition)&#10;        &quot;&quot;&quot;)&#10; void updateUserPosition(@Param(&quot;userId&quot;) String userId, @Param(&quot;positionId&quot;) String positionId);&#10;&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})&#10;        OPTIONAL MATCH (u)-[r:HAS_ACADEMIC]-&gt;()&#10;        DELETE r&#10;        WITH u&#10;        MATCH (newAcademic:Academic {id: $academicId})&#10;        MERGE (u)-[:HAS_ACADEMIC]-&gt;(newAcademic)&#10;        &quot;&quot;&quot;)&#10; void updateUserAcademic(@Param(&quot;userId&quot;) String userId, @Param(&quot;academicId&quot;) String academicId);&#10;&#10; // Quan hệ bạn bè (Friendship)&#10;&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})-[:FRIEND]-(friend:User)&#10;        RETURN friend&#10;        &quot;&quot;&quot;)&#10; List&lt;UserEntity&gt; findFriends(@Param(&quot;userId&quot;) String userId);&#10;&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u1:User {id: $userId1})-[:FRIEND]-(friend:User),&#10;              (u2:User {id: $userId2})-[:FRIEND]-(friend)&#10;        WHERE friend.id &lt;&gt; $userId1 AND friend.id &lt;&gt; $userId2&#10;        RETURN DISTINCT friend&#10;        &quot;&quot;&quot;)&#10; List&lt;UserEntity&gt; findMutualFriends(@Param(&quot;userId1&quot;) String userId1, @Param(&quot;userId2&quot;) String userId2);&#10;&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u1:User {id: $userId1}), (u2:User {id: $userId2})&#10;        WHERE u1.id &lt;&gt; u2.id&#10;        MERGE (u1)-[:FRIEND_REQUEST {createdAt: datetime(), status: 'PENDING'}]-&gt;(u2)&#10;        &quot;&quot;&quot;)&#10; void sendFriendRequest(@Param(&quot;userId1&quot;) String userId1, @Param(&quot;userId2&quot;) String userId2);&#10;&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u1:User {id: $userId1})-[r:FRIEND_REQUEST {status: 'PENDING'}]-&gt;(u2:User {id: $userId2})&#10;        DELETE r&#10;        MERGE (u1)-[:FRIEND {since: datetime()}]-(u2)&#10;        &quot;&quot;&quot;)&#10; void acceptFriendRequest(@Param(&quot;userId1&quot;) String userId1, @Param(&quot;userId2&quot;) String userId2);&#10;&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u1:User {id: $userId1})-[r:FRIEND_REQUEST]-&gt;(u2:User {id: $userId2})&#10;        DELETE r&#10;        &quot;&quot;&quot;)&#10; void rejectFriendRequest(@Param(&quot;userId1&quot;) String userId1, @Param(&quot;userId2&quot;) String userId2);&#10;&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u1:User {id: $userId1})-[r:FRIEND]-(u2:User {id: $userId2})&#10;        DELETE r&#10;        &quot;&quot;&quot;)&#10; void deleteFriendship(@Param(&quot;userId1&quot;) String userId1, @Param(&quot;userId2&quot;) String userId2);&#10;&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u1:User {id: $userId1})-[:FRIEND]-(u2:User {id: $userId2})&#10;        RETURN COUNT(*) &gt; 0&#10;        &quot;&quot;&quot;)&#10; boolean areFriends(@Param(&quot;userId1&quot;) String userId1, @Param(&quot;userId2&quot;) String userId2);&#10;&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u1:User {id: $userId1})-[:FRIEND_REQUEST {status: 'PENDING'}]-&gt;(u2:User {id: $userId2})&#10;        RETURN COUNT(*) &gt; 0&#10;        &quot;&quot;&quot;)&#10; boolean hasPendingFriendRequest(@Param(&quot;userId1&quot;) String userId1, @Param(&quot;userId2&quot;) String userId2);&#10;&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (sender:User)-[:FRIEND_REQUEST {status: 'PENDING'}]-&gt;(u:User {id: $userId})&#10;        RETURN sender&#10;        &quot;&quot;&quot;)&#10; List&lt;UserEntity&gt; findIncomingFriendRequests(@Param(&quot;userId&quot;) String userId);&#10;&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})-[:FRIEND_REQUEST {status: 'PENDING'}]-&gt;(receiver:User)&#10;        RETURN receiver&#10;        &quot;&quot;&quot;)&#10; List&lt;UserEntity&gt; findOutgoingFriendRequests(@Param(&quot;userId&quot;) String userId);&#10;&#10; // Tìm bạn bè gợi ý dựa trên bạn chung&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})-[:FRIEND]-(friend:User)-[:FRIEND]-(suggestion:User)&#10;        WHERE u.id &lt;&gt; suggestion.id&#10;          AND NOT (u)-[:FRIEND]-(suggestion)&#10;          AND NOT (u)-[:FRIEND_REQUEST]-(suggestion)&#10;        RETURN suggestion, COUNT(*) AS mutualFriends&#10;        ORDER BY mutualFriends DESC&#10;        LIMIT 10&#10;        &quot;&quot;&quot;)&#10; List&lt;UserEntity&gt; findFriendSuggestions(@Param(&quot;userId&quot;) String userId);&#10;&#10; // Tìm kiếm user theo các bộ lọc&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})&#10;        OPTIONAL MATCH (u)-[:ENROLLED_IN]-&gt;(uMajor:Major)&#10;        OPTIONAL MATCH (u)-[:IN_BATCH]-&gt;(uBatch:Batch)&#10;        OPTIONAL MATCH (uMajor)-[:BELONGS_TO]-&gt;(uFaculty:Faculty)&#10;        OPTIONAL MATCH (uFaculty)-[:PART_OF]-&gt;(uCollege:College)&#10;&#10;        MATCH (other:User)&#10;        OPTIONAL MATCH (other)-[:ENROLLED_IN]-&gt;(oMajor:Major)&#10;        OPTIONAL MATCH (other)-[:IN_BATCH]-&gt;(oBatch:Batch)&#10;        OPTIONAL MATCH (oMajor)-[:BELONGS_TO]-&gt;(oFaculty:Faculty)&#10;        OPTIONAL MATCH (oFaculty)-[:PART_OF]-&gt;(oCollege:College)&#10;&#10;        WHERE u.id &lt;&gt; other.id&#10;          AND ($isSameMajor = false OR uMajor.name = oMajor.name)&#10;          AND ($isSameBatch = false OR uBatch.year = oBatch.year)&#10;          AND ($isSameFaculty = false OR uFaculty.name = oFaculty.name)&#10;          AND ($isSameCollege = false OR uCollege.name = oCollege.name)&#10;&#10;        RETURN DISTINCT other&#10;        &quot;&quot;&quot;)&#10; List&lt;UserEntity&gt; findUsersWithFilters(&#10;         @Param(&quot;userId&quot;) String userId,&#10;         @Param(&quot;isSameCollege&quot;) boolean isSameCollege,&#10;         @Param(&quot;isSameFaculty&quot;) boolean isSameFaculty,&#10;         @Param(&quot;isSameMajor&quot;) boolean isSameMajor,&#10;         @Param(&quot;isSameBatch&quot;) boolean isSameBatch);&#10;&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})-[:FRIEND]-(friend:User)&#10;        OPTIONAL MATCH (u)-[:ENROLLED_IN]-&gt;(uMajor:Major)&#10;        OPTIONAL MATCH (friend)-[:ENROLLED_IN]-&gt;(fMajor:Major)&#10;        OPTIONAL MATCH (uMajor)-[:BELONGS_TO]-&gt;(uFaculty:Faculty)&#10;        OPTIONAL MATCH (fMajor)-[:BELONGS_TO]-&gt;(fFaculty:Faculty)&#10;        OPTIONAL MATCH (uFaculty)-[:PART_OF]-&gt;(uCollege:College)&#10;        OPTIONAL MATCH (fFaculty)-[:PART_OF]-&gt;(fCollege:College)&#10;        OPTIONAL MATCH (u)-[:IN_BATCH]-&gt;(uBatch:Batch)&#10;        OPTIONAL MATCH (friend)-[:IN_BATCH]-&gt;(fBatch:Batch)&#10;&#10;        WHERE ($isSameMajor = false OR uMajor.name = fMajor.name)&#10;          AND ($isSameFaculty = false OR uFaculty.name = fFaculty.name)&#10;          AND ($isSameCollege = false OR uCollege.name = fCollege.name)&#10;          AND ($isSameBatch = false OR uBatch.year = fBatch.year)&#10;&#10;        RETURN DISTINCT friend&#10;        &quot;&quot;&quot;)&#10; List&lt;UserEntity&gt; findFriendsWithFilters(&#10;         @Param(&quot;userId&quot;) String userId,&#10;         @Param(&quot;isSameCollege&quot;) boolean isSameCollege,&#10;         @Param(&quot;isSameFaculty&quot;) boolean isSameFaculty,&#10;         @Param(&quot;isSameMajor&quot;) boolean isSameMajor,&#10;         @Param(&quot;isSameBatch&quot;) boolean isSameBatch);&#10;&#10; // Tìm người dùng theo các thuộc tính cụ thể&#10; @Query(&quot;MATCH (u:User)-[:ENROLLED_IN]-&gt;(m:Major {name: $major}) RETURN u&quot;)&#10; List&lt;UserEntity&gt; findByMajor(@Param(&quot;major&quot;) String major);&#10;&#10; @Query(&quot;MATCH (u:User)-[:IN_BATCH]-&gt;(b:Batch {year: $batch}) RETURN u&quot;)&#10; List&lt;UserEntity&gt; findByBatch(@Param(&quot;batch&quot;) int batch);&#10;&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User)-[:ENROLLED_IN]-&gt;(:Major)-[:BELONGS_TO]-&gt;(:Faculty {name: $faculty})&#10;        RETURN u&#10;        &quot;&quot;&quot;)&#10; List&lt;UserEntity&gt; findByFaculty(@Param(&quot;faculty&quot;) String faculty);&#10;&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User)-[:ENROLLED_IN]-&gt;(:Major)-[:BELONGS_TO]-&gt;(:Faculty)-[:PART_OF]-&gt;(:College {name: $college})&#10;        RETURN u&#10;        &quot;&quot;&quot;)&#10; List&lt;UserEntity&gt; findByCollege(@Param(&quot;college&quot;) String college);&#10;&#10; // Tìm user có cùng thuộc tính&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})-[:ENROLLED_IN]-&gt;(m:Major)&lt;-[:ENROLLED_IN]-(other:User)&#10;        WHERE u.id &lt;&gt; other.id&#10;        RETURN other&#10;        &quot;&quot;&quot;)&#10; List&lt;UserEntity&gt; findUsersWithSameMajor(@Param(&quot;userId&quot;) String userId);&#10;&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})-[:IN_BATCH]-&gt;(b:Batch)&lt;-[:IN_BATCH]-(other:User)&#10;        WHERE u.id &lt;&gt; other.id&#10;        RETURN other&#10;        &quot;&quot;&quot;)&#10; List&lt;UserEntity&gt; findUsersWithSameBatch(@Param(&quot;userId&quot;) String userId);&#10;&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})-[:ENROLLED_IN]-&gt;(:Major)-[:BELONGS_TO]-&gt;(f:Faculty)&#10;        MATCH (other:User)-[:ENROLLED_IN]-&gt;(:Major)-[:BELONGS_TO]-&gt;(f)&#10;        WHERE other.id &lt;&gt; $userId&#10;        RETURN other&#10;        &quot;&quot;&quot;)&#10; List&lt;UserEntity&gt; findUsersWithSameFaculty(@Param(&quot;userId&quot;) String userId);&#10;&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})-[:ENROLLED_IN]-&gt;(:Major)-[:BELONGS_TO]-&gt;(:Faculty)-[:PART_OF]-&gt;(c:College)&#10;        MATCH (other:User)-[:ENROLLED_IN]-&gt;(:Major)-[:BELONGS_TO]-&gt;(:Faculty)-[:PART_OF]-&gt;(c)&#10;        WHERE other.id &lt;&gt; $userId&#10;        RETURN other&#10;        &quot;&quot;&quot;)&#10; List&lt;UserEntity&gt; findUsersWithSameCollege(@Param(&quot;userId&quot;) String userId);&#10;&#10; // ========================= ADDITIONAL METHODS FOR USERSERVICE =========================&#10;    &#10;    /**&#10;     * Find users by faculty ID&#10;     */&#10;    @Query(&quot;MATCH (u:User)-[:WORKS_IN]-&gt;(f:Faculty {id: $facultyId}) RETURN u&quot;)&#10;    List&lt;UserEntity&gt; findByFacultyId(@Param(&quot;facultyId&quot;) String facultyId);&#10;    &#10;    /**&#10;     * Find users by major ID&#10;     */&#10;    @Query(&quot;MATCH (u:User)-[:ENROLLED_IN]-&gt;(m:Major {id: $majorId}) RETURN u&quot;)&#10;    List&lt;UserEntity&gt; findByMajorId(@Param(&quot;majorId&quot;) String majorId);&#10;    &#10;    /**&#10;     * Find users by full name containing (case insensitive)&#10;     */&#10;    @Query(&quot;MATCH (u:User) WHERE toLower(u.fullName) CONTAINS toLower($name) RETURN u&quot;)&#10;    List&lt;UserEntity&gt; findByFullNameContainingIgnoreCase(@Param(&quot;name&quot;) String name);&#10;    &#10;    /**&#10;     * Find users by college ID&#10;     */&#10;    @Query(&quot;MATCH (u:User)-[:BELONGS_TO]-&gt;(c:College {id: $collegeId}) RETURN u&quot;)&#10;    List&lt;UserEntity&gt; findByCollegeId(@Param(&quot;collegeId&quot;) String collegeId);&#10;    &#10;    /**&#10;     * Find users by batch ID&#10;     */&#10;    @Query(&quot;MATCH (u:User)-[:IN_BATCH]-&gt;(b:Batch {id: $batchId}) RETURN u&quot;)&#10;    List&lt;UserEntity&gt; findByBatchId(@Param(&quot;batchId&quot;) String batchId);&#10;    &#10;    /**&#10;     * Find users by gender ID&#10;     */&#10;    @Query(&quot;MATCH (u:User)-[:HAS_GENDER]-&gt;(g:Gender {id: $genderId}) RETURN u&quot;)&#10;    List&lt;UserEntity&gt; findByGenderId(@Param(&quot;genderId&quot;) String genderId);&#10;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/user-service/src/main/java/com/ctuconnect/service/SocialGraphService.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/user-service/src/main/java/com/ctuconnect/service/SocialGraphService.java" />
              <option name="originalContent" value="package com.ctuconnect.service;&#10;&#10;import com.ctuconnect.entity.UserEntity;&#10;import com.ctuconnect.dto.FriendSuggestionDTO;&#10;import com.ctuconnect.dto.UserDTO;&#10;import com.ctuconnect.repository.UserRepository;&#10;import lombok.RequiredArgsConstructor;&#10;import lombok.extern.slf4j.Slf4j;&#10;import org.springframework.data.neo4j.core.Neo4jTemplate;&#10;import org.springframework.data.redis.core.RedisTemplate;&#10;import org.springframework.stereotype.Service;&#10;&#10;import java.time.LocalDateTime;&#10;import java.util.*;&#10;import java.util.stream.Collectors;&#10;import java.util.concurrent.TimeUnit;&#10;&#10;@Service&#10;@RequiredArgsConstructor&#10;@Slf4j&#10;public class SocialGraphService {&#10;&#10;    private final UserRepository userRepository;&#10;    private final Neo4jTemplate neo4jTemplate;&#10;    private final RedisTemplate&lt;String, Object&gt; redisTemplate;&#10;&#10;    private static final String FRIEND_SUGGESTIONS_CACHE = &quot;friend_suggestions:&quot;;&#10;    private static final String MUTUAL_FRIENDS_CACHE = &quot;mutual_friends:&quot;;&#10;    private static final int CACHE_TTL_HOURS = 6;&#10;&#10;    /**&#10;     * Facebook-like friend suggestion algorithm using multiple signals&#10;     */&#10;    public List&lt;FriendSuggestionDTO&gt; getFriendSuggestions(String userId, int limit) {&#10;        String cacheKey = FRIEND_SUGGESTIONS_CACHE + userId;&#10;&#10;        // Try cache first&#10;        List&lt;FriendSuggestionDTO&gt; cached = getCachedSuggestions(cacheKey);&#10;        if (cached != null &amp;&amp; !cached.isEmpty()) {&#10;            return cached.stream().limit(limit).collect(Collectors.toList());&#10;        }&#10;&#10;        UserEntity currentUser = userRepository.findById(userId)&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;User not found&quot;));&#10;&#10;        List&lt;FriendSuggestionDTO&gt; suggestions = new ArrayList&lt;&gt;();&#10;&#10;        // 1. Mutual friends suggestions (highest priority)&#10;        suggestions.addAll(getMutualFriendsSuggestions(currentUser, 20));&#10;&#10;        // 2. Academic connections (same faculty, major, batch)&#10;        suggestions.addAll(getAcademicConnectionSuggestions(currentUser, 15));&#10;&#10;        // 3. Friends of friends&#10;        suggestions.addAll(getFriendsOfFriendsSuggestions(currentUser, 15));&#10;&#10;        // 4. People who viewed your profile&#10;        suggestions.addAll(getProfileViewersSuggestions(currentUser, 10));&#10;&#10;        // 5. Similar interests/activities&#10;        suggestions.addAll(getSimilarInterestsSuggestions(currentUser, 10));&#10;&#10;        // Remove duplicates and rank by relevance score&#10;        Map&lt;String, FriendSuggestionDTO&gt; uniqueSuggestions = suggestions.stream()&#10;                .filter(suggestion -&gt; !suggestion.getUserId().equals(userId))&#10;                .filter(suggestion -&gt; !isAlreadyConnected(userId, suggestion.getUserId()))&#10;                .collect(Collectors.toMap(&#10;                    FriendSuggestionDTO::getUserId,&#10;                    suggestion -&gt; suggestion,&#10;                    (existing, replacement) -&gt; {&#10;                        // Keep the one with higher relevance score&#10;                        return existing.getRelevanceScore() &gt; replacement.getRelevanceScore()&#10;                            ? existing : replacement;&#10;                    }&#10;                ));&#10;&#10;        List&lt;FriendSuggestionDTO&gt; rankedSuggestions = uniqueSuggestions.values().stream()&#10;                .sorted((a, b) -&gt; Double.compare(b.getRelevanceScore(), a.getRelevanceScore()))&#10;                .limit(limit)&#10;                .collect(Collectors.toList());&#10;&#10;        // Cache the results&#10;        cacheSuggestions(cacheKey, rankedSuggestions);&#10;&#10;        return rankedSuggestions;&#10;    }&#10;&#10;    /**&#10;     * Get mutual friends suggestions with high relevance&#10;     */&#10;    private List&lt;FriendSuggestionDTO&gt; getMutualFriendsSuggestions(UserEntity user, int limit) {&#10;        String query = &quot;&quot;&quot;&#10;            MATCH (u:User {id: $userId})-[:FRIENDS_WITH]-(friend:User)-[:FRIENDS_WITH]-(suggestion:User)&#10;            WHERE NOT (u)-[:FRIENDS_WITH]-(suggestion)&#10;            AND u.id &lt;&gt; suggestion.id&#10;            AND NOT (u)-[:BLOCKED]-(suggestion)&#10;            WITH suggestion, COUNT(friend) as mutualCount&#10;            WHERE mutualCount &gt;= 2&#10;            RETURN suggestion, mutualCount&#10;            ORDER BY mutualCount DESC&#10;                    return FriendSuggestionDTO.builder()&#10;                            .userId(suggestedUser.getId())&#10;                            .username(suggestedUser.getUsername())&#10;                            .fullName(suggestedUser.getFullName())&#10;                            .avatarUrl(suggestedUser.getAvatarUrl())&#10;                            .mutualFriendsCount(mutualCount)&#10;                            .suggestionReason(&quot;You have &quot; + mutualCount + &quot; mutual friends&quot;)&#10;                            .relevanceScore(calculateMutualFriendsScore(mutualCount))&#10;                            .suggestionType(FriendSuggestionDTO.SuggestionType.MUTUAL_FRIENDS)&#10;                            .build();&#10;                })&#10;                .collect(Collectors.toList());&#10;        Map&lt;String, Object&gt; params = Map.of(&#10;            &quot;userId&quot;, user.getId(),&#10;            &quot;limit&quot;, limit&#10;        );&#10;&#10;        return neo4jTemplate.findAll(query, params).stream()&#10;                .map(record -&gt; {&#10;                    UserEntity suggestedUser = (UserEntity) record.get(&quot;suggestion&quot;);&#10;                    int mutualCount = ((Number) record.get(&quot;mutualCount&quot;)).intValue();&#10;&#10;                    return FriendSuggestionDTO.builder()&#10;        String query = &quot;&quot;&quot;&#10;            MATCH (u:User {id: $userId}), (suggestion:User)&#10;            WHERE u.id &lt;&gt; suggestion.id&#10;            AND NOT (u)-[:FRIENDS_WITH]-(suggestion)&#10;            AND NOT (u)-[:BLOCKED]-(suggestion)&#10;            AND (&#10;                (u.facultyId = suggestion.facultyId AND u.facultyId IS NOT NULL) OR&#10;                (u.majorId = suggestion.majorId AND u.majorId IS NOT NULL) OR&#10;                (u.batchId = suggestion.batchId AND u.batchId IS NOT NULL)&#10;            )&#10;            WITH suggestion,&#10;                 CASE WHEN u.batchId = suggestion.batchId THEN 3 ELSE 0 END +&#10;                 CASE WHEN u.majorId = suggestion.majorId THEN 2 ELSE 0 END +&#10;                 CASE WHEN u.facultyId = suggestion.facultyId THEN 1 ELSE 0 END as academicScore&#10;            WHERE academicScore &gt; 0&#10;            RETURN suggestion, academicScore&#10;            ORDER BY academicScore DESC&#10;            LIMIT $limit&#10;            &quot;&quot;&quot;;&#10;&#10;    /**&#10;     * Friends of friends suggestions&#10;     */&#10;    private List&lt;FriendSuggestionDTO&gt; getFriendsOfFriendsSuggestions(UserEntity user, int limit) {&#10;        String query = &quot;&quot;&quot;&#10;            MATCH (u:User {id: $userId})-[:FRIENDS_WITH*2]-(suggestion:User)&#10;            WHERE NOT (u)-[:FRIENDS_WITH]-(suggestion)&#10;            AND u.id &lt;&gt; suggestion.id&#10;            AND NOT (u)-[:BLOCKED]-(suggestion)&#10;            WITH suggestion, COUNT(*) as connectionPaths&#10;            RETURN suggestion, connectionPaths&#10;            ORDER BY connectionPaths DESC&#10;            LIMIT $limit&#10;            &quot;&quot;&quot;;&#10;&#10;        Map&lt;String, Object&gt; params = Map.of(&#10;            &quot;userId&quot;, user.getId(),&#10;            &quot;limit&quot;, limit&#10;        );&#10;&#10;        return neo4jTemplate.findAll(query, params).stream()&#10;                .map(record -&gt; {&#10;                    UserEntity suggestedUser = (UserEntity) record.get(&quot;suggestion&quot;);&#10;                    int paths = ((Number) record.get(&quot;connectionPaths&quot;)).intValue();&#10;&#10;                    return FriendSuggestionDTO.builder()&#10;                            .userId(suggestedUser.getId())&#10;                            .username(suggestedUser.getUsername())&#10;                            .fullName(suggestedUser.getFullName())&#10;                            .avatarUrl(suggestedUser.getAvatarUrl())&#10;                            .suggestionReason(&quot;Friend of a friend&quot;)&#10;                            .relevanceScore(calculateFriendsOfFriendsScore(paths))&#10;                            .suggestionType(FriendSuggestionDTO.SuggestionType.FRIENDS_OF_FRIENDS)&#10;        String query = &quot;&quot;&quot;&#10;            MATCH (viewer:User)-[v:VIEWED_PROFILE]-&gt;(u:User {id: $userId})&#10;            WHERE NOT (u)-[:FRIENDS_WITH]-(viewer)&#10;            AND u.id &lt;&gt; viewer.id&#10;            AND NOT (u)-[:BLOCKED]-(viewer)&#10;            AND v.viewedAt &gt; datetime() - duration('P7D')&#10;            WITH viewer, COUNT(v) as viewCount&#10;            RETURN viewer, viewCount&#10;            ORDER BY viewCount DESC&#10;            LIMIT $limit&#10;            &quot;&quot;&quot;;&#10;&#10;        Map&lt;String, Object&gt; params = Map.of(&#10;            &quot;userId&quot;, user.getId(),&#10;            &quot;limit&quot;, limit&#10;        );&#10;&#10;                    return FriendSuggestionDTO.builder()&#10;        return neo4jTemplate.findAll(query, params).stream()&#10;                .map(record -&gt; {&#10;                    UserEntity viewer = (UserEntity) record.get(&quot;viewer&quot;);&#10;&#10;                    return FriendSuggestionDTO.builder()&#10;                            .userId(viewer.getId())&#10;                            .username(viewer.getUsername())&#10;                            .fullName(viewer.getFullName())&#10;                            .avatarUrl(viewer.getAvatarUrl())&#10;                            .suggestionReason(&quot;Viewed your profile recently&quot;)&#10;                            .relevanceScore(0.6)&#10;                            .suggestionType(FriendSuggestionDTO.SuggestionType.PROFILE_VIEWER)&#10;                            .build();&#10;                })&#10;                .collect(Collectors.toList());&#10;                })&#10;                .collect(Collectors.toList());&#10;    }&#10;&#10;    /**&#10;     * Friends of friends suggestions&#10;        Map&lt;String, Object&gt; params = Map.of(&#10;            &quot;userId1&quot;, userId1,&#10;            &quot;userId2&quot;, userId2&#10;        );&#10;&#10;        return neo4jTemplate.findOne(query, params)&#10;                .map(record -&gt; (Boolean) record.get(&quot;connected&quot;))&#10;                .orElse(false);&#10;            MATCH (u1:User {id: $userId1})-[r:FRIENDS_WITH|FRIEND_REQUEST_SENT|FRIEND_REQUEST_RECEIVED]-(u2:User {id: $userId2})&#10;            RETURN COUNT(r) &gt; 0 as connected&#10;            &quot;&quot;&quot;;&#10;            AND NOT (u)-[:BLOCKED]-(suggestion)&#10;            WITH suggestion, COUNT(*) as connectionPaths&#10;            RETURN suggestion, connectionPaths&#10;            ORDER BY connectionPaths DESC&#10;        Map&lt;String, Object&gt; params = Map.of(&#10;            &quot;userId1&quot;, userId1,&#10;            &quot;userId2&quot;, userId2&#10;        );&#10;            RETURN COUNT(mutual) as mutualCount&#10;            &quot;&quot;&quot;;&#10;            &quot;userId&quot;, user.getId(),&#10;        Integer count = neo4jTemplate.findOne(query, params)&#10;                .map(record -&gt; ((Number) record.get(&quot;mutualCount&quot;)).intValue())&#10;        // Cache for 1 hour&#10;        redisTemplate.opsForValue().set(cacheKey, count, 1, TimeUnit.HOURS);&#10;                .map(record -&gt; {&#10;        return count;&#10;            // Cache for 1 hour&#10;            redisTemplate.opsForValue().set(cacheKey, count, 1, TimeUnit.HOURS);&#10;&#10;                    UserEntity suggestedUser = (UserEntity) record.get(&quot;suggestion&quot;);&#10;                    int paths = ((Number) record.get(&quot;connectionPaths&quot;)).intValue();&#10;&#10;                    return FriendSuggestionDTO.builder()&#10;                            .userId(suggestedUser.getId())&#10;                            .username(suggestedUser.getUsername())&#10;                            .fullName(suggestedUser.getFullName())&#10;                            .avatarUrl(suggestedUser.getAvatarUrl())&#10;                            .suggestionReason(&quot;Friend of a friend&quot;)&#10;                            .relevanceScore(calculateFriendsOfFriendsScore(paths))&#10;                            .suggestionType(FriendSuggestionDTO.SuggestionType.FRIENDS_OF_FRIENDS)&#10;        String query = &quot;&quot;&quot;&#10;            MATCH (viewer:User)-[v:VIEWED_PROFILE]-&gt;(u:User {id: $userId})&#10;            WHERE NOT (u)-[:FRIENDS_WITH]-(viewer)&#10;            AND u.id &lt;&gt; viewer.id&#10;            AND NOT (u)-[:BLOCKED]-(viewer)&#10;            AND v.viewedAt &gt; datetime() - duration('P7D')&#10;            WITH viewer, COUNT(v) as viewCount&#10;            RETURN viewer, viewCount&#10;            ORDER BY viewCount DESC&#10;            LIMIT $limit&#10;            &quot;&quot;&quot;;&#10;&#10;        Map&lt;String, Object&gt; params = Map.of(&#10;            &quot;userId&quot;, user.getId(),&#10;            &quot;limit&quot;, limit&#10;        );&#10;&#10;        return neo4jTemplate.findAll(query, params).stream()&#10;                .map(record -&gt; {&#10;                    UserEntity viewer = (UserEntity) record.get(&quot;viewer&quot;);&#10;&#10;                    return FriendSuggestionDTO.builder()&#10;                            .userId(viewer.getId())&#10;                            .username(viewer.getUsername())&#10;                            .fullName(viewer.getFullName())&#10;                            .avatarUrl(viewer.getAvatarUrl())&#10;        if (!keys.isEmpty()) {&#10;                            .relevanceScore(0.6)&#10;                            .suggestionType(FriendSuggestionDTO.SuggestionType.PROFILE_VIEWER)&#10;                            .build();&#10;                })&#10;                .collect(Collectors.toList());&#10;    }&#10;&#10;    /**&#10;     * People who viewed your profile&#10;     */&#10;    private List&lt;FriendSuggestionDTO&gt; getProfileViewersSuggestions(UserEntity user, int limit) {&#10;        // This would typically require profile view tracking&#10;        // For now, returning empty list as this feature requires additional implementation&#10;        return new ArrayList&lt;&gt;();&#10;        String query = &quot;&quot;&quot;&#10;            MATCH (u1:User {id: $userId1})-[r:FRIENDS_WITH|FRIEND_REQUEST_SENT|FRIEND_REQUEST_RECEIVED]-(u2:User {id: $userId2})&#10;            RETURN COUNT(r) &gt; 0 as connected&#10;            &quot;&quot;&quot;;&#10;&#10;        Map&lt;String, Object&gt; params = Map.of(&#10;            &quot;userId1&quot;, userId1,&#10;            &quot;userId2&quot;, userId2&#10;        );&#10;&#10;        return neo4jTemplate.findOne(query, params)&#10;                .map(record -&gt; (Boolean) record.get(&quot;connected&quot;))&#10;                .orElse(false);&#10;        return new ArrayList&lt;&gt;();&#10;    }&#10;&#10;    /**&#10;     * Calculate mutual friends count between two users&#10;     */&#10;        String query = &quot;&quot;&quot;&#10;            MATCH (u1:User {id: $userId1})-[:FRIENDS_WITH]-(mutual:User)-[:FRIENDS_WITH]-(u2:User {id: $userId2})&#10;            RETURN COUNT(mutual) as mutualCount&#10;            &quot;&quot;&quot;;&#10;&#10;        Map&lt;String, Object&gt; params = Map.of(&#10;            &quot;userId1&quot;, userId1,&#10;            &quot;userId2&quot;, userId2&#10;        );&#10;&#10;        Integer count = neo4jTemplate.findOne(query, params)&#10;                .map(record -&gt; ((Number) record.get(&quot;mutualCount&quot;)).intValue())&#10;                .orElse(0);&#10;&#10;        // Cache for 1 hour&#10;        redisTemplate.opsForValue().set(cacheKey, count, 1, TimeUnit.HOURS);&#10;&#10;        return count;&#10;            // Cache for 1 hour&#10;            redisTemplate.opsForValue().set(cacheKey, count, 1, TimeUnit.HOURS);&#10;&#10;            return count;&#10;        } catch (Exception e) {&#10;            log.warn(&quot;Failed to get mutual friends count: {}&quot;, e.getMessage());&#10;            return 0;&#10;        }&#10;    }&#10;&#10;    private boolean isAlreadyConnected(String userId1, String userId2) {&#10;        try {&#10;            return userRepository.areFriends(userId1, userId2) ||&#10;                   userRepository.hasPendingFriendRequest(userId1, userId2) ||&#10;                   userRepository.hasPendingFriendRequest(userId2, userId1);&#10;        } catch (Exception e) {&#10;            log.warn(&quot;Failed to check connection status: {}&quot;, e.getMessage());&#10;            return false;&#10;        }&#10;    }&#10;&#10;    private double calculateMutualFriendsScore(int mutualCount) {&#10;        // Higher mutual friends = higher relevance&#10;        return Math.min(1.0, mutualCount / 10.0);&#10;    }&#10;&#10;    private double calculateAcademicScore(int academicScore) {&#10;        return academicScore / 6.0; // Max score is 6 (3+2+1)&#10;    }&#10;&#10;    private double calculateFriendsOfFriendsScore(int paths) {&#10;        return Math.min(0.7, paths / 5.0);&#10;    }&#10;&#10;    private String buildAcademicReason(UserEntity user, UserEntity suggestion) {&#10;        List&lt;String&gt; connections = new ArrayList&lt;&gt;();&#10;&#10;        if (Objects.equals(user.getBatchId(), suggestion.getBatchId())) {&#10;            connections.add(&quot;same batch&quot;);&#10;        }&#10;        if (!keys.isEmpty()) {&#10;            connections.add(&quot;same major&quot;);&#10;        }&#10;        if (Objects.equals(user.getFacultyId(), suggestion.getFacultyId())) {&#10;            connections.add(&quot;same faculty&quot;);&#10;        }&#10;&#10;        return &quot;You share &quot; + String.join(&quot;, &quot;, connections);&#10;    }&#10;&#10;    private List&lt;FriendSuggestionDTO&gt; getCachedSuggestions(String cacheKey) {&#10;        try {&#10;            return (List&lt;FriendSuggestionDTO&gt;) redisTemplate.opsForValue().get(cacheKey);&#10;        } catch (Exception e) {&#10;            log.warn(&quot;Failed to get cached suggestions: {}&quot;, e.getMessage());&#10;            return null;&#10;        }&#10;    }&#10;&#10;    private void cacheSuggestions(String cacheKey, List&lt;FriendSuggestionDTO&gt; suggestions) {&#10;        try {&#10;            redisTemplate.opsForValue().set(cacheKey, suggestions, CACHE_TTL_HOURS, TimeUnit.HOURS);&#10;        } catch (Exception e) {&#10;            log.warn(&quot;Failed to cache suggestions: {}&quot;, e.getMessage());&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Invalidate friend suggestions cache when user relationships change&#10;     */&#10;    public void invalidateFriendSuggestionsCache(String userId) {&#10;        String pattern = FRIEND_SUGGESTIONS_CACHE + userId;&#10;        redisTemplate.delete(pattern);&#10;&#10;        // Also invalidate mutual friends cache for this user&#10;        String mutualPattern = MUTUAL_FRIENDS_CACHE + userId + &quot;:*&quot;;&#10;        Set&lt;String&gt; keys = redisTemplate.keys(mutualPattern);&#10;        if (keys != null &amp;&amp; !keys.isEmpty()) {&#10;            redisTemplate.delete(keys);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.ctuconnect.service;&#13;&#10;&#13;&#10;import com.ctuconnect.entity.UserEntity;&#13;&#10;import com.ctuconnect.dto.FriendSuggestionDTO;&#13;&#10;import com.ctuconnect.dto.UserDTO;&#13;&#10;import com.ctuconnect.repository.UserRepository;&#13;&#10;import lombok.RequiredArgsConstructor;&#13;&#10;import lombok.extern.slf4j.Slf4j;&#13;&#10;import org.springframework.data.neo4j.core.Neo4jTemplate;&#13;&#10;import org.springframework.data.redis.core.RedisTemplate;&#13;&#10;import org.springframework.stereotype.Service;&#13;&#10;&#13;&#10;import java.time.LocalDateTime;&#13;&#10;import java.util.*;&#13;&#10;import java.util.stream.Collectors;&#13;&#10;import java.util.concurrent.TimeUnit;&#13;&#10;&#13;&#10;@Service&#13;&#10;@RequiredArgsConstructor&#13;&#10;@Slf4j&#13;&#10;public class SocialGraphService {&#13;&#10;&#13;&#10;    private final UserRepository userRepository;&#13;&#10;    private final Neo4jTemplate neo4jTemplate;&#13;&#10;    private final RedisTemplate&lt;String, Object&gt; redisTemplate;&#13;&#10;&#13;&#10;    private static final String FRIEND_SUGGESTIONS_CACHE = &quot;friend_suggestions:&quot;;&#13;&#10;    private static final String MUTUAL_FRIENDS_CACHE = &quot;mutual_friends:&quot;;&#13;&#10;    private static final int CACHE_TTL_HOURS = 6;&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Facebook-like friend suggestion algorithm using multiple signals&#13;&#10;     */&#13;&#10;    public List&lt;FriendSuggestionDTO&gt; getFriendSuggestions(String userId, int limit) {&#13;&#10;        String cacheKey = FRIEND_SUGGESTIONS_CACHE + userId;&#13;&#10;&#13;&#10;        // Try cache first&#13;&#10;        List&lt;FriendSuggestionDTO&gt; cached = getCachedSuggestions(cacheKey);&#13;&#10;        if (cached != null &amp;&amp; !cached.isEmpty()) {&#13;&#10;            return cached.stream().limit(limit).collect(Collectors.toList());&#13;&#10;        }&#13;&#10;&#13;&#10;        UserEntity currentUser = userRepository.findById(userId)&#13;&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;User not found&quot;));&#13;&#10;&#13;&#10;        List&lt;FriendSuggestionDTO&gt; suggestions = new ArrayList&lt;&gt;();&#13;&#10;&#13;&#10;        // 1. Mutual friends suggestions (highest priority)&#13;&#10;        suggestions.addAll(getMutualFriendsSuggestions(currentUser, 20));&#13;&#10;&#13;&#10;        // 2. Academic connections (same faculty, major, batch)&#13;&#10;        suggestions.addAll(getAcademicConnectionSuggestions(currentUser, 15));&#13;&#10;&#13;&#10;        // 3. Friends of friends&#13;&#10;        suggestions.addAll(getFriendsOfFriendsSuggestions(currentUser, 15));&#13;&#10;&#13;&#10;        // 4. People who viewed your profile&#13;&#10;        suggestions.addAll(getProfileViewersSuggestions(currentUser, 10));&#13;&#10;&#13;&#10;        // 5. Similar interests/activities&#13;&#10;        suggestions.addAll(getSimilarInterestsSuggestions(currentUser, 10));&#13;&#10;&#13;&#10;        // Remove duplicates and rank by relevance score&#13;&#10;        Map&lt;String, FriendSuggestionDTO&gt; uniqueSuggestions = suggestions.stream()&#13;&#10;                .filter(suggestion -&gt; !suggestion.getUserId().equals(userId))&#13;&#10;                .filter(suggestion -&gt; !isAlreadyConnected(userId, suggestion.getUserId()))&#13;&#10;                .collect(Collectors.toMap(&#13;&#10;                    FriendSuggestionDTO::getUserId,&#13;&#10;                    suggestion -&gt; suggestion,&#13;&#10;                    (existing, replacement) -&gt; {&#13;&#10;                        // Keep the one with higher relevance score&#13;&#10;                        return existing.getRelevanceScore() &gt; replacement.getRelevanceScore()&#13;&#10;                            ? existing : replacement;&#13;&#10;                    }&#13;&#10;                ));&#13;&#10;&#13;&#10;        List&lt;FriendSuggestionDTO&gt; rankedSuggestions = uniqueSuggestions.values().stream()&#13;&#10;                .sorted((a, b) -&gt; Double.compare(b.getRelevanceScore(), a.getRelevanceScore()))&#13;&#10;                .limit(limit)&#13;&#10;                .collect(Collectors.toList());&#13;&#10;&#13;&#10;        // Cache the results&#13;&#10;        cacheSuggestions(cacheKey, rankedSuggestions);&#13;&#10;&#13;&#10;        return rankedSuggestions;&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Get mutual friends suggestions with high relevance&#13;&#10;     */&#13;&#10;    private List&lt;FriendSuggestionDTO&gt; getMutualFriendsSuggestions(UserEntity user, int limit) {&#13;&#10;        // Use repository method instead of direct Neo4j queries&#13;&#10;        try {&#13;&#10;            List&lt;UserEntity&gt; mutualFriendSuggestions = userRepository.findFriendSuggestions(user.getId());&#13;&#10;&#13;&#10;            return mutualFriendSuggestions.stream()&#13;&#10;                    .limit(limit)&#13;&#10;                    .map(suggestedUser -&gt; {&#13;&#10;                        int mutualCount = getMutualFriendsCount(user.getId(), suggestedUser.getId());&#13;&#10;&#13;&#10;                        return FriendSuggestionDTO.builder()&#13;&#10;                                .userId(suggestedUser.getId())&#13;&#10;                                .username(suggestedUser.getUsername())&#13;&#10;                                .fullName(suggestedUser.getFullName())&#13;&#10;                                .avatarUrl(suggestedUser.getAvatarUrl())&#13;&#10;                                .mutualFriendsCount(mutualCount)&#13;&#10;                                .suggestionReason(&quot;You have &quot; + mutualCount + &quot; mutual friends&quot;)&#13;&#10;                                .relevanceScore(calculateMutualFriendsScore(mutualCount))&#13;&#10;                                .suggestionType(FriendSuggestionDTO.SuggestionType.MUTUAL_FRIENDS)&#13;&#10;                                .build();&#13;&#10;                    })&#13;&#10;                    .collect(Collectors.toList());&#13;&#10;        } catch (Exception e) {&#13;&#10;            log.warn(&quot;Failed to get mutual friends suggestions: {}&quot;, e.getMessage());&#13;&#10;            return new ArrayList&lt;&gt;();&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Academic connections (same faculty, major, batch)&#13;&#10;     */&#13;&#10;    private List&lt;FriendSuggestionDTO&gt; getAcademicConnectionSuggestions(UserEntity user, int limit) {&#13;&#10;        List&lt;FriendSuggestionDTO&gt; suggestions = new ArrayList&lt;&gt;();&#13;&#10;&#13;&#10;        try {&#13;&#10;            // Get users from same faculty&#13;&#10;            if (user.getFacultyId() != null) {&#13;&#10;                List&lt;UserEntity&gt; sameFacultyUsers = userRepository.findByFacultyId(user.getFacultyId());&#13;&#10;                suggestions.addAll(sameFacultyUsers.stream()&#13;&#10;                        .filter(u -&gt; !u.getId().equals(user.getId()))&#13;&#10;                        .limit(limit / 3)&#13;&#10;                        .map(suggestedUser -&gt; FriendSuggestionDTO.builder()&#13;&#10;                                .userId(suggestedUser.getId())&#13;&#10;                                .username(suggestedUser.getUsername())&#13;&#10;                                .fullName(suggestedUser.getFullName())&#13;&#10;                                .avatarUrl(suggestedUser.getAvatarUrl())&#13;&#10;                                .suggestionReason(&quot;Same faculty: &quot; + user.getFacultyName())&#13;&#10;                                .relevanceScore(calculateAcademicScore(2))&#13;&#10;                                .suggestionType(FriendSuggestionDTO.SuggestionType.ACADEMIC_CONNECTION)&#13;&#10;                                .build())&#13;&#10;                        .collect(Collectors.toList()));&#13;&#10;            }&#13;&#10;&#13;&#10;            // Get users from same major&#13;&#10;            if (user.getMajorId() != null) {&#13;&#10;                List&lt;UserEntity&gt; sameMajorUsers = userRepository.findByMajorId(user.getMajorId());&#13;&#10;                suggestions.addAll(sameMajorUsers.stream()&#13;&#10;                        .filter(u -&gt; !u.getId().equals(user.getId()))&#13;&#10;                        .limit(limit / 3)&#13;&#10;                        .map(suggestedUser -&gt; FriendSuggestionDTO.builder()&#13;&#10;                                .userId(suggestedUser.getId())&#13;&#10;                                .username(suggestedUser.getUsername())&#13;&#10;                                .fullName(suggestedUser.getFullName())&#13;&#10;                                .avatarUrl(suggestedUser.getAvatarUrl())&#13;&#10;                                .suggestionReason(&quot;Same major: &quot; + user.getMajorName())&#13;&#10;                                .relevanceScore(calculateAcademicScore(3))&#13;&#10;                                .suggestionType(FriendSuggestionDTO.SuggestionType.ACADEMIC_CONNECTION)&#13;&#10;                                .build())&#13;&#10;                        .collect(Collectors.toList()));&#13;&#10;            }&#13;&#10;        } catch (Exception e) {&#13;&#10;            log.warn(&quot;Failed to get academic connection suggestions: {}&quot;, e.getMessage());&#13;&#10;        }&#13;&#10;&#13;&#10;        return suggestions;&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Friends of friends suggestions&#13;&#10;     */&#13;&#10;    private List&lt;FriendSuggestionDTO&gt; getFriendsOfFriendsSuggestions(UserEntity user, int limit) {&#13;&#10;        try {&#13;&#10;            // Get friends of the current user&#13;&#10;            List&lt;UserEntity&gt; friends = userRepository.findFriends(user.getId());&#13;&#10;            List&lt;FriendSuggestionDTO&gt; suggestions = new ArrayList&lt;&gt;();&#13;&#10;&#13;&#10;            for (UserEntity friend : friends) {&#13;&#10;                List&lt;UserEntity&gt; friendsOfFriend = userRepository.findFriends(friend.getId());&#13;&#10;&#13;&#10;                for (UserEntity suggestion : friendsOfFriend) {&#13;&#10;                    if (!suggestion.getId().equals(user.getId()) &amp;&amp;&#13;&#10;                        !userRepository.areFriends(user.getId(), suggestion.getId())) {&#13;&#10;&#13;&#10;                        suggestions.add(FriendSuggestionDTO.builder()&#13;&#10;                                .userId(suggestion.getId())&#13;&#10;                                .username(suggestion.getUsername())&#13;&#10;                                .fullName(suggestion.getFullName())&#13;&#10;                                .avatarUrl(suggestion.getAvatarUrl())&#13;&#10;                                .suggestionReason(&quot;Friend of &quot; + friend.getFullName())&#13;&#10;                                .relevanceScore(calculateFriendsOfFriendsScore(1))&#13;&#10;                                .suggestionType(FriendSuggestionDTO.SuggestionType.FRIENDS_OF_FRIENDS)&#13;&#10;                                .build());&#13;&#10;                    }&#13;&#10;                }&#13;&#10;            }&#13;&#10;&#13;&#10;            return suggestions.stream()&#13;&#10;                    .limit(limit)&#13;&#10;                    .collect(Collectors.toList());&#13;&#10;&#13;&#10;        } catch (Exception e) {&#13;&#10;            log.warn(&quot;Failed to get friends of friends suggestions: {}&quot;, e.getMessage());&#13;&#10;            return new ArrayList&lt;&gt;();&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * People who viewed your profile&#13;&#10;     */&#13;&#10;    private List&lt;FriendSuggestionDTO&gt; getProfileViewersSuggestions(UserEntity user, int limit) {&#13;&#10;        // This would typically require profile view tracking&#13;&#10;        // For now, returning empty list as this feature requires additional implementation&#13;&#10;        return new ArrayList&lt;&gt;();&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Similar interests suggestions&#13;&#10;     */&#13;&#10;    private List&lt;FriendSuggestionDTO&gt; getSimilarInterestsSuggestions(UserEntity user, int limit) {&#13;&#10;        // Implementation would analyze user interactions, tags, groups, etc.&#13;&#10;        // For now, returning empty list as it requires more complex analysis&#13;&#10;        return new ArrayList&lt;&gt;();&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Calculate mutual friends count between two users&#13;&#10;     */&#13;&#10;    public int getMutualFriendsCount(String userId1, String userId2) {&#13;&#10;        String cacheKey = MUTUAL_FRIENDS_CACHE + userId1 + &quot;:&quot; + userId2;&#13;&#10;&#13;&#10;        Object cached = redisTemplate.opsForValue().get(cacheKey);&#13;&#10;        if (cached != null) {&#13;&#10;            return ((Number) cached).intValue();&#13;&#10;        }&#13;&#10;&#13;&#10;        try {&#13;&#10;            List&lt;UserEntity&gt; mutualFriends = userRepository.findMutualFriends(userId1, userId2);&#13;&#10;            int count = mutualFriends.size();&#13;&#10;&#13;&#10;            // Cache for 1 hour&#13;&#10;            redisTemplate.opsForValue().set(cacheKey, count, 1, TimeUnit.HOURS);&#13;&#10;&#13;&#10;            return count;&#13;&#10;        } catch (Exception e) {&#13;&#10;            log.warn(&quot;Failed to get mutual friends count: {}&quot;, e.getMessage());&#13;&#10;            return 0;&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    private boolean isAlreadyConnected(String userId1, String userId2) {&#13;&#10;        try {&#13;&#10;            return userRepository.areFriends(userId1, userId2) ||&#13;&#10;                   userRepository.hasPendingFriendRequest(userId1, userId2) ||&#13;&#10;                   userRepository.hasPendingFriendRequest(userId2, userId1);&#13;&#10;        } catch (Exception e) {&#13;&#10;            log.warn(&quot;Failed to check connection status: {}&quot;, e.getMessage());&#13;&#10;            return false;&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    private double calculateMutualFriendsScore(int mutualCount) {&#13;&#10;        // Higher mutual friends = higher relevance&#13;&#10;        return Math.min(1.0, mutualCount / 10.0);&#13;&#10;    }&#13;&#10;&#13;&#10;    private double calculateAcademicScore(int academicScore) {&#13;&#10;        return academicScore / 6.0; // Max score is 6 (3+2+1)&#13;&#10;    }&#13;&#10;&#13;&#10;    private double calculateFriendsOfFriendsScore(int paths) {&#13;&#10;        return Math.min(0.7, paths / 5.0);&#13;&#10;    }&#13;&#10;&#13;&#10;    private String buildAcademicReason(UserEntity user, UserEntity suggestion) {&#13;&#10;        List&lt;String&gt; connections = new ArrayList&lt;&gt;();&#13;&#10;&#13;&#10;        if (Objects.equals(user.getBatchId(), suggestion.getBatchId())) {&#13;&#10;            connections.add(&quot;same batch&quot;);&#13;&#10;        }&#13;&#10;        if (Objects.equals(user.getMajorId(), suggestion.getMajorId())) {&#13;&#10;            connections.add(&quot;same major&quot;);&#13;&#10;        }&#13;&#10;        if (Objects.equals(user.getFacultyId(), suggestion.getFacultyId())) {&#13;&#10;            connections.add(&quot;same faculty&quot;);&#13;&#10;        }&#13;&#10;&#13;&#10;        return &quot;You share &quot; + String.join(&quot;, &quot;, connections);&#13;&#10;    }&#13;&#10;&#13;&#10;    private List&lt;FriendSuggestionDTO&gt; getCachedSuggestions(String cacheKey) {&#13;&#10;        try {&#13;&#10;            return (List&lt;FriendSuggestionDTO&gt;) redisTemplate.opsForValue().get(cacheKey);&#13;&#10;        } catch (Exception e) {&#13;&#10;            log.warn(&quot;Failed to get cached suggestions: {}&quot;, e.getMessage());&#13;&#10;            return null;&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    private void cacheSuggestions(String cacheKey, List&lt;FriendSuggestionDTO&gt; suggestions) {&#13;&#10;        try {&#13;&#10;            redisTemplate.opsForValue().set(cacheKey, suggestions, CACHE_TTL_HOURS, TimeUnit.HOURS);&#13;&#10;        } catch (Exception e) {&#13;&#10;            log.warn(&quot;Failed to cache suggestions: {}&quot;, e.getMessage());&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Invalidate friend suggestions cache when user relationships change&#13;&#10;     */&#13;&#10;    public void invalidateFriendSuggestionsCache(String userId) {&#13;&#10;        String pattern = FRIEND_SUGGESTIONS_CACHE + userId;&#13;&#10;        redisTemplate.delete(pattern);&#13;&#10;&#13;&#10;        // Also invalidate mutual friends cache for this user&#13;&#10;        String mutualPattern = MUTUAL_FRIENDS_CACHE + userId + &quot;:*&quot;;&#13;&#10;        Set&lt;String&gt; keys = redisTemplate.keys(mutualPattern);&#13;&#10;        if (keys != null &amp;&amp; !keys.isEmpty()) {&#13;&#10;            redisTemplate.delete(keys);&#13;&#10;        }&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/user-service/src/main/resources/application-docker.properties">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/user-service/src/main/resources/application-docker.properties" />
              <option name="updatedContent" value="# Docker-specific configuration for user-service&#10;server.port=8081&#10;spring.application.name=user-service&#10;&#10;# Neo4j Configuration - Docker service name&#10;spring.neo4j.uri=bolt://neo4j:7687&#10;spring.neo4j.authentication.username=neo4j&#10;spring.neo4j.authentication.password=password&#10;&#10;# Redis Configuration - Docker service name&#10;spring.data.redis.host=redis&#10;spring.data.redis.port=6379&#10;spring.data.redis.timeout=60000ms&#10;spring.data.redis.lettuce.pool.max-active=8&#10;spring.data.redis.lettuce.pool.max-idle=8&#10;spring.data.redis.lettuce.pool.min-idle=0&#10;&#10;# Kafka Configuration - Docker service name&#10;spring.kafka.bootstrap-servers=kafka:9092&#10;spring.kafka.consumer.group-id=user-service-group&#10;spring.kafka.consumer.auto-offset-reset=earliest&#10;spring.kafka.consumer.key-deserializer=org.apache.kafka.common.serialization.StringDeserializer&#10;spring.kafka.consumer.value-deserializer=org.springframework.kafka.support.serializer.JsonDeserializer&#10;spring.kafka.consumer.properties.spring.json.trusted.packages=*&#10;&#10;spring.kafka.producer.key-serializer=org.apache.kafka.common.serialization.StringSerializer&#10;spring.kafka.producer.value-serializer=org.springframework.kafka.support.serializer.JsonSerializer&#10;&#10;# Security Configuration&#10;app.jwt.secret=mySecretKey&#10;app.jwt.expiration=86400000&#10;&#10;# Eureka Configuration - Docker service name&#10;eureka.client.service-url.defaultZone=http://eureka-server:8761/eureka/&#10;eureka.instance.prefer-ip-address=true&#10;eureka.instance.instance-id=${spring.application.name}:${server.port}&#10;&#10;# Actuator Configuration&#10;management.endpoints.web.exposure.include=health,info,metrics&#10;management.endpoint.health.show-details=always&#10;&#10;# Logging&#10;logging.level.com.ctuconnect=INFO&#10;logging.level.org.springframework.kafka=DEBUG" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>