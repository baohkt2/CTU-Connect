<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/.env.example">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/.env.example" />
              <option name="updatedContent" value="# CTU Connect Environment Variables&#10;# Copy this file to .env and update values as needed&#10;&#10;# Eureka Server&#10;EUREKA_PORT=8761&#10;&#10;# API Gateway&#10;API_GATEWAY_PORT=8090&#10;&#10;# Auth Service&#10;AUTH_SERVICE_PORT=8080&#10;&#10;# User Service  &#10;USER_SERVICE_PORT=8081&#10;&#10;# Media Service&#10;MEDIA_SERVICE_PORT=8084&#10;&#10;# Database Configuration&#10;POSTGRES_USER=postgres&#10;POSTGRES_PASSWORD=password&#10;AUTH_DB_PORT=5432&#10;&#10;# Redis Configuration&#10;REDIS_PORT=6379&#10;&#10;# Recommendation Service&#10;RECOMMENDATION_SECRET_KEY=recommendation-secret-key-change-in-production&#10;&#10;# Email Configuration (for Auth Service)&#10;MAIL_HOST=smtp.gmail.com&#10;MAIL_PORT=587&#10;MAIL_USERNAME=your_email@gmail.com&#10;MAIL_PASSWORD=your_app_password&#10;&#10;# Cloudinary Configuration (for Media Service)&#10;CLOUDINARY_CLOUD_NAME=your_cloudinary_cloud_name&#10;CLOUDINARY_API_KEY=your_cloudinary_api_key&#10;CLOUDINARY_API_SECRET=your_cloudinary_api_secret" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/ARCHITECTURE_OPTIMIZATION.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ARCHITECTURE_OPTIMIZATION.md" />
              <option name="originalContent" value="# CTU-Connect Architecture Optimization Plan&#10;## Based on Facebook's Social Network Model&#10;&#10;### Current Architecture Analysis&#10;- ✅ Microservices architecture with proper service separation&#10;- ✅ Event-driven communication via Kafka&#10;- ✅ Multiple database technologies (PostgreSQL, MongoDB, Neo4j, Redis)&#10;- ✅ API Gateway for centralized routing&#10;- ✅ Service discovery with Eureka&#10;&#10;### Key Optimizations Required&#10;- Implement eventual consistency patterns&#10;#### 1. Data Consistency &amp; Flow Optimization&#10;- Implement eventual consistency patterns&#10;- Add distributed transaction management&#10;- Optimize cross-service data synchronization&#10;&#10;#### 3. Social Graph Optimization&#10;- Friend suggestion algorithms&#10;#### 2. Enhanced Post System (Facebook-like)&#10;- Timeline generation algorithms&#10;- News feed ranking and personalization&#10;- Real-time updates and notifications&#10;- Database optimization and indexing&#10;- Load balancing and horizontal scaling&#10;&#10;#### 5. Real-time Features&#10;#### 3. Social Graph Optimization&#10;- Friend suggestion algorithms&#10;- Privacy controls and audience targeting&#10;- Activity feed generation&#10;- Real-time chat and comments&#10;- Activity status tracking&#10;#### 4. Performance &amp; Scalability&#10;- Caching strategies at multiple levels&#10;#### 5. Real-time Features&#10;- Live notifications&#10;- Real-time chat and comments&#10;- Activity status tracking&#10;" />
              <option name="updatedContent" value="# CTU-Connect Architecture Optimization Plan&#10;## Based on Facebook's Social Network Model&#10;&#10;### Current Architecture Analysis&#10;- ✅ Microservices architecture with proper service separation&#10;- ✅ Event-driven communication via Kafka&#10;- ✅ Multiple database technologies (PostgreSQL, MongoDB, Neo4j, Redis)&#10;- ✅ API Gateway for centralized routing&#10;- ✅ Service discovery with Eureka&#10;&#10;## COMPLETED OPTIMIZATIONS&#10;&#10;### 1. Enhanced Data Models (Facebook-like)&#10;&#10;#### Enhanced PostEntity&#10;- **Audience Targeting**: Similar to Facebook's privacy controls with granular audience settings&#10;- **Engagement Metrics**: Real-time engagement scoring for feed ranking algorithms&#10;- **Post Types**: Support for TEXT, IMAGE, VIDEO, LINK, POLL, EVENT, SHARED&#10;- **Location Support**: Geographic tagging capabilities&#10;- **Scheduled Posts**: Ability to schedule posts for future publishing&#10;- **Edit History**: Track post modifications with timestamps&#10;&#10;#### Advanced Social Graph (Neo4j)&#10;- **Friend Suggestions**: Multi-signal algorithm using mutual friends, academic connections, profile viewers&#10;- **Relationship Types**: FRIENDS_WITH, FRIEND_REQUEST_SENT, VIEWED_PROFILE, BLOCKED&#10;- **Academic Context**: Faculty, major, and batch-based connections&#10;- **Interaction History**: Track user interactions for personalization&#10;&#10;### 2. Facebook-like News Feed Algorithm&#10;&#10;#### NewsFeedService Implementation&#10;- **Personalized Ranking**: Multi-factor scoring system&#10;  - Friend relationship weight (1.0)&#10;  - Engagement score weight (0.8)&#10;  - Recency weight (0.6)&#10;  - Content relevance weight (0.7)&#10;- **Cache Strategy**: 30-minute feed cache with intelligent invalidation&#10;- **Over-fetching**: Retrieve 3x posts for optimal ranking&#10;- **Diversity Control**: Prevent feed domination by single authors&#10;&#10;#### Feed Types&#10;- **Personalized Feed**: User-specific content based on social graph&#10;- **Trending Posts**: Engagement-based trending algorithm&#10;- **User Timeline**: Profile-specific post timeline with privacy filtering&#10;&#10;### 3. Real-time Notification System&#10;&#10;#### NotificationService Features&#10;- **Real-time WebSocket**: Instant notifications via SimpMessagingTemplate&#10;- **Event-driven**: Kafka integration for scalable notification processing&#10;- **Notification Types**: POST_LIKED, COMMENTED, SHARED, FRIEND_REQUEST, etc.&#10;- **Bulk Notifications**: Efficient handling of viral content notifications&#10;- **Unread Counters**: Redis-cached unread notification counts&#10;&#10;### 4. Data Consistency Management&#10;&#10;#### DataConsistencyService&#10;- **Eventual Consistency**: Cross-service data synchronization&#10;- **Cache Invalidation**: Smart cache invalidation on data changes&#10;- **Compensation Logic**: Failure handling and retry mechanisms&#10;- **Event Sourcing**: Kafka-based event propagation&#10;&#10;### 5. Advanced Caching Strategy&#10;&#10;#### Multi-level Caching&#10;- **Redis Caching**: &#10;  - User data (24 hours TTL)&#10;  - Posts (6 hours TTL)&#10;  - Friend suggestions (6 hours TTL)&#10;  - News feed (30 minutes TTL)&#10;- **Application-level**: In-memory caching for frequently accessed data&#10;- **Database-level**: Optimized queries and indexing&#10;&#10;### 6. Social Graph Optimization&#10;&#10;#### SocialGraphService Features&#10;- **Friend Suggestions Algorithm**:&#10;  - Mutual friends (highest priority)&#10;  - Academic connections (faculty/major/batch)&#10;  - Friends of friends&#10;  - Profile viewers&#10;  - Similar interests&#10;- **Relevance Scoring**: Multi-factor relevance calculation&#10;- **Cache Management**: 6-hour TTL with smart invalidation&#10;&#10;### 7. Performance Enhancements&#10;&#10;#### Database Optimizations&#10;- **MongoDB**: Compound indexes for posts, engagement-based sorting&#10;- **Neo4j**: Optimized Cypher queries for relationship traversal&#10;- **PostgreSQL**: Proper indexing for auth and media services&#10;- **Redis**: Strategic caching and session management&#10;&#10;#### API Optimizations&#10;- **Pagination**: Consistent pagination across all endpoints&#10;- **Bulk Operations**: Efficient batch processing for notifications&#10;- **Async Processing**: CompletableFuture for non-blocking operations&#10;&#10;### 8. Enhanced Security &amp; Privacy&#10;&#10;#### Privacy Controls&#10;- **Audience Settings**: PUBLIC, FRIENDS, CUSTOM, ONLY_ME&#10;- **Academic Targeting**: Faculty/major/batch-specific visibility&#10;- **Block Lists**: User blocking functionality&#10;- **Profile Privacy**: Granular profile visibility controls&#10;&#10;### 9. Real-time Features&#10;&#10;#### WebSocket Integration&#10;- **Live Notifications**: Real-time notification delivery&#10;- **Activity Status**: User online/offline status tracking&#10;- **Real-time Comments**: Live comment updates on posts&#10;&#10;### 10. Monitoring &amp; Health Checks&#10;&#10;#### System Monitoring&#10;- **Health Indicators**: Redis, MongoDB, Neo4j health checks&#10;- **Performance Metrics**: Engagement rates, cache hit ratios&#10;- **Error Tracking**: Comprehensive logging and error handling&#10;&#10;## IMPLEMENTATION SUMMARY&#10;&#10;### New Services Created&#10;1. **NewsFeedService** - Facebook-like feed generation&#10;2. **NotificationService** - Real-time notification system&#10;3. **SocialGraphService** - Advanced friend suggestions&#10;4. **DataConsistencyService** - Cross-service data synchronization&#10;&#10;### Enhanced Controllers&#10;1. **EnhancedPostController** - Advanced post management&#10;2. **EnhancedUserController** - Social graph operations&#10;&#10;### Data Models Enhanced&#10;- **PostEntity** - Facebook-like post features&#10;- **NotificationEntity** - Rich notification system&#10;- **FriendSuggestionDTO** - Comprehensive suggestion data&#10;&#10;### Configuration Added&#10;- **CacheConfig** - Multi-level caching strategy&#10;- **HealthCheckConfig** - System health monitoring&#10;&#10;## FACEBOOK-INSPIRED FEATURES IMPLEMENTED&#10;&#10;### Content &amp; Engagement&#10;✅ **News Feed Algorithm** - Personalized content ranking&#10;✅ **Post Types** - Text, image, video, link, poll support&#10;✅ **Reactions System** - Like, love, laugh, etc.&#10;✅ **Comments &amp; Replies** - Threaded comment system&#10;✅ **Share Functionality** - Post sharing with attribution&#10;✅ **Trending Posts** - Viral content discovery&#10;&#10;### Social Features&#10;✅ **Friend Suggestions** - Multi-signal recommendation engine&#10;✅ **Mutual Friends** - Connection discovery&#10;✅ **Academic Networks** - University-specific connections&#10;✅ **People You May Know** - Profile viewer suggestions&#10;✅ **Friend Requests** - Connection management&#10;&#10;### Privacy &amp; Security&#10;✅ **Audience Controls** - Granular post visibility&#10;✅ **Academic Targeting** - Faculty/major-based sharing&#10;✅ **Block/Unblock** - User blocking system&#10;✅ **Profile Privacy** - Customizable profile visibility&#10;&#10;### Real-time Features&#10;✅ **Live Notifications** - Instant activity updates  &#10;✅ **Real-time Comments** - Live comment updates&#10;✅ **Activity Status** - Online presence tracking&#10;✅ **WebSocket Integration** - Real-time communication&#10;&#10;### Performance &amp; Scale&#10;✅ **Multi-level Caching** - Redis + application caching&#10;✅ **Event-driven Architecture** - Kafka message streaming&#10;✅ **Database Optimization** - Proper indexing and queries&#10;✅ **Load Balancing Ready** - Horizontal scaling support&#10;&#10;## DEPLOYMENT RECOMMENDATIONS&#10;&#10;### 1. Database Scaling&#10;- **MongoDB Sharding** for post data&#10;- **Neo4j Clustering** for social graph&#10;- **Redis Clustering** for caching layer&#10;&#10;### 2. Performance Monitoring&#10;- Implement APM tools (New Relic, DataDog)&#10;- Set up alerts for cache hit ratios&#10;- Monitor database query performance&#10;&#10;### 3. Content Delivery&#10;- Integrate CDN for media files&#10;- Implement image/video optimization&#10;- Add progressive loading for feeds&#10;&#10;### 4. Security Enhancements&#10;- Rate limiting on API endpoints&#10;- Content moderation system&#10;- Spam detection algorithms&#10;&#10;This comprehensive optimization transforms your CTU-Connect platform into a robust, scalable social network with Facebook-like capabilities while maintaining the academic focus of your original vision." />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/client-frontend/src/app/profile/[userId]/page.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/client-frontend/src/app/profile/[userId]/page.tsx" />
              <option name="originalContent" value="'use client';&#10;&#10;import React from 'react';&#10;import { useParams } from 'next/navigation';&#10;import { useAuth } from '@/contexts/AuthContext';&#10;import Layout from '@/components/layout/Layout';&#10;import UserProfile from '@/components/user/UserProfile';&#10;import { useRouter } from 'next/navigation';&#10;import { useEffect } from 'react';&#10;&#10;export default function ProfilePage() {&#10;  const { user, loading } = useAuth();&#10;  const router = useRouter();&#10;  const params = useParams();&#10;  const userId = params.userId as string;&#10;&#10;  useEffect(() =&gt; {&#10;    if (!loading &amp;&amp; !user) {&#10;      router.push('/login');&#10;    }&#10;  }, [user, loading, router]);&#10;&#10;  if (loading) {&#10;    return (&#10;      &lt;div className=&quot;min-h-screen flex items-center justify-center bg-gray-50&quot;&gt;&#10;        &lt;div className=&quot;text-center&quot;&gt;&#10;          &lt;div className=&quot;animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600 mx-auto mb-4&quot;&gt;&lt;/div&gt;&#10;          &lt;p className=&quot;text-gray-600 vietnamese-text&quot;&gt;Đang tải trang cá nhân...&lt;/p&gt;&#10;        &lt;/div&gt;&#10;      &lt;/div&gt;&#10;    );&#10;  }&#10;&#10;  if (!user) {&#10;    return null;&#10;  }&#10;&#10;  return (&#10;    &lt;Layout&gt;&#10;      &lt;div className=&quot;min-h-screen bg-gray-50&quot;&gt;&#10;        &lt;UserProfile userId={userId} /&gt;&#10;      &lt;/div&gt;&#10;    &lt;/Layout&gt;&#10;  );&#10;}&#10;" />
              <option name="updatedContent" value="'use client';&#10;&#10;import React from 'react';&#10;import { useParams } from 'next/navigation';&#10;import { useAuth } from '@/contexts/AuthContext';&#10;import Layout from '@/components/layout/Layout';&#10;import UserProfile from '@/components/user/UserProfile';&#10;import { useRouter } from 'next/navigation';&#10;import { useEffect } from 'react';&#10;&#10;export default function OtherUserProfilePage() {&#10;  const { user, loading } = useAuth();&#10;  const router = useRouter();&#10;  const params = useParams();&#10;  const userId = params.userId as string;&#10;&#10;  useEffect(() =&gt; {&#10;    if (!loading &amp;&amp; !user) {&#10;      router.push('/login');&#10;      return;&#10;    }&#10;&#10;    // If the userId matches current user's ID, redirect to /profile/me&#10;    if (user &amp;&amp; user.id === userId) {&#10;      router.push('/profile/me');&#10;      return;&#10;    }&#10;  }, [user, loading, router, userId]);&#10;&#10;  if (loading) {&#10;    return (&#10;      &lt;div className=&quot;min-h-screen flex items-center justify-center bg-gray-50&quot;&gt;&#10;        &lt;div className=&quot;text-center&quot;&gt;&#10;          &lt;div className=&quot;animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600 mx-auto mb-4&quot;&gt;&lt;/div&gt;&#10;          &lt;p className=&quot;text-gray-600 vietnamese-text&quot;&gt;Đang tải trang cá nhân...&lt;/p&gt;&#10;        &lt;/div&gt;&#10;      &lt;/div&gt;&#10;    );&#10;  }&#10;&#10;  if (!user) {&#10;    return null;&#10;  }&#10;&#10;  // Don't render if this is current user's profile (will be redirected)&#10;  if (user.id === userId) {&#10;    return null;&#10;  }&#10;&#10;  return (&#10;    &lt;Layout&gt;&#10;      &lt;div className=&quot;min-h-screen bg-gray-50&quot;&gt;&#10;        &lt;UserProfile userId={userId} /&gt;&#10;      &lt;/div&gt;&#10;    &lt;/Layout&gt;&#10;  );&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/client-frontend/src/app/profile/me/page.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/client-frontend/src/app/profile/me/page.tsx" />
              <option name="updatedContent" value="'use client';&#10;&#10;import React from 'react';&#10;import { useAuth } from '@/contexts/AuthContext';&#10;import Layout from '@/components/layout/Layout';&#10;import UserProfile from '@/components/user/UserProfile';&#10;import { useRouter } from 'next/navigation';&#10;import { useEffect } from 'react';&#10;&#10;export default function MyProfilePage() {&#10;  const { user, loading } = useAuth();&#10;  const router = useRouter();&#10;&#10;  useEffect(() =&gt; {&#10;    if (!loading &amp;&amp; !user) {&#10;      router.push('/login');&#10;    }&#10;  }, [user, loading, router]);&#10;&#10;  if (loading) {&#10;    return (&#10;      &lt;div className=&quot;min-h-screen flex items-center justify-center bg-gray-50&quot;&gt;&#10;        &lt;div className=&quot;text-center&quot;&gt;&#10;          &lt;div className=&quot;animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600 mx-auto mb-4&quot;&gt;&lt;/div&gt;&#10;          &lt;p className=&quot;text-gray-600 vietnamese-text&quot;&gt;Đang tải trang cá nhân của bạn...&lt;/p&gt;&#10;        &lt;/div&gt;&#10;      &lt;/div&gt;&#10;    );&#10;  }&#10;&#10;  if (!user) {&#10;    return null;&#10;  }&#10;&#10;  return (&#10;    &lt;Layout&gt;&#10;      &lt;div className=&quot;min-h-screen bg-gray-50&quot;&gt;&#10;        &lt;UserProfile userId={user.id} /&gt;&#10;      &lt;/div&gt;&#10;    &lt;/Layout&gt;&#10;  );&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/client-frontend/src/app/profile/update/page.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/client-frontend/src/app/profile/update/page.tsx" />
              <option name="originalContent" value="'use client';&#10;&#10;import { useEffect, useState } from 'react';&#10;import { useAuth } from '@/contexts/AuthContext';&#10;import { userService } from '@/services/userService';&#10;import { User } from '@/types';&#10;import StudentProfileForm from '@/components/profile/StudentProfileForm';&#10;import LecturerProfileForm from '@/components/profile/LecturerProfileForm';&#10;import LoadingSpinner from '@/components/ui/LoadingSpinner';&#10;import {useRouter} from &quot;next/navigation&quot;;&#10;&#10;export default function UpdateProfilePage() {&#10;  const { user } = useAuth();&#10;  const [currentUser, setCurrentUser] = useState&lt;User | null&gt;(null);&#10;  const [loading, setLoading] = useState(true);&#10;  const [error, setError] = useState&lt;string | null&gt;(null);&#10;&#10;  useEffect(() =&gt; {&#10;    const fetchUserProfile = async () =&gt; {&#10;      try {&#10;        const profile = await userService.getMyProfile();&#10;        setCurrentUser(profile);&#10;        console.log('Current user profile:', profile);&#10;      } catch (err) {&#10;        console.error('Error fetching user profile:', err);&#10;        setError('Không thể tải thông tin người dùng');&#10;      } finally {&#10;        setLoading(false);&#10;      }&#10;    };&#10;&#10;    fetchUserProfile();&#10;  }, [user]);&#10;&#10;  if (loading) {&#10;    return (&#10;      &lt;div className=&quot;min-h-screen flex items-center justify-center&quot;&gt;&#10;        &lt;LoadingSpinner /&gt;&#10;      &lt;/div&gt;&#10;    );&#10;  }&#10;&#10;  if (error) {&#10;    return (&#10;      &lt;div className=&quot;min-h-screen flex items-center justify-center&quot;&gt;&#10;        &lt;div className=&quot;text-center&quot;&gt;&#10;          &lt;h2 className=&quot;text-2xl font-bold text-red-600 mb-4&quot;&gt;Lỗi&lt;/h2&gt;&#10;          &lt;p className=&quot;text-gray-600&quot;&gt;{error}&lt;/p&gt;&#10;        &lt;/div&gt;&#10;      &lt;/div&gt;&#10;    );&#10;  }&#10;&#10;  if (!currentUser) {&#10;    return (&#10;      &lt;div className=&quot;min-h-screen flex items-center justify-center&quot;&gt;&#10;        &lt;div className=&quot;text-center&quot;&gt;&#10;          &lt;h2 className=&quot;text-2xl font-bold text-gray-800 mb-4&quot;&gt;Không tìm thấy thông tin người dùng&lt;/h2&gt;&#10;        &lt;/div&gt;&#10;      &lt;/div&gt;&#10;    );&#10;  }&#10;&#10;  return (&#10;    &lt;div className=&quot;min-h-screen bg-gray-50 py-8&quot;&gt;&#10;      &lt;div className=&quot;max-w-4xl mx-auto px-4 sm:px-6 lg:px-8&quot;&gt;&#10;        &lt;div className=&quot;bg-white rounded-lg shadow-lg p-8&quot;&gt;&#10;          &lt;div className=&quot;text-center mb-8&quot;&gt;&#10;            &lt;h1 className=&quot;text-3xl font-bold text-gray-900 mb-2&quot;&gt;&#10;              Cập nhật thông tin cá nhân&#10;            &lt;/h1&gt;&#10;            &lt;p className=&quot;text-gray-600&quot;&gt;&#10;              Vui lòng hoàn thiện thông tin để sử dụng đầy đủ các tính năng của hệ thống&#10;            &lt;/p&gt;&#10;          &lt;/div&gt;&#10;&#10;          {currentUser.role === 'STUDENT' &amp;&amp; (&#10;            &lt;StudentProfileForm user={currentUser} /&gt;&#10;          )}&#10;&#10;          {currentUser.role === 'LECTURER' &amp;&amp; (&#10;            &lt;LecturerProfileForm user={currentUser} /&gt;&#10;          )}&#10;&#10;          {!['STUDENT', 'LECTURER'].includes(currentUser.role) &amp;&amp; (&#10;            &lt;div className=&quot;text-center py-8&quot;&gt;&#10;              &lt;p className=&quot;text-gray-600&quot;&gt;&#10;                Vai trò người dùng không hợp lệ để cập nhật thông tin cá nhân.&#10;              &lt;/p&gt;&#10;            &lt;/div&gt;&#10;          )}&#10;        &lt;/div&gt;&#10;      &lt;/div&gt;&#10;    &lt;/div&gt;&#10;  );&#10;}&#10;" />
              <option name="updatedContent" value="'use client';&#13;&#10;&#13;&#10;import { useEffect, useState } from 'react';&#13;&#10;import { useAuth } from '@/contexts/AuthContext';&#13;&#10;import { userService } from '@/services/userService';&#13;&#10;import { User } from '@/types';&#13;&#10;import StudentProfileForm from '@/components/profile/StudentProfileForm';&#13;&#10;import LecturerProfileForm from '@/components/profile/LecturerProfileForm';&#13;&#10;import LoadingSpinner from '@/components/ui/LoadingSpinner';&#13;&#10;import Layout from '@/components/layout/Layout';&#13;&#10;import { useRouter } from &quot;next/navigation&quot;;&#13;&#10;import { ArrowLeft, User as UserIcon } from 'lucide-react';&#13;&#10;import { Button } from '@/components/ui/Button';&#13;&#10;&#13;&#10;export default function UpdateProfilePage() {&#13;&#10;  const { user } = useAuth();&#13;&#10;  const router = useRouter();&#13;&#10;  const [currentUser, setCurrentUser] = useState&lt;User | null&gt;(null);&#13;&#10;  const [loading, setLoading] = useState(true);&#13;&#10;  const [error, setError] = useState&lt;string | null&gt;(null);&#13;&#10;&#13;&#10;  useEffect(() =&gt; {&#13;&#10;    if (!user) {&#13;&#10;      router.push('/login');&#13;&#10;      return;&#13;&#10;    }&#13;&#10;&#13;&#10;    const fetchUserProfile = async () =&gt; {&#13;&#10;      try {&#13;&#10;        const profile = await userService.getMyProfile();&#13;&#10;        setCurrentUser(profile);&#13;&#10;        console.log('Current user profile:', profile);&#13;&#10;      } catch (err) {&#13;&#10;        console.error('Error fetching user profile:', err);&#13;&#10;        setError('Không thể tải thông tin người dùng');&#13;&#10;      } finally {&#13;&#10;        setLoading(false);&#13;&#10;      }&#13;&#10;    };&#13;&#10;&#13;&#10;    fetchUserProfile();&#13;&#10;  }, [user, router]);&#13;&#10;&#13;&#10;  const handleBackToProfile = () =&gt; {&#13;&#10;    router.push('/profile/me');&#13;&#10;  };&#13;&#10;&#13;&#10;  if (loading) {&#13;&#10;    return (&#13;&#10;      &lt;Layout&gt;&#13;&#10;        &lt;div className=&quot;min-h-screen flex items-center justify-center bg-gray-50&quot;&gt;&#13;&#10;          &lt;div className=&quot;text-center&quot;&gt;&#13;&#10;            &lt;LoadingSpinner size=&quot;lg&quot; /&gt;&#13;&#10;            &lt;p className=&quot;text-gray-600 mt-4 vietnamese-text&quot;&gt;Đang tải thông tin cá nhân...&lt;/p&gt;&#13;&#10;          &lt;/div&gt;&#13;&#10;        &lt;/div&gt;&#13;&#10;      &lt;/Layout&gt;&#13;&#10;    );&#13;&#10;  }&#13;&#10;&#13;&#10;  if (error) {&#13;&#10;    return (&#13;&#10;      &lt;Layout&gt;&#13;&#10;        &lt;div className=&quot;min-h-screen flex items-center justify-center bg-gray-50&quot;&gt;&#13;&#10;          &lt;div className=&quot;text-center bg-white rounded-lg shadow-sm p-8 max-w-md&quot;&gt;&#13;&#10;            &lt;div className=&quot;text-red-500 mb-4&quot;&gt;&#13;&#10;              &lt;UserIcon className=&quot;h-16 w-16 mx-auto&quot; /&gt;&#13;&#10;            &lt;/div&gt;&#13;&#10;            &lt;h2 className=&quot;text-2xl font-bold text-red-600 mb-4 vietnamese-text&quot;&gt;Lỗi&lt;/h2&gt;&#13;&#10;            &lt;p className=&quot;text-gray-600 mb-6 vietnamese-text&quot;&gt;{error}&lt;/p&gt;&#13;&#10;            &lt;Button onClick={() =&gt; window.location.reload()} className=&quot;mr-3&quot;&gt;&#13;&#10;              Thử lại&#13;&#10;            &lt;/Button&gt;&#13;&#10;            &lt;Button variant=&quot;outline&quot; onClick={() =&gt; router.push('/profile/me')}&gt;&#13;&#10;              Quay lại&#13;&#10;            &lt;/Button&gt;&#13;&#10;          &lt;/div&gt;&#13;&#10;        &lt;/div&gt;&#13;&#10;      &lt;/Layout&gt;&#13;&#10;    );&#13;&#10;  }&#13;&#10;&#13;&#10;  if (!currentUser) {&#13;&#10;    return (&#13;&#10;      &lt;Layout&gt;&#13;&#10;        &lt;div className=&quot;min-h-screen flex items-center justify-center bg-gray-50&quot;&gt;&#13;&#10;          &lt;div className=&quot;text-center bg-white rounded-lg shadow-sm p-8 max-w-md&quot;&gt;&#13;&#10;            &lt;div className=&quot;text-gray-400 mb-4&quot;&gt;&#13;&#10;              &lt;UserIcon className=&quot;h-16 w-16 mx-auto&quot; /&gt;&#13;&#10;            &lt;/div&gt;&#13;&#10;            &lt;h2 className=&quot;text-2xl font-bold text-gray-800 mb-4 vietnamese-text&quot;&gt;&#13;&#10;              Không tìm thấy thông tin người dùng&#13;&#10;            &lt;/h2&gt;&#13;&#10;            &lt;Button onClick={() =&gt; router.push('/profile/me')}&gt;&#13;&#10;              Quay lại trang cá nhân&#13;&#10;            &lt;/Button&gt;&#13;&#10;          &lt;/div&gt;&#13;&#10;        &lt;/div&gt;&#13;&#10;      &lt;/Layout&gt;&#13;&#10;    );&#13;&#10;  }&#13;&#10;&#13;&#10;  return (&#13;&#10;    &lt;Layout&gt;&#13;&#10;      &lt;div className=&quot;min-h-screen bg-gray-50 py-8&quot;&gt;&#13;&#10;        &lt;div className=&quot;max-w-4xl mx-auto px-4 sm:px-6 lg:px-8&quot;&gt;&#13;&#10;          {/* Header with Back Button */}&#13;&#10;          &lt;div className=&quot;mb-6&quot;&gt;&#13;&#10;            &lt;Button&#13;&#10;              variant=&quot;outline&quot;&#13;&#10;              onClick={handleBackToProfile}&#13;&#10;              className=&quot;flex items-center space-x-2 mb-4&quot;&#13;&#10;            &gt;&#13;&#10;              &lt;ArrowLeft className=&quot;h-4 w-4&quot; /&gt;&#13;&#10;              &lt;span className=&quot;vietnamese-text&quot;&gt;Quay lại trang cá nhân&lt;/span&gt;&#13;&#10;            &lt;/Button&gt;&#13;&#10;          &lt;/div&gt;&#13;&#10;&#13;&#10;          &lt;div className=&quot;bg-white rounded-lg shadow-lg p-8&quot;&gt;&#13;&#10;            &lt;div className=&quot;text-center mb-8&quot;&gt;&#13;&#10;              &lt;div className=&quot;mb-4&quot;&gt;&#13;&#10;                {currentUser.avatarUrl ? (&#13;&#10;                  &lt;img&#13;&#10;                    src={currentUser.avatarUrl}&#13;&#10;                    alt=&quot;Avatar&quot;&#13;&#10;                    className=&quot;w-20 h-20 rounded-full mx-auto object-cover border-4 border-white shadow-lg&quot;&#13;&#10;                  /&gt;&#13;&#10;                ) : (&#13;&#10;                  &lt;div className=&quot;w-20 h-20 bg-gradient-to-br from-blue-400 to-purple-600 rounded-full mx-auto flex items-center justify-center text-white text-2xl font-bold shadow-lg&quot;&gt;&#13;&#10;                    {(currentUser.fullName || currentUser.name || 'U').charAt(0).toUpperCase()}&#13;&#10;                  &lt;/div&gt;&#13;&#10;                )}&#13;&#10;              &lt;/div&gt;&#13;&#10;              &#13;&#10;              &lt;h1 className=&quot;text-3xl font-bold text-gray-900 mb-2 vietnamese-text&quot;&gt;&#13;&#10;                Cập nhật thông tin cá nhân&#13;&#10;              &lt;/h1&gt;&#13;&#10;              &lt;p className=&quot;text-gray-600 vietnamese-text&quot;&gt;&#13;&#10;                Vui lòng hoàn thiện thông tin để sử dụng đầy đủ các tính năng của hệ thống&#13;&#10;              &lt;/p&gt;&#13;&#10;              &#13;&#10;              {/* Role Badge */}&#13;&#10;              &lt;div className=&quot;mt-4&quot;&gt;&#13;&#10;                &lt;span className={`inline-flex px-3 py-1 rounded-full text-sm font-medium ${&#13;&#10;                  currentUser.role === 'LECTURER' &#13;&#10;                    ? 'bg-blue-100 text-blue-700' &#13;&#10;                    : 'bg-green-100 text-green-700'&#13;&#10;                }`}&gt;&#13;&#10;                  {currentUser.role === 'LECTURER' ? 'Giảng viên' : 'Sinh viên'}&#13;&#10;                &lt;/span&gt;&#13;&#10;              &lt;/div&gt;&#13;&#10;            &lt;/div&gt;&#13;&#10;&#13;&#10;            {currentUser.role === 'STUDENT' &amp;&amp; (&#13;&#10;              &lt;StudentProfileForm user={currentUser} /&gt;&#13;&#10;            )}&#13;&#10;&#13;&#10;            {currentUser.role === 'LECTURER' &amp;&amp; (&#13;&#10;              &lt;LecturerProfileForm user={currentUser} /&gt;&#13;&#10;            )}&#13;&#10;&#13;&#10;            {!['STUDENT', 'LECTURER'].includes(currentUser.role) &amp;&amp; (&#13;&#10;              &lt;div className=&quot;text-center py-8&quot;&gt;&#13;&#10;                &lt;div className=&quot;text-gray-400 mb-4&quot;&gt;&#13;&#10;                  &lt;UserIcon className=&quot;h-12 w-12 mx-auto&quot; /&gt;&#13;&#10;                &lt;/div&gt;&#13;&#10;                &lt;p className=&quot;text-gray-600 vietnamese-text&quot;&gt;&#13;&#10;                  Vai trò người dùng không hợp lệ để cập nhật thông tin cá nhân.&#13;&#10;                &lt;/p&gt;&#13;&#10;                &lt;Button &#13;&#10;                  variant=&quot;outline&quot; &#13;&#10;                  onClick={() =&gt; router.push('/profile/me')} &#13;&#10;                  className=&quot;mt-4&quot;&#13;&#10;                &gt;&#13;&#10;                  Quay lại trang cá nhân&#13;&#10;                &lt;/Button&gt;&#13;&#10;              &lt;/div&gt;&#13;&#10;            )}&#13;&#10;          &lt;/div&gt;&#13;&#10;        &lt;/div&gt;&#13;&#10;      &lt;/div&gt;&#13;&#10;    &lt;/Layout&gt;&#13;&#10;  );&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/client-frontend/src/components/post/PostCard.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/client-frontend/src/components/post/PostCard.tsx" />
              <option name="originalContent" value="'use client';&#10;&#10;import React, { useState, useEffect, useCallback } from 'react';&#10;import { Post, CreateCommentRequest, UpdatePostRequest } from '@/types';&#10;import { postService } from '@/services/postService';&#10;import { Button } from '@/components/ui/Button';&#10;import { Card } from '@/components/ui/Card';&#10;import { Textarea } from '@/components/ui/Textarea';&#10;import { LoadingSpinner } from '@/components/ui/LoadingSpinner';&#10;import { ReactionButton } from '@/components/ui/ReactionButton';&#10;import { PostMenu } from '@/components/post/PostMenu';&#10;import { PostEditModal } from '@/components/post/PostEditModal';&#10;import { EditIndicator } from '@/components/post/EditIndicator';&#10;import { CommentItem } from '@/components/post/CommentItem';&#10;import { t, formatTimeAgo } from '@/utils/localization';&#10;import {&#10;  MessageCircle,&#10;  Share,&#10;  Eye,&#10;  Globe,&#10;  Users,&#10;  Lock, ThumbsUp, Heart, MoreHorizontal, Flag, Trash2, EyeOff&#10;} from 'lucide-react';&#10;import Avatar from &quot;@/components/ui/Avatar&quot;;&#10;import {useAuth} from &quot;@/contexts/AuthContext&quot;;&#10;&#10;interface PostCardProps {&#10;  post: any;&#10;  onPostUpdate?: (updatedPost: any) =&gt; void;&#10;  onPostDelete?: (postId: string) =&gt; void;&#10;  className?: string;&#10;}&#10;&#10;export const PostCard: React.FC&lt;PostCardProps&gt; = ({&#10;  post,&#10;  onPostUpdate,&#10;  onPostDelete,&#10;  className = ''&#10;}) =&gt; {&#10;  const { user } = useAuth();&#10;  const [isLiked, setIsLiked] = useState(false);&#10;  const [isBookmarked, setIsBookmarked] = useState(false);&#10;  const [showComments, setShowComments] = useState(false);&#10;  const [commentText, setCommentText] = useState('');&#10;  const [comments, setComments] = useState&lt;any[]&gt;([]);&#10;  const [isLoadingComments, setIsLoadingComments] = useState(false);&#10;  const [isSubmittingComment, setIsSubmittingComment] = useState(false);&#10;  const [isLoadingInteraction, setIsLoadingInteraction] = useState(false);&#10;  const [actionFeedback, setActionFeedback] = useState&lt;string | null&gt;(null);&#10;  const [showEditModal, setShowEditModal] = useState(false);&#10;  const [currentReaction, setCurrentReaction] = useState&lt;string | null&gt;(null);&#10;  const [reactionCounts, setReactionCounts] = useState&lt;{[key: string]: number}&gt;({});&#10;  const [commentMenus, setCommentMenus] = useState&lt;{[key: string]: boolean}&gt;({});&#10;&#10;  const isOwnPost = user?.id === post.authorId || user?.id === post.author?.id;&#10;&#10;  // Load trạng thái like, bookmark khi mount&#10;  useEffect(() =&gt; {&#10;    let mounted = true;&#10;    (async () =&gt; {&#10;      try {&#10;        const status = await postService.getInteractionStatus(post.id);&#10;        if (mounted) {&#10;          setIsLiked(status.hasLiked);&#10;          setIsBookmarked(status.hasBookmarked);&#10;        }&#10;      } catch (error) {&#10;        console.debug('Không thể tải trạng thái tương tác:', error);&#10;      }&#10;    })();&#10;    return () =&gt; { mounted = false; };&#10;  }, [post.id]);&#10;&#10;  // Show feedback message temporarily&#10;  const showFeedback = (message: string) =&gt; {&#10;    setActionFeedback(message);&#10;    setTimeout(() =&gt; setActionFeedback(null), 1500);&#10;  };&#10;&#10;  // Toggle phần comment&#10;  const toggleComments = useCallback(async () =&gt; {&#10;    if (!showComments &amp;&amp; comments.length === 0) {&#10;      setIsLoadingComments(true);&#10;      try {&#10;        const response = await postService.getComments(post.id);&#10;        setComments(response.content || []);&#10;      } catch (error) {&#10;        console.error('Không thể tải bình luận:', error);&#10;        showFeedback('Không thể tải bình luận');&#10;      } finally {&#10;        setIsLoadingComments(false);&#10;      }&#10;    }&#10;    setShowComments(v =&gt; !v);&#10;  }, [showComments, comments.length, post.id]);&#10;&#10;  // Chức năng tương tác: like, bookmark, share&#10;  const handleInteraction = useCallback(async (type: 'like' | 'bookmark' | 'share') =&gt; {&#10;    if (isLoadingInteraction) return;&#10;    setIsLoadingInteraction(true);&#10;    try {&#10;      if (type === 'like') {&#10;        await postService.toggleLike(post.id);&#10;        setIsLiked(l =&gt; {&#10;          const newLiked = !l;&#10;          const newLikes = newLiked ? post.stats.likes + 1 : post.stats.likes - 1;&#10;          onPostUpdate?.({&#10;            ...post,&#10;            stats: { ...post.stats, likes: newLikes }&#10;          });&#10;          showFeedback(newLiked ? 'Đã thích bài viết' : 'Đã bỏ thích');&#10;          return newLiked;&#10;        });&#10;      } else if (type === 'bookmark') {&#10;        await postService.toggleBookmark(post.id);&#10;        setIsBookmarked(b =&gt; {&#10;          const newBookmarked = !b;&#10;          const newBookmarks = newBookmarked ? post.stats.bookmarks + 1 : post.stats.bookmarks - 1;&#10;          onPostUpdate?.({&#10;            ...post,&#10;            stats: { ...post.stats, bookmarks: newBookmarks }&#10;          });&#10;          showFeedback(newBookmarked ? 'Đã lưu bài viết' : 'Đã bỏ lưu bài viết');&#10;          return newBookmarked;&#10;        });&#10;      } else if (type === 'share') {&#10;        await postService.sharePost(post.id);&#10;        onPostUpdate?.({&#10;          ...post,&#10;          stats: { ...post.stats, shares: post.stats.shares + 1 }&#10;        });&#10;        await navigator.clipboard.writeText(`${window.location.origin}/posts/${post.id}`);&#10;        showFeedback('Đã sao chép liên kết bài viết');&#10;      }&#10;    } catch (error) {&#10;      console.error(`Không thể thực hiện ${type}:`, error);&#10;      showFeedback('Có lỗi xảy ra, vui lòng thử lại');&#10;    } finally {&#10;      setIsLoadingInteraction(false);&#10;    }&#10;  }, [isLoadingInteraction, onPostUpdate, post]);&#10;&#10;  // Gửi comment&#10;  const handleSubmitComment = useCallback(async (e: React.FormEvent) =&gt; {&#10;    e.preventDefault();&#10;    if (!commentText.trim() || isSubmittingComment) return;&#10;&#10;    setIsSubmittingComment(true);&#10;    try {&#10;      const commentData: CreateCommentRequest = { content: commentText.trim() };&#10;      const newComment = await postService.createComment(post.id, commentData);&#10;      setComments(prev =&gt; [...prev, newComment]);&#10;      setCommentText('');&#10;      onPostUpdate?.({&#10;        ...post,&#10;        stats: { ...post.stats, comments: post.stats.comments + 1 }&#10;      });&#10;      showFeedback('Đã thêm bình luận');&#10;    } catch (error) {&#10;      console.error('Không thể tạo bình luận:', error);&#10;      showFeedback('Không th�� gửi bình luận');&#10;    } finally {&#10;      setIsSubmittingComment(false);&#10;    }&#10;  }, [commentText, isSubmittingComment, onPostUpdate, post]);&#10;&#10;  // Format số lượng hiển thị&#10;  const formatStats = (count: number): string =&gt; {&#10;    if (count &gt;= 1_000_000) return `${(count / 1_000_000).toFixed(1)}M`;&#10;    if (count &gt;= 1000) return `${(count / 1000).toFixed(1)}K`;&#10;    return count.toString();&#10;  };&#10;&#10;  // Get privacy icon&#10;  const getPrivacyIcon = () =&gt; {&#10;    switch (post.privacy || post.visibility) {&#10;      case 'PUBLIC':&#10;        return &lt;Globe className=&quot;h-3 w-3 text-gray-500&quot; /&gt;;&#10;      case 'FRIENDS':&#10;        return &lt;Users className=&quot;h-3 w-3 text-gray-500&quot; /&gt;;&#10;      case 'PRIVATE':&#10;        return &lt;Lock className=&quot;h-3 w-3 text-gray-500&quot; /&gt;;&#10;      default:&#10;        return &lt;Globe className=&quot;h-3 w-3 text-gray-500&quot; /&gt;;&#10;    }&#10;  };&#10;&#10;  const getPrivacyText = () =&gt; {&#10;    switch (post.privacy || post.visibility) {&#10;      case 'PUBLIC': return 'Công khai';&#10;      case 'FRIENDS': return 'Bạn bè';&#10;      case 'PRIVATE': return 'Riêng tư';&#10;      default: return 'Công khai';&#10;    }&#10;  };&#10;&#10;  // Function to toggle comment menu&#10;  const toggleCommentMenu = (commentId: string) =&gt; {&#10;    setCommentMenus(prev =&gt; ({&#10;      ...prev,&#10;      [commentId]: !prev[commentId]&#10;    }));&#10;  };&#10;&#10;  // New enhanced handlers for reactions and post actions&#10;  const handleReactionClick = useCallback(async (reactionId: string) =&gt; {&#10;    if (isLoadingInteraction) return;&#10;    setIsLoadingInteraction(true);&#10;&#10;    try {&#10;      // TODO: Implement reaction API call&#10;      // await postService.addReaction(post.id, reactionId);&#10;      setCurrentReaction(reactionId);&#10;&#10;      // Update reaction counts&#10;      setReactionCounts(prev =&gt; ({&#10;        ...prev,&#10;        [reactionId]: (prev[reactionId] || 0) + 1&#10;      }));&#10;&#10;      showFeedback(`Đã ${reactionId === 'LIKE' ? 'thích' : 'phản ứng'} bài viết`);&#10;    } catch (error) {&#10;      console.error('Error adding reaction:', error);&#10;      showFeedback('Không thể thêm phản ứng');&#10;    } finally {&#10;      setIsLoadingInteraction(false);&#10;    }&#10;  }, [isLoadingInteraction, post.id]);&#10;&#10;  const handleReactionRemove = useCallback(async () =&gt; {&#10;    if (isLoadingInteraction || !currentReaction) return;&#10;    setIsLoadingInteraction(true);&#10;&#10;    try {&#10;      // TODO: Implement remove reaction API call&#10;      // await postService.removeReaction(post.id);&#10;&#10;      // Update reaction counts&#10;      setReactionCounts(prev =&gt; ({&#10;        ...prev,&#10;        [currentReaction]: Math.max((prev[currentReaction] || 0) - 1, 0)&#10;      }));&#10;&#10;      setCurrentReaction(null);&#10;      showFeedback('Đã bỏ phản ứng');&#10;    } catch (error) {&#10;      console.error('Error removing reaction:', error);&#10;      showFeedback('Không thể bỏ phản ứng');&#10;    } finally {&#10;      setIsLoadingInteraction(false);&#10;    }&#10;  }, [isLoadingInteraction, currentReaction, post.id]);&#10;&#10;  // Post menu handlers&#10;  const handlePostEdit = () =&gt; {&#10;    setShowEditModal(true);&#10;  };&#10;&#10;  const handlePostDelete = async () =&gt; {&#10;    if (window.confirm('Bạn có chắc chắn muốn xóa bài viết này?')) {&#10;      try {&#10;        await postService.deletePost(post.id);&#10;        onPostDelete?.(post.id);&#10;        showFeedback('Đã xóa bài viết');&#10;      } catch (error) {&#10;        console.error('Error deleting post:', error);&#10;        showFeedback('Không thể xóa bài viết');&#10;      }&#10;    }&#10;  };&#10;&#10;  const handlePostSave = async (updatedPost: UpdatePostRequest) =&gt; {&#10;    try {&#10;      const result = await postService.updatePost(post.id, updatedPost);&#10;      onPostUpdate?.(result);&#10;      showFeedback('Đã cập nhật bài viết');&#10;    } catch (error) {&#10;      console.error('Error updating post:', error);&#10;      throw error;&#10;    }&#10;  };&#10;&#10;  const handlePostReport = () =&gt; {&#10;    // TODO: Implement report functionality&#10;    showFeedback('Đã báo cáo bài viết');&#10;  };&#10;&#10;  const handlePostHide = () =&gt; {&#10;    // TODO: Implement hide functionality&#10;    showFeedback('Đã ẩn bài viết');&#10;  };&#10;&#10;  const handlePostBlock = () =&gt; {&#10;    // TODO: Implement block functionality&#10;    showFeedback(`Đã chặn bài viết từ ${post.author?.fullName || post.author?.name || 'người dùng này'}`);&#10;  };&#10;&#10;  const handleCopyLink = async () =&gt; {&#10;    try {&#10;      await navigator.clipboard.writeText(`${window.location.origin}/posts/${post.id}`);&#10;      showFeedback('Đã sao chép liên kết');&#10;    } catch (error) {&#10;      showFeedback('Không thể sao chép liên kết');&#10;    }&#10;  };&#10;&#10;  return (&#10;    &lt;Card className={`bg-white rounded-lg shadow-sm hover:shadow-md transition-shadow duration-200 border border-gray-200 mb-4 ${className}`}&gt;&#10;      {/* Feedback Toast */}&#10;      {actionFeedback &amp;&amp; (&#10;        &lt;div className=&quot;absolute top-3 right-3 z-10 bg-gray-800 text-white px-3 py-1 rounded text-xs animate-fade-in&quot;&gt;&#10;          {actionFeedback}&#10;        &lt;/div&gt;&#10;      )}&#10;      &#10;      {/* Header - Facebook Style */}&#10;      &lt;div className=&quot;p-3&quot;&gt;&#10;        &lt;div className=&quot;flex items-center justify-between&quot;&gt;&#10;          &lt;div className=&quot;flex items-center space-x-3&quot;&gt;&#10;            {/* Avatar */}&#10;&#10;                &lt;Avatar&#10;                    id={post.author?.id}&#10;                    src={post.author?.avatarUrl || '/default-avatar.png'}&#10;                    alt={ post.author?.fullName ||  post.author?.username || 'Avatar'}&#10;                    size=&quot;md&quot;&#10;                /&gt;&#10;&#10;            &#10;            {/* User Info */}&#10;            &lt;div className=&quot;flex-1&quot;&gt;&#10;              &lt;div className=&quot;flex items-center space-x-2&quot;&gt;&#10;                &lt;h3 className=&quot;font-semibold text-sm text-gray-900 hover:underline cursor-pointer vietnamese-text&quot;&gt;&#10;                  {post.author?.fullName || post.author?.name || post.authorName || 'Người dùng'}&#10;                &lt;/h3&gt;&#10;                {post.author?.role &amp;&amp; (&#10;                  &lt;span className={`px-2 py-0.5 rounded text-xs font-medium ${&#10;                    post.author.role === 'LECTURER' &#10;                      ? 'bg-blue-100 text-blue-700' &#10;                      : 'bg-green-100 text-green-700'&#10;                  }`}&gt;&#10;                    {post.author.role === 'LECTURER' ? 'GV' : 'SV'}&#10;                  &lt;/span&gt;&#10;                )}&#10;              &lt;/div&gt;&#10;              &#10;              &lt;div className=&quot;flex items-center space-x-1 text-xs text-gray-500 mt-0.5&quot;&gt;&#10;                &lt;time dateTime={post.createdAt}&gt;&#10;                  {formatTimeAgo(post.createdAt)}&#10;                &lt;/time&gt;&#10;                &lt;span&gt;•&lt;/span&gt;&#10;                {getPrivacyIcon()}&#10;              &lt;/div&gt;&#10;            &lt;/div&gt;&#10;          &lt;/div&gt;&#10;          &#10;          {/* More Options */}&#10;          &lt;PostMenu&#10;            post={post}&#10;            onEdit={isOwnPost ? handlePostEdit : undefined}&#10;            onDelete={isOwnPost ? handlePostDelete : undefined}&#10;            onReport={!isOwnPost ? handlePostReport : undefined}&#10;            onHide={!isOwnPost ? handlePostHide : undefined}&#10;            onBlock={!isOwnPost ? handlePostBlock : undefined}&#10;            onBookmark={() =&gt; handleInteraction('bookmark')}&#10;            onShare={() =&gt; handleInteraction('share')}&#10;            onCopyLink={handleCopyLink}&#10;          /&gt;&#10;        &lt;/div&gt;&#10;&#10;        {/* Edit Indicator */}&#10;        &lt;EditIndicator&#10;          isEdited={post.isEdited}&#10;          className=&quot;mt-1 ml-12&quot;&#10;        /&gt;&#10;      &lt;/div&gt;&#10;&#10;      {/* Content */}&#10;      &lt;div className=&quot;px-3 pb-3&quot;&gt;&#10;        {/* Title */}&#10;        {post.title &amp;&amp; (&#10;          &lt;h2 className=&quot;font-semibold text-gray-900 mb-2 vietnamese-text&quot;&gt;&#10;            {post.title}&#10;          &lt;/h2&gt;&#10;        )}&#10;        &#10;        {/* Text Content */}&#10;        &lt;div className=&quot;text-gray-800 text-sm leading-relaxed vietnamese-text mb-3&quot;&gt;&#10;          {post.content}&#10;        &lt;/div&gt;&#10;        &#10;        {/* Tags */}&#10;        {post.tags &amp;&amp; post.tags.length &gt; 0 &amp;&amp; (&#10;          &lt;div className=&quot;flex flex-wrap gap-1 mb-3&quot;&gt;&#10;            {post.tags.map((tag: string, index: number) =&gt; (&#10;              &lt;span&#10;                key={index}&#10;                className=&quot;text-blue-600 hover:underline cursor-pointer text-sm&quot;&#10;              &gt;&#10;                #{tag}&#10;              &lt;/span&gt;&#10;            ))}&#10;          &lt;/div&gt;&#10;        )}&#10;&#10;        {/* Media - Images */}&#10;        {post.images &amp;&amp; post.images.length &gt; 0 &amp;&amp; (&#10;          &lt;div className=&quot;mb-3 -mx-3&quot;&gt;&#10;            &lt;div className={`grid gap-0.5 ${&#10;              post.images.length === 1 ? 'grid-cols-1' :&#10;              post.images.length === 2 ? 'grid-cols-2' :&#10;              post.images.length === 3 ? 'grid-cols-2' : 'grid-cols-2'&#10;            }`}&gt;&#10;              {post.images.slice(0, 4).map((imageUrl: string, index: number) =&gt; (&#10;                &lt;div&#10;                  key={index}&#10;                  className={`relative bg-gray-100 ${&#10;                    post.images.length === 3 &amp;&amp; index === 0 ? 'row-span-2' : ''&#10;                  }`}&#10;                &gt;&#10;                  &lt;img&#10;                    src={imageUrl}&#10;                    alt={`Ảnh bài viết ${index + 1}`}&#10;                    className=&quot;w-full h-full object-cover cursor-pointer hover:opacity-95 transition-opacity min-h-[200px] max-h-[400px]&quot;&#10;                    onClick={() =&gt; window.open(imageUrl, '_blank')}&#10;                  /&gt;&#10;                  {post.images.length &gt; 4 &amp;&amp; index === 3 &amp;&amp; (&#10;                    &lt;div className=&quot;absolute inset-0 bg-black bg-opacity-60 flex items-center justify-center cursor-pointer&quot;&gt;&#10;                      &lt;span className=&quot;text-white text-xl font-semibold&quot;&gt;&#10;                        +{post.images.length - 4}&#10;                      &lt;/span&gt;&#10;                    &lt;/div&gt;&#10;                  )}&#10;                &lt;/div&gt;&#10;              ))}&#10;            &lt;/div&gt;&#10;          &lt;/div&gt;&#10;        )}&#10;&#10;        {/* Media - Videos */}&#10;        {post.videos &amp;&amp; post.videos.length &gt; 0 &amp;&amp; (&#10;          &lt;div className=&quot;mb-3 -mx-3&quot;&gt;&#10;            {post.videos.map((videoUrl: string, index: number) =&gt; (&#10;              &lt;div key={index} className=&quot;bg-black&quot;&gt;&#10;                &lt;video&#10;                  src={videoUrl}&#10;                  controls&#10;                  className=&quot;w-full h-auto max-h-[500px]&quot;&#10;                  preload=&quot;metadata&quot;&#10;                &gt;&#10;                  Trình duyệt của bạn không hỗ trợ video.&#10;                &lt;/video&gt;&#10;              &lt;/div&gt;&#10;            ))}&#10;          &lt;/div&gt;&#10;        )}&#10;      &lt;/div&gt;&#10;&#10;      {/* Stats */}&#10;      {(post.stats?.likes &gt; 0 || post.stats?.comments &gt; 0 || post.stats?.shares &gt; 0) &amp;&amp; (&#10;        &lt;div className=&quot;px-3 py-2 border-t border-gray-100&quot;&gt;&#10;          &lt;div className=&quot;flex items-center justify-between text-xs text-gray-500&quot;&gt;&#10;            &lt;div className=&quot;flex items-center space-x-1&quot;&gt;&#10;              {post.stats?.likes &gt; 0 &amp;&amp; (&#10;                &lt;&gt;&#10;                  &lt;div className=&quot;flex -space-x-1&quot;&gt;&#10;                    &lt;div className=&quot;w-4 h-4 bg-blue-500 rounded-full flex items-center justify-center&quot;&gt;&#10;                      &lt;ThumbsUp className=&quot;w-2.5 h-2.5 text-white fill-current&quot; /&gt;&#10;                    &lt;/div&gt;&#10;                    &lt;div className=&quot;w-4 h-4 bg-red-500 rounded-full flex items-center justify-center&quot;&gt;&#10;                      &lt;Heart className=&quot;w-2.5 h-2.5 text-white fill-current&quot; /&gt;&#10;                    &lt;/div&gt;&#10;                  &lt;/div&gt;&#10;                  &lt;span&gt;{formatStats(post.stats.likes)}&lt;/span&gt;&#10;                &lt;/&gt;&#10;              )}&#10;            &lt;/div&gt;&#10;            &lt;div className=&quot;flex items-center space-x-3&quot;&gt;&#10;              {post.stats?.comments &gt; 0 &amp;&amp; (&#10;                &lt;button&#10;                  onClick={toggleComments}&#10;                  className=&quot;hover:underline&quot;&#10;                &gt;&#10;                  {formatStats(post.stats.comments)} bình luận&#10;                &lt;/button&gt;&#10;              )}&#10;              {post.stats?.shares &gt; 0 &amp;&amp; (&#10;                &lt;span&gt;{formatStats(post.stats.shares)} chia sẻ&lt;/span&gt;&#10;              )}&#10;            &lt;/div&gt;&#10;          &lt;/div&gt;&#10;        &lt;/div&gt;&#10;      )}&#10;&#10;      {/* Action Buttons - Facebook Style */}&#10;      &lt;div className=&quot;border-t border-gray-100&quot;&gt;&#10;        &lt;div className=&quot;flex&quot;&gt;&#10;          &lt;button&#10;            onClick={() =&gt; handleInteraction('like')}&#10;            disabled={isLoadingInteraction}&#10;            className={`flex-1 flex items-center justify-center py-2 px-3 hover:bg-gray-50 transition-colors ${&#10;              isLiked ? 'text-blue-600' : 'text-gray-600'&#10;            }`}&#10;          &gt;&#10;            &lt;ThumbsUp className={`h-4 w-4 mr-2 ${isLiked ? 'fill-current' : ''}`} /&gt;&#10;            &lt;span className=&quot;text-sm font-medium&quot;&gt;Thích&lt;/span&gt;&#10;          &lt;/button&gt;&#10;&#10;          &lt;button&#10;            onClick={toggleComments}&#10;            className=&quot;flex-1 flex items-center justify-center py-2 px-3 text-gray-600 hover:bg-gray-50 transition-colors&quot;&#10;          &gt;&#10;            &lt;MessageCircle className=&quot;h-4 w-4 mr-2&quot; /&gt;&#10;            &lt;span className=&quot;text-sm font-medium&quot;&gt;Bình luận&lt;/span&gt;&#10;          &lt;/button&gt;&#10;&#10;          &lt;button&#10;            onClick={() =&gt; handleInteraction('share')}&#10;            disabled={isLoadingInteraction}&#10;            className=&quot;flex-1 flex items-center justify-center py-2 px-3 text-gray-600 hover:bg-gray-50 transition-colors&quot;&#10;          &gt;&#10;            &lt;Share className=&quot;h-4 w-4 mr-2&quot; /&gt;&#10;            &lt;span className=&quot;text-sm font-medium&quot;&gt;Chia sẻ&lt;/span&gt;&#10;          &lt;/button&gt;&#10;        &lt;/div&gt;&#10;      &lt;/div&gt;&#10;&#10;      {/* Comments Section */}&#10;      {showComments &amp;&amp; (&#10;        &lt;div className=&quot;border-t border-gray-100 bg-gray-50&quot;&gt;&#10;          &lt;div className=&quot;p-3&quot;&gt;&#10;            {/* Comment Form */}&#10;            &lt;form onSubmit={handleSubmitComment} className=&quot;mb-3&quot;&gt;&#10;              &lt;div className=&quot;flex space-x-2&quot;&gt;&#10;&#10;                    &lt;Avatar&#10;                        id={ user?.id}&#10;                        src={ user?.avatarUrl || '/default-avatar.png'}&#10;                        alt={ user?.fullName ||  user?.username || 'Avatar'}&#10;                        size=&quot;md&quot;&#10;                        /&gt;&#10;&#10;                &lt;div className=&quot;flex-1&quot;&gt;&#10;                  &lt;Textarea&#10;                    value={commentText}&#10;                    onChange={(e) =&gt; setCommentText(e.target.value)}&#10;                    placeholder=&quot;Viết bình luận...&quot;&#10;                    className=&quot;min-h-[32px] text-sm bg-gray-300 text-black border-0 rounded-full px-3 py-2 resize-none vietnamese-text&quot;&#10;                    disabled={isSubmittingComment}&#10;                  /&gt;&#10;                  {commentText.trim() &amp;&amp; (&#10;                    &lt;div className=&quot;flex justify-end mt-1&quot;&gt;&#10;                      &lt;Button&#10;                        type=&quot;submit&quot;&#10;                        size=&quot;sm&quot;&#10;                        disabled={isSubmittingComment}&#10;                        className=&quot;text-xs px-3 py-1&quot;&#10;                      &gt;&#10;                        {isSubmittingComment ? &lt;LoadingSpinner size=&quot;sm&quot; /&gt; : 'Gửi'}&#10;                      &lt;/Button&gt;&#10;                    &lt;/div&gt;&#10;                  )}&#10;                &lt;/div&gt;&#10;              &lt;/div&gt;&#10;            &lt;/form&gt;&#10;&#10;            {/* Comments List */}&#10;            {isLoadingComments ? (&#10;              &lt;div className=&quot;flex justify-center py-4&quot;&gt;&#10;                &lt;LoadingSpinner size=&quot;sm&quot; /&gt;&#10;              &lt;/div&gt;&#10;            ) : (&#10;              &lt;div className=&quot;max-h-80 overflow-y-auto scrollbar-thin scrollbar-thumb-gray-300 scrollbar-track-gray-100&quot;&gt;&#10;                &lt;div className=&quot;space-y-3 pr-2&quot;&gt;&#10;                  {comments.length === 0 ? (&#10;                    &lt;p className=&quot;text-gray-500 text-sm text-center py-8 vietnamese-text&quot;&gt;&#10;                      Chưa có bình luận nào. Hãy là người đầu tiên bình luận!&#10;                    &lt;/p&gt;&#10;                  ) : (&#10;                    comments.map((comment) =&gt; (&#10;                      &lt;div key={comment.id} className=&quot;flex space-x-3 group&quot;&gt;&#10;                        {/* Comment Author Avatar */}&#10;&#10;                          &lt;Avatar&#10;                            id={comment.author?.id}&#10;                            src={comment.author?.avatarUrl || '/default-avatar.png'}&#10;                            alt={comment.author?.fullName || comment.author?.username || 'Avatar'}&#10;                            size=&quot;md&quot;&#10;                          /&gt;&#10;&#10;&#10;                        &lt;div className=&quot;flex-1 min-w-0&quot;&gt;&#10;                          &lt;div className=&quot;bg-gray-100 rounded-2xl px-4 py-3 relative&quot;&gt;&#10;                            {/* Comment Menu Button */}&#10;                            &lt;div className=&quot;absolute top-2 right-2 opacity-0 group-hover:opacity-100 transition-opacity&quot;&gt;&#10;                              &lt;div className=&quot;relative&quot;&gt;&#10;                                &lt;button&#10;                                  onClick={() =&gt; toggleCommentMenu(comment.id)}&#10;                                  className=&quot;p-1 hover:bg-gray-200 rounded-full transition-colors&quot;&#10;                                &gt;&#10;                                  &lt;MoreHorizontal className=&quot;h-3 w-3 text-gray-500&quot; /&gt;&#10;                                &lt;/button&gt;&#10;&#10;                                {/* Comment Menu Dropdown */}&#10;                                {commentMenus[comment.id] &amp;&amp; (&#10;                                  &lt;div className=&quot;absolute right-0 top-full mt-1 bg-white rounded-lg shadow-lg border border-gray-200 py-1 z-50 min-w-[140px]&quot;&gt;&#10;                                    { comment.author?.id != user?.id &amp;&amp; (&#10;                                        &lt;button&#10;                                            onClick={() =&gt; handleCommentAction('report', comment.id)}&#10;                                            className=&quot;flex items-center space-x-2 w-full px-3 py-2 text-sm text-gray-700 hover:bg-gray-50 transition-colors&quot;&#10;                                        &gt;&#10;                                          &lt;Flag className=&quot;h-4 w-4 text-red-500&quot; /&gt;&#10;                                          &lt;span&gt;Báo cáo&lt;/span&gt;&#10;                                        &lt;/button&gt;)}&#10;&#10;&#10;                                    {comment.author?.id === user?.id &amp;&amp; (&#10;                                      &lt;button&#10;                                        onClick={() =&gt; handleCommentAction('delete', comment.id)}&#10;                                        className=&quot;flex items-center space-x-2 w-full px-3 py-2 text-sm text-red-600 hover:bg-red-50 transition-colors&quot;&#10;                                      &gt;&#10;                                        &lt;Trash2 className=&quot;h-4 w-4&quot; /&gt;&#10;                                        &lt;span&gt;Xóa&lt;/span&gt;&#10;                                      &lt;/button&gt;&#10;                                    )}&#10;                                    {comment.author?.id != user?.id &amp;&amp; (&#10;                                        &lt;button&#10;                                            onClick={() =&gt; handleCommentAction('hide', comment.id)}&#10;                                            className=&quot;flex items-center space-x-2 w-full px-3 py-2 text-sm text-gray-700 hover:bg-gray-50 transition-colors&quot;&#10;                                        &gt;&#10;                                          &lt;EyeOff className=&quot;h-4 w-4&quot; /&gt;&#10;                                          &lt;span&gt;Ẩn bình luận&lt;/span&gt;&#10;                                        &lt;/button&gt;)}&#10;&#10;                                  &lt;/div&gt;&#10;                                )}&#10;                              &lt;/div&gt;&#10;                            &lt;/div&gt;&#10;&#10;                            &lt;div className=&quot;flex items-center space-x-2 mb-1&quot;&gt;&#10;                              &lt;span className=&quot;font-semibold text-sm text-gray-900 vietnamese-text truncate&quot;&gt;&#10;                                {comment.author?.fullName || comment.author?.name || 'Người dùng ẩn danh'}&#10;                              &lt;/span&gt;&#10;                              {comment.author?.role &amp;&amp; (&#10;                                &lt;span className={`px-2 py-0.5 rounded-full text-xs font-medium flex-shrink-0 ${&#10;                                  comment.author.role === 'LECTURER' &#10;                                    ? 'bg-blue-100 text-blue-700' &#10;                                    : 'bg-green-100 text-green-700'&#10;                                }`}&gt;&#10;                                  {comment.author.role === 'LECTURER' ? 'Giảng viên' : 'Sinh viên'}&#10;                                &lt;/span&gt;&#10;                              )}&#10;                            &lt;/div&gt;&#10;&#10;                            &lt;p className=&quot;text-sm text-gray-800 vietnamese-text leading-relaxed break-words&quot;&gt;&#10;                              {comment.content}&#10;                            &lt;/p&gt;&#10;                          &lt;/div&gt;&#10;&#10;                          {/* Comment Actions */}&#10;                          &lt;div className=&quot;flex items-center space-x-4 mt-2 text-xs text-gray-500&quot;&gt;&#10;                            &lt;time dateTime={comment.createdAt} className=&quot;flex-shrink-0&quot;&gt;&#10;                              {formatTimeAgo(comment.createdAt)}&#10;                            &lt;/time&gt;&#10;                            &lt;button className=&quot;hover:underline font-medium transition-colors hover:text-blue-600&quot;&gt;&#10;                              Thích&#10;                            &lt;/button&gt;&#10;                            &lt;button className=&quot;hover:underline font-medium transition-colors hover:text-blue-600&quot;&gt;&#10;                              Trả lời&#10;                            &lt;/button&gt;&#10;                          &lt;/div&gt;&#10;                        &lt;/div&gt;&#10;                      &lt;/div&gt;&#10;                    ))&#10;                  )}&#10;                &lt;/div&gt;&#10;&#10;                {/* Load More Comments Button */}&#10;                {comments.length &gt; 0 &amp;&amp; (&#10;                  &lt;div className=&quot;text-center pt-3 mt-3 border-t border-gray-200&quot;&gt;&#10;                    &lt;button className=&quot;text-sm text-blue-600 hover:text-blue-700 font-medium transition-colors&quot;&gt;&#10;                      Xem thêm bình luận&#10;                    &lt;/button&gt;&#10;                  &lt;/div&gt;&#10;                )}&#10;              &lt;/div&gt;&#10;            )}&#10;          &lt;/div&gt;&#10;        &lt;/div&gt;&#10;      )}&#10;&#10;      {/* Action Feedback */}&#10;      {actionFeedback &amp;&amp; (&#10;        &lt;div className=&quot;fixed bottom-4 left-1/2 transform -translate-x-1/2 bg-gray-800 text-white px-4 py-2 rounded-lg shadow-lg z-50 vietnamese-text&quot;&gt;&#10;          {actionFeedback}&#10;        &lt;/div&gt;&#10;      )}&#10;&#10;      {/* Edit Post Modal */}&#10;      {showEditModal &amp;&amp; (&#10;        &lt;PostEditModal&#10;          isOpen={showEditModal}&#10;          onClose={() =&gt; setShowEditModal(false)}&#10;          post={post}&#10;          onSave={handlePostSave}&#10;        /&gt;&#10;      )}&#10;    &lt;/Card&gt;&#10;  );&#10;};&#10;" />
              <option name="updatedContent" value="'use client';&#10;&#10;import React, { useState, useEffect, useCallback } from 'react';&#10;import { Post, CreateCommentRequest, UpdatePostRequest } from '@/types';&#10;import { postService } from '@/services/postService';&#10;import { Button } from '@/components/ui/Button';&#10;import { Card } from '@/components/ui/Card';&#10;import { Textarea } from '@/components/ui/Textarea';&#10;import { LoadingSpinner } from '@/components/ui/LoadingSpinner';&#10;import { ReactionButton } from '@/components/ui/ReactionButton';&#10;import { PostMenu } from '@/components/post/PostMenu';&#10;import { PostEditModal } from '@/components/post/PostEditModal';&#10;import { EditIndicator } from '@/components/post/EditIndicator';&#10;import { CommentItem } from '@/components/post/CommentItem';&#10;import { t, formatTimeAgo } from '@/utils/localization';&#10;import {&#10;  MessageCircle,&#10;  Share,&#10;  Eye,&#10;  Globe,&#10;  Users,&#10;  Lock, ThumbsUp, Heart, MoreHorizontal, Flag, Trash2, EyeOff&#10;} from 'lucide-react';&#10;import Avatar from &quot;@/components/ui/Avatar&quot;;&#10;import {useAuth} from &quot;@/contexts/AuthContext&quot;;&#10;&#10;interface PostCardProps {&#10;  post: any;&#10;  onPostUpdate?: (updatedPost: any) =&gt; void;&#10;  onPostDelete?: (postId: string) =&gt; void;&#10;  className?: string;&#10;}&#10;&#10;export const PostCard: React.FC&lt;PostCardProps&gt; = ({&#10;  post,&#10;  onPostUpdate,&#10;  onPostDelete,&#10;  className = ''&#10;}) =&gt; {&#10;  const { user } = useAuth();&#10;  const [isLiked, setIsLiked] = useState(false);&#10;  const [isBookmarked, setIsBookmarked] = useState(false);&#10;  const [showComments, setShowComments] = useState(false);&#10;  const [commentText, setCommentText] = useState('');&#10;  const [comments, setComments] = useState&lt;any[]&gt;([]);&#10;  const [isLoadingComments, setIsLoadingComments] = useState(false);&#10;  const [isSubmittingComment, setIsSubmittingComment] = useState(false);&#10;  const [isLoadingInteraction, setIsLoadingInteraction] = useState(false);&#10;  const [actionFeedback, setActionFeedback] = useState&lt;string | null&gt;(null);&#10;  const [showEditModal, setShowEditModal] = useState(false);&#10;  const [currentReaction, setCurrentReaction] = useState&lt;string | null&gt;(null);&#10;  const [reactionCounts, setReactionCounts] = useState&lt;{[key: string]: number}&gt;({});&#10;  const [commentMenus, setCommentMenus] = useState&lt;{[key: string]: boolean}&gt;({});&#10;&#10;  const isOwnPost = user?.id === post.authorId || user?.id === post.author?.id;&#10;&#10;  // Load trạng thái like, bookmark khi mount&#10;  useEffect(() =&gt; {&#10;    let mounted = true;&#10;    (async () =&gt; {&#10;      try {&#10;        const status = await postService.getInteractionStatus(post.id);&#10;        if (mounted) {&#10;          setIsLiked(status.hasLiked);&#10;          setIsBookmarked(status.hasBookmarked);&#10;        }&#10;      } catch (error) {&#10;        console.debug('Không thể tải trạng thái tương tác:', error);&#10;      }&#10;    })();&#10;    return () =&gt; { mounted = false; };&#10;  }, [post.id]);&#10;&#10;  // Show feedback message temporarily&#10;  const showFeedback = (message: string) =&gt; {&#10;    setActionFeedback(message);&#10;    setTimeout(() =&gt; setActionFeedback(null), 1500);&#10;  };&#10;&#10;  // Toggle phần comment&#10;  const toggleComments = useCallback(async () =&gt; {&#10;    if (!showComments &amp;&amp; comments.length === 0) {&#10;      setIsLoadingComments(true);&#10;      try {&#10;        const response = await postService.getComments(post.id);&#10;        setComments(response.content || []);&#10;      } catch (error) {&#10;        console.error('Không thể tải bình luận:', error);&#10;        showFeedback('Không thể tải bình luận');&#10;      } finally {&#10;        setIsLoadingComments(false);&#10;      }&#10;    }&#10;    setShowComments(v =&gt; !v);&#10;  }, [showComments, comments.length, post.id]);&#10;&#10;  // Chức năng tương tác: like, bookmark, share&#10;  const handleInteraction = useCallback(async (type: 'like' | 'bookmark' | 'share') =&gt; {&#10;    if (isLoadingInteraction) return;&#10;    setIsLoadingInteraction(true);&#10;    try {&#10;      if (type === 'like') {&#10;        await postService.toggleLike(post.id);&#10;        setIsLiked(l =&gt; {&#10;          const newLiked = !l;&#10;          const newLikes = newLiked ? post.stats.likes + 1 : post.stats.likes - 1;&#10;          onPostUpdate?.({&#10;            ...post,&#10;            stats: { ...post.stats, likes: newLikes }&#10;          });&#10;          showFeedback(newLiked ? 'Đã thích bài viết' : 'Đã bỏ thích');&#10;          return newLiked;&#10;        });&#10;      } else if (type === 'bookmark') {&#10;        await postService.toggleBookmark(post.id);&#10;        setIsBookmarked(b =&gt; {&#10;          const newBookmarked = !b;&#10;          const newBookmarks = newBookmarked ? post.stats.bookmarks + 1 : post.stats.bookmarks - 1;&#10;          onPostUpdate?.({&#10;            ...post,&#10;            stats: { ...post.stats, bookmarks: newBookmarks }&#10;          });&#10;          showFeedback(newBookmarked ? 'Đã lưu bài viết' : 'Đã bỏ lưu bài viết');&#10;          return newBookmarked;&#10;        });&#10;      } else if (type === 'share') {&#10;        await postService.sharePost(post.id);&#10;        onPostUpdate?.({&#10;          ...post,&#10;          stats: { ...post.stats, shares: post.stats.shares + 1 }&#10;        });&#10;        await navigator.clipboard.writeText(`${window.location.origin}/posts/${post.id}`);&#10;        showFeedback('Đã sao chép liên kết bài viết');&#10;      }&#10;    } catch (error) {&#10;      console.error(`Không thể thực hiện ${type}:`, error);&#10;      showFeedback('Có lỗi xảy ra, vui lòng thử lại');&#10;    } finally {&#10;      setIsLoadingInteraction(false);&#10;    }&#10;  }, [isLoadingInteraction, onPostUpdate, post]);&#10;&#10;  // Gửi comment&#10;  const handleSubmitComment = useCallback(async (e: React.FormEvent) =&gt; {&#10;    e.preventDefault();&#10;    if (!commentText.trim() || isSubmittingComment) return;&#10;&#10;    setIsSubmittingComment(true);&#10;    try {&#10;      const commentData: CreateCommentRequest = { content: commentText.trim() };&#10;      const newComment = await postService.createComment(post.id, commentData);&#10;      setComments(prev =&gt; [...prev, newComment]);&#10;      setCommentText('');&#10;      onPostUpdate?.({&#10;        ...post,&#10;        stats: { ...post.stats, comments: post.stats.comments + 1 }&#10;      });&#10;      showFeedback('Đã thêm bình luận');&#10;    } catch (error) {&#10;      console.error('Không thể tạo bình luận:', error);&#10;      showFeedback('Không th�� gửi bình luận');&#10;    } finally {&#10;      setIsSubmittingComment(false);&#10;    }&#10;  }, [commentText, isSubmittingComment, onPostUpdate, post]);&#10;&#10;  // Format số lượng hiển thị&#10;  const formatStats = (count: number): string =&gt; {&#10;    if (count &gt;= 1_000_000) return `${(count / 1_000_000).toFixed(1)}M`;&#10;    if (count &gt;= 1000) return `${(count / 1000).toFixed(1)}K`;&#10;    return count.toString();&#10;  };&#10;&#10;  // Get privacy icon&#10;  const getPrivacyIcon = () =&gt; {&#10;    switch (post.privacy || post.visibility) {&#10;      case 'PUBLIC':&#10;        return &lt;Globe className=&quot;h-3 w-3 text-gray-500&quot; /&gt;;&#10;      case 'FRIENDS':&#10;        return &lt;Users className=&quot;h-3 w-3 text-gray-500&quot; /&gt;;&#10;      case 'PRIVATE':&#10;        return &lt;Lock className=&quot;h-3 w-3 text-gray-500&quot; /&gt;;&#10;      default:&#10;        return &lt;Globe className=&quot;h-3 w-3 text-gray-500&quot; /&gt;;&#10;    }&#10;  };&#10;&#10;  const getPrivacyText = () =&gt; {&#10;    switch (post.privacy || post.visibility) {&#10;      case 'PUBLIC': return 'Công khai';&#10;      case 'FRIENDS': return 'Bạn bè';&#10;      case 'PRIVATE': return 'Riêng tư';&#10;      default: return 'Công khai';&#10;    }&#10;  };&#10;&#10;  // Function to toggle comment menu&#10;  const toggleCommentMenu = (commentId: string) =&gt; {&#10;    setCommentMenus(prev =&gt; ({&#10;      ...prev,&#10;      [commentId]: !prev[commentId]&#10;    }));&#10;  };&#10;&#10;  // New enhanced handlers for reactions and post actions&#10;  const handleReactionClick = useCallback(async (reactionId: string) =&gt; {&#10;    if (isLoadingInteraction) return;&#10;    setIsLoadingInteraction(true);&#10;&#10;    try {&#10;      // TODO: Implement reaction API call&#10;      // await postService.addReaction(post.id, reactionId);&#10;      setCurrentReaction(reactionId);&#10;&#10;      // Update reaction counts&#10;      setReactionCounts(prev =&gt; ({&#10;        ...prev,&#10;        [reactionId]: (prev[reactionId] || 0) + 1&#10;      }));&#10;&#10;      showFeedback(`Đã ${reactionId === 'LIKE' ? 'thích' : 'phản ứng'} bài viết`);&#10;    } catch (error) {&#10;      console.error('Error adding reaction:', error);&#10;      showFeedback('Không thể thêm phản ứng');&#10;    } finally {&#10;      setIsLoadingInteraction(false);&#10;    }&#10;  }, [isLoadingInteraction, post.id]);&#10;&#10;  const handleReactionRemove = useCallback(async () =&gt; {&#10;    if (isLoadingInteraction || !currentReaction) return;&#10;    setIsLoadingInteraction(true);&#10;&#10;    try {&#10;      // TODO: Implement remove reaction API call&#10;      // await postService.removeReaction(post.id);&#10;&#10;      // Update reaction counts&#10;      setReactionCounts(prev =&gt; ({&#10;        ...prev,&#10;        [currentReaction]: Math.max((prev[currentReaction] || 0) - 1, 0)&#10;      }));&#10;&#10;      setCurrentReaction(null);&#10;      showFeedback('Đã bỏ phản ứng');&#10;    } catch (error) {&#10;      console.error('Error removing reaction:', error);&#10;      showFeedback('Không thể bỏ phản ứng');&#10;    } finally {&#10;      setIsLoadingInteraction(false);&#10;    }&#10;  }, [isLoadingInteraction, currentReaction, post.id]);&#10;&#10;  // Post menu handlers&#10;  const handlePostEdit = () =&gt; {&#10;    setShowEditModal(true);&#10;  };&#10;&#10;  const handlePostDelete = async () =&gt; {&#10;    if (window.confirm('Bạn có chắc chắn muốn xóa bài viết này?')) {&#10;      try {&#10;        await postService.deletePost(post.id);&#10;        onPostDelete?.(post.id);&#10;        showFeedback('Đã xóa bài viết');&#10;      } catch (error) {&#10;        console.error('Error deleting post:', error);&#10;        showFeedback('Không thể xóa bài viết');&#10;      }&#10;    }&#10;  };&#10;&#10;  const handlePostSave = async (updatedPost: UpdatePostRequest) =&gt; {&#10;    try {&#10;      const result = await postService.updatePost(post.id, updatedPost);&#10;      onPostUpdate?.(result);&#10;      showFeedback('Đã cập nhật bài viết');&#10;    } catch (error) {&#10;      console.error('Error updating post:', error);&#10;      throw error;&#10;    }&#10;  };&#10;&#10;  const handlePostReport = () =&gt; {&#10;    // TODO: Implement report functionality&#10;    showFeedback('Đã báo cáo bài viết');&#10;  };&#10;&#10;  const handlePostHide = () =&gt; {&#10;    // TODO: Implement hide functionality&#10;    showFeedback('Đã ẩn bài viết');&#10;  };&#10;&#10;  const handlePostBlock = () =&gt; {&#10;    // TODO: Implement block functionality&#10;    showFeedback(`Đã chặn bài viết từ ${post.author?.fullName || post.author?.name || 'người dùng này'}`);&#10;  };&#10;&#10;  const handleCopyLink = async () =&gt; {&#10;    try {&#10;      await navigator.clipboard.writeText(`${window.location.origin}/posts/${post.id}`);&#10;      showFeedback('Đã sao chép liên kết');&#10;    } catch (error) {&#10;      showFeedback('Không thể sao chép liên kết');&#10;    }&#10;  };&#10;&#10;  return (&#10;    &lt;Card className={`bg-white rounded-lg shadow-sm hover:shadow-md transition-shadow duration-200 border border-gray-200 mb-4 ${className}`}&gt;&#10;      {/* Feedback Toast */}&#10;      {actionFeedback &amp;&amp; (&#10;        &lt;div className=&quot;absolute top-3 right-3 z-10 bg-gray-800 text-white px-3 py-1 rounded text-xs animate-fade-in&quot;&gt;&#10;          {actionFeedback}&#10;        &lt;/div&gt;&#10;      )}&#10;      &#10;      {/* Header - Facebook Style */}&#10;      &lt;div className=&quot;p-3&quot;&gt;&#10;        &lt;div className=&quot;flex items-center justify-between&quot;&gt;&#10;          &lt;div className=&quot;flex items-center space-x-3&quot;&gt;&#10;            {/* Avatar */}&#10;&#10;                &lt;Avatar&#10;                    id={post.author?.id}&#10;                    src={post.author?.avatarUrl || '/default-avatar.png'}&#10;                    alt={ post.author?.fullName ||  post.author?.username || 'Avatar'}&#10;                    size=&quot;md&quot;&#10;                /&gt;&#10;&#10;            &#10;            {/* User Info */}&#10;            &lt;div className=&quot;flex-1&quot;&gt;&#10;              &lt;div className=&quot;flex items-center space-x-2&quot;&gt;&#10;                &lt;h3 className=&quot;font-semibold text-sm text-gray-900 hover:underline cursor-pointer vietnamese-text&quot;&gt;&#10;                  {post.author?.fullName || post.author?.name || post.authorName || 'Người dùng'}&#10;                &lt;/h3&gt;&#10;                {post.author?.role &amp;&amp; (&#10;                  &lt;span className={`px-2 py-0.5 rounded text-xs font-medium ${&#10;                    post.author.role === 'LECTURER' &#10;                      ? 'bg-blue-100 text-blue-700' &#10;                      : 'bg-green-100 text-green-700'&#10;                  }`}&gt;&#10;                    {post.author.role === 'LECTURER' ? 'GV' : 'SV'}&#10;                  &lt;/span&gt;&#10;                )}&#10;              &lt;/div&gt;&#10;              &#10;              &lt;div className=&quot;flex items-center space-x-1 text-xs text-gray-500 mt-0.5&quot;&gt;&#10;                &lt;time dateTime={post.createdAt}&gt;&#10;                  {formatTimeAgo(post.createdAt)}&#10;                &lt;/time&gt;&#10;                &lt;span&gt;•&lt;/span&gt;&#10;                {getPrivacyIcon()}&#10;              &lt;/div&gt;&#10;            &lt;/div&gt;&#10;          &lt;/div&gt;&#10;          &#10;          {/* More Options */}&#10;          &lt;PostMenu&#10;            post={post}&#10;            onEdit={isOwnPost ? handlePostEdit : undefined}&#10;            onDelete={isOwnPost ? handlePostDelete : undefined}&#10;            onReport={!isOwnPost ? handlePostReport : undefined}&#10;            onHide={!isOwnPost ? handlePostHide : undefined}&#10;            onBlock={!isOwnPost ? handlePostBlock : undefined}&#10;            onBookmark={() =&gt; handleInteraction('bookmark')}&#10;            onShare={() =&gt; handleInteraction('share')}&#10;            onCopyLink={handleCopyLink}&#10;          /&gt;&#10;        &lt;/div&gt;&#10;&#10;        {/* Edit Indicator */}&#10;        &lt;EditIndicator&#10;          isEdited={post.isEdited}&#10;          className=&quot;mt-1 ml-12&quot;&#10;        /&gt;&#10;      &lt;/div&gt;&#10;&#10;      {/* Content */}&#10;      &lt;div className=&quot;px-3 pb-3&quot;&gt;&#10;        {/* Title */}&#10;        {post.title &amp;&amp; (&#10;          &lt;h2 className=&quot;font-semibold text-gray-900 mb-2 vietnamese-text&quot;&gt;&#10;            {post.title}&#10;          &lt;/h2&gt;&#10;        )}&#10;        &#10;        {/* Text Content */}&#10;        &lt;div className=&quot;text-gray-800 text-sm leading-relaxed vietnamese-text mb-3&quot;&gt;&#10;          {post.content}&#10;        &lt;/div&gt;&#10;        &#10;        {/* Tags */}&#10;        {post.tags &amp;&amp; post.tags.length &gt; 0 &amp;&amp; (&#10;          &lt;div className=&quot;flex flex-wrap gap-1 mb-3&quot;&gt;&#10;            {post.tags.map((tag: string, index: number) =&gt; (&#10;              &lt;span&#10;                key={index}&#10;                className=&quot;text-blue-600 hover:underline cursor-pointer text-sm&quot;&#10;              &gt;&#10;                #{tag}&#10;              &lt;/span&gt;&#10;            ))}&#10;          &lt;/div&gt;&#10;        )}&#10;&#10;        {/* Media - Images */}&#10;        {post.images &amp;&amp; post.images.length &gt; 0 &amp;&amp; (&#10;          &lt;div className=&quot;mb-3 -mx-3&quot;&gt;&#10;            &lt;div className={`grid gap-0.5 ${&#10;              post.images.length === 1 ? 'grid-cols-1' :&#10;              post.images.length === 2 ? 'grid-cols-2' :&#10;              post.images.length === 3 ? 'grid-cols-2' : 'grid-cols-2'&#10;            }`}&gt;&#10;              {post.images.slice(0, 4).map((imageUrl: string, index: number) =&gt; (&#10;                &lt;div&#10;                  key={index}&#10;                  className={`relative bg-gray-100 ${&#10;                    post.images.length === 3 &amp;&amp; index === 0 ? 'row-span-2' : ''&#10;                  }`}&#10;                &gt;&#10;                  &lt;img&#10;                    src={imageUrl}&#10;                    alt={`Ảnh bài viết ${index + 1}`}&#10;                    className=&quot;w-full h-full object-cover cursor-pointer hover:opacity-95 transition-opacity min-h-[200px] max-h-[400px]&quot;&#10;                    onClick={() =&gt; window.open(imageUrl, '_blank')}&#10;                  /&gt;&#10;                  {post.images.length &gt; 4 &amp;&amp; index === 3 &amp;&amp; (&#10;                    &lt;div className=&quot;absolute inset-0 bg-black bg-opacity-60 flex items-center justify-center cursor-pointer&quot;&gt;&#10;                      &lt;span className=&quot;text-white text-xl font-semibold&quot;&gt;&#10;                        +{post.images.length - 4}&#10;                      &lt;/span&gt;&#10;                    &lt;/div&gt;&#10;                  )}&#10;                &lt;/div&gt;&#10;              ))}&#10;            &lt;/div&gt;&#10;          &lt;/div&gt;&#10;        )}&#10;&#10;        {/* Media - Videos */}&#10;        {post.videos &amp;&amp; post.videos.length &gt; 0 &amp;&amp; (&#10;          &lt;div className=&quot;mb-3 -mx-3&quot;&gt;&#10;            {post.videos.map((videoUrl: string, index: number) =&gt; (&#10;              &lt;div key={index} className=&quot;bg-black&quot;&gt;&#10;                &lt;video&#10;                  src={videoUrl}&#10;                  controls&#10;                  className=&quot;w-full h-auto max-h-[500px]&quot;&#10;                  preload=&quot;metadata&quot;&#10;                &gt;&#10;                  Trình duyệt của bạn không hỗ trợ video.&#10;                &lt;/video&gt;&#10;              &lt;/div&gt;&#10;            ))}&#10;          &lt;/div&gt;&#10;        )}&#10;      &lt;/div&gt;&#10;&#10;      {/* Stats */}&#10;      {(post.stats?.likes &gt; 0 || post.stats?.comments &gt; 0 || post.stats?.shares &gt; 0) &amp;&amp; (&#10;        &lt;div className=&quot;px-3 py-2 border-t border-gray-100&quot;&gt;&#10;          &lt;div className=&quot;flex items-center justify-between text-xs text-gray-500&quot;&gt;&#10;            &lt;div className=&quot;flex items-center space-x-1&quot;&gt;&#10;              {post.stats?.likes &gt; 0 &amp;&amp; (&#10;                &lt;&gt;&#10;                  &lt;div className=&quot;flex -space-x-1&quot;&gt;&#10;                    &lt;div className=&quot;w-4 h-4 bg-blue-500 rounded-full flex items-center justify-center&quot;&gt;&#10;                      &lt;ThumbsUp className=&quot;w-2.5 h-2.5 text-white fill-current&quot; /&gt;&#10;                    &lt;/div&gt;&#10;                    &lt;div className=&quot;w-4 h-4 bg-red-500 rounded-full flex items-center justify-center&quot;&gt;&#10;                      &lt;Heart className=&quot;w-2.5 h-2.5 text-white fill-current&quot; /&gt;&#10;                    &lt;/div&gt;&#10;                  &lt;/div&gt;&#10;                  &lt;span&gt;{formatStats(post.stats.likes)}&lt;/span&gt;&#10;                &lt;/&gt;&#10;              )}&#10;            &lt;/div&gt;&#10;            &lt;div className=&quot;flex items-center space-x-3&quot;&gt;&#10;              {post.stats?.comments &gt; 0 &amp;&amp; (&#10;                &lt;button&#10;                  onClick={toggleComments}&#10;                  className=&quot;hover:underline&quot;&#10;                &gt;&#10;                  {formatStats(post.stats.comments)} bình luận&#10;                &lt;/button&gt;&#10;              )}&#10;              {post.stats?.shares &gt; 0 &amp;&amp; (&#10;                &lt;span&gt;{formatStats(post.stats.shares)} chia sẻ&lt;/span&gt;&#10;              )}&#10;            &lt;/div&gt;&#10;          &lt;/div&gt;&#10;        &lt;/div&gt;&#10;      )}&#10;&#10;      {/* Action Buttons - Enhanced with Reactions */}&#10;      &lt;div className=&quot;border-t border-gray-100&quot;&gt;&#10;        &lt;div className=&quot;flex&quot;&gt;&#10;          {/* Enhanced Reaction Button */}&#10;          &lt;div className=&quot;flex-1 flex justify-center&quot;&gt;&#10;            &lt;ReactionButton&#10;              onReactionClick={handleReactionClick}&#10;              onReactionRemove={handleReactionRemove}&#10;              currentReaction={currentReaction}&#10;              reactionCounts={reactionCounts}&#10;              disabled={isLoadingInteraction}&#10;              size=&quot;md&quot;&#10;              showPicker={true}&#10;            /&gt;&#10;          &lt;/div&gt;&#10;&#10;          &lt;button&#10;            onClick={toggleComments}&#10;            className=&quot;flex-1 flex items-center justify-center py-2 px-3 text-gray-600 hover:bg-gray-50 transition-colors&quot;&#10;          &gt;&#10;            &lt;MessageCircle className=&quot;h-4 w-4 mr-2&quot; /&gt;&#10;            &lt;span className=&quot;text-sm font-medium vietnamese-text&quot;&gt;Bình luận&lt;/span&gt;&#10;          &lt;/button&gt;&#10;&#10;          &lt;button&#10;            onClick={() =&gt; handleInteraction('share')}&#10;            disabled={isLoadingInteraction}&#10;            className=&quot;flex-1 flex items-center justify-center py-2 px-3 text-gray-600 hover:bg-gray-50 transition-colors&quot;&#10;          &gt;&#10;            &lt;Share className=&quot;h-4 w-4 mr-2&quot; /&gt;&#10;            &lt;span className=&quot;text-sm font-medium vietnamese-text&quot;&gt;Chia sẻ&lt;/span&gt;&#10;          &lt;/button&gt;&#10;        &lt;/div&gt;&#10;      &lt;/div&gt;&#10;&#10;      {/* Comments Section */}&#10;      {showComments &amp;&amp; (&#10;        &lt;div className=&quot;border-t border-gray-100 bg-gray-50&quot;&gt;&#10;          &lt;div className=&quot;p-3&quot;&gt;&#10;            {/* Comment Form */}&#10;            &lt;form onSubmit={handleSubmitComment} className=&quot;mb-3&quot;&gt;&#10;              &lt;div className=&quot;flex space-x-2&quot;&gt;&#10;&#10;                    &lt;Avatar&#10;                        id={ user?.id}&#10;                        src={ user?.avatarUrl || '/default-avatar.png'}&#10;                        alt={ user?.fullName ||  user?.username || 'Avatar'}&#10;                        size=&quot;md&quot;&#10;                        /&gt;&#10;&#10;                &lt;div className=&quot;flex-1&quot;&gt;&#10;                  &lt;Textarea&#10;                    value={commentText}&#10;                    onChange={(e) =&gt; setCommentText(e.target.value)}&#10;                    placeholder=&quot;Viết bình luận...&quot;&#10;                    className=&quot;min-h-[32px] text-sm bg-gray-300 text-black border-0 rounded-full px-3 py-2 resize-none vietnamese-text&quot;&#10;                    disabled={isSubmittingComment}&#10;                  /&gt;&#10;                  {commentText.trim() &amp;&amp; (&#10;                    &lt;div className=&quot;flex justify-end mt-1&quot;&gt;&#10;                      &lt;Button&#10;                        type=&quot;submit&quot;&#10;                        size=&quot;sm&quot;&#10;                        disabled={isSubmittingComment}&#10;                        className=&quot;text-xs px-3 py-1&quot;&#10;                      &gt;&#10;                        {isSubmittingComment ? &lt;LoadingSpinner size=&quot;sm&quot; /&gt; : 'Gửi'}&#10;                      &lt;/Button&gt;&#10;                    &lt;/div&gt;&#10;                  )}&#10;                &lt;/div&gt;&#10;              &lt;/div&gt;&#10;            &lt;/form&gt;&#10;&#10;            {/* Comments List - Enhanced with CommentItem */}&#10;            {isLoadingComments ? (&#10;              &lt;div className=&quot;flex justify-center py-4&quot;&gt;&#10;                &lt;LoadingSpinner size=&quot;sm&quot; /&gt;&#10;              &lt;/div&gt;&#10;            ) : (&#10;              &lt;div className=&quot;max-h-80 overflow-y-auto scrollbar-thin scrollbar-thumb-gray-300 scrollbar-track-gray-100&quot;&gt;&#10;                &lt;div className=&quot;space-y-3 pr-2&quot;&gt;&#10;                  {comments.length === 0 ? (&#10;                    &lt;p className=&quot;text-gray-500 text-sm text-center py-8 vietnamese-text&quot;&gt;&#10;                      Chưa có bình luận nào. Hãy là người đầu tiên bình luận!&#10;                    &lt;/p&gt;&#10;                  ) : (&#10;                    comments.map((comment) =&gt; (&#10;                      &lt;CommentItem&#10;                        key={comment.id}&#10;                        comment={comment}&#10;                        postId={post.id}&#10;                        onCommentUpdate={(updatedComment) =&gt; {&#10;                          setComments(prev =&gt; &#10;                            prev.map(c =&gt; c.id === updatedComment.id ? updatedComment : c)&#10;                          );&#10;                        }}&#10;                        onCommentDelete={(commentId) =&gt; {&#10;                          setComments(prev =&gt; prev.filter(c =&gt; c.id !== commentId));&#10;                          onPostUpdate?.({&#10;                            ...post,&#10;                            stats: { ...post.stats, comments: Math.max(post.stats.comments - 1, 0) }&#10;                          });&#10;                        }}&#10;                        depth={0}&#10;                      /&gt;&#10;                    ))&#10;                  )}&#10;                &lt;/div&gt;&#10;&#10;                {/* Load More Comments Button */}&#10;                {comments.length &gt; 0 &amp;&amp; (&#10;                  &lt;div className=&quot;text-center pt-3 mt-3 border-t border-gray-200&quot;&gt;&#10;                    &lt;button className=&quot;text-sm text-blue-600 hover:text-blue-700 font-medium transition-colors vietnamese-text&quot;&gt;&#10;                      Xem thêm bình luận&#10;                    &lt;/button&gt;&#10;                  &lt;/div&gt;&#10;                )}&#10;              &lt;/div&gt;&#10;            )}&#10;          &lt;/div&gt;&#10;        &lt;/div&gt;&#10;      )}&#10;&#10;      {/* Action Feedback */}&#10;      {actionFeedback &amp;&amp; (&#10;        &lt;div className=&quot;fixed bottom-4 left-1/2 transform -translate-x-1/2 bg-gray-800 text-white px-4 py-2 rounded-lg shadow-lg z-50 vietnamese-text&quot;&gt;&#10;          {actionFeedback}&#10;        &lt;/div&gt;&#10;      )}&#10;&#10;      {/* Edit Post Modal */}&#10;      {showEditModal &amp;&amp; (&#10;        &lt;PostEditModal&#10;          isOpen={showEditModal}&#10;          onClose={() =&gt; setShowEditModal(false)}&#10;          post={post}&#10;          onSave={handlePostSave}&#10;        /&gt;&#10;      )}&#10;    &lt;/Card&gt;&#10;  );&#10;};&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/client-frontend/src/components/post/PostEditModal.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/client-frontend/src/components/post/PostEditModal.tsx" />
              <option name="updatedContent" value="'use client';&#10;&#10;import React, { useState } from 'react';&#10;import { Modal } from '@/components/ui/Modal';&#10;import { Button } from '@/components/ui/Button';&#10;import { Textarea } from '@/components/ui/Textarea';&#10;import { Input } from '@/components/ui/Input';&#10;import { LoadingSpinner } from '@/components/ui/LoadingSpinner';&#10;import { UpdatePostRequest } from '@/types';&#10;import { X, Image, Video, Hash } from 'lucide-react';&#10;&#10;interface PostEditModalProps {&#10;  isOpen: boolean;&#10;  onClose: () =&gt; void;&#10;  post: any;&#10;  onSave: (updatedPost: UpdatePostRequest) =&gt; Promise&lt;void&gt;;&#10;}&#10;&#10;export const PostEditModal: React.FC&lt;PostEditModalProps&gt; = ({&#10;  isOpen,&#10;  onClose,&#10;  post,&#10;  onSave&#10;}) =&gt; {&#10;  const [title, setTitle] = useState(post.title || '');&#10;  const [content, setContent] = useState(post.content || '');&#10;  const [category, setCategory] = useState(post.category || '');&#10;  const [tags, setTags] = useState&lt;string[]&gt;(post.tags || []);&#10;  const [tagInput, setTagInput] = useState('');&#10;  const [visibility, setVisibility] = useState(post.visibility || post.privacy || 'PUBLIC');&#10;  const [isSaving, setIsSaving] = useState(false);&#10;&#10;  const handleAddTag = () =&gt; {&#10;    if (tagInput.trim() &amp;&amp; !tags.includes(tagInput.trim())) {&#10;      setTags(prev =&gt; [...prev, tagInput.trim()]);&#10;      setTagInput('');&#10;    }&#10;  };&#10;&#10;  const handleRemoveTag = (tagToRemove: string) =&gt; {&#10;    setTags(prev =&gt; prev.filter(tag =&gt; tag !== tagToRemove));&#10;  };&#10;&#10;  const handleKeyPress = (e: React.KeyboardEvent) =&gt; {&#10;    if (e.key === 'Enter' &amp;&amp; tagInput.trim()) {&#10;      e.preventDefault();&#10;      handleAddTag();&#10;    }&#10;  };&#10;&#10;  const handleSave = async () =&gt; {&#10;    if (!content.trim()) return;&#10;&#10;    setIsSaving(true);&#10;    try {&#10;      const updatedPost: UpdatePostRequest = {&#10;        title: title.trim() || undefined,&#10;        content: content.trim(),&#10;        category: category.trim() || undefined,&#10;        tags: tags.length &gt; 0 ? tags : undefined,&#10;        visibility: visibility as 'PUBLIC' | 'FRIENDS' | 'PRIVATE'&#10;      };&#10;&#10;      await onSave(updatedPost);&#10;      onClose();&#10;    } catch (error) {&#10;      console.error('Error saving post:', error);&#10;    } finally {&#10;      setIsSaving(false);&#10;    }&#10;  };&#10;&#10;  const handleClose = () =&gt; {&#10;    if (!isSaving) {&#10;      onClose();&#10;    }&#10;  };&#10;&#10;  return (&#10;    &lt;Modal &#10;      isOpen={isOpen} &#10;      onClose={handleClose}&#10;      title=&quot;Chỉnh sửa bài viết&quot;&#10;      size=&quot;lg&quot;&#10;    &gt;&#10;      &lt;div className=&quot;space-y-6&quot;&gt;&#10;        {/* Title */}&#10;        &lt;div&gt;&#10;          &lt;label className=&quot;block text-sm font-medium text-gray-700 mb-2 vietnamese-text&quot;&gt;&#10;            Tiêu đề (tùy chọn)&#10;          &lt;/label&gt;&#10;          &lt;Input&#10;            type=&quot;text&quot;&#10;            value={title}&#10;            onChange={(e) =&gt; setTitle(e.target.value)}&#10;            placeholder=&quot;Nhập tiêu đề bài viết...&quot;&#10;            className=&quot;vietnamese-text&quot;&#10;            disabled={isSaving}&#10;          /&gt;&#10;        &lt;/div&gt;&#10;&#10;        {/* Content */}&#10;        &lt;div&gt;&#10;          &lt;label className=&quot;block text-sm font-medium text-gray-700 mb-2 vietnamese-text&quot;&gt;&#10;            Nội dung &lt;span className=&quot;text-red-500&quot;&gt;*&lt;/span&gt;&#10;          &lt;/label&gt;&#10;          &lt;Textarea&#10;            value={content}&#10;            onChange={(e) =&gt; setContent(e.target.value)}&#10;            placeholder=&quot;Bạn đang nghĩ gì?&quot;&#10;            className=&quot;min-h-[120px] vietnamese-text&quot;&#10;            disabled={isSaving}&#10;          /&gt;&#10;        &lt;/div&gt;&#10;&#10;        {/* Category */}&#10;        &lt;div&gt;&#10;          &lt;label className=&quot;block text-sm font-medium text-gray-700 mb-2 vietnamese-text&quot;&gt;&#10;            Danh mục&#10;          &lt;/label&gt;&#10;          &lt;select&#10;            value={category}&#10;            onChange={(e) =&gt; setCategory(e.target.value)}&#10;            className=&quot;w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 vietnamese-text&quot;&#10;            disabled={isSaving}&#10;          &gt;&#10;            &lt;option value=&quot;&quot;&gt;Chọn danh mục&lt;/option&gt;&#10;            &lt;option value=&quot;Tin tức&quot;&gt;Tin tức&lt;/option&gt;&#10;            &lt;option value=&quot;Học tập&quot;&gt;Học tập&lt;/option&gt;&#10;            &lt;option value=&quot;Giải trí&quot;&gt;Giải trí&lt;/option&gt;&#10;            &lt;option value=&quot;Thể thao&quot;&gt;Thể thao&lt;/option&gt;&#10;            &lt;option value=&quot;Công nghệ&quot;&gt;Công nghệ&lt;/option&gt;&#10;            &lt;option value=&quot;Du lịch&quot;&gt;Du lịch&lt;/option&gt;&#10;            &lt;option value=&quot;Khác&quot;&gt;Khác&lt;/option&gt;&#10;          &lt;/select&gt;&#10;        &lt;/div&gt;&#10;&#10;        {/* Tags */}&#10;        &lt;div&gt;&#10;          &lt;label className=&quot;block text-sm font-medium text-gray-700 mb-2 vietnamese-text&quot;&gt;&#10;            Thẻ hashtag&#10;          &lt;/label&gt;&#10;          &lt;div className=&quot;flex flex-wrap gap-2 mb-2&quot;&gt;&#10;            {tags.map((tag, index) =&gt; (&#10;              &lt;span&#10;                key={index}&#10;                className=&quot;inline-flex items-center bg-blue-100 text-blue-800 text-sm px-2 py-1 rounded-full&quot;&#10;              &gt;&#10;                &lt;Hash className=&quot;h-3 w-3 mr-1&quot; /&gt;&#10;                {tag}&#10;                &lt;button&#10;                  type=&quot;button&quot;&#10;                  onClick={() =&gt; handleRemoveTag(tag)}&#10;                  className=&quot;ml-1 hover:text-blue-600&quot;&#10;                  disabled={isSaving}&#10;                &gt;&#10;                  &lt;X className=&quot;h-3 w-3&quot; /&gt;&#10;                &lt;/button&gt;&#10;              &lt;/span&gt;&#10;            ))}&#10;          &lt;/div&gt;&#10;          &lt;div className=&quot;flex space-x-2&quot;&gt;&#10;            &lt;Input&#10;              type=&quot;text&quot;&#10;              value={tagInput}&#10;              onChange={(e) =&gt; setTagInput(e.target.value)}&#10;              onKeyPress={handleKeyPress}&#10;              placeholder=&quot;Thêm thẻ hashtag...&quot;&#10;              className=&quot;flex-1 vietnamese-text&quot;&#10;              disabled={isSaving}&#10;            /&gt;&#10;            &lt;Button&#10;              type=&quot;button&quot;&#10;              onClick={handleAddTag}&#10;              disabled={!tagInput.trim() || isSaving}&#10;              variant=&quot;outline&quot;&#10;              size=&quot;sm&quot;&#10;            &gt;&#10;              Thêm&#10;            &lt;/Button&gt;&#10;          &lt;/div&gt;&#10;        &lt;/div&gt;&#10;&#10;        {/* Visibility */}&#10;        &lt;div&gt;&#10;          &lt;label className=&quot;block text-sm font-medium text-gray-700 mb-2 vietnamese-text&quot;&gt;&#10;            Quyền riêng tư&#10;          &lt;/label&gt;&#10;          &lt;select&#10;            value={visibility}&#10;            onChange={(e) =&gt; setVisibility(e.target.value)}&#10;            className=&quot;w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 vietnamese-text&quot;&#10;            disabled={isSaving}&#10;          &gt;&#10;            &lt;option value=&quot;PUBLIC&quot;&gt;Công khai&lt;/option&gt;&#10;            &lt;option value=&quot;FRIENDS&quot;&gt;Bạn bè&lt;/option&gt;&#10;            &lt;option value=&quot;PRIVATE&quot;&gt;Riêng tư&lt;/option&gt;&#10;          &lt;/select&gt;&#10;        &lt;/div&gt;&#10;&#10;        {/* Media Preview (if exists) */}&#10;        {(post.images?.length &gt; 0 || post.videos?.length &gt; 0) &amp;&amp; (&#10;          &lt;div&gt;&#10;            &lt;label className=&quot;block text-sm font-medium text-gray-700 mb-2 vietnamese-text&quot;&gt;&#10;              Media hiện tại&#10;            &lt;/label&gt;&#10;            &lt;div className=&quot;bg-gray-50 rounded-lg p-4&quot;&gt;&#10;              &lt;div className=&quot;flex items-center space-x-4 text-sm text-gray-600&quot;&gt;&#10;                {post.images?.length &gt; 0 &amp;&amp; (&#10;                  &lt;div className=&quot;flex items-center space-x-1&quot;&gt;&#10;                    &lt;Image className=&quot;h-4 w-4&quot; /&gt;&#10;                    &lt;span&gt;{post.images.length} ảnh&lt;/span&gt;&#10;                  &lt;/div&gt;&#10;                )}&#10;                {post.videos?.length &gt; 0 &amp;&amp; (&#10;                  &lt;div className=&quot;flex items-center space-x-1&quot;&gt;&#10;                    &lt;Video className=&quot;h-4 w-4&quot; /&gt;&#10;                    &lt;span&gt;{post.videos.length} video&lt;/span&gt;&#10;                  &lt;/div&gt;&#10;                )}&#10;              &lt;/div&gt;&#10;              &lt;p className=&quot;text-xs text-gray-500 mt-2 vietnamese-text&quot;&gt;&#10;                Lưu ý: Không thể chỉnh sửa media trong phiên bản hiện tại&#10;              &lt;/p&gt;&#10;            &lt;/div&gt;&#10;          &lt;/div&gt;&#10;        )}&#10;&#10;        {/* Action Buttons */}&#10;        &lt;div className=&quot;flex justify-end space-x-3 pt-4 border-t&quot;&gt;&#10;          &lt;Button&#10;            variant=&quot;outline&quot;&#10;            onClick={handleClose}&#10;            disabled={isSaving}&#10;          &gt;&#10;            Hủy&#10;          &lt;/Button&gt;&#10;          &lt;Button&#10;            onClick={handleSave}&#10;            disabled={!content.trim() || isSaving}&#10;            className=&quot;flex items-center space-x-2&quot;&#10;          &gt;&#10;            {isSaving ? (&#10;              &lt;&gt;&#10;                &lt;LoadingSpinner size=&quot;sm&quot; /&gt;&#10;                &lt;span&gt;Đang lưu...&lt;/span&gt;&#10;              &lt;/&gt;&#10;            ) : (&#10;              &lt;span&gt;Lưu thay đổi&lt;/span&gt;&#10;            )}&#10;          &lt;/Button&gt;&#10;        &lt;/div&gt;&#10;      &lt;/div&gt;&#10;    &lt;/Modal&gt;&#10;  );&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/client-frontend/src/components/post/PostMenu.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/client-frontend/src/components/post/PostMenu.tsx" />
              <option name="updatedContent" value="'use client';&#10;&#10;import React, { useState } from 'react';&#10;import { &#10;  MoreHorizontal, &#10;  Edit3, &#10;  Trash2, &#10;  Flag, &#10;  EyeOff, &#10;  UserX,&#10;  Copy,&#10;  Bookmark,&#10;  Share&#10;} from 'lucide-react';&#10;import { useAuth } from '@/contexts/AuthContext';&#10;&#10;interface PostMenuProps {&#10;  post: any;&#10;  onEdit?: () =&gt; void;&#10;  onDelete?: () =&gt; void;&#10;  onReport?: () =&gt; void;&#10;  onHide?: () =&gt; void;&#10;  onBlock?: () =&gt; void;&#10;  onBookmark?: () =&gt; void;&#10;  onShare?: () =&gt; void;&#10;  onCopyLink?: () =&gt; void;&#10;  className?: string;&#10;}&#10;&#10;export const PostMenu: React.FC&lt;PostMenuProps&gt; = ({&#10;  post,&#10;  onEdit,&#10;  onDelete,&#10;  onReport,&#10;  onHide,&#10;  onBlock,&#10;  onBookmark,&#10;  onShare,&#10;  onCopyLink,&#10;  className = ''&#10;}) =&gt; {&#10;  const { user } = useAuth();&#10;  const [isOpen, setIsOpen] = useState(false);&#10;  const isOwnPost = user?.id === post.authorId || user?.id === post.author?.id;&#10;&#10;  const handleAction = (action: () =&gt; void) =&gt; {&#10;    action();&#10;    setIsOpen(false);&#10;  };&#10;&#10;  const menuItems = [&#10;    // Own post actions&#10;    ...(isOwnPost ? [&#10;      {&#10;        icon: &lt;Edit3 className=&quot;h-4 w-4&quot; /&gt;,&#10;        label: 'Chỉnh sửa bài viết',&#10;        action: onEdit,&#10;        className: 'text-gray-700 hover:bg-gray-50'&#10;      },&#10;      {&#10;        icon: &lt;Trash2 className=&quot;h-4 w-4 text-red-500&quot; /&gt;,&#10;        label: 'Xóa bài viết',&#10;        action: onDelete,&#10;        className: 'text-red-600 hover:bg-red-50'&#10;      }&#10;    ] : []),&#10;    &#10;    // Common actions&#10;    {&#10;      icon: &lt;Bookmark className=&quot;h-4 w-4&quot; /&gt;,&#10;      label: 'Lưu bài viết',&#10;      action: onBookmark,&#10;      className: 'text-gray-700 hover:bg-gray-50'&#10;    },&#10;    {&#10;      icon: &lt;Share className=&quot;h-4 w-4&quot; /&gt;,&#10;      label: 'Chia sẻ',&#10;      action: onShare,&#10;      className: 'text-gray-700 hover:bg-gray-50'&#10;    },&#10;    {&#10;      icon: &lt;Copy className=&quot;h-4 w-4&quot; /&gt;,&#10;      label: 'Sao chép liên kết',&#10;      action: onCopyLink,&#10;      className: 'text-gray-700 hover:bg-gray-50'&#10;    },&#10;    &#10;    // Other user's post actions&#10;    ...(!isOwnPost ? [&#10;      {&#10;        icon: &lt;Flag className=&quot;h-4 w-4 text-red-500&quot; /&gt;,&#10;        label: 'Báo cáo bài viết',&#10;        action: onReport,&#10;        className: 'text-red-600 hover:bg-red-50'&#10;      },&#10;      {&#10;        icon: &lt;EyeOff className=&quot;h-4 w-4&quot; /&gt;,&#10;        label: 'Ẩn bài viết',&#10;        action: onHide,&#10;        className: 'text-gray-700 hover:bg-gray-50'&#10;      },&#10;      {&#10;        icon: &lt;UserX className=&quot;h-4 w-4 text-red-500&quot; /&gt;,&#10;        label: `Chặn bài viết từ ${post.author?.fullName || post.author?.name || post.authorName}`,&#10;        action: onBlock,&#10;        className: 'text-red-600 hover:bg-red-50'&#10;      }&#10;    ] : [])&#10;  ].filter(item =&gt; item.action); // Only include items with actions&#10;&#10;  return (&#10;    &lt;div className={`relative ${className}`}&gt;&#10;      &lt;button&#10;        onClick={() =&gt; setIsOpen(!isOpen)}&#10;        className=&quot;p-2 hover:bg-gray-100 rounded-full transition-colors&quot;&#10;        aria-label=&quot;Tùy chọn bài viết&quot;&#10;      &gt;&#10;        &lt;MoreHorizontal className=&quot;h-4 w-4 text-gray-500&quot; /&gt;&#10;      &lt;/button&gt;&#10;&#10;      {isOpen &amp;&amp; (&#10;        &lt;&gt;&#10;          {/* Backdrop */}&#10;          &lt;div &#10;            className=&quot;fixed inset-0 z-40&quot; &#10;            onClick={() =&gt; setIsOpen(false)}&#10;          /&gt;&#10;          &#10;          {/* Menu */}&#10;          &lt;div className=&quot;absolute right-0 top-full mt-1 bg-white rounded-lg shadow-lg border border-gray-200 py-2 z-50 min-w-[220px]&quot;&gt;&#10;            {menuItems.map((item, index) =&gt; (&#10;              &lt;button&#10;                key={index}&#10;                onClick={() =&gt; handleAction(item.action!)}&#10;                className={`&#10;                  flex items-center space-x-3 w-full px-4 py-2 text-sm transition-colors vietnamese-text&#10;                  ${item.className}&#10;                `}&#10;              &gt;&#10;                {item.icon}&#10;                &lt;span&gt;{item.label}&lt;/span&gt;&#10;              &lt;/button&gt;&#10;            ))}&#10;            &#10;            {menuItems.length === 0 &amp;&amp; (&#10;              &lt;div className=&quot;px-4 py-2 text-sm text-gray-500 vietnamese-text&quot;&gt;&#10;                Không có tùy chọn nào&#10;              &lt;/div&gt;&#10;            )}&#10;          &lt;/div&gt;&#10;        &lt;/&gt;&#10;      )}&#10;    &lt;/div&gt;&#10;  );&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/client-frontend/src/components/profile/ProfileHeader.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/client-frontend/src/components/profile/ProfileHeader.tsx" />
              <option name="updatedContent" value="'use client';&#10;&#10;import React, { useState } from 'react';&#10;import { User } from '@/types';&#10;import { Camera, MapPin, Calendar, Briefcase, GraduationCap, Edit3, UserPlus, MessageCircle, MoreHorizontal } from 'lucide-react';&#10;import { Button } from '@/components/ui/Button';&#10;import { formatTimeAgo } from '@/utils/localization';&#10;&#10;interface ProfileHeaderProps {&#10;  user: User;&#10;  isOwnProfile: boolean;&#10;  isFollowing?: boolean;&#10;  onFollow?: () =&gt; void;&#10;  onMessage?: () =&gt; void;&#10;  onEditProfile?: () =&gt; void;&#10;  onEditCover?: () =&gt; void;&#10;  onEditAvatar?: () =&gt; void;&#10;}&#10;&#10;export const ProfileHeader: React.FC&lt;ProfileHeaderProps&gt; = ({&#10;  user,&#10;  isOwnProfile,&#10;  isFollowing = false,&#10;  onFollow,&#10;  onMessage,&#10;  onEditProfile,&#10;  onEditCover,&#10;  onEditAvatar&#10;}) =&gt; {&#10;  const [showFullBio, setShowFullBio] = useState(false);&#10;&#10;  const getRoleDisplay = (role: string) =&gt; {&#10;    switch (role) {&#10;      case 'STUDENT': return 'Sinh viên';&#10;      case 'LECTURER': return 'Giảng viên';&#10;      case 'ADMIN': return 'Quản trị viên';&#10;      default: return 'Người dùng';&#10;    }&#10;  };&#10;&#10;  return (&#10;    &lt;div className=&quot;bg-white rounded-lg shadow-sm overflow-hidden&quot;&gt;&#10;      {/* Cover Photo */}&#10;      &lt;div className=&quot;relative h-80 bg-gradient-to-r from-blue-500 to-purple-600&quot;&gt;&#10;        {user.backgroundUrl ? (&#10;          &lt;img&#10;            src={user.backgroundUrl}&#10;            alt=&quot;Ảnh bìa&quot;&#10;            className=&quot;w-full h-full object-cover&quot;&#10;          /&gt;&#10;        ) : (&#10;          &lt;div className=&quot;w-full h-full bg-gradient-to-r from-blue-500 via-purple-500 to-pink-500&quot; /&gt;&#10;        )}&#10;        &#10;        {/* Cover Photo Edit Button */}&#10;        {isOwnProfile &amp;&amp; (&#10;          &lt;button&#10;            onClick={onEditCover}&#10;            className=&quot;absolute bottom-4 right-4 bg-white bg-opacity-90 hover:bg-opacity-100 rounded-lg px-3 py-2 text-gray-700 font-medium transition-all duration-200 flex items-center space-x-2&quot;&#10;          &gt;&#10;            &lt;Camera className=&quot;h-4 w-4&quot; /&gt;&#10;            &lt;span className=&quot;text-sm&quot;&gt;Chỉnh sửa ảnh bìa&lt;/span&gt;&#10;          &lt;/button&gt;&#10;        )}&#10;      &lt;/div&gt;&#10;&#10;      {/* Profile Info Section */}&#10;      &lt;div className=&quot;px-6 pb-6&quot;&gt;&#10;        &lt;div className=&quot;flex flex-col lg:flex-row lg:items-end lg:justify-between -mt-20 relative&quot;&gt;&#10;          {/* Avatar and Basic Info */}&#10;          &lt;div className=&quot;flex flex-col sm:flex-row sm:items-end sm:space-x-5&quot;&gt;&#10;            {/* Avatar */}&#10;            &lt;div className=&quot;relative&quot;&gt;&#10;              &lt;div className=&quot;w-40 h-40 rounded-full border-4 border-white shadow-xl overflow-hidden bg-gray-200&quot;&gt;&#10;                {user.avatarUrl ? (&#10;                  &lt;img&#10;                    src={user.avatarUrl}&#10;                    alt={user.fullName || user.name || 'Avatar'}&#10;                    className=&quot;w-full h-full object-cover&quot;&#10;                  /&gt;&#10;                ) : (&#10;                  &lt;div className=&quot;w-full h-full bg-gradient-to-br from-blue-400 to-purple-600 flex items-center justify-center text-white text-4xl font-bold&quot;&gt;&#10;                    {(user.fullName || user.name || 'U').charAt(0).toUpperCase()}&#10;                  &lt;/div&gt;&#10;                )}&#10;              &lt;/div&gt;&#10;              &#10;              {/* Avatar Edit Button */}&#10;              {isOwnProfile &amp;&amp; (&#10;                &lt;button&#10;                  onClick={onEditAvatar}&#10;                  className=&quot;absolute bottom-2 right-2 bg-gray-100 hover:bg-gray-200 rounded-full p-2 shadow-lg transition-colors&quot;&#10;                &gt;&#10;                  &lt;Camera className=&quot;h-4 w-4 text-gray-600&quot; /&gt;&#10;                &lt;/button&gt;&#10;              )}&#10;            &lt;/div&gt;&#10;&#10;            {/* Name and Title */}&#10;            &lt;div className=&quot;mt-4 sm:mt-0 flex-1&quot;&gt;&#10;              &lt;div className=&quot;flex items-center space-x-2&quot;&gt;&#10;                &lt;h1 className=&quot;text-3xl font-bold text-gray-900 vietnamese-text&quot;&gt;&#10;                  {user.fullName || user.name || 'Người dùng'}&#10;                &lt;/h1&gt;&#10;                {user.isVerified &amp;&amp; (&#10;                  &lt;div className=&quot;w-6 h-6 bg-blue-500 rounded-full flex items-center justify-center&quot;&gt;&#10;                    &lt;svg className=&quot;w-4 h-4 text-white&quot; fill=&quot;currentColor&quot; viewBox=&quot;0 0 20 20&quot;&gt;&#10;                      &lt;path fillRule=&quot;evenodd&quot; d=&quot;M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z&quot; clipRule=&quot;evenodd&quot; /&gt;&#10;                    &lt;/svg&gt;&#10;                  &lt;/div&gt;&#10;                )}&#10;              &lt;/div&gt;&#10;              &#10;              &lt;div className=&quot;flex items-center space-x-2 mt-1&quot;&gt;&#10;                &lt;span className={`px-3 py-1 rounded-full text-sm font-medium ${&#10;                  user.role === 'LECTURER' &#10;                    ? 'bg-blue-100 text-blue-700' &#10;                    : 'bg-green-100 text-green-700'&#10;                }`}&gt;&#10;                  {getRoleDisplay(user.role)}&#10;                &lt;/span&gt;&#10;                {user.isOnline &amp;&amp; (&#10;                  &lt;span className=&quot;flex items-center text-sm text-gray-500&quot;&gt;&#10;                    &lt;div className=&quot;w-2 h-2 bg-green-500 rounded-full mr-1&quot;&gt;&lt;/div&gt;&#10;                    Đang hoạt động&#10;                  &lt;/span&gt;&#10;                )}&#10;              &lt;/div&gt;&#10;&#10;              {/* Quick Info */}&#10;              &lt;div className=&quot;flex flex-wrap items-center mt-3 text-sm text-gray-600 space-x-4&quot;&gt;&#10;                {user.role === 'STUDENT' &amp;&amp; user.major &amp;&amp; (&#10;                  &lt;div className=&quot;flex items-center space-x-1&quot;&gt;&#10;                    &lt;GraduationCap className=&quot;h-4 w-4&quot; /&gt;&#10;                    &lt;span&gt;{user.major.name}&lt;/span&gt;&#10;                  &lt;/div&gt;&#10;                )}&#10;                &#10;                {user.role === 'LECTURER' &amp;&amp; user.faculty &amp;&amp; (&#10;                  &lt;div className=&quot;flex items-center space-x-1&quot;&gt;&#10;                    &lt;Briefcase className=&quot;h-4 w-4&quot; /&gt;&#10;                    &lt;span&gt;{user.faculty.name}&lt;/span&gt;&#10;                  &lt;/div&gt;&#10;                )}&#10;                &#10;                {user.createdAt &amp;&amp; (&#10;                  &lt;div className=&quot;flex items-center space-x-1&quot;&gt;&#10;                    &lt;Calendar className=&quot;h-4 w-4&quot; /&gt;&#10;                    &lt;span&gt;Tham gia {formatTimeAgo(user.createdAt)}&lt;/span&gt;&#10;                  &lt;/div&gt;&#10;                )}&#10;              &lt;/div&gt;&#10;            &lt;/div&gt;&#10;          &lt;/div&gt;&#10;&#10;          {/* Action Buttons */}&#10;          &lt;div className=&quot;flex items-center space-x-3 mt-4 lg:mt-0&quot;&gt;&#10;            {isOwnProfile ? (&#10;              &lt;&gt;&#10;                &lt;Button&#10;                  onClick={onEditProfile}&#10;                  variant=&quot;outline&quot;&#10;                  className=&quot;flex items-center space-x-2&quot;&#10;                &gt;&#10;                  &lt;Edit3 className=&quot;h-4 w-4&quot; /&gt;&#10;                  &lt;span&gt;Chỉnh sửa trang cá nhân&lt;/span&gt;&#10;                &lt;/Button&gt;&#10;              &lt;/&gt;&#10;            ) : (&#10;              &lt;&gt;&#10;                &lt;Button&#10;                  onClick={onFollow}&#10;                  variant={isFollowing ? &quot;outline&quot; : &quot;primary&quot;}&#10;                  className=&quot;flex items-center space-x-2&quot;&#10;                &gt;&#10;                  &lt;UserPlus className=&quot;h-4 w-4&quot; /&gt;&#10;                  &lt;span&gt;{isFollowing ? 'Đang theo dõi' : 'Theo dõi'}&lt;/span&gt;&#10;                &lt;/Button&gt;&#10;                &#10;                &lt;Button&#10;                  onClick={onMessage}&#10;                  variant=&quot;outline&quot;&#10;                  className=&quot;flex items-center space-x-2&quot;&#10;                &gt;&#10;                  &lt;MessageCircle className=&quot;h-4 w-4&quot; /&gt;&#10;                  &lt;span&gt;Nhắn tin&lt;/span&gt;&#10;                &lt;/Button&gt;&#10;                &#10;                &lt;button className=&quot;p-2 hover:bg-gray-100 rounded-lg transition-colors&quot;&gt;&#10;                  &lt;MoreHorizontal className=&quot;h-5 w-5 text-gray-600&quot; /&gt;&#10;                &lt;/button&gt;&#10;              &lt;/&gt;&#10;            )}&#10;          &lt;/div&gt;&#10;        &lt;/div&gt;&#10;&#10;        {/* Bio Section */}&#10;        {user.bio &amp;&amp; (&#10;          &lt;div className=&quot;mt-6 bg-gray-50 rounded-lg p-4&quot;&gt;&#10;            &lt;h3 className=&quot;font-semibold text-gray-900 mb-2&quot;&gt;Giới thiệu&lt;/h3&gt;&#10;            &lt;p className=&quot;text-gray-700 vietnamese-text leading-relaxed&quot;&gt;&#10;              {showFullBio || user.bio.length &lt;= 200 &#10;                ? user.bio &#10;                : `${user.bio.substring(0, 200)}...`&#10;              }&#10;            &lt;/p&gt;&#10;            {user.bio.length &gt; 200 &amp;&amp; (&#10;              &lt;button&#10;                onClick={() =&gt; setShowFullBio(!showFullBio)}&#10;                className=&quot;text-blue-600 hover:text-blue-700 font-medium mt-2&quot;&#10;              &gt;&#10;                {showFullBio ? 'Thu gọn' : 'Xem thêm'}&#10;              &lt;/button&gt;&#10;            )}&#10;          &lt;/div&gt;&#10;        )}&#10;      &lt;/div&gt;&#10;    &lt;/div&gt;&#10;  );&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/client-frontend/src/components/profile/ProfilePhotoModal.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/client-frontend/src/components/profile/ProfilePhotoModal.tsx" />
              <option name="updatedContent" value="'use client';&#10;&#10;import React, { useState } from 'react';&#10;import { User } from '@/types';&#10;import { Camera, X, Upload, Loader2 } from 'lucide-react';&#10;import { Button } from '@/components/ui/Button';&#10;import { Modal } from '@/components/ui/Modal';&#10;&#10;interface ProfilePhotoModalProps {&#10;  isOpen: boolean;&#10;  onClose: () =&gt; void;&#10;  user: User;&#10;  type: 'avatar' | 'cover';&#10;  onPhotoUpdate: (photoUrl: string) =&gt; void;&#10;}&#10;&#10;export const ProfilePhotoModal: React.FC&lt;ProfilePhotoModalProps&gt; = ({&#10;  isOpen,&#10;  onClose,&#10;  user,&#10;  type,&#10;  onPhotoUpdate&#10;}) =&gt; {&#10;  const [selectedFile, setSelectedFile] = useState&lt;File | null&gt;(null);&#10;  const [previewUrl, setPreviewUrl] = useState&lt;string | null&gt;(null);&#10;  const [isUploading, setIsUploading] = useState(false);&#10;&#10;  const handleFileSelect = (event: React.ChangeEvent&lt;HTMLInputElement&gt;) =&gt; {&#10;    const file = event.target.files?.[0];&#10;    if (file) {&#10;      setSelectedFile(file);&#10;      const url = URL.createObjectURL(file);&#10;      setPreviewUrl(url);&#10;    }&#10;  };&#10;&#10;  const handleUpload = async () =&gt; {&#10;    if (!selectedFile) return;&#10;&#10;    setIsUploading(true);&#10;    try {&#10;      // TODO: Implement actual upload logic&#10;      // const uploadResult = await mediaService.uploadImage(selectedFile);&#10;      // onPhotoUpdate(uploadResult.url);&#10;      &#10;      // Mock upload for now&#10;      setTimeout(() =&gt; {&#10;        onPhotoUpdate(previewUrl || '');&#10;        setIsUploading(false);&#10;        onClose();&#10;        resetModal();&#10;      }, 2000);&#10;    } catch (error) {&#10;      console.error('Error uploading photo:', error);&#10;      setIsUploading(false);&#10;    }&#10;  };&#10;&#10;  const resetModal = () =&gt; {&#10;    setSelectedFile(null);&#10;    if (previewUrl) {&#10;      URL.revokeObjectURL(previewUrl);&#10;    }&#10;    setPreviewUrl(null);&#10;  };&#10;&#10;  const handleClose = () =&gt; {&#10;    if (!isUploading) {&#10;      resetModal();&#10;      onClose();&#10;    }&#10;  };&#10;&#10;  const title = type === 'avatar' ? 'Cập nhật ảnh đại diện' : 'Cập nhật ảnh bìa';&#10;  const aspectRatio = type === 'avatar' ? 'aspect-square' : 'aspect-[3/1]';&#10;&#10;  return (&#10;    &lt;Modal isOpen={isOpen} onClose={handleClose} title={title}&gt;&#10;      &lt;div className=&quot;space-y-6&quot;&gt;&#10;        {/* Current Photo */}&#10;        &lt;div className=&quot;text-center&quot;&gt;&#10;          &lt;h3 className=&quot;text-sm font-medium text-gray-900 mb-3 vietnamese-text&quot;&gt;&#10;            {type === 'avatar' ? 'Ảnh đại diện hiện tại' : 'Ảnh bìa hiện tại'}&#10;          &lt;/h3&gt;&#10;          &lt;div className={`mx-auto bg-gray-200 rounded-lg overflow-hidden ${&#10;            type === 'avatar' ? 'w-32 h-32 rounded-full' : 'w-full h-40'&#10;          }`}&gt;&#10;            {(type === 'avatar' ? user.avatarUrl : user.backgroundUrl) ? (&#10;              &lt;img&#10;                src={type === 'avatar' ? user.avatarUrl! : user.backgroundUrl!}&#10;                alt={title}&#10;                className=&quot;w-full h-full object-cover&quot;&#10;              /&gt;&#10;            ) : (&#10;              &lt;div className=&quot;w-full h-full bg-gradient-to-br from-blue-400 to-purple-600 flex items-center justify-center text-white text-2xl font-bold&quot;&gt;&#10;                {type === 'avatar' ? (user.fullName || user.name || 'U').charAt(0).toUpperCase() : ''}&#10;              &lt;/div&gt;&#10;            )}&#10;          &lt;/div&gt;&#10;        &lt;/div&gt;&#10;&#10;        {/* Preview New Photo */}&#10;        {previewUrl &amp;&amp; (&#10;          &lt;div className=&quot;text-center&quot;&gt;&#10;            &lt;h3 className=&quot;text-sm font-medium text-gray-900 mb-3 vietnamese-text&quot;&gt;&#10;              Xem trước&#10;            &lt;/h3&gt;&#10;            &lt;div className={`mx-auto bg-gray-200 rounded-lg overflow-hidden ${&#10;              type === 'avatar' ? 'w-32 h-32 rounded-full' : 'w-full h-40'&#10;            }`}&gt;&#10;              &lt;img&#10;                src={previewUrl}&#10;                alt=&quot;Preview&quot;&#10;                className=&quot;w-full h-full object-cover&quot;&#10;              /&gt;&#10;            &lt;/div&gt;&#10;          &lt;/div&gt;&#10;        )}&#10;&#10;        {/* File Upload */}&#10;        &lt;div className=&quot;border-2 border-dashed border-gray-300 rounded-lg p-6 text-center hover:border-gray-400 transition-colors&quot;&gt;&#10;          &lt;input&#10;            type=&quot;file&quot;&#10;            accept=&quot;image/*&quot;&#10;            onChange={handleFileSelect}&#10;            className=&quot;hidden&quot;&#10;            id=&quot;photo-upload&quot;&#10;            disabled={isUploading}&#10;          /&gt;&#10;          &lt;label htmlFor=&quot;photo-upload&quot; className=&quot;cursor-pointer&quot;&gt;&#10;            &lt;Upload className=&quot;h-12 w-12 text-gray-400 mx-auto mb-4&quot; /&gt;&#10;            &lt;p className=&quot;text-sm text-gray-600 vietnamese-text&quot;&gt;&#10;              Nhấp để chọn ảnh hoặc kéo thả ảnh vào đây&#10;            &lt;/p&gt;&#10;            &lt;p className=&quot;text-xs text-gray-500 mt-1 vietnamese-text&quot;&gt;&#10;              Định dạng: JPG, PNG (Tối đa 10MB)&#10;            &lt;/p&gt;&#10;          &lt;/label&gt;&#10;        &lt;/div&gt;&#10;&#10;        {/* Action Buttons */}&#10;        &lt;div className=&quot;flex justify-end space-x-3&quot;&gt;&#10;          &lt;Button&#10;            variant=&quot;outline&quot;&#10;            onClick={handleClose}&#10;            disabled={isUploading}&#10;          &gt;&#10;            Hủy&#10;          &lt;/Button&gt;&#10;          &lt;Button&#10;            onClick={handleUpload}&#10;            disabled={!selectedFile || isUploading}&#10;            className=&quot;flex items-center space-x-2&quot;&#10;          &gt;&#10;            {isUploading ? (&#10;              &lt;&gt;&#10;                &lt;Loader2 className=&quot;h-4 w-4 animate-spin&quot; /&gt;&#10;                &lt;span&gt;Đang tải lên...&lt;/span&gt;&#10;              &lt;/&gt;&#10;            ) : (&#10;              &lt;&gt;&#10;                &lt;Camera className=&quot;h-4 w-4&quot; /&gt;&#10;                &lt;span&gt;Cập nhật ảnh&lt;/span&gt;&#10;              &lt;/&gt;&#10;            )}&#10;          &lt;/Button&gt;&#10;        &lt;/div&gt;&#10;      &lt;/div&gt;&#10;    &lt;/Modal&gt;&#10;  );&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/client-frontend/src/components/profile/ProfilePostFeed.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/client-frontend/src/components/profile/ProfilePostFeed.tsx" />
              <option name="originalContent" value="'use client';&#10;&#10;import React, { useState, useEffect, useCallback } from 'react';&#10;import { Post, PaginatedResponse } from '@/types';&#10;import { postService } from '@/services/postService';&#10;import { PostCard } from '@/components/post/PostCard';&#10;import { LoadingSpinner } from '@/components/ui/LoadingSpinner';&#10;import { ErrorAlert } from '@/components/ui/ErrorAlert';&#10;import { Button } from '@/components/ui/Button';&#10;import { RefreshCw, FileText, Image, Video, Clock } from 'lucide-react';&#10;import { useAuth } from '@/contexts/AuthContext';&#10;&#10;interface ProfilePostFeedProps {&#10;  userId: string;&#10;  userName?: string;&#10;  isOwnProfile?: boolean;&#10;  className?: string;&#10;}&#10;&#10;export const ProfilePostFeed: React.FC&lt;ProfilePostFeedProps&gt; = ({&#10;  userId,&#10;  userName,&#10;  isOwnProfile = false,&#10;  className = ''&#10;}) =&gt; {&#10;  const [posts, setPosts] = useState&lt;Post[]&gt;([]);&#10;  const [isLoading, setIsLoading] = useState(true);&#10;  const [isLoadingMore, setIsLoadingMore] = useState(false);&#10;  const [error, setError] = useState&lt;string | null&gt;(null);&#10;  const [hasMore, setHasMore] = useState(true);&#10;  const [currentPage, setCurrentPage] = useState(0);&#10;  const [totalPosts, setTotalPosts] = useState(0);&#10;  const [activeFilter, setActiveFilter] = useState&lt;'all' | 'text' | 'image' | 'video'&gt;('all');&#10;  const {user} = useAuth();&#10;  const loadUserPosts = useCallback(async (page = 0, append = false, filter = 'all') =&gt; {&#10;    try {&#10;      if (!append) {&#10;        setIsLoading(true);&#10;        setError(null);&#10;      } else {&#10;        setIsLoadingMore(true);&#10;      }&#10;      let response;&#10;      // TODO: Replace with actual API call to get user posts&#10;      if (userId !== user?.id) {&#10;        response = await postService.getUserPosts(userId, page, 10, filter);&#10;      } else {&#10;        response = await postService.getMyPosts(page, 10);&#10;      }&#10;&#10;        const mockResponse: PaginatedResponse&lt;Post&gt; = response;&#10;      // Mock data for now - replace with actual API call&#10;      /*const mockResponse: PaginatedResponse&lt;Post&gt; = {&#10;        content: [],&#10;        totalElements: 0,&#10;        totalPages: 0,&#10;        size: 10,&#10;        number: page,&#10;        first: page === 0,&#10;        last: true&#10;      };*/&#10;&#10;      if (append) {&#10;        setPosts(prev =&gt; [...prev, ...mockResponse.content]);&#10;      } else {&#10;        setPosts(mockResponse.content);&#10;      }&#10;&#10;      setTotalPosts(mockResponse.totalElements);&#10;      setHasMore(!mockResponse.last);&#10;      setCurrentPage(mockResponse.number);&#10;&#10;    } catch (err: any) {&#10;      console.error('Error loading user posts:', err);&#10;      setError('Không thể tải bài viết của người dùng');&#10;    } finally {&#10;      setIsLoading(false);&#10;      setIsLoadingMore(false);&#10;    }&#10;  }, [userId]);&#10;&#10;  useEffect(() =&gt; {&#10;    loadUserPosts(0, false, activeFilter);&#10;  }, [loadUserPosts, activeFilter]);&#10;&#10;  const handleLoadMore = () =&gt; {&#10;    if (hasMore &amp;&amp; !isLoadingMore) {&#10;      loadUserPosts(currentPage + 1, true, activeFilter);&#10;    }&#10;  };&#10;&#10;  const handleRefresh = () =&gt; {&#10;    loadUserPosts(0, false, activeFilter);&#10;  };&#10;&#10;  const handleFilterChange = (filter: 'all' | 'text' | 'image' | 'video') =&gt; {&#10;    setActiveFilter(filter);&#10;    setCurrentPage(0);&#10;  };&#10;&#10;  const handlePostUpdate = (updatedPost: Post) =&gt; {&#10;    setPosts(prev =&gt; prev.map(post =&gt;&#10;      post.id === updatedPost.id ? updatedPost : post&#10;    ));&#10;  };&#10;&#10;  const handlePostDelete = (postId: string) =&gt; {&#10;    setPosts(prev =&gt; prev.filter(post =&gt; post.id !== postId));&#10;    setTotalPosts(prev =&gt; prev - 1);&#10;  };&#10;&#10;  const getFilterIcon = (filter: string) =&gt; {&#10;    switch (filter) {&#10;      case 'text': return &lt;FileText className=&quot;h-4 w-4&quot; /&gt;;&#10;      case 'image': return &lt;Image className=&quot;h-4 w-4&quot; /&gt;;&#10;      case 'video': return &lt;Video className=&quot;h-4 w-4&quot; /&gt;;&#10;      default: return &lt;Clock className=&quot;h-4 w-4&quot; /&gt;;&#10;    }&#10;  };&#10;&#10;  const getFilterLabel = (filter: string) =&gt; {&#10;    switch (filter) {&#10;      case 'text': return 'Văn bản';&#10;      case 'image': return 'Hình ảnh';&#10;      case 'video': return 'Video';&#10;      default: return 'Tất cả';&#10;    }&#10;  };&#10;&#10;  if (isLoading) {&#10;    return (&#10;      &lt;div className={`space-y-6 ${className}`}&gt;&#10;        &lt;div className=&quot;flex justify-center py-12&quot;&gt;&#10;          &lt;div className=&quot;text-center&quot;&gt;&#10;            &lt;LoadingSpinner size=&quot;lg&quot; /&gt;&#10;            &lt;p className=&quot;text-gray-600 mt-4 vietnamese-text&quot;&gt;&#10;              Đang tải bài viết...&#10;            &lt;/p&gt;&#10;          &lt;/div&gt;&#10;        &lt;/div&gt;&#10;      &lt;/div&gt;&#10;    );&#10;  }&#10;&#10;  if (error) {&#10;    return (&#10;      &lt;div className={`space-y-6 ${className}`}&gt;&#10;        &lt;ErrorAlert&#10;          message={error}&#10;          onRetry={handleRefresh}&#10;        /&gt;&#10;      &lt;/div&gt;&#10;    );&#10;  }&#10;&#10;  return (&#10;    &lt;div className={`space-y-6 ${className}`}&gt;&#10;      {/* Header with Stats and Filters */}&#10;      &lt;div className=&quot;bg-white rounded-lg shadow-sm p-6&quot;&gt;&#10;        &lt;div className=&quot;flex flex-col sm:flex-row sm:items-center sm:justify-between gap-4&quot;&gt;&#10;          {/* Post Count */}&#10;          &lt;div&gt;&#10;            &lt;h2 className=&quot;text-xl font-bold text-gray-900 vietnamese-text&quot;&gt;&#10;              Bài viết của {isOwnProfile ? 'bạn' : (userName || 'người dùng')}&#10;            &lt;/h2&gt;&#10;            &lt;p className=&quot;text-sm text-gray-600 vietnamese-text&quot;&gt;&#10;              {totalPosts} bài viết&#10;            &lt;/p&gt;&#10;          &lt;/div&gt;&#10;&#10;          {/* Refresh Button */}&#10;          &lt;Button&#10;            variant=&quot;outline&quot;&#10;            onClick={handleRefresh}&#10;            className=&quot;flex items-center space-x-2&quot;&#10;            disabled={isLoading}&#10;          &gt;&#10;            &lt;RefreshCw className={`h-4 w-4 ${isLoading ? 'animate-spin' : ''}`} /&gt;&#10;            &lt;span className=&quot;vietnamese-text&quot;&gt;Làm mới&lt;/span&gt;&#10;          &lt;/Button&gt;&#10;        &lt;/div&gt;&#10;&#10;        {/* Filter Tabs */}&#10;        &lt;div className=&quot;mt-6 border-b border-gray-200&quot;&gt;&#10;          &lt;nav className=&quot;flex space-x-8&quot;&gt;&#10;            {[&#10;              { key: 'all', label: 'Tất cả' },&#10;              { key: 'text', label: 'Văn bản' },&#10;              { key: 'image', label: 'Hình ảnh' },&#10;              { key: 'video', label: 'Video' }&#10;            ].map((filter) =&gt; (&#10;              &lt;button&#10;                key={filter.key}&#10;                onClick={() =&gt; handleFilterChange(filter.key as any)}&#10;                className={`py-2 px-1 border-b-2 font-medium text-sm vietnamese-text transition-colors flex items-center space-x-2 ${&#10;                  activeFilter === filter.key&#10;                    ? 'border-blue-500 text-blue-600'&#10;                    : 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300'&#10;                }`}&#10;              &gt;&#10;                {getFilterIcon(filter.key)}&#10;                &lt;span&gt;{filter.label}&lt;/span&gt;&#10;              &lt;/button&gt;&#10;            ))}&#10;          &lt;/nav&gt;&#10;        &lt;/div&gt;&#10;      &lt;/div&gt;&#10;&#10;      {/* Posts List */}&#10;      {posts.length === 0 ? (&#10;        &lt;div className=&quot;bg-white rounded-lg shadow-sm p-12 text-center&quot;&gt;&#10;          &lt;div className=&quot;text-gray-400 mb-4&quot;&gt;&#10;            &lt;FileText className=&quot;h-16 w-16 mx-auto&quot; /&gt;&#10;          &lt;/div&gt;&#10;          &lt;h3 className=&quot;text-lg font-medium text-gray-900 mb-2 vietnamese-text&quot;&gt;&#10;            {isOwnProfile ? 'Bạn chưa có bài viết nào' : 'Người dùng này chưa có bài viết nào'}&#10;          &lt;/h3&gt;&#10;          &lt;p className=&quot;text-gray-600 vietnamese-text&quot;&gt;&#10;            {isOwnProfile&#10;              ? 'Hãy tạo bài viết đầu tiên để chia sẻ với mọi người!'&#10;              : 'Hãy quay lại sau để xem bài viết mới nhất.'&#10;            }&#10;          &lt;/p&gt;&#10;          {isOwnProfile &amp;&amp; (&#10;            &lt;Button&#10;              className=&quot;mt-4&quot;&#10;              onClick={() =&gt; window.location.href = '/posts/create'}&#10;            &gt;&#10;              Tạo bài viết đầu tiên&#10;            &lt;/Button&gt;&#10;          )}&#10;        &lt;/div&gt;&#10;      ) : (&#10;        &lt;&gt;&#10;          {/* Posts */}&#10;          &lt;div className=&quot;space-y-6&quot;&gt;&#10;            {posts.map((post) =&gt; (&#10;              &lt;PostCard&#10;                key={post.id}&#10;                post={post}&#10;                onPostUpdate={handlePostUpdate}&#10;                onPostDelete={handlePostDelete}&#10;                className=&quot;shadow-sm hover:shadow-md transition-shadow&quot;&#10;              /&gt;&#10;            ))}&#10;          &lt;/div&gt;&#10;&#10;          {/* Load More Button */}&#10;          {hasMore &amp;&amp; (&#10;            &lt;div className=&quot;text-center pt-6&quot;&gt;&#10;              &lt;Button&#10;                variant=&quot;outline&quot;&#10;                onClick={handleLoadMore}&#10;                disabled={isLoadingMore}&#10;                className=&quot;px-8&quot;&#10;              &gt;&#10;                {isLoadingMore ? (&#10;                  &lt;&gt;&#10;                    &lt;LoadingSpinner size=&quot;sm&quot; className=&quot;mr-2&quot; /&gt;&#10;                    &lt;span className=&quot;vietnamese-text&quot;&gt;Đang tải...&lt;/span&gt;&#10;                  &lt;/&gt;&#10;                ) : (&#10;                  &lt;span className=&quot;vietnamese-text&quot;&gt;Xem thêm bài viết&lt;/span&gt;&#10;                )}&#10;              &lt;/Button&gt;&#10;            &lt;/div&gt;&#10;          )}&#10;&#10;          {/* End Message */}&#10;          {!hasMore &amp;&amp; posts.length &gt; 0 &amp;&amp; (&#10;            &lt;div className=&quot;text-center py-8&quot;&gt;&#10;              &lt;p className=&quot;text-gray-500 vietnamese-text&quot;&gt;&#10;                Bạn đã xem hết tất cả bài viết&#10;              &lt;/p&gt;&#10;            &lt;/div&gt;&#10;          )}&#10;        &lt;/&gt;&#10;      )}&#10;    &lt;/div&gt;&#10;  );&#10;};&#10;" />
              <option name="updatedContent" value="'use client';&#13;&#10;&#13;&#10;import React, { useState, useEffect, useCallback } from 'react';&#13;&#10;import { Post, PaginatedResponse } from '@/types';&#13;&#10;import { postService } from '@/services/postService';&#13;&#10;import { PostCard } from '@/components/post/PostCard';&#13;&#10;import { LoadingSpinner } from '@/components/ui/LoadingSpinner';&#13;&#10;import { ErrorAlert } from '@/components/ui/ErrorAlert';&#13;&#10;import { Button } from '@/components/ui/Button';&#13;&#10;import { RefreshCw, FileText, Image, Video, Clock } from 'lucide-react';&#13;&#10;import { useAuth } from '@/contexts/AuthContext';&#13;&#10;&#13;&#10;interface ProfilePostFeedProps {&#13;&#10;  userId: string;&#13;&#10;  userName?: string;&#13;&#10;  isOwnProfile?: boolean;&#13;&#10;  className?: string;&#13;&#10;}&#13;&#10;&#13;&#10;export const ProfilePostFeed: React.FC&lt;ProfilePostFeedProps&gt; = ({&#13;&#10;  userId,&#13;&#10;  userName,&#13;&#10;  isOwnProfile = false,&#13;&#10;  className = ''&#13;&#10;}) =&gt; {&#13;&#10;  const [posts, setPosts] = useState&lt;Post[]&gt;([]);&#13;&#10;  const [isLoading, setIsLoading] = useState(true);&#13;&#10;  const [isLoadingMore, setIsLoadingMore] = useState(false);&#13;&#10;  const [error, setError] = useState&lt;string | null&gt;(null);&#13;&#10;  const [hasMore, setHasMore] = useState(true);&#13;&#10;  const [currentPage, setCurrentPage] = useState(0);&#13;&#10;  const [totalPosts, setTotalPosts] = useState(0);&#13;&#10;  const [activeFilter, setActiveFilter] = useState&lt;'all' | 'text' | 'image' | 'video'&gt;('all');&#13;&#10;  const {user} = useAuth();&#13;&#10;  const loadUserPosts = useCallback(async (page = 0, append = false, filter = 'all') =&gt; {&#13;&#10;    try {&#13;&#10;      if (!append) {&#13;&#10;        setIsLoading(true);&#13;&#10;        setError(null);&#13;&#10;      } else {&#13;&#10;        setIsLoadingMore(true);&#13;&#10;      }&#13;&#10;&#13;&#10;      // Call the correct API endpoint based on whether it's own profile or not&#13;&#10;      let response: PaginatedResponse&lt;Post&gt;;&#13;&#10;      &#13;&#10;      if (isOwnProfile) {&#13;&#10;        // For own profile, use getMyPosts which calls /posts/me&#13;&#10;        response = await postService.getMyPosts(page, 10);&#13;&#10;      } else {&#13;&#10;        // For other users, we need to implement getUserPosts in postService&#13;&#10;        // For now, let's create a temporary implementation&#13;&#10;        const apiResponse = await fetch(`/api/posts/user/${userId}?page=${page}&amp;size=10`, {&#13;&#10;          headers: {&#13;&#10;            'Authorization': `Bearer ${localStorage.getItem('token')}`,&#13;&#10;            'Content-Type': 'application/json'&#13;&#10;          }&#13;&#10;        });&#13;&#10;        &#13;&#10;        if (!apiResponse.ok) {&#13;&#10;          throw new Error('Failed to fetch user posts');&#13;&#10;        }&#13;&#10;        &#13;&#10;        response = await apiResponse.json();&#13;&#10;      }&#13;&#10;&#13;&#10;      if (append) {&#13;&#10;        setPosts(prev =&gt; [...prev, ...response.content]);&#13;&#10;      } else {&#13;&#10;        setPosts(response.content);&#13;&#10;      }&#13;&#10;&#13;&#10;      setTotalPosts(response.totalElements);&#13;&#10;      setHasMore(!response.last);&#13;&#10;      setCurrentPage(response.number);&#13;&#10;&#13;&#10;    } catch (err: any) {&#13;&#10;      console.error('Error loading user posts:', err);&#13;&#10;      setError('Không thể tải bài viết của người dùng');&#13;&#10;    } finally {&#13;&#10;      setIsLoading(false);&#13;&#10;      setIsLoadingMore(false);&#13;&#10;    }&#13;&#10;  }, [userId, isOwnProfile]);&#13;&#10;&#13;&#10;  useEffect(() =&gt; {&#13;&#10;    loadUserPosts(0, false, activeFilter);&#13;&#10;  }, [loadUserPosts, activeFilter]);&#13;&#10;&#13;&#10;  const handleLoadMore = () =&gt; {&#13;&#10;    if (hasMore &amp;&amp; !isLoadingMore) {&#13;&#10;      loadUserPosts(currentPage + 1, true, activeFilter);&#13;&#10;    }&#13;&#10;  };&#13;&#10;&#13;&#10;  const handleRefresh = () =&gt; {&#13;&#10;    loadUserPosts(0, false, activeFilter);&#13;&#10;  };&#13;&#10;&#13;&#10;  const handleFilterChange = (filter: 'all' | 'text' | 'image' | 'video') =&gt; {&#13;&#10;    setActiveFilter(filter);&#13;&#10;    setCurrentPage(0);&#13;&#10;  };&#13;&#10;&#13;&#10;  const handlePostUpdate = (updatedPost: Post) =&gt; {&#13;&#10;    setPosts(prev =&gt; prev.map(post =&gt;&#13;&#10;      post.id === updatedPost.id ? updatedPost : post&#13;&#10;    ));&#13;&#10;  };&#13;&#10;&#13;&#10;  const handlePostDelete = (postId: string) =&gt; {&#13;&#10;    setPosts(prev =&gt; prev.filter(post =&gt; post.id !== postId));&#13;&#10;    setTotalPosts(prev =&gt; prev - 1);&#13;&#10;  };&#13;&#10;&#13;&#10;  const getFilterIcon = (filter: string) =&gt; {&#13;&#10;    switch (filter) {&#13;&#10;      case 'text': return &lt;FileText className=&quot;h-4 w-4&quot; /&gt;;&#13;&#10;      case 'image': return &lt;Image className=&quot;h-4 w-4&quot; /&gt;;&#13;&#10;      case 'video': return &lt;Video className=&quot;h-4 w-4&quot; /&gt;;&#13;&#10;      default: return &lt;Clock className=&quot;h-4 w-4&quot; /&gt;;&#13;&#10;    }&#13;&#10;  };&#13;&#10;&#13;&#10;  const getFilterLabel = (filter: string) =&gt; {&#13;&#10;    switch (filter) {&#13;&#10;      case 'text': return 'Văn bản';&#13;&#10;      case 'image': return 'Hình ảnh';&#13;&#10;      case 'video': return 'Video';&#13;&#10;      default: return 'Tất cả';&#13;&#10;    }&#13;&#10;  };&#13;&#10;&#13;&#10;  if (isLoading) {&#13;&#10;    return (&#13;&#10;      &lt;div className={`space-y-6 ${className}`}&gt;&#13;&#10;        &lt;div className=&quot;flex justify-center py-12&quot;&gt;&#13;&#10;          &lt;div className=&quot;text-center&quot;&gt;&#13;&#10;            &lt;LoadingSpinner size=&quot;lg&quot; /&gt;&#13;&#10;            &lt;p className=&quot;text-gray-600 mt-4 vietnamese-text&quot;&gt;&#13;&#10;              Đang tải bài viết...&#13;&#10;            &lt;/p&gt;&#13;&#10;          &lt;/div&gt;&#13;&#10;        &lt;/div&gt;&#13;&#10;      &lt;/div&gt;&#13;&#10;    );&#13;&#10;  }&#13;&#10;&#13;&#10;  if (error) {&#13;&#10;    return (&#13;&#10;      &lt;div className={`space-y-6 ${className}`}&gt;&#13;&#10;        &lt;ErrorAlert&#13;&#10;          message={error}&#13;&#10;          onRetry={handleRefresh}&#13;&#10;        /&gt;&#13;&#10;      &lt;/div&gt;&#13;&#10;    );&#13;&#10;  }&#13;&#10;&#13;&#10;  return (&#13;&#10;    &lt;div className={`space-y-6 ${className}`}&gt;&#13;&#10;      {/* Header with Stats and Filters */}&#13;&#10;      &lt;div className=&quot;bg-white rounded-lg shadow-sm p-6&quot;&gt;&#13;&#10;        &lt;div className=&quot;flex flex-col sm:flex-row sm:items-center sm:justify-between gap-4&quot;&gt;&#13;&#10;          {/* Post Count */}&#13;&#10;          &lt;div&gt;&#13;&#10;            &lt;h2 className=&quot;text-xl font-bold text-gray-900 vietnamese-text&quot;&gt;&#13;&#10;              Bài viết của {isOwnProfile ? 'bạn' : (userName || 'người dùng')}&#13;&#10;            &lt;/h2&gt;&#13;&#10;            &lt;p className=&quot;text-sm text-gray-600 vietnamese-text&quot;&gt;&#13;&#10;              {totalPosts} bài viết&#13;&#10;            &lt;/p&gt;&#13;&#10;          &lt;/div&gt;&#13;&#10;&#13;&#10;          {/* Refresh Button */}&#13;&#10;          &lt;Button&#13;&#10;            variant=&quot;outline&quot;&#13;&#10;            onClick={handleRefresh}&#13;&#10;            className=&quot;flex items-center space-x-2&quot;&#13;&#10;            disabled={isLoading}&#13;&#10;          &gt;&#13;&#10;            &lt;RefreshCw className={`h-4 w-4 ${isLoading ? 'animate-spin' : ''}`} /&gt;&#13;&#10;            &lt;span className=&quot;vietnamese-text&quot;&gt;Làm mới&lt;/span&gt;&#13;&#10;          &lt;/Button&gt;&#13;&#10;        &lt;/div&gt;&#13;&#10;&#13;&#10;        {/* Filter Tabs */}&#13;&#10;        &lt;div className=&quot;mt-6 border-b border-gray-200&quot;&gt;&#13;&#10;          &lt;nav className=&quot;flex space-x-8&quot;&gt;&#13;&#10;            {[&#13;&#10;              { key: 'all', label: 'Tất cả' },&#13;&#10;              { key: 'text', label: 'Văn bản' },&#13;&#10;              { key: 'image', label: 'Hình ảnh' },&#13;&#10;              { key: 'video', label: 'Video' }&#13;&#10;            ].map((filter) =&gt; (&#13;&#10;              &lt;button&#13;&#10;                key={filter.key}&#13;&#10;                onClick={() =&gt; handleFilterChange(filter.key as any)}&#13;&#10;                className={`py-2 px-1 border-b-2 font-medium text-sm vietnamese-text transition-colors flex items-center space-x-2 ${&#13;&#10;                  activeFilter === filter.key&#13;&#10;                    ? 'border-blue-500 text-blue-600'&#13;&#10;                    : 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300'&#13;&#10;                }`}&#13;&#10;              &gt;&#13;&#10;                {getFilterIcon(filter.key)}&#13;&#10;                &lt;span&gt;{filter.label}&lt;/span&gt;&#13;&#10;              &lt;/button&gt;&#13;&#10;            ))}&#13;&#10;          &lt;/nav&gt;&#13;&#10;        &lt;/div&gt;&#13;&#10;      &lt;/div&gt;&#13;&#10;&#13;&#10;      {/* Posts List */}&#13;&#10;      {posts.length === 0 ? (&#13;&#10;        &lt;div className=&quot;bg-white rounded-lg shadow-sm p-12 text-center&quot;&gt;&#13;&#10;          &lt;div className=&quot;text-gray-400 mb-4&quot;&gt;&#13;&#10;            &lt;FileText className=&quot;h-16 w-16 mx-auto&quot; /&gt;&#13;&#10;          &lt;/div&gt;&#13;&#10;          &lt;h3 className=&quot;text-lg font-medium text-gray-900 mb-2 vietnamese-text&quot;&gt;&#13;&#10;            {isOwnProfile ? 'Bạn chưa có bài viết nào' : 'Người dùng này chưa có bài viết nào'}&#13;&#10;          &lt;/h3&gt;&#13;&#10;          &lt;p className=&quot;text-gray-600 vietnamese-text&quot;&gt;&#13;&#10;            {isOwnProfile&#13;&#10;              ? 'Hãy tạo bài viết đầu tiên để chia sẻ với mọi người!'&#13;&#10;              : 'Hãy quay lại sau để xem bài viết mới nhất.'&#13;&#10;            }&#13;&#10;          &lt;/p&gt;&#13;&#10;          {isOwnProfile &amp;&amp; (&#13;&#10;            &lt;Button&#13;&#10;              className=&quot;mt-4&quot;&#13;&#10;              onClick={() =&gt; window.location.href = '/posts/create'}&#13;&#10;            &gt;&#13;&#10;              Tạo bài viết đầu tiên&#13;&#10;            &lt;/Button&gt;&#13;&#10;          )}&#13;&#10;        &lt;/div&gt;&#13;&#10;      ) : (&#13;&#10;        &lt;&gt;&#13;&#10;          {/* Posts */}&#13;&#10;          &lt;div className=&quot;space-y-6&quot;&gt;&#13;&#10;            {posts.map((post) =&gt; (&#13;&#10;              &lt;PostCard&#13;&#10;                key={post.id}&#13;&#10;                post={post}&#13;&#10;                onPostUpdate={handlePostUpdate}&#13;&#10;                onPostDelete={handlePostDelete}&#13;&#10;                className=&quot;shadow-sm hover:shadow-md transition-shadow&quot;&#13;&#10;              /&gt;&#13;&#10;            ))}&#13;&#10;          &lt;/div&gt;&#13;&#10;&#13;&#10;          {/* Load More Button */}&#13;&#10;          {hasMore &amp;&amp; (&#13;&#10;            &lt;div className=&quot;text-center pt-6&quot;&gt;&#13;&#10;              &lt;Button&#13;&#10;                variant=&quot;outline&quot;&#13;&#10;                onClick={handleLoadMore}&#13;&#10;                disabled={isLoadingMore}&#13;&#10;                className=&quot;px-8&quot;&#13;&#10;              &gt;&#13;&#10;                {isLoadingMore ? (&#13;&#10;                  &lt;&gt;&#13;&#10;                    &lt;LoadingSpinner size=&quot;sm&quot; className=&quot;mr-2&quot; /&gt;&#13;&#10;                    &lt;span className=&quot;vietnamese-text&quot;&gt;Đang tải...&lt;/span&gt;&#13;&#10;                  &lt;/&gt;&#13;&#10;                ) : (&#13;&#10;                  &lt;span className=&quot;vietnamese-text&quot;&gt;Xem thêm bài viết&lt;/span&gt;&#13;&#10;                )}&#13;&#10;              &lt;/Button&gt;&#13;&#10;            &lt;/div&gt;&#13;&#10;          )}&#13;&#10;&#13;&#10;          {/* End Message */}&#13;&#10;          {!hasMore &amp;&amp; posts.length &gt; 0 &amp;&amp; (&#13;&#10;            &lt;div className=&quot;text-center py-8&quot;&gt;&#13;&#10;              &lt;p className=&quot;text-gray-500 vietnamese-text&quot;&gt;&#13;&#10;                Bạn đã xem hết tất cả bài viết&#13;&#10;              &lt;/p&gt;&#13;&#10;            &lt;/div&gt;&#13;&#10;          )}&#13;&#10;        &lt;/&gt;&#13;&#10;      )}&#13;&#10;    &lt;/div&gt;&#13;&#10;  );&#13;&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/client-frontend/src/components/profile/ProfileStats.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/client-frontend/src/components/profile/ProfileStats.tsx" />
              <option name="updatedContent" value="'use client';&#10;&#10;import React from 'react';&#10;import { Users, FileText, Heart, Eye } from 'lucide-react';&#10;&#10;interface ProfileStatsProps {&#10;  stats: {&#10;    posts?: number;&#10;    followers?: number;&#10;    following?: number;&#10;    likes?: number;&#10;    views?: number;&#10;  };&#10;  onStatsClick?: (type: 'posts' | 'followers' | 'following') =&gt; void;&#10;}&#10;&#10;export const ProfileStats: React.FC&lt;ProfileStatsProps&gt; = ({ stats, onStatsClick }) =&gt; {&#10;  const formatNumber = (num: number): string =&gt; {&#10;    if (num &gt;= 1000000) return `${(num / 1000000).toFixed(1)}M`;&#10;    if (num &gt;= 1000) return `${(num / 1000).toFixed(1)}K`;&#10;    return num.toString();&#10;  };&#10;&#10;  const statItems = [&#10;    {&#10;      key: 'posts' as const,&#10;      label: 'Bài viết',&#10;      value: stats.posts || 0,&#10;      icon: &lt;FileText className=&quot;h-5 w-5 text-blue-500&quot; /&gt;,&#10;      clickable: true&#10;    },&#10;    {&#10;      key: 'followers' as const,&#10;      label: 'Người theo dõi',&#10;      value: stats.followers || 0,&#10;      icon: &lt;Users className=&quot;h-5 w-5 text-green-500&quot; /&gt;,&#10;      clickable: true&#10;    },&#10;    {&#10;      key: 'following' as const,&#10;      label: 'Đang theo dõi',&#10;      value: stats.following || 0,&#10;      icon: &lt;Users className=&quot;h-5 w-5 text-purple-500&quot; /&gt;,&#10;      clickable: true&#10;    },&#10;    {&#10;      key: 'likes' as const,&#10;      label: 'Lượt thích',&#10;      value: stats.likes || 0,&#10;      icon: &lt;Heart className=&quot;h-5 w-5 text-red-500&quot; /&gt;,&#10;      clickable: false&#10;    },&#10;    {&#10;      key: 'views' as const,&#10;      label: 'Lượt xem',&#10;      value: stats.views || 0,&#10;      icon: &lt;Eye className=&quot;h-5 w-5 text-gray-500&quot; /&gt;,&#10;      clickable: false&#10;    }&#10;  ];&#10;&#10;  return (&#10;    &lt;div className=&quot;bg-white rounded-lg shadow-sm p-6&quot;&gt;&#10;      &lt;h2 className=&quot;text-xl font-bold text-gray-900 mb-6 vietnamese-text&quot;&gt;Thống kê&lt;/h2&gt;&#10;      &#10;      &lt;div className=&quot;grid grid-cols-2 lg:grid-cols-5 gap-4&quot;&gt;&#10;        {statItems.map((item) =&gt; (&#10;          &lt;div&#10;            key={item.key}&#10;            className={`text-center p-4 rounded-lg border ${&#10;              item.clickable &#10;                ? 'cursor-pointer hover:bg-gray-50 hover:border-gray-300 transition-all duration-200' &#10;                : 'bg-gray-50'&#10;            }`}&#10;            onClick={item.clickable ? () =&gt; onStatsClick?.(item.key) : undefined}&#10;          &gt;&#10;            &lt;div className=&quot;flex justify-center mb-2&quot;&gt;&#10;              {item.icon}&#10;            &lt;/div&gt;&#10;            &lt;div className=&quot;text-2xl font-bold text-gray-900 mb-1&quot;&gt;&#10;              {formatNumber(item.value)}&#10;            &lt;/div&gt;&#10;            &lt;div className=&quot;text-sm text-gray-600 vietnamese-text&quot;&gt;&#10;              {item.label}&#10;            &lt;/div&gt;&#10;          &lt;/div&gt;&#10;        ))}&#10;      &lt;/div&gt;&#10;    &lt;/div&gt;&#10;  );&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/client-frontend/src/components/profile/StudentProfileInfo.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/client-frontend/src/components/profile/StudentProfileInfo.tsx" />
              <option name="updatedContent" value="'use client';&#10;&#10;import React from 'react';&#10;import { User } from '@/types';&#10;import { &#10;  GraduationCap, &#10;  BookOpen, &#10;  Calendar, &#10;  Users, &#10;  MapPin,&#10;  Award,&#10;  Hash&#10;} from 'lucide-react';&#10;&#10;interface StudentProfileInfoProps {&#10;  user: User;&#10;}&#10;&#10;export const StudentProfileInfo: React.FC&lt;StudentProfileInfoProps&gt; = ({ user }) =&gt; {&#10;  const infoSections = [&#10;    {&#10;      title: 'Thông tin học tập',&#10;      icon: &lt;GraduationCap className=&quot;h-5 w-5 text-blue-500&quot; /&gt;,&#10;      items: [&#10;        user.studentId &amp;&amp; { label: 'Mã số sinh viên', value: user.studentId, icon: &lt;Hash className=&quot;h-4 w-4&quot; /&gt; },&#10;        user.major &amp;&amp; { label: 'Ngành học', value: user.major.name, icon: &lt;BookOpen className=&quot;h-4 w-4&quot; /&gt; },&#10;        user.faculty &amp;&amp; { label: 'Khoa', value: user.faculty.name, icon: &lt;Award className=&quot;h-4 w-4&quot; /&gt; },&#10;        user.college &amp;&amp; { label: 'Trường', value: user.college.name, icon: &lt;MapPin className=&quot;h-4 w-4&quot; /&gt; },&#10;        user.yearOfStudy &amp;&amp; { label: 'Năm học', value: `Năm ${user.yearOfStudy}`, icon: &lt;Calendar className=&quot;h-4 w-4&quot; /&gt; },&#10;        user.batch &amp;&amp; { label: 'Khóa', value: `Khóa ${user.batch.year}`, icon: &lt;Users className=&quot;h-4 w-4&quot; /&gt; },&#10;      ].filter(Boolean)&#10;    }&#10;  ];&#10;&#10;  return (&#10;    &lt;div className=&quot;bg-white rounded-lg shadow-sm p-6&quot;&gt;&#10;      &lt;h2 className=&quot;text-xl font-bold text-gray-900 mb-6 vietnamese-text&quot;&gt;Thông tin cá nhân&lt;/h2&gt;&#10;      &#10;      &lt;div className=&quot;space-y-6&quot;&gt;&#10;        {infoSections.map((section, sectionIndex) =&gt; (&#10;          &lt;div key={sectionIndex}&gt;&#10;            &lt;div className=&quot;flex items-center space-x-2 mb-4&quot;&gt;&#10;              {section.icon}&#10;              &lt;h3 className=&quot;font-semibold text-gray-800 vietnamese-text&quot;&gt;{section.title}&lt;/h3&gt;&#10;            &lt;/div&gt;&#10;            &#10;            &lt;div className=&quot;space-y-3&quot;&gt;&#10;              {section.items.map((item, itemIndex) =&gt; (&#10;                &lt;div key={itemIndex} className=&quot;flex items-center space-x-3 p-3 bg-gray-50 rounded-lg hover:bg-gray-100 transition-colors&quot;&gt;&#10;                  &lt;div className=&quot;text-gray-500&quot;&gt;&#10;                    {item.icon}&#10;                  &lt;/div&gt;&#10;                  &lt;div className=&quot;flex-1&quot;&gt;&#10;                    &lt;div className=&quot;text-sm text-gray-600 vietnamese-text&quot;&gt;{item.label}&lt;/div&gt;&#10;                    &lt;div className=&quot;font-medium text-gray-900 vietnamese-text&quot;&gt;{item.value}&lt;/div&gt;&#10;                  &lt;/div&gt;&#10;                &lt;/div&gt;&#10;              ))}&#10;            &lt;/div&gt;&#10;          &lt;/div&gt;&#10;        ))}&#10;      &lt;/div&gt;&#10;    &lt;/div&gt;&#10;  );&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/client-frontend/src/components/user/UserProfile.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/client-frontend/src/components/user/UserProfile.tsx" />
              <option name="originalContent" value="'use client';&#10;&#10;import React, { useState, useEffect } from 'react';&#10;import { useAuth } from '@/contexts/AuthContext';&#10;import { User, Post } from '@/types';&#10;import { userService } from '@/services/userService';&#10;import { postService } from '@/services/postService';&#10;import { ProfileHeader } from '@/components/profile/ProfileHeader';&#10;import { ProfileStats } from '@/components/profile/ProfileStats';&#10;import { StudentProfileInfo } from '@/components/profile/StudentProfileInfo';&#10;import { LecturerProfileInfo } from '@/components/profile/LecturerProfileInfo';&#10;import { ProfilePostFeed } from '@/components/profile/ProfilePostFeed';&#10;import { LoadingSpinner } from '@/components/ui/LoadingSpinner';&#10;import { ErrorAlert } from '@/components/ui/ErrorAlert';&#10;&#10;interface UserProfileProps {&#10;  userId: string;&#10;}&#10;&#10;const UserProfile: React.FC&lt;UserProfileProps&gt; = ({ userId }) =&gt; {&#10;  const { user: currentUser } = useAuth();&#10;  const [profileUser, setProfileUser] = useState&lt;User | null&gt;(null);&#10;  const [userPosts, setUserPosts] = useState&lt;Post[]&gt;([]);&#10;  const [isLoading, setIsLoading] = useState(true);&#10;  const [error, setError] = useState&lt;string | null&gt;(null);&#10;  const [isFollowing, setIsFollowing] = useState(false);&#10;  const [activeTab, setActiveTab] = useState&lt;'posts' | 'about' | 'photos' | 'videos'&gt;('posts');&#10;  const [stats, setStats] = useState({&#10;    posts: 0,&#10;    followers: 0,&#10;    following: 0,&#10;    likes: 0,&#10;    views: 0&#10;  });&#10;&#10;  const isOwnProfile = currentUser?.id === userId;&#10;&#10;  useEffect(() =&gt; {&#10;    loadUserProfile();&#10;    if (userId) {&#10;      loadUserPosts();&#10;      loadUserStats();&#10;    }&#10;  }, [userId]);&#10;&#10;  const loadUserProfile = async () =&gt; {&#10;    try {&#10;      setIsLoading(true);&#10;      const user = await userService.getMyProfile();&#10;      setProfileUser(user);&#10;&#10;      // Check if current user is following this user&#10;      if (!isOwnProfile &amp;&amp; currentUser) {&#10;        // TODO: Implement follow status check&#10;        // const followStatus = await userService.getFollowStatus(userId);&#10;        // setIsFollowing(followStatus.isFollowing);&#10;      }&#10;    } catch (err) {&#10;      setError('Không thể tải thông tin người dùng');&#10;      console.error('Error loading user profile:', err);&#10;    } finally {&#10;      setIsLoading(false);&#10;    }&#10;  };&#10;&#10;  const loadUserPosts = async () =&gt; {&#10;    try {&#10;      // TODO: Implement user-specific posts loading&#10;      //  const posts = await postService.getMyPosts();&#10;      // setUserPosts(posts);&#10;      setUserPosts([]); // Temporary empty array&#10;    } catch (err) {&#10;      console.error('Error loading user posts:', err);&#10;    }&#10;  };&#10;&#10;  const loadUserStats = async () =&gt; {&#10;    try {&#10;      // TODO: Implement stats loading from backend&#10;      // For now, using mock data&#10;      setStats({&#10;        posts: Math.floor(Math.random() * 100),&#10;        followers: Math.floor(Math.random() * 1000),&#10;        following: Math.floor(Math.random() * 500),&#10;        likes: Math.floor(Math.random() * 5000),&#10;        views: Math.floor(Math.random() * 10000)&#10;      });&#10;    } catch (err) {&#10;      console.error('Error loading user stats:', err);&#10;    }&#10;  };&#10;&#10;  const handleFollow = async () =&gt; {&#10;    try {&#10;      if (isFollowing) {&#10;        await userService.unfollowUser(userId);&#10;        setIsFollowing(false);&#10;        setStats(prev =&gt; ({ ...prev, followers: prev.followers - 1 }));&#10;      } else {&#10;        await userService.followUser(userId);&#10;        setIsFollowing(true);&#10;        setStats(prev =&gt; ({ ...prev, followers: prev.followers + 1 }));&#10;      }&#10;    } catch (err) {&#10;      console.error('Error updating follow status:', err);&#10;    }&#10;  };&#10;&#10;  const handleMessage = () =&gt; {&#10;    // TODO: Implement messaging functionality&#10;    console.log('Open chat with user:', userId);&#10;  };&#10;&#10;  const handleEditProfile = () =&gt; {&#10;    // TODO: Implement profile editing&#10;    console.log('Edit profile');&#10;  };&#10;&#10;  const handleEditCover = () =&gt; {&#10;    // TODO: Implement cover photo editing&#10;    console.log('Edit cover photo');&#10;  };&#10;&#10;  const handleEditAvatar = () =&gt; {&#10;    // TODO: Implement avatar editing&#10;    console.log('Edit avatar');&#10;  };&#10;&#10;  const handleStatsClick = (type: 'posts' | 'followers' | 'following') =&gt; {&#10;    switch (type) {&#10;      case 'posts':&#10;        setActiveTab('posts');&#10;        break;&#10;      case 'followers':&#10;        // TODO: Show followers modal/page&#10;        console.log('Show followers');&#10;        break;&#10;      case 'following':&#10;        // TODO: Show following modal/page&#10;        console.log('Show following');&#10;        break;&#10;    }&#10;  };&#10;&#10;  if (isLoading) {&#10;    return (&#10;      &lt;div className=&quot;max-w-4xl mx-auto p-4&quot;&gt;&#10;        &lt;div className=&quot;flex justify-center items-center h-64&quot;&gt;&#10;          &lt;LoadingSpinner size=&quot;lg&quot; /&gt;&#10;        &lt;/div&gt;&#10;      &lt;/div&gt;&#10;    );&#10;  }&#10;&#10;  if (error || !profileUser) {&#10;    return (&#10;      &lt;div className=&quot;max-w-4xl mx-auto p-4&quot;&gt;&#10;        &lt;ErrorAlert message={error || 'Không tìm thấy người dùng'} /&gt;&#10;      &lt;/div&gt;&#10;    );&#10;  }&#10;&#10;  return (&#10;    &lt;div className=&quot;max-w-6xl mx-auto p-4 space-y-6&quot;&gt;&#10;      {/* Profile Header */}&#10;      &lt;ProfileHeader&#10;        user={profileUser}&#10;        isOwnProfile={isOwnProfile}&#10;        isFollowing={isFollowing}&#10;        onFollow={handleFollow}&#10;        onMessage={handleMessage}&#10;        onEditProfile={handleEditProfile}&#10;        onEditCover={handleEditCover}&#10;        onEditAvatar={handleEditAvatar}&#10;      /&gt;&#10;&#10;      {/* Profile Stats */}&#10;      &lt;ProfileStats&#10;        stats={stats}&#10;        onStatsClick={handleStatsClick}&#10;      /&gt;&#10;&#10;      {/* Navigation Tabs */}&#10;      &lt;div className=&quot;bg-white rounded-lg shadow-sm&quot;&gt;&#10;        &lt;div className=&quot;border-b border-gray-200&quot;&gt;&#10;          &lt;nav className=&quot;flex space-x-8 px-6&quot;&gt;&#10;            {[&#10;              { key: 'posts', label: 'Bài viết' },&#10;              { key: 'about', label: 'Giới thiệu' },&#10;              { key: 'photos', label: 'Ảnh' },&#10;              { key: 'videos', label: 'Video' }&#10;            ].map((tab) =&gt; (&#10;              &lt;button&#10;                key={tab.key}&#10;                onClick={() =&gt; setActiveTab(tab.key as any)}&#10;                className={`py-4 px-1 border-b-2 font-medium text-sm vietnamese-text transition-colors ${&#10;                  activeTab === tab.key&#10;                    ? 'border-blue-500 text-blue-600'&#10;                    : 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300'&#10;                }`}&#10;              &gt;&#10;                {tab.label}&#10;              &lt;/button&gt;&#10;            ))}&#10;          &lt;/nav&gt;&#10;        &lt;/div&gt;&#10;&#10;        {/* Tab Content */}&#10;        &lt;div className=&quot;p-6&quot;&gt;&#10;          {activeTab === 'posts' &amp;&amp; (&#10;            &lt;ProfilePostFeed&#10;              userId={userId}&#10;              userName={profileUser.fullName || profileUser.name}&#10;              isOwnProfile={isOwnProfile}&#10;            /&gt;&#10;          )}&#10;&#10;          {activeTab === 'about' &amp;&amp; (&#10;            &lt;div className=&quot;grid grid-cols-1 lg:grid-cols-2 gap-6&quot;&gt;&#10;              {profileUser.role === 'STUDENT' ? (&#10;                &lt;StudentProfileInfo user={profileUser} /&gt;&#10;              ) : (&#10;                &lt;LecturerProfileInfo user={profileUser} /&gt;&#10;              )}&#10;&#10;              {/* Additional Info Section */}&#10;              &lt;div className=&quot;space-y-6&quot;&gt;&#10;                {profileUser.bio &amp;&amp; (&#10;                  &lt;div className=&quot;bg-white rounded-lg shadow-sm p-6&quot;&gt;&#10;                    &lt;h3 className=&quot;text-lg font-semibold text-gray-900 mb-4 vietnamese-text&quot;&gt;&#10;                      Giới thiệu bản thân&#10;                    &lt;/h3&gt;&#10;                    &lt;p className=&quot;text-gray-700 leading-relaxed vietnamese-text&quot;&gt;&#10;                      {profileUser.bio}&#10;                    &lt;/p&gt;&#10;                  &lt;/div&gt;&#10;                )}&#10;              &lt;/div&gt;&#10;            &lt;/div&gt;&#10;          )}&#10;&#10;          {activeTab === 'photos' &amp;&amp; (&#10;            &lt;div className=&quot;text-center py-12&quot;&gt;&#10;              &lt;div className=&quot;text-gray-400 mb-4&quot;&gt;&#10;                &lt;svg className=&quot;w-16 h-16 mx-auto&quot; fill=&quot;currentColor&quot; viewBox=&quot;0 0 20 20&quot;&gt;&#10;                  &lt;path fillRule=&quot;evenodd&quot; d=&quot;M4 3a2 2 0 00-2 2v10a2 2 0 002 2h12a2 2 0 002-2V5a2 2 0 00-2-2H4zm12 12H4l4-8 3 6 2-4 3 6z&quot; clipRule=&quot;evenodd&quot; /&gt;&#10;                &lt;/svg&gt;&#10;              &lt;/div&gt;&#10;              &lt;p className=&quot;text-gray-500 vietnamese-text&quot;&gt;Chức năng xem ảnh đang được phát triển&lt;/p&gt;&#10;            &lt;/div&gt;&#10;          )}&#10;&#10;          {activeTab === 'videos' &amp;&amp; (&#10;            &lt;div className=&quot;text-center py-12&quot;&gt;&#10;              &lt;div className=&quot;text-gray-400 mb-4&quot;&gt;&#10;                &lt;svg className=&quot;w-16 h-16 mx-auto&quot; fill=&quot;currentColor&quot; viewBox=&quot;0 0 20 20&quot;&gt;&#10;                  &lt;path fillRule=&quot;evenodd&quot; d=&quot;M2 6a2 2 0 012-2h6a2 2 0 012 2v8a2 2 0 01-2 2H4a2 2 0 01-2-2V6zM14.553 7.106A1 1 0 0014 8v4a1 1 0 00.553.894l2 1A1 1 0 0018 13V7a1 1 0 00-1.447-.894l-2 1z&quot; clipRule=&quot;evenodd&quot; /&gt;&#10;                &lt;/svg&gt;&#10;              &lt;/div&gt;&#10;              &lt;p className=&quot;text-gray-500 vietnamese-text&quot;&gt;Chức năng xem video đang được phát triển&lt;/p&gt;&#10;            &lt;/div&gt;&#10;          )}&#10;        &lt;/div&gt;&#10;      &lt;/div&gt;&#10;    &lt;/div&gt;&#10;  );&#10;};&#10;&#10;export default UserProfile;&#10;" />
              <option name="updatedContent" value="'use client';&#13;&#10;&#13;&#10;import React, { useState, useEffect } from 'react';&#13;&#10;import { useAuth } from '@/contexts/AuthContext';&#13;&#10;import { User, Post } from '@/types';&#13;&#10;import { userService } from '@/services/userService';&#13;&#10;import { postService } from '@/services/postService';&#13;&#10;import { ProfileHeader } from '@/components/profile/ProfileHeader';&#13;&#10;import { ProfileStats } from '@/components/profile/ProfileStats';&#13;&#10;import { StudentProfileInfo } from '@/components/profile/StudentProfileInfo';&#13;&#10;import { LecturerProfileInfo } from '@/components/profile/LecturerProfileInfo';&#13;&#10;import { ProfilePostFeed } from '@/components/profile/ProfilePostFeed';&#13;&#10;import { LoadingSpinner } from '@/components/ui/LoadingSpinner';&#13;&#10;import { ErrorAlert } from '@/components/ui/ErrorAlert';&#13;&#10;&#13;&#10;interface UserProfileProps {&#13;&#10;  userId: string;&#13;&#10;}&#13;&#10;&#13;&#10;const UserProfile: React.FC&lt;UserProfileProps&gt; = ({ userId }) =&gt; {&#13;&#10;  const { user: currentUser } = useAuth();&#13;&#10;  const [profileUser, setProfileUser] = useState&lt;User | null&gt;(null);&#13;&#10;  const [userPosts, setUserPosts] = useState&lt;Post[]&gt;([]);&#13;&#10;  const [isLoading, setIsLoading] = useState(true);&#13;&#10;  const [error, setError] = useState&lt;string | null&gt;(null);&#13;&#10;  const [isFollowing, setIsFollowing] = useState(false);&#13;&#10;  const [activeTab, setActiveTab] = useState&lt;'posts' | 'about' | 'photos' | 'videos'&gt;('posts');&#13;&#10;  const [stats, setStats] = useState({&#13;&#10;    posts: 0,&#13;&#10;    followers: 0,&#13;&#10;    following: 0,&#13;&#10;    likes: 0,&#13;&#10;    views: 0&#13;&#10;  });&#13;&#10;&#13;&#10;  const isOwnProfile = currentUser?.id === userId;&#13;&#10;&#13;&#10;  useEffect(() =&gt; {&#13;&#10;    loadUserProfile();&#13;&#10;    if (userId) {&#13;&#10;      loadUserPosts();&#13;&#10;      loadUserStats();&#13;&#10;    }&#13;&#10;  }, [userId]);&#13;&#10;&#13;&#10;  const loadUserProfile = async () =&gt; {&#13;&#10;    try {&#13;&#10;      setIsLoading(true);&#13;&#10;      // Use the correct method based on whether it's own profile or not&#13;&#10;      const user = isOwnProfile &#13;&#10;        ? await userService.getMyProfile() &#13;&#10;        : await userService.getProfile(userId);&#13;&#10;      setProfileUser(user);&#13;&#10;      &#13;&#10;      // Check if current user is following this user&#13;&#10;      if (!isOwnProfile &amp;&amp; currentUser) {&#13;&#10;        // TODO: Implement follow status check&#13;&#10;        // const followStatus = await userService.getFollowStatus(userId);&#13;&#10;        // setIsFollowing(followStatus.isFollowing);&#13;&#10;      }&#13;&#10;    } catch (err) {&#13;&#10;      setError('Không thể tải thông tin người dùng');&#13;&#10;      console.error('Error loading user profile:', err);&#13;&#10;    } finally {&#13;&#10;      setIsLoading(false);&#13;&#10;    }&#13;&#10;  };&#13;&#10;&#13;&#10;  const loadUserPosts = async () =&gt; {&#13;&#10;    try {&#13;&#10;      // TODO: Implement user-specific posts loading&#13;&#10;      //  const posts = await postService.getMyPosts();&#13;&#10;      // setUserPosts(posts);&#13;&#10;      setUserPosts([]); // Temporary empty array&#13;&#10;    } catch (err) {&#13;&#10;      console.error('Error loading user posts:', err);&#13;&#10;    }&#13;&#10;  };&#13;&#10;&#13;&#10;  const loadUserStats = async () =&gt; {&#13;&#10;    try {&#13;&#10;      // TODO: Implement stats loading from backend&#13;&#10;      // For now, using mock data&#13;&#10;      setStats({&#13;&#10;        posts: Math.floor(Math.random() * 100),&#13;&#10;        followers: Math.floor(Math.random() * 1000),&#13;&#10;        following: Math.floor(Math.random() * 500),&#13;&#10;        likes: Math.floor(Math.random() * 5000),&#13;&#10;        views: Math.floor(Math.random() * 10000)&#13;&#10;      });&#13;&#10;    } catch (err) {&#13;&#10;      console.error('Error loading user stats:', err);&#13;&#10;    }&#13;&#10;  };&#13;&#10;&#13;&#10;  const handleFollow = async () =&gt; {&#13;&#10;    try {&#13;&#10;      if (isFollowing) {&#13;&#10;        await userService.unfollowUser(userId);&#13;&#10;        setIsFollowing(false);&#13;&#10;        setStats(prev =&gt; ({ ...prev, followers: prev.followers - 1 }));&#13;&#10;      } else {&#13;&#10;        await userService.followUser(userId);&#13;&#10;        setIsFollowing(true);&#13;&#10;        setStats(prev =&gt; ({ ...prev, followers: prev.followers + 1 }));&#13;&#10;      }&#13;&#10;    } catch (err) {&#13;&#10;      console.error('Error updating follow status:', err);&#13;&#10;    }&#13;&#10;  };&#13;&#10;&#13;&#10;  const handleMessage = () =&gt; {&#13;&#10;    // TODO: Implement messaging functionality&#13;&#10;    console.log('Open chat with user:', userId);&#13;&#10;  };&#13;&#10;&#13;&#10;  const handleEditProfile = () =&gt; {&#13;&#10;    // TODO: Implement profile editing&#13;&#10;    console.log('Edit profile');&#13;&#10;  };&#13;&#10;&#13;&#10;  const handleEditCover = () =&gt; {&#13;&#10;    // TODO: Implement cover photo editing&#13;&#10;    console.log('Edit cover photo');&#13;&#10;  };&#13;&#10;&#13;&#10;  const handleEditAvatar = () =&gt; {&#13;&#10;    // TODO: Implement avatar editing&#13;&#10;    console.log('Edit avatar');&#13;&#10;  };&#13;&#10;&#13;&#10;  const handleStatsClick = (type: 'posts' | 'followers' | 'following') =&gt; {&#13;&#10;    switch (type) {&#13;&#10;      case 'posts':&#13;&#10;        setActiveTab('posts');&#13;&#10;        break;&#13;&#10;      case 'followers':&#13;&#10;        // TODO: Show followers modal/page&#13;&#10;        console.log('Show followers');&#13;&#10;        break;&#13;&#10;      case 'following':&#13;&#10;        // TODO: Show following modal/page&#13;&#10;        console.log('Show following');&#13;&#10;        break;&#13;&#10;    }&#13;&#10;  };&#13;&#10;&#13;&#10;  if (isLoading) {&#13;&#10;    return (&#13;&#10;      &lt;div className=&quot;max-w-4xl mx-auto p-4&quot;&gt;&#13;&#10;        &lt;div className=&quot;flex justify-center items-center h-64&quot;&gt;&#13;&#10;          &lt;LoadingSpinner size=&quot;lg&quot; /&gt;&#13;&#10;        &lt;/div&gt;&#13;&#10;      &lt;/div&gt;&#13;&#10;    );&#13;&#10;  }&#13;&#10;&#13;&#10;  if (error || !profileUser) {&#13;&#10;    return (&#13;&#10;      &lt;div className=&quot;max-w-4xl mx-auto p-4&quot;&gt;&#13;&#10;        &lt;ErrorAlert message={error || 'Không tìm thấy người dùng'} /&gt;&#13;&#10;      &lt;/div&gt;&#13;&#10;    );&#13;&#10;  }&#13;&#10;&#13;&#10;  return (&#13;&#10;    &lt;div className=&quot;max-w-6xl mx-auto p-4 space-y-6&quot;&gt;&#13;&#10;      {/* Profile Header */}&#13;&#10;      &lt;ProfileHeader&#13;&#10;        user={profileUser}&#13;&#10;        isOwnProfile={isOwnProfile}&#13;&#10;        isFollowing={isFollowing}&#13;&#10;        onFollow={handleFollow}&#13;&#10;        onMessage={handleMessage}&#13;&#10;        onEditProfile={handleEditProfile}&#13;&#10;        onEditCover={handleEditCover}&#13;&#10;        onEditAvatar={handleEditAvatar}&#13;&#10;      /&gt;&#13;&#10;&#13;&#10;      {/* Profile Stats */}&#13;&#10;      &lt;ProfileStats&#13;&#10;        stats={stats}&#13;&#10;        onStatsClick={handleStatsClick}&#13;&#10;      /&gt;&#13;&#10;&#13;&#10;      {/* Navigation Tabs */}&#13;&#10;      &lt;div className=&quot;bg-white rounded-lg shadow-sm&quot;&gt;&#13;&#10;        &lt;div className=&quot;border-b border-gray-200&quot;&gt;&#13;&#10;          &lt;nav className=&quot;flex space-x-8 px-6&quot;&gt;&#13;&#10;            {[&#13;&#10;              { key: 'posts', label: 'Bài viết' },&#13;&#10;              { key: 'about', label: 'Giới thiệu' },&#13;&#10;              { key: 'photos', label: 'Ảnh' },&#13;&#10;              { key: 'videos', label: 'Video' }&#13;&#10;            ].map((tab) =&gt; (&#13;&#10;              &lt;button&#13;&#10;                key={tab.key}&#13;&#10;                onClick={() =&gt; setActiveTab(tab.key as any)}&#13;&#10;                className={`py-4 px-1 border-b-2 font-medium text-sm vietnamese-text transition-colors ${&#13;&#10;                  activeTab === tab.key&#13;&#10;                    ? 'border-blue-500 text-blue-600'&#13;&#10;                    : 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300'&#13;&#10;                }`}&#13;&#10;              &gt;&#13;&#10;                {tab.label}&#13;&#10;              &lt;/button&gt;&#13;&#10;            ))}&#13;&#10;          &lt;/nav&gt;&#13;&#10;        &lt;/div&gt;&#13;&#10;&#13;&#10;        {/* Tab Content */}&#13;&#10;        &lt;div className=&quot;p-6&quot;&gt;&#13;&#10;          {activeTab === 'posts' &amp;&amp; (&#13;&#10;            &lt;ProfilePostFeed&#13;&#10;              userId={userId}&#13;&#10;              userName={profileUser.fullName || profileUser.name}&#13;&#10;              isOwnProfile={isOwnProfile}&#13;&#10;            /&gt;&#13;&#10;          )}&#13;&#10;&#13;&#10;          {activeTab === 'about' &amp;&amp; (&#13;&#10;            &lt;div className=&quot;grid grid-cols-1 lg:grid-cols-2 gap-6&quot;&gt;&#13;&#10;              {profileUser.role === 'STUDENT' ? (&#13;&#10;                &lt;StudentProfileInfo user={profileUser} /&gt;&#13;&#10;              ) : (&#13;&#10;                &lt;LecturerProfileInfo user={profileUser} /&gt;&#13;&#10;              )}&#13;&#10;&#13;&#10;              {/* Additional Info Section */}&#13;&#10;              &lt;div className=&quot;space-y-6&quot;&gt;&#13;&#10;                {profileUser.bio &amp;&amp; (&#13;&#10;                  &lt;div className=&quot;bg-white rounded-lg shadow-sm p-6&quot;&gt;&#13;&#10;                    &lt;h3 className=&quot;text-lg font-semibold text-gray-900 mb-4 vietnamese-text&quot;&gt;&#13;&#10;                      Giới thiệu bản thân&#13;&#10;                    &lt;/h3&gt;&#13;&#10;                    &lt;p className=&quot;text-gray-700 leading-relaxed vietnamese-text&quot;&gt;&#13;&#10;                      {profileUser.bio}&#13;&#10;                    &lt;/p&gt;&#13;&#10;                  &lt;/div&gt;&#13;&#10;                )}&#13;&#10;              &lt;/div&gt;&#13;&#10;            &lt;/div&gt;&#13;&#10;          )}&#13;&#10;&#13;&#10;          {activeTab === 'photos' &amp;&amp; (&#13;&#10;            &lt;div className=&quot;text-center py-12&quot;&gt;&#13;&#10;              &lt;div className=&quot;text-gray-400 mb-4&quot;&gt;&#13;&#10;                &lt;svg className=&quot;w-16 h-16 mx-auto&quot; fill=&quot;currentColor&quot; viewBox=&quot;0 0 20 20&quot;&gt;&#13;&#10;                  &lt;path fillRule=&quot;evenodd&quot; d=&quot;M4 3a2 2 0 00-2 2v10a2 2 0 002 2h12a2 2 0 002-2V5a2 2 0 00-2-2H4zm12 12H4l4-8 3 6 2-4 3 6z&quot; clipRule=&quot;evenodd&quot; /&gt;&#13;&#10;                &lt;/svg&gt;&#13;&#10;              &lt;/div&gt;&#13;&#10;              &lt;p className=&quot;text-gray-500 vietnamese-text&quot;&gt;Chức năng xem ảnh đang được phát triển&lt;/p&gt;&#13;&#10;            &lt;/div&gt;&#13;&#10;          )}&#13;&#10;&#13;&#10;          {activeTab === 'videos' &amp;&amp; (&#13;&#10;            &lt;div className=&quot;text-center py-12&quot;&gt;&#13;&#10;              &lt;div className=&quot;text-gray-400 mb-4&quot;&gt;&#13;&#10;                &lt;svg className=&quot;w-16 h-16 mx-auto&quot; fill=&quot;currentColor&quot; viewBox=&quot;0 0 20 20&quot;&gt;&#13;&#10;                  &lt;path fillRule=&quot;evenodd&quot; d=&quot;M2 6a2 2 0 012-2h6a2 2 0 012 2v8a2 2 0 01-2 2H4a2 2 0 01-2-2V6zM14.553 7.106A1 1 0 0014 8v4a1 1 0 00.553.894l2 1A1 1 0 0018 13V7a1 1 0 00-1.447-.894l-2 1z&quot; clipRule=&quot;evenodd&quot; /&gt;&#13;&#10;                &lt;/svg&gt;&#13;&#10;              &lt;/div&gt;&#13;&#10;              &lt;p className=&quot;text-gray-500 vietnamese-text&quot;&gt;Chức năng xem video đang được phát triển&lt;/p&gt;&#13;&#10;            &lt;/div&gt;&#13;&#10;          )}&#13;&#10;        &lt;/div&gt;&#13;&#10;      &lt;/div&gt;&#13;&#10;    &lt;/div&gt;&#13;&#10;  );&#13;&#10;};&#13;&#10;&#13;&#10;export default UserProfile;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/client-frontend/src/lib/locales/vi.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/client-frontend/src/lib/locales/vi.ts" />
              <option name="updatedContent" value="// Vietnamese localization constants&#10;export const VI_LOCALE = {&#10;  // Common actions&#10;  actions: {&#10;    save: 'Lưu',&#10;    cancel: 'Hủy',&#10;    delete: 'Xóa',&#10;    edit: 'Chỉnh sửa',&#10;    submit: 'Gửi',&#10;    confirm: 'Xác nhận',&#10;    back: 'Quay lại',&#10;    next: 'Tiếp theo',&#10;    loading: 'Đang tải...',&#10;    retry: 'Thử lại',&#10;    close: 'Đóng',&#10;    open: 'Mở',&#10;    view: 'Xem',&#10;    share: 'Chia sẻ',&#10;    copy: 'Sao chép',&#10;    download: 'Tải xuống',&#10;    upload: 'Tải lên',&#10;    search: 'Tìm kiếm',&#10;    filter: 'Lọc',&#10;    sort: 'Sắp xếp',&#10;    refresh: 'Làm mới'&#10;  },&#10;&#10;  // Authentication&#10;  auth: {&#10;    login: 'Đăng nhập',&#10;    logout: 'Đăng xuất',&#10;    register: 'Đăng ký',&#10;    forgotPassword: 'Quên mật khẩu',&#10;    resetPassword: 'Đặt lại mật khẩu',&#10;    changePassword: 'Đổi mật khẩu',&#10;    verifyEmail: 'Xác thực email',&#10;    resendVerification: 'Gửi lại mã xác thực'&#10;  },&#10;&#10;  // Posts&#10;  posts: {&#10;    createPost: 'Tạo bài viết',&#10;    editPost: 'Chỉnh sửa bài viết',&#10;    deletePost: 'Xóa bài viết',&#10;    sharePost: 'Chia sẻ bài viết',&#10;    likePost: 'Thích bài viết',&#10;    unlikePost: 'Bỏ thích',&#10;    bookmarkPost: 'Lưu bài viết',&#10;    removeBookmark: 'Bỏ lưu',&#10;    commentPost: 'Bình luận',&#10;    viewComments: 'Xem bình luận',&#10;    hideComments: 'Ẩn bình luận',&#10;    writeComment: 'Viết bình luận...',&#10;    replyComment: 'Trả lời',&#10;    postTitle: 'Tiêu đề bài viết',&#10;    postContent: 'Nội dung bài viết',&#10;    addMedia: 'Thêm ảnh/video',&#10;    addTag: 'Thêm thẻ',&#10;    selectCategory: 'Chọn danh mục',&#10;    noPostsFound: 'Không tìm thấy bài viết nào',&#10;    loadMorePosts: 'Tải thêm bài viết'&#10;  },&#10;&#10;  // User profile&#10;  profile: {&#10;    profile: 'Hồ sơ',&#10;    editProfile: 'Chỉnh sửa hồ sơ',&#10;    viewProfile: 'Xem hồ sơ',&#10;    fullName: 'Họ và tên',&#10;    email: 'Email',&#10;    username: 'Tên đăng nhập',&#10;    bio: 'Giới thiệu',&#10;    avatar: 'Ảnh đại diện',&#10;    coverPhoto: 'Ảnh bìa',&#10;    birthday: 'Ngày sinh',&#10;    gender: 'Giới tính',&#10;    faculty: 'Khoa',&#10;    major: 'Ngành học',&#10;    studentId: 'Mã số sinh viên',&#10;    academicYear: 'Niên khóa',&#10;    phone: 'Số điện thoại',&#10;    address: 'Địa chỉ'&#10;  },&#10;&#10;  // Messages and notifications&#10;  messages: {&#10;    success: {&#10;      loginSuccess: 'Đăng nhập thành công',&#10;      logoutSuccess: 'Đăng xuất thành công',&#10;      registrationSuccess: 'Đăng ký thành công',&#10;      profileUpdated: 'Cập nhật hồ sơ thành công',&#10;      postCreated: 'Tạo bài viết thành công',&#10;      postUpdated: 'Cập nhật bài viết thành công',&#10;      postDeleted: 'Xóa bài viết thành công',&#10;      commentAdded: 'Thêm bình luận thành công',&#10;      passwordChanged: 'Đổi mật khẩu thành công',&#10;      emailVerified: 'Xác thực email thành công'&#10;    },&#10;    error: {&#10;      genericError: 'Đã xảy ra lỗi. Vui lòng thử lại.',&#10;      networkError: 'Lỗi kết nối mạng. Vui lòng kiểm tra kết nối internet.',&#10;      unauthorized: 'Bạn không có quyền truy cập.',&#10;      forbidden: 'Truy cập bị từ chối.',&#10;      notFound: 'Không tìm thấy tài nguyên.',&#10;      serverError: 'Lỗi máy chủ. Vui lòng thử lại sau.',&#10;      validationError: 'Dữ liệu không hợp lệ.',&#10;      loginFailed: 'Đăng nhập thất bại',&#10;      registrationFailed: 'Đăng ký thất bại',&#10;      uploadFailed: 'Tải file thất bại',&#10;      securityError: 'Xác thực bảo mật thất bại. Vui lòng thử lại.'&#10;    },&#10;    validation: {&#10;      required: 'Trường này là bắt buộc',&#10;      invalidEmail: 'Email không hợp lệ',&#10;      invalidPassword: 'Mật khẩu không hợp lệ',&#10;      passwordMismatch: 'Mật khẩu xác nhận không khớp',&#10;      minLength: 'Tối thiểu {min} ký tự',&#10;      maxLength: 'Tối đa {max} ký tự',&#10;      invalidFormat: 'Định dạng không hợp lệ'&#10;    }&#10;  },&#10;&#10;  // Time formatting&#10;  time: {&#10;    now: 'Vừa xong',&#10;    minutesAgo: '{count} phút trước',&#10;    hoursAgo: '{count} giờ trước',&#10;    daysAgo: '{count} ngày trước',&#10;    weeksAgo: '{count} tuần trước',&#10;    monthsAgo: '{count} tháng trước',&#10;    yearsAgo: '{count} năm trước'&#10;  },&#10;&#10;  // File upload&#10;  upload: {&#10;    selectFiles: 'Chọn tệp',&#10;    dragAndDrop: 'Kéo thả tệp vào đây',&#10;    maxFileSize: 'Kích thước tệp tối đa: {size}MB',&#10;    supportedFormats: 'Định dạng hỗ trợ: {formats}',&#10;    uploadProgress: 'Đang tải lên... {progress}%',&#10;    uploadComplete: 'Tải lên hoàn tất',&#10;    uploadFailed: 'Tải lên thất bại'&#10;  },&#10;&#10;  // Search and filters&#10;  search: {&#10;    searchPlaceholder: 'Tìm kiếm...',&#10;    noResults: 'Không tìm thấy kết quả',&#10;    searchResults: 'Kết quả tìm kiếm',&#10;    filters: 'Bộ lọc',&#10;    sortBy: 'Sắp xếp theo',&#10;    sortNewest: 'Mới nhất',&#10;    sortOldest: 'Cũ nhất',&#10;    sortMostLiked: 'Nhiều lượt thích nhất',&#10;    sortMostViewed: 'Nhiều lượt xem nhất'&#10;  },&#10;&#10;  // Categories&#10;  categories: {&#10;    academic: 'Học tập',&#10;    social: 'Sinh hoạt',&#10;    announcement: 'Thông báo',&#10;    career: 'Nghề nghiệp',&#10;    technology: 'Công nghệ',&#10;    sports: 'Thể thao',&#10;    entertainment: 'Giải trí',&#10;    other: 'Khác'&#10;  }&#10;} as const;&#10;&#10;export type LocaleKey = keyof typeof VI_LOCALE;&#10;export type LocaleValue = typeof VI_LOCALE[LocaleKey];" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/client-frontend/src/services/postService.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/client-frontend/src/services/postService.ts" />
              <option name="originalContent" value="import api from '@/lib/api';&#10;import { mediaService, MediaResponse } from './mediaService';&#10;import {&#10;  Post,&#10;  Comment,&#10;  CreatePostRequest,&#10;  UpdatePostRequest,&#10;  CreateCommentRequest,&#10;  CreateInteractionRequest,&#10;  Interaction,&#10;  PaginatedResponse,&#10;  InteractionType,&#10;  ReactionType&#10;} from '@/types';&#10;&#10;export const postService = {&#10;  // Create post with proper structure matching backend&#10;  async createPost(postData: CreatePostRequest, files?: File[]): Promise&lt;Post&gt; {&#10;    try {&#10;      let imageUrls: string[] = [];&#10;      let videoUrls: string[] = [];&#10;&#10;      // Step 1: Upload files to media service first if files exist&#10;      if (files &amp;&amp; files.length &gt; 0) {&#10;        console.log('Uploading files to media service...');&#10;        const mediaResponses: MediaResponse[] = await mediaService.uploadFiles(&#10;          files,&#10;          'Post media files'&#10;        );&#10;&#10;        // Separate images and videos based on media type&#10;        mediaResponses.forEach(media =&gt; {&#10;          if (media.mediaType === 'IMAGE') {&#10;            imageUrls.push(media.cloudinaryUrl);&#10;          } else if (media.mediaType === 'VIDEO') {&#10;            videoUrls.push(media.cloudinaryUrl);&#10;          }&#10;        });&#10;&#10;        console.log('Files uploaded successfully - Images:', imageUrls, 'Videos:', videoUrls);&#10;      }&#10;&#10;      // Step 2: Create post data with separated media URLs&#10;      const postRequestData = {&#10;        ...postData,&#10;        images: imageUrls.length &gt; 0 ? imageUrls : undefined,&#10;        videos: videoUrls.length &gt; 0 ? videoUrls : undefined&#10;      };&#10;      console.log('Creating post request...', postRequestData);&#10;&#10;      // Step 3: Create post via post service&#10;      const response = await api.post('/posts', postRequestData, {&#10;        headers: {&#10;          'Content-Type': 'application/json',&#10;        },&#10;      });&#10;&#10;      return response.data;&#10;    } catch (error) {&#10;      console.error('Error creating post:', error);&#10;      throw error;&#10;    }&#10;  },&#10;&#10;  // Get paginated posts&#10;  async getPosts(&#10;    page = 0,&#10;    size = 10,&#10;    sortBy = 'createdAt',&#10;    sortDir = 'desc',&#10;    authorId?: string,&#10;    category?: string,&#10;    search?: string&#10;  ): Promise&lt;PaginatedResponse&lt;Post&gt;&gt; {&#10;    const params = new URLSearchParams({&#10;      page: page.toString(),&#10;      size: size.toString(),&#10;      sortBy,&#10;      sortDir,&#10;    });&#10;&#10;    if (authorId) params.append('authorId', authorId);&#10;    if (category) params.append('category', category);&#10;    if (search) params.append('search', search);&#10;&#10;    const response = await api.get(`/posts?${params.toString()}`);&#10;&#10;    return response.data;&#10;  },&#10;&#10;  // Get single post by ID&#10;  async getPost(postId: string): Promise&lt;Post&gt; {&#10;    const response = await api.get(`/posts/${postId}`);&#10;    return response.data;&#10;  },&#10;&#10;  // Get posts by author&#10;  async getUserPosts(authorId: string, page = 0, size = 10): Promise&lt;PaginatedResponse&lt;Post&gt;&gt; {&#10;    const response = await api.get(`/posts/user/${authorId}`, {&#10;      params: {&#10;        page,&#10;        size&#10;      }&#10;    });&#10;    console.log(&quot;Fetched user posts:&quot;, response.data);&#10;    return response.data;&#10;  },&#10;&#10;  // Update post&#10;  async updatePost(postId: string, updateData: UpdatePostRequest): Promise&lt;Post&gt; {&#10;    const response = await api.put(`/posts/${postId}`, updateData);&#10;    return response.data;&#10;  },&#10;&#10;  // Delete post&#10;  async deletePost(postId: string): Promise&lt;void&gt; {&#10;    await api.delete(`/posts/${postId}`);&#10;  },&#10;&#10;  // Search posts&#10;  async searchPosts(query: string, page = 0, size = 10): Promise&lt;PaginatedResponse&lt;Post&gt;&gt; {&#10;    return this.getPosts(page, size, 'createdAt', 'desc', undefined, undefined, query);&#10;  },&#10;&#10;  // Get posts by category&#10;  async getPostsByCategory(category: string, page = 0, size = 10): Promise&lt;PaginatedResponse&lt;Post&gt;&gt; {&#10;    return this.getPosts(page, size, 'createdAt', 'desc', undefined, category);&#10;  },&#10;&#10;  // INTERACTION METHODS&#10;&#10;  // Create interaction (like, share, bookmark)&#10;  async createInteraction(postId: string, interactionData: CreateInteractionRequest): Promise&lt;Interaction | null&gt; {&#10;    const response = await api.post(`/posts/${postId}/interactions`, interactionData);&#10;    console.log(&quot;Created interaction:&quot;, response.data);&#10;    return response.data;&#10;  },&#10;&#10;  // Like/Unlike post&#10;  async toggleLike(postId: string): Promise&lt;Interaction | null&gt; {&#10;    return this.createInteraction(postId, {&#10;      type: InteractionType.LIKE,&#10;      reactionType: ReactionType.LIKE&#10;    });&#10;  },&#10;&#10;  // Share post&#10;  async sharePost(postId: string): Promise&lt;Interaction | null&gt; {&#10;    return this.createInteraction(postId, {&#10;      type: InteractionType.SHARE&#10;    });&#10;  },&#10;&#10;  // Bookmark post&#10;  async toggleBookmark(postId: string): Promise&lt;Interaction | null&gt; {&#10;    return this.createInteraction(postId, {&#10;      type: InteractionType.BOOKMARK,&#10;      reactionType: ReactionType.BOOKMARK&#10;    });&#10;  },&#10;&#10;  // Check if user has liked post&#10;  async hasUserLikedPost(postId: string): Promise&lt;boolean&gt; {&#10;    const response = await api.get(`/posts/${postId}/likes/check`);&#10;    return response.data;&#10;  },&#10;&#10;  // Get top viewed posts&#10;  async getTopViewedPosts(): Promise&lt;Post[]&gt; {&#10;    const response = await api.get('/posts/top-viewed');&#10;    return response.data;&#10;  },&#10;&#10;  // Get top liked posts&#10;  async getTopLikedPosts(): Promise&lt;Post[]&gt; {&#10;    const response = await api.get('/posts/top-liked');&#10;    return response.data;&#10;  },&#10;&#10;  // INTERACTION STATUS METHODS (New - for persistent state)&#10;&#10;  // Check interaction status for a post&#10;  async getInteractionStatus(postId: string): Promise&lt;{&#10;    postId: string;&#10;    userId: string;&#10;    hasLiked: boolean;&#10;    hasBookmarked: boolean;&#10;    interactions: { LIKE: boolean; BOOKMARK: boolean };&#10;  }&gt; {&#10;    const response = await api.get(`/posts/${postId}/interactions/status`);&#10;    return response.data;&#10;  },&#10;&#10;  // Check like status specifically&#10;  async checkLikeStatus(postId: string): Promise&lt;{&#10;    postId: string;&#10;    hasLiked: boolean;&#10;    userId: string;&#10;  }&gt; {&#10;    const response = await api.get(`/posts/${postId}/interactions/like/status`);&#10;    return response.data;&#10;  },&#10;&#10;  // Check bookmark status specifically&#10;  async checkBookmarkStatus(postId: string): Promise&lt;{&#10;    postId: string;&#10;    hasBookmarked: boolean;&#10;    userId: string;&#10;  }&gt; {&#10;    const response = await api.get(`/posts/${postId}/interactions/bookmark/status`);&#10;    return response.data;&#10;  },&#10;&#10;  // COMMENT METHODS (Missing)&#10;&#10;  // Get comments for a post&#10;  async getComments(postId: string, page = 0, size = 10): Promise&lt;PaginatedResponse&lt;Comment&gt;&gt; {&#10;    const params = new URLSearchParams({&#10;      page: page.toString(),&#10;      size: size.toString(),&#10;    });&#10;&#10;    const response = await api.get(`/posts/${postId}/comments?${params.toString()}`);&#10;    console.log(&quot;Fetched comments for post:&quot;, postId, response.data);&#10;    return response.data;&#10;  },&#10;&#10;  // Create a comment&#10;  async createComment(postId: string, commentData: CreateCommentRequest): Promise&lt;Comment&gt; {&#10;    const response = await api.post(`/posts/${postId}/comments`, commentData);&#10;    return response.data;&#10;  },&#10;&#10;  async getMyPosts(page = 0, size = 10): Promise&lt;PaginatedResponse&lt;Post&gt;&gt; {&#10;    const response = await api.get(`/posts/me?page=${page}&amp;size=${size}`);&#10;&#10;    return response.data;&#10;  },&#10;&#10;};&#10;" />
              <option name="updatedContent" value="import api from '@/lib/api';&#13;&#10;import { mediaService, MediaResponse } from './mediaService';&#13;&#10;import {&#13;&#10;  Post,&#13;&#10;  Comment,&#13;&#10;  CreatePostRequest,&#13;&#10;  UpdatePostRequest,&#13;&#10;  CreateCommentRequest,&#13;&#10;  CreateInteractionRequest,&#13;&#10;  Interaction,&#13;&#10;  PaginatedResponse,&#13;&#10;  InteractionType,&#13;&#10;  ReactionType&#13;&#10;} from '@/types';&#13;&#10;&#13;&#10;export const postService = {&#13;&#10;  // Create post with proper structure matching backend&#13;&#10;  async createPost(postData: CreatePostRequest, files?: File[]): Promise&lt;Post&gt; {&#13;&#10;    try {&#13;&#10;      let imageUrls: string[] = [];&#13;&#10;      let videoUrls: string[] = [];&#13;&#10;&#13;&#10;      // Step 1: Upload files to media service first if files exist&#13;&#10;      if (files &amp;&amp; files.length &gt; 0) {&#13;&#10;        console.log('Uploading files to media service...');&#13;&#10;        const mediaResponses: MediaResponse[] = await mediaService.uploadFiles(&#13;&#10;          files,&#13;&#10;          'Post media files'&#13;&#10;        );&#13;&#10;&#13;&#10;        // Separate images and videos based on media type&#13;&#10;        mediaResponses.forEach(media =&gt; {&#13;&#10;          if (media.mediaType === 'IMAGE') {&#13;&#10;            imageUrls.push(media.cloudinaryUrl);&#13;&#10;          } else if (media.mediaType === 'VIDEO') {&#13;&#10;            videoUrls.push(media.cloudinaryUrl);&#13;&#10;          }&#13;&#10;        });&#13;&#10;&#13;&#10;        console.log('Files uploaded successfully - Images:', imageUrls, 'Videos:', videoUrls);&#13;&#10;      }&#13;&#10;&#13;&#10;      // Step 2: Create post data with separated media URLs&#13;&#10;      const postRequestData = {&#13;&#10;        ...postData,&#13;&#10;        images: imageUrls.length &gt; 0 ? imageUrls : undefined,&#13;&#10;        videos: videoUrls.length &gt; 0 ? videoUrls : undefined&#13;&#10;      };&#13;&#10;      console.log('Creating post request...', postRequestData);&#13;&#10;&#13;&#10;      // Step 3: Create post via post service&#13;&#10;      const response = await api.post('/posts', postRequestData, {&#13;&#10;        headers: {&#13;&#10;          'Content-Type': 'application/json',&#13;&#10;        },&#13;&#10;      });&#13;&#10;&#13;&#10;      return response.data;&#13;&#10;    } catch (error) {&#13;&#10;      console.error('Error creating post:', error);&#13;&#10;      throw error;&#13;&#10;    }&#13;&#10;  },&#13;&#10;&#13;&#10;  // Get paginated posts&#13;&#10;  async getPosts(&#13;&#10;    page = 0,&#13;&#10;    size = 10,&#13;&#10;    sortBy = 'createdAt',&#13;&#10;    sortDir = 'desc',&#13;&#10;    authorId?: string,&#13;&#10;    category?: string,&#13;&#10;    search?: string&#13;&#10;  ): Promise&lt;PaginatedResponse&lt;Post&gt;&gt; {&#13;&#10;    const params = new URLSearchParams({&#13;&#10;      page: page.toString(),&#13;&#10;      size: size.toString(),&#13;&#10;      sortBy,&#13;&#10;      sortDir,&#13;&#10;    });&#13;&#10;&#13;&#10;    if (authorId) params.append('authorId', authorId);&#13;&#10;    if (category) params.append('category', category);&#13;&#10;    if (search) params.append('search', search);&#13;&#10;&#13;&#10;    const response = await api.get(`/posts?${params.toString()}`);&#13;&#10;&#13;&#10;    return response.data;&#13;&#10;  },&#13;&#10;&#13;&#10;  // Get single post by ID&#13;&#10;  async getPost(postId: string): Promise&lt;Post&gt; {&#13;&#10;    const response = await api.get(`/posts/${postId}`);&#13;&#10;    return response.data;&#13;&#10;  },&#13;&#10;&#13;&#10;  // Get posts by author&#13;&#10;  async getUserPosts(authorId: string, page = 0, size = 10): Promise&lt;PaginatedResponse&lt;Post&gt;&gt; {&#13;&#10;    const response = await api.get(`/posts/user/${authorId}`, {&#13;&#10;      params: {&#13;&#10;        page,&#13;&#10;        size&#13;&#10;      }&#13;&#10;    });&#13;&#10;    console.log(&quot;Fetched user posts:&quot;, response.data);&#13;&#10;    return response.data;&#13;&#10;  },&#13;&#10;&#13;&#10;  // Update post&#13;&#10;  async updatePost(postId: string, updateData: UpdatePostRequest): Promise&lt;Post&gt; {&#13;&#10;    const response = await api.put(`/posts/${postId}`, updateData);&#13;&#10;    return response.data;&#13;&#10;  },&#13;&#10;&#13;&#10;  // Delete post&#13;&#10;  async deletePost(postId: string): Promise&lt;void&gt; {&#13;&#10;    await api.delete(`/posts/${postId}`);&#13;&#10;  },&#13;&#10;&#13;&#10;  // Search posts&#13;&#10;  async searchPosts(query: string, page = 0, size = 10): Promise&lt;PaginatedResponse&lt;Post&gt;&gt; {&#13;&#10;    return this.getPosts(page, size, 'createdAt', 'desc', undefined, undefined, query);&#13;&#10;  },&#13;&#10;&#13;&#10;  // Get posts by category&#13;&#10;  async getPostsByCategory(category: string, page = 0, size = 10): Promise&lt;PaginatedResponse&lt;Post&gt;&gt; {&#13;&#10;    return this.getPosts(page, size, 'createdAt', 'desc', undefined, category);&#13;&#10;  },&#13;&#10;&#13;&#10;  // INTERACTION METHODS&#13;&#10;&#13;&#10;  // Create interaction (like, share, bookmark)&#13;&#10;  async createInteraction(postId: string, interactionData: CreateInteractionRequest): Promise&lt;Interaction | null&gt; {&#13;&#10;    const response = await api.post(`/posts/${postId}/interactions`, interactionData);&#13;&#10;    console.log(&quot;Created interaction:&quot;, response.data);&#13;&#10;    return response.data;&#13;&#10;  },&#13;&#10;&#13;&#10;  // Like/Unlike post&#13;&#10;  async toggleLike(postId: string): Promise&lt;Interaction | null&gt; {&#13;&#10;    return this.createInteraction(postId, {&#13;&#10;      type: InteractionType.LIKE,&#13;&#10;      reactionType: ReactionType.LIKE&#13;&#10;    });&#13;&#10;  },&#13;&#10;&#13;&#10;  // Share post&#13;&#10;  async sharePost(postId: string): Promise&lt;Interaction | null&gt; {&#13;&#10;    return this.createInteraction(postId, {&#13;&#10;      type: InteractionType.SHARE&#13;&#10;    });&#13;&#10;  },&#13;&#10;&#13;&#10;  // Bookmark post&#13;&#10;  async toggleBookmark(postId: string): Promise&lt;Interaction | null&gt; {&#13;&#10;    return this.createInteraction(postId, {&#13;&#10;      type: InteractionType.BOOKMARK,&#13;&#10;      reactionType: ReactionType.BOOKMARK&#13;&#10;    });&#13;&#10;  },&#13;&#10;&#13;&#10;  // Check if user has liked post&#13;&#10;  async hasUserLikedPost(postId: string): Promise&lt;boolean&gt; {&#13;&#10;    const response = await api.get(`/posts/${postId}/likes/check`);&#13;&#10;    return response.data;&#13;&#10;  },&#13;&#10;&#13;&#10;  // Get top viewed posts&#13;&#10;  async getTopViewedPosts(): Promise&lt;Post[]&gt; {&#13;&#10;    const topViewedResponse = await api.get('/posts/top-viewed');&#13;&#10;    return topViewedResponse.data;&#13;&#10;  },&#13;&#10;&#13;&#10;  // Get top liked posts&#13;&#10;  async getTopLikedPosts(): Promise&lt;Post[]&gt; {&#13;&#10;    const response = await api.get('/posts/top-liked');&#13;&#10;    return response.data;&#13;&#10;  },&#13;&#10;&#13;&#10;  // INTERACTION STATUS METHODS (New - for persistent state)&#13;&#10;&#13;&#10;  // Check interaction status for a post&#13;&#10;  async getInteractionStatus(postId: string): Promise&lt;{&#13;&#10;    postId: string;&#13;&#10;    userId: string;&#13;&#10;    hasLiked: boolean;&#13;&#10;    hasBookmarked: boolean;&#13;&#10;    interactions: { LIKE: boolean; BOOKMARK: boolean };&#13;&#10;  }&gt; {&#13;&#10;    const response = await api.get(`/posts/${postId}/interactions/status`);&#13;&#10;    return response.data;&#13;&#10;  },&#13;&#10;&#13;&#10;  // Check like status specifically&#13;&#10;  async checkLikeStatus(postId: string): Promise&lt;{&#13;&#10;    postId: string;&#13;&#10;    hasLiked: boolean;&#13;&#10;    userId: string;&#13;&#10;  }&gt; {&#13;&#10;    const response = await api.get(`/posts/${postId}/interactions/like/status`);&#13;&#10;    return response.data;&#13;&#10;  },&#13;&#10;&#13;&#10;  // Check bookmark status specifically&#13;&#10;  async checkBookmarkStatus(postId: string): Promise&lt;{&#13;&#10;    postId: string;&#13;&#10;    hasBookmarked: boolean;&#13;&#10;    userId: string;&#13;&#10;  }&gt; {&#13;&#10;    const response = await api.get(`/posts/${postId}/interactions/bookmark/status`);&#13;&#10;    return response.data;&#13;&#10;  },&#13;&#10;&#13;&#10;  // COMMENT METHODS (Missing)&#13;&#10;&#13;&#10;  // Get comments for a post&#13;&#10;  async getComments(postId: string, page = 0, size = 10): Promise&lt;PaginatedResponse&lt;Comment&gt;&gt; {&#13;&#10;    const params = new URLSearchParams({&#13;&#10;      page: page.toString(),&#13;&#10;      size: size.toString(),&#13;&#10;    });&#13;&#10;&#13;&#10;    const response = await api.get(`/posts/${postId}/comments?${params.toString()}`);&#13;&#10;    console.log(&quot;Fetched comments for post:&quot;, postId, response.data);&#13;&#10;    return response.data;&#13;&#10;  },&#13;&#10;&#13;&#10;  // Create a comment&#13;&#10;  async createComment(postId: string, commentData: CreateCommentRequest): Promise&lt;Comment&gt; {&#13;&#10;    const response = await api.post(`/posts/${postId}/comments`, commentData);&#13;&#10;    return response.data;&#13;&#10;  },&#13;&#10;&#13;&#10;  async getMyPosts(page = 0, size = 10): Promise&lt;PaginatedResponse&lt;Post&gt;&gt; {&#13;&#10;    const response = await api.get(`/posts/me?page=${page}&amp;size=${size}`);&#13;&#10;&#13;&#10;    return response.data;&#13;&#10;  },&#13;&#10;&#13;&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/client-frontend/src/shared/services/post.service.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/client-frontend/src/shared/services/post.service.ts" />
              <option name="originalContent" value="import { apiClient } from '@/shared/config/api-client';&#10;import { API_ENDPOINTS } from '@/shared/constants';&#10;import { createApiUrl } from '@/shared/utils';&#10;import {&#10;  Post,&#10;  Comment,&#10;  CreatePostRequest,&#10;  UpdatePostRequest,&#10;  CreateCommentRequest,&#10;  UpdateCommentRequest,&#10;  PaginatedResponse,&#10;  ApiResponse,&#10;  PostVisibility,&#10;} from '@/shared/types';&#10;&#10;/**&#10; * Post Service&#10; * Handles all post-related API calls&#10; * Handles all post-related API calls&#10; */&#10;export class PostService {&#10;   * Create new post&#10;   * Create new post&#10;    const formData = new FormData();&#10;    formData.append('content', postData.content);&#10;&#10;    if (postData.visibility) {&#10;      formData.append('visibility', postData.visibility);&#10;    }&#10;    formData.append('content', postData.content);&#10;    if (postData.tags) {&#10;      postData.tags.forEach(tag =&gt; formData.append('tags', tag));&#10;    }&#10;&#10;    if (postData.images) {&#10;      postData.images.forEach(image =&gt; formData.append('images', image));&#10;    }&#10;&#10;    return apiClient.post&lt;Post&gt;(API_ENDPOINTS.POSTS.BASE, formData, {&#10;      headers: {&#10;        'Content-Type': 'multipart/form-data',&#10;      },&#10;    });&#10;      postData.tags.forEach(tag =&gt; formData.append('tags', tag));&#10;    }&#10;&#10;    if (postData.images) {&#10;      postData.images.forEach(image =&gt; formData.append('images', image));&#10;    }&#10;&#10;    return apiClient.post&lt;Post&gt;(API_ENDPOINTS.POSTS.BASE, formData, {&#10;      headers: {&#10;        'Content-Type': 'multipart/form-data',&#10;      },&#10;    });&#10;  }&#10;&#10;  /**&#10;   * Get posts feed&#10;   */&#10;  async getPosts(page = 0, size = 10): Promise&lt;PaginatedResponse&lt;Post&gt;&gt; {&#10;    const url = createApiUrl(API_ENDPOINTS.POSTS.BASE, undefined, { page, size });&#10;    return apiClient.get&lt;PaginatedResponse&lt;Post&gt;&gt;(url);&#10;  }&#10;&#10;  /**&#10;   * Get single post by ID&#10;   */&#10;  async getPost(postId: string): Promise&lt;Post&gt; {&#10;    const url = createApiUrl(API_ENDPOINTS.POSTS.BASE + '/:id', { id: postId });&#10;    return apiClient.get&lt;Post&gt;(url);&#10;  }&#10;&#10;  /**&#10;   * Get posts by user&#10;   */&#10;  async getUserPosts(&#10;    userId: string,&#10;    page = 0,&#10;    size = 10&#10;  ): Promise&lt;PaginatedResponse&lt;Post&gt;&gt; {&#10;    const url = createApiUrl(&#10;      API_ENDPOINTS.POSTS.BY_USER,&#10;      { id: userId },&#10;      { page, size }&#10;    );&#10;    return apiClient.get&lt;PaginatedResponse&lt;Post&gt;&gt;(url);&#10;  }&#10;&#10;  /**&#10;   * Update post&#10;   */&#10;  async updatePost(postId: string, updateData: UpdatePostRequest): Promise&lt;Post&gt; {&#10;    const url = createApiUrl(API_ENDPOINTS.POSTS.BASE + '/:id', { id: postId });&#10;    return apiClient.put&lt;Post&gt;(url, updateData);&#10;  }&#10;&#10;  /**&#10;   * Delete post&#10;   */&#10;  async deletePost(postId: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#10;    const url = createApiUrl(API_ENDPOINTS.POSTS.BASE + '/:id', { id: postId });&#10;    return apiClient.delete&lt;ApiResponse&lt;null&gt;&gt;(url);&#10;  }&#10;&#10;  /**&#10;   * Like post&#10;   */&#10;  async likePost(postId: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#10;    const url = createApiUrl(API_ENDPOINTS.POSTS.LIKE, { id: postId });&#10;    return apiClient.post&lt;ApiResponse&lt;null&gt;&gt;(url);&#10;  }&#10;&#10;  /**&#10;   * Unlike post&#10;   */&#10;  async unlikePost(postId: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#10;    const url = createApiUrl(API_ENDPOINTS.POSTS.LIKE, { id: postId });&#10;    return apiClient.delete&lt;ApiResponse&lt;null&gt;&gt;(url);&#10;  }&#10;&#10;  /**&#10;   * Get post comments&#10;   */&#10;  async getComments(&#10;    postId: string,&#10;    page = 0,&#10;    size = 10&#10;  ): Promise&lt;PaginatedResponse&lt;Comment&gt;&gt; {&#10;    const url = createApiUrl(&#10;      API_ENDPOINTS.POSTS.COMMENTS,&#10;      { id: postId },&#10;      { page, size }&#10;    );&#10;    return apiClient.get&lt;PaginatedResponse&lt;Comment&gt;&gt;(url);&#10;  }&#10;&#10;  /**&#10;   * Create comment&#10;   */&#10;  async createComment(commentData: CreateCommentRequest): Promise&lt;Comment&gt; {&#10;    const url = createApiUrl(API_ENDPOINTS.POSTS.COMMENTS, { id: commentData.postId });&#10;    return apiClient.post&lt;Comment&gt;(url, {&#10;      content: commentData.content,&#10;      parentId: commentData.parentId,&#10;    });&#10;  }&#10;&#10;  /**&#10;   * Update comment&#10;   */&#10;  async updateComment(&#10;    commentId: string,&#10;    updateData: UpdateCommentRequest&#10;  ): Promise&lt;Comment&gt; {&#10;    const url = createApiUrl('/comments/:id', { id: commentId });&#10;    return apiClient.put&lt;Comment&gt;(url, updateData);&#10;  }&#10;&#10;  /**&#10;   * Delete comment&#10;   */&#10;  async deleteComment(commentId: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#10;    const url = createApiUrl('/comments/:id', { id: commentId });&#10;    return apiClient.delete&lt;ApiResponse&lt;null&gt;&gt;(url);&#10;  }&#10;&#10;  /**&#10;   * Like comment&#10;   */&#10;  async likeComment(commentId: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#10;    const url = createApiUrl(API_ENDPOINTS.POSTS.COMMENT_LIKE, { id: commentId });&#10;    return apiClient.post&lt;ApiResponse&lt;null&gt;&gt;(url);&#10;  }&#10;&#10;  /**&#10;   * Unlike comment&#10;   */&#10;  async unlikeComment(commentId: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#10;    const url = createApiUrl(API_ENDPOINTS.POSTS.COMMENT_LIKE, { id: commentId });&#10;    return apiClient.delete&lt;ApiResponse&lt;null&gt;&gt;(url);&#10;  }&#10;&#10;  /**&#10;   * Share post&#10;   */&#10;  async sharePost(postId: string, content?: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#10;    const url = createApiUrl('/posts/:id/share', { id: postId });&#10;    return apiClient.post&lt;ApiResponse&lt;null&gt;&gt;(url, { content });&#10;  }&#10;&#10;  /**&#10;   * Bookmark post&#10;   */&#10;  async bookmarkPost(postId: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#10;    const url = createApiUrl('/posts/:id/bookmark', { id: postId });&#10;    return apiClient.post&lt;ApiResponse&lt;null&gt;&gt;(url);&#10;  }&#10;&#10;  /**&#10;   * Remove bookmark&#10;   */&#10;  async removeBookmark(postId: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#10;    const url = createApiUrl('/posts/:id/bookmark', { id: postId });&#10;    return apiClient.delete&lt;ApiResponse&lt;null&gt;&gt;(url);&#10;  }&#10;}&#10;&#10;// Export singleton instance&#10;export const postService = new PostService();&#10;" />
              <option name="updatedContent" value="import { apiClient } from '@/shared/config/api-client';&#13;&#10;import { API_ENDPOINTS } from '@/shared/constants';&#13;&#10;import { createApiUrl } from '@/shared/utils';&#13;&#10;import {&#13;&#10;  Post,&#13;&#10;  Comment,&#13;&#10;  CreatePostRequest,&#13;&#10;  UpdatePostRequest,&#13;&#10;  CreateCommentRequest,&#13;&#10;  UpdateCommentRequest,&#13;&#10;  PaginatedResponse,&#13;&#10;  ApiResponse,&#13;&#10;  PostVisibility,&#13;&#10;} from '@/shared/types';&#13;&#10;&#13;&#10;/**&#13;&#10; * Post Service - Updated to sync with backend APIs&#13;&#10; */&#13;&#10;export class PostService {&#13;&#10;  /**&#13;&#10;   * Create new post - Updated to match EnhancedPostController&#13;&#10;   */&#13;&#10;  async createPost(postData: CreatePostRequest): Promise&lt;Post&gt; {&#13;&#10;    // Use JSON instead of FormData to match EnhancedPostController&#13;&#10;    return apiClient.post&lt;Post&gt;(API_ENDPOINTS.POSTS.BASE, postData);&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Get personalized feed - Updated to match backend&#13;&#10;   */&#13;&#10;  async getPersonalizedFeed(page = 0, size = 10): Promise&lt;Post[]&gt; {&#13;&#10;    const url = createApiUrl(API_ENDPOINTS.POSTS.FEED, undefined, { page, size });&#13;&#10;    return apiClient.get&lt;Post[]&gt;(url);&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Get posts feed&#13;&#10;   */&#13;&#10;  async getPosts(page = 0, size = 10): Promise&lt;PaginatedResponse&lt;Post&gt;&gt; {&#13;&#10;    const url = createApiUrl(API_ENDPOINTS.POSTS.BASE, undefined, { page, size });&#13;&#10;    return apiClient.get&lt;PaginatedResponse&lt;Post&gt;&gt;(url);&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Get single post by ID&#13;&#10;   */&#13;&#10;  async getPost(postId: string): Promise&lt;Post&gt; {&#13;&#10;    const url = createApiUrl(API_ENDPOINTS.POSTS.BASE + '/:id', { id: postId });&#13;&#10;    return apiClient.get&lt;Post&gt;(url);&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Get posts by user&#13;&#10;   */&#13;&#10;  async getUserPosts(&#13;&#10;    userId: string,&#13;&#10;    page = 0,&#13;&#10;    size = 10&#13;&#10;  ): Promise&lt;PaginatedResponse&lt;Post&gt;&gt; {&#13;&#10;    const url = createApiUrl(&#13;&#10;      API_ENDPOINTS.POSTS.BY_USER,&#13;&#10;      { id: userId },&#13;&#10;      { page, size }&#13;&#10;    );&#13;&#10;    return apiClient.get&lt;PaginatedResponse&lt;Post&gt;&gt;(url);&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Update post&#13;&#10;   */&#13;&#10;  async updatePost(postId: string, updateData: UpdatePostRequest): Promise&lt;Post&gt; {&#13;&#10;    const url = createApiUrl(API_ENDPOINTS.POSTS.BASE + '/:id', { id: postId });&#13;&#10;    return apiClient.put&lt;Post&gt;(url, updateData);&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Delete post&#13;&#10;   */&#13;&#10;  async deletePost(postId: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#13;&#10;    const url = createApiUrl(API_ENDPOINTS.POSTS.BASE + '/:id', { id: postId });&#13;&#10;    return apiClient.delete&lt;ApiResponse&lt;null&gt;&gt;(url);&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Like post&#13;&#10;   */&#13;&#10;  async likePost(postId: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#13;&#10;    const url = createApiUrl(API_ENDPOINTS.POSTS.LIKE, { id: postId });&#13;&#10;    return apiClient.post&lt;ApiResponse&lt;null&gt;&gt;(url);&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Unlike post&#13;&#10;   */&#13;&#10;  async unlikePost(postId: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#13;&#10;    const url = createApiUrl(API_ENDPOINTS.POSTS.LIKE, { id: postId });&#13;&#10;    return apiClient.delete&lt;ApiResponse&lt;null&gt;&gt;(url);&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Get post comments&#13;&#10;   */&#13;&#10;  async getComments(&#13;&#10;    postId: string,&#13;&#10;    page = 0,&#13;&#10;    size = 10&#13;&#10;  ): Promise&lt;PaginatedResponse&lt;Comment&gt;&gt; {&#13;&#10;    const url = createApiUrl(&#13;&#10;      API_ENDPOINTS.POSTS.COMMENTS,&#13;&#10;      { id: postId },&#13;&#10;      { page, size }&#13;&#10;    );&#13;&#10;    return apiClient.get&lt;PaginatedResponse&lt;Comment&gt;&gt;(url);&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Create comment&#13;&#10;   */&#13;&#10;  async createComment(commentData: CreateCommentRequest): Promise&lt;Comment&gt; {&#13;&#10;    const url = createApiUrl(API_ENDPOINTS.POSTS.COMMENTS, { id: commentData.postId });&#13;&#10;    return apiClient.post&lt;Comment&gt;(url, {&#13;&#10;      content: commentData.content,&#13;&#10;      parentId: commentData.parentId,&#13;&#10;    });&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Update comment&#13;&#10;   */&#13;&#10;  async updateComment(&#13;&#10;    commentId: string,&#13;&#10;    updateData: UpdateCommentRequest&#13;&#10;  ): Promise&lt;Comment&gt; {&#13;&#10;    const url = createApiUrl('/comments/:id', { id: commentId });&#13;&#10;    return apiClient.put&lt;Comment&gt;(url, updateData);&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Delete comment&#13;&#10;   */&#13;&#10;  async deleteComment(commentId: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#13;&#10;    const url = createApiUrl('/comments/:id', { id: commentId });&#13;&#10;    return apiClient.delete&lt;ApiResponse&lt;null&gt;&gt;(url);&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Like comment&#13;&#10;   */&#13;&#10;  async likeComment(commentId: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#13;&#10;    const url = createApiUrl(API_ENDPOINTS.POSTS.COMMENT_LIKE, { id: commentId });&#13;&#10;    return apiClient.post&lt;ApiResponse&lt;null&gt;&gt;(url);&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Unlike comment&#13;&#10;   */&#13;&#10;  async unlikeComment(commentId: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#13;&#10;    const url = createApiUrl(API_ENDPOINTS.POSTS.COMMENT_LIKE, { id: commentId });&#13;&#10;    return apiClient.delete&lt;ApiResponse&lt;null&gt;&gt;(url);&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Share post&#13;&#10;   */&#13;&#10;  async sharePost(postId: string, content?: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#13;&#10;    const url = createApiUrl('/posts/:id/share', { id: postId });&#13;&#10;    return apiClient.post&lt;ApiResponse&lt;null&gt;&gt;(url, { content });&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Bookmark post&#13;&#10;   */&#13;&#10;  async bookmarkPost(postId: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#13;&#10;    const url = createApiUrl('/posts/:id/bookmark', { id: postId });&#13;&#10;    return apiClient.post&lt;ApiResponse&lt;null&gt;&gt;(url);&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Remove bookmark&#13;&#10;   */&#13;&#10;  async removeBookmark(postId: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#13;&#10;    const url = createApiUrl('/posts/:id/bookmark', { id: postId });&#13;&#10;    return apiClient.delete&lt;ApiResponse&lt;null&gt;&gt;(url);&#13;&#10;  }&#13;&#10;}&#13;&#10;&#13;&#10;// Export singleton instance&#13;&#10;export const postService = new PostService();" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/docker-compose.yml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/docker-compose.yml" />
              <option name="originalContent" value="services:&#10;  # Service Discovery&#10;  eureka-server:&#10;    build:&#10;      context: ./eureka-server&#10;    container_name: eureka-server&#10;    ports:&#10;      - &quot;${EUREKA_PORT}:8761&quot;&#10;    environment:&#10;      - SPRING_PROFILES_ACTIVE=docker&#10;    networks:&#10;      - ctuconnect-network&#10;    healthcheck:&#10;      test: [&quot;CMD&quot;, &quot;curl&quot;, &quot;-f&quot;, &quot;http://localhost:8761/actuator/health&quot;]&#10;      interval: 30s&#10;      timeout: 10s&#10;      retries: 1&#10;    develop: # Phần mới&#10;      watch:&#10;        - action: rebuild # Hoặc 'sync' nếu bạn muốn bind mount&#10;          path: . # Giám sát toàn bộ thư mục context của Dockerfile&#10;&#10;  # API Gateway&#10;  api-gateway:&#10;    build:&#10;      context: ./api-gateway&#10;    container_name: api-gateway&#10;    ports:&#10;      - &quot;${API_GATEWAY_PORT}:8090&quot;&#10;    depends_on:&#10;      eureka-server:&#10;        condition: service_healthy&#10;    environment:&#10;      - SPRING_PROFILES_ACTIVE=docker&#10;      - EUREKA_CLIENT_SERVICE_URL_DEFAULTZONE=http://eureka-server:8761/eureka&#10;    networks:&#10;      - ctuconnect-network&#10;    healthcheck:&#10;      test: [ &quot;CMD&quot;, &quot;curl&quot;, &quot;-f&quot;, &quot;http://localhost:8090/actuator/health&quot; ]&#10;      interval: 30s # Có thể tăng lên 45s hoặc 60s&#10;      timeout: 20s  # Tăng lên 20s (lớn hơn 13.617s)&#10;      retries: 5    # Tăng số lần thử lại để linh hoạt hơn&#10;    develop: # Phần mới&#10;      watch:&#10;        - action: rebuild # Hoặc 'sync' nếu bạn muốn bind mount&#10;          path: . # Giám sát toàn bộ thư mục context của Dockerfile&#10;&#10;  # Authentication Service&#10;  auth-service:&#10;    build:&#10;      context: ./auth-service&#10;    container_name: auth-service&#10;    ports:&#10;      - &quot;${AUTH_SERVICE_PORT}:8080&quot;&#10;    depends_on:&#10;      auth_db:&#10;        condition: service_healthy&#10;      redis:&#10;        condition: service_healthy&#10;      eureka-server:&#10;        condition: service_healthy&#10;      kafka:&#10;        condition: service_healthy&#10;    environment:&#10;      - SPRING_PROFILES_ACTIVE=docker&#10;      - SPRING_DATASOURCE_URL=jdbc:postgresql://auth_db:5432/auth_db&#10;      - SPRING_DATASOURCE_USERNAME=${POSTGRES_USER}&#10;      - SPRING_DATASOURCE_PASSWORD=${POSTGRES_PASSWORD}&#10;      - SPRING_DATA_REDIS_HOST=redis&#10;      - SPRING_DATA_REDIS_PORT=${REDIS_PORT}&#10;      - EUREKA_CLIENT_SERVICEURL_DEFAULTZONE=http://eureka-server:8761/eureka/&#10;      - SPRING_KAFKA_BOOTSTRAP_SERVERS=kafka:9092&#10;      - MAIL_HOST=${MAIL_HOST}&#10;      - MAIL_PORT=${MAIL_PORT}&#10;      - MAIL_USERNAME=${MAIL_USERNAME}&#10;      - MAIL_PASSWORD=${MAIL_PASSWORD}&#10;    restart: on-failure&#10;    networks:&#10;      - ctuconnect-network&#10;    healthcheck:&#10;      test: [ &quot;CMD&quot;, &quot;curl&quot;, &quot;-f&quot;, &quot;http://localhost:8080/actuator/health&quot; ]&#10;      interval: 30s&#10;      timeout: 10s&#10;      retries: 3&#10;      start_period: 60s&#10;    develop: # Phần mới&#10;      watch:&#10;        - action: rebuild # Hoặc 'sync' nếu bạn muốn bind mount&#10;          path: . # Giám sát toàn bộ thư mục context của Dockerfile&#10;&#10;  # User Service&#10;&#10;  user-service:&#10;      build:&#10;        context: ./user-service&#10;      container_name: user-service&#10;      ports:&#10;        - &quot;${USER_SERVICE_PORT}:8081&quot;&#10;      depends_on:&#10;        neo4j:&#10;            condition: service_healthy&#10;        auth_db:&#10;            condition: service_healthy&#10;        redis:&#10;            condition: service_healthy&#10;        eureka-server:&#10;            condition: service_healthy&#10;        kafka:&#10;            condition: service_healthy&#10;      environment:&#10;        - SPRING_PROFILES_ACTIVE=docker&#10;        - SPRING_DATA_NEO4J_URI=bolt://neo4j:7687&#10;        - SPRING_DATA_NEO4J_USERNAME=neo4j&#10;        - SPRING_DATA_NEO4J_PASSWORD=password&#10;        - SPRING_DATA_REDIS_HOST=redis&#10;        - SPRING_DATA_REDIS_PORT=6379&#10;        - EUREKA_CLIENT_SERVICEURL_DEFAULTZONE=http://eureka-server:8761/eureka/&#10;        - SPRING_KAFKA_BOOTSTRAP_SERVERS=kafka:9092&#10;      networks:&#10;        - ctuconnect-network&#10;      healthcheck:&#10;        test: [ &quot;CMD&quot;, &quot;curl&quot;, &quot;-f&quot;, &quot;http://localhost:8081/actuator/health&quot; ]&#10;        interval: 30s&#10;        timeout: 10s&#10;        retries: 3&#10;        start_period: 60s&#10;      develop: # Phần mới&#10;        watch:&#10;            - action: rebuild # Hoặc 'sync' nếu bạn muốn bind mount&#10;              path: . # Giám sát toàn bộ thư mục context của Dockerfile&#10;&#10;&#10;  # Media Service&#10;  media-service:&#10;    build:&#10;      context: ./media-service&#10;    container_name: media-service&#10;    ports:&#10;      - &quot;${MEDIA_SERVICE_PORT}:8084&quot;&#10;    depends_on:&#10;      media_db:&#10;        condition: service_healthy&#10;      kafka:&#10;        condition: service_healthy&#10;      eureka-server:&#10;        condition: service_healthy&#10;    environment:&#10;      - SPRING_PROFILES_ACTIVE=docker&#10;      - SPRING_DATASOURCE_URL=jdbc:postgresql://media_db:5432/media_db&#10;      - SPRING_DATASOURCE_USERNAME=${POSTGRES_USER}&#10;      - SPRING_DATASOURCE_PASSWORD=${POSTGRES_PASSWORD}&#10;      - EUREKA_CLIENT_SERVICEURL_DEFAULTZONE=http://eureka-server:8761/eureka/&#10;      - SPRING_KAFKA_BOOTSTRAP_SERVERS=kafka:9092&#10;      - CLOUDINARY_CLOUD_NAME=${CLOUDINARY_CLOUD_NAME}&#10;      - CLOUDINARY_API_KEY=${CLOUDINARY_API_KEY}&#10;      - CLOUDINARY_API_SECRET=${CLOUDINARY_API_SECRET}&#10;    networks:&#10;      - ctuconnect-network&#10;    healthcheck:&#10;      test: [ &quot;CMD&quot;, &quot;curl&quot;, &quot;-f&quot;, &quot;http://localhost:8084/actuator/health&quot; ]&#10;      interval: 30s&#10;      timeout: 10s&#10;      retries: 3&#10;      start_period: 60s&#10;    develop:&#10;      watch:&#10;        - action: rebuild&#10;          path: .&#10;&#10;  # Post Service&#10;  post-service:&#10;    build:&#10;      context: ./post-service&#10;    container_name: post-service&#10;    ports:&#10;      - &quot;8085:8085&quot;&#10;    depends_on:&#10;      post_db:&#10;        condition: service_healthy&#10;      redis:&#10;        condition: service_healthy&#10;      kafka:&#10;        condition: service_healthy&#10;      eureka-server:&#10;        condition: service_healthy&#10;#      media-service:&#10;#        condition: service_healthy&#10;    environment:&#10;      - SPRING_PROFILES_ACTIVE=docker&#10;      - SPRING_DATA_MONGODB_HOST=post_db&#10;      - SPRING_DATA_MONGODB_PORT=27017&#10;      - SPRING_DATA_MONGODB_DATABASE=post_db&#10;      - SPRING_DATA_REDIS_HOST=redis&#10;      - SPRING_DATA_REDIS_PORT=6379&#10;      - SPRING_KAFKA_BOOTSTRAP_SERVERS=kafka:9092&#10;      - EUREKA_CLIENT_SERVICEURL_DEFAULTZONE=http://eureka-server:8761/eureka/&#10;      - MEDIA_SERVICE_URL=http://media-service:8084&#10;    networks:&#10;      - ctuconnect-network&#10;    healthcheck:&#10;      test: [ &quot;CMD&quot;, &quot;curl&quot;, &quot;-f&quot;, &quot;http://localhost:8085/actuator/health&quot; ]&#10;      interval: 30s&#10;      timeout: 10s&#10;      retries: 3&#10;      start_period: 60s&#10;    develop:&#10;      watch:&#10;        - action: rebuild&#10;          path: .&#10;&#10;  # Neo4j Graph Database for User Service&#10;  neo4j:&#10;    image: neo4j:5.13.0&#10;    container_name: neo4j-graph-db&#10;    hostname: neo4j&#10;    ports:&#10;      - &quot;7474:7474&quot;&#10;      - &quot;7687:7687&quot;&#10;    volumes:&#10;      - neo4j-data:/data&#10;      - ./database/neo4j/conf/neo4j.conf:/conf/neo4j.conf&#10;      - ./database/neo4j/logs:/logs&#10;      - ./database/neo4j/plugins:/plugins&#10;      - ./database/neo4j/import:/import&#10;      - ./database/neo4j/init.sh:/docker-entrypoint-initdb.d/init.sh&#10;    environment:&#10;      - NEO4J_AUTH=neo4j/password&#10;      - NEO4J_ACCEPT_LICENSE_AGREEMENT=yes&#10;      - NEO4J_dbms_security_procedures_unrestricted=apoc.*&#10;      - NEO4J_dbms_security_procedures_allowlist=apoc.*&#10;      - NEO4J_server_config_strict__validation_enabled=false&#10;    networks:&#10;      - ctuconnect-network&#10;    healthcheck:&#10;      test: [ &quot;CMD&quot;, &quot;wget&quot;, &quot;--no-verbose&quot;, &quot;--tries=1&quot;, &quot;--spider&quot;, &quot;http://localhost:7474&quot; ]&#10;      interval: 30s&#10;      timeout: 10s&#10;      retries: 5&#10;      start_period: 40s&#10;&#10;&#10;  # Kafka for Event Streaming (No ZooKeeper needed)&#10;  kafka:&#10;    image: bitnami/kafka:3.4&#10;    container_name: kafka&#10;    ports:&#10;      - &quot;9092:9092&quot;&#10;      - &quot;9093:9093&quot;&#10;    environment:&#10;      # KRaft settings&#10;      - KAFKA_CFG_NODE_ID=0&#10;      - KAFKA_CFG_PROCESS_ROLES=controller,broker&#10;      - KAFKA_CFG_CONTROLLER_QUORUM_VOTERS=0@kafka:9093&#10;      - KAFKA_CFG_LISTENERS=PLAINTEXT://:9092,CONTROLLER://:9093&#10;      - KAFKA_CFG_ADVERTISED_LISTENERS=PLAINTEXT://kafka:9092&#10;      - KAFKA_CFG_CONTROLLER_LISTENER_NAMES=CONTROLLER&#10;      - KAFKA_CFG_LISTENER_SECURITY_PROTOCOL_MAP=CONTROLLER:PLAINTEXT,PLAINTEXT:PLAINTEXT&#10;      # Topic settings&#10;      - KAFKA_CFG_AUTO_CREATE_TOPICS_ENABLE=true&#10;      - KAFKA_CFG_NUM_PARTITIONS=3&#10;      - KAFKA_CFG_DEFAULT_REPLICATION_FACTOR=1&#10;      # Performance settings&#10;      - KAFKA_CFG_LOG_RETENTION_HOURS=168&#10;      - KAFKA_CFG_LOG_SEGMENT_BYTES=1073741824&#10;      - KAFKA_CFG_LOG_RETENTION_CHECK_INTERVAL_MS=300000&#10;    networks:&#10;      - ctuconnect-network&#10;    volumes:&#10;      - kafka-data:/bitnami/kafka&#10;    healthcheck:&#10;      test: [&quot;CMD-SHELL&quot;, &quot;kafka-topics.sh --bootstrap-server localhost:9092 --list || exit 1&quot;]&#10;      interval: 30s&#10;      timeout: 10s&#10;      retries: 5&#10;      start_period: 60s&#10;    develop: # Phần mới&#10;      watch:&#10;        - action: rebuild # Hoặc 'sync' nếu bạn muốn bind mount&#10;          path: . # Giám sát toàn bộ thư mục context của Dockerfile&#10;&#10;  # Auth Database&#10;  auth_db:&#10;    image: postgres:15-alpine&#10;    container_name: postgres_auth_db&#10;    volumes:&#10;      - auth_db_data:/var/lib/postgresql/data&#10;      - ./database/auth_db:/docker-entrypoint-initdb.d&#10;    ports:&#10;      - &quot;5433:${AUTH_DB_PORT}&quot;&#10;    environment:&#10;      - POSTGRES_USER=${POSTGRES_USER}&#10;      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}&#10;      - POSTGRES_DB=auth_db&#10;    networks:&#10;      - ctuconnect-network&#10;    healthcheck:&#10;      test: [&quot;CMD-SHELL&quot;, &quot;pg_isready -U ${POSTGRES_USER} -d auth_db&quot;]&#10;      interval: 10s&#10;      timeout: 5s&#10;      retries: 1&#10;    develop: # Phần mới&#10;      watch:&#10;        - action: rebuild # Hoặc 'sync' nếu bạn muốn bind mount&#10;          path: . # Giám sát toàn bộ thư mục context của Dockerfile&#10;&#10;  media_db:&#10;    image: postgres:15-alpine&#10;    container_name: media_db&#10;    environment:&#10;        - POSTGRES_USER=${POSTGRES_USER}&#10;        - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}&#10;        - POSTGRES_DB=media_db&#10;    ports:&#10;      - &quot;5434:5432&quot;&#10;    volumes:&#10;      - media_data:/var/lib/postgresql/data&#10;    networks:&#10;      - ctuconnect-network&#10;    healthcheck:&#10;        test: [&quot;CMD-SHELL&quot;, &quot;pg_isready -U ${POSTGRES_USER} -d media_db&quot;]&#10;        interval: 10s&#10;        timeout: 5s&#10;        retries: 1&#10;    develop: # Phần mới&#10;      watch:&#10;        - action: rebuild # Hoặc 'sync' nếu bạn muốn bind mount&#10;          path: . # Giám sát toàn bộ thư mục context của Dockerfile&#10;&#10;  # Redis Cache&#10;  redis:&#10;    image: redis:7-alpine&#10;    container_name: redis&#10;    ports:&#10;      - &quot;${REDIS_PORT}:6379&quot;&#10;    volumes:&#10;      - redis-data:/data&#10;    networks:&#10;      - ctuconnect-network&#10;    command: redis-server --save 60 1 --loglevel warning&#10;    healthcheck:&#10;      test: [&quot;CMD&quot;, &quot;redis-cli&quot;, &quot;ping&quot;]&#10;      interval: 10s&#10;      timeout: 5s&#10;      retries: 1&#10;    develop: # Phần mới&#10;      watch:&#10;        - action: rebuild # Hoặc 'sync' nếu bạn muốn bind mount&#10;          path: . # Giám sát toàn bộ thư mục context của Dockerfile&#10;&#10;  # MongoDB for Post Service&#10;  post_db:&#10;    image: mongo:7.0&#10;    container_name: mongodb&#10;    ports:&#10;      - &quot;27018:27017&quot;&#10;    environment:&#10;      - MONGO_INITDB_DATABASE=post_db&#10;    volumes:&#10;      - post-data:/data/db&#10;    networks:&#10;      - ctuconnect-network&#10;    healthcheck:&#10;      test: [&quot;CMD&quot;, &quot;mongosh&quot;, &quot;--eval&quot;, &quot;db.adminCommand('ping')&quot;]&#10;      interval: 10s&#10;      timeout: 5s&#10;      retries: 3&#10;    develop:&#10;      watch:&#10;        - action: rebuild&#10;          path: .&#10;&#10;  # Recommendation Service Redis&#10;  recommendation-redis:&#10;    image: redis:7-alpine&#10;    container_name: recommendation-redis&#10;    ports:&#10;      - &quot;6379:6379&quot;&#10;    command: redis-server --appendonly yes&#10;    volumes:&#10;      - recommendation_redis_data:/data&#10;    networks:&#10;      - ctuconnect-network&#10;    healthcheck:&#10;      test: [&quot;CMD&quot;, &quot;redis-cli&quot;, &quot;ping&quot;]&#10;      interval: 10s&#10;      timeout: 5s&#10;      retries: 3&#10;&#10;  # MLflow for ML experiment tracking&#10;  mlflow-server:&#10;    image: python:3.11-slim&#10;    container_name: mlflow-server&#10;    ports:&#10;      - &quot;5000:5000&quot;&#10;    environment:&#10;      - MLFLOW_BACKEND_STORE_URI=postgresql://postgres:${POSTGRES_PASSWORD}@postgres:5432/ctuconnect_db&#10;    command: &gt;&#10;      bash -c &quot;&#10;        pip install mlflow psycopg2-binary &amp;&amp;&#10;        mlflow server &#10;          --backend-store-uri postgresql://postgres:${POSTGRES_PASSWORD}@postgres:5432/ctuconnect_db&#10;          --default-artifact-root ./mlruns&#10;          --host 0.0.0.0&#10;          --port 5000&#10;      &quot;&#10;    depends_on:&#10;      postgres:&#10;        condition: service_healthy&#10;    networks:&#10;      - ctuconnect-network&#10;    volumes:&#10;      - mlflow_data:/mlruns&#10;&#10;  # Recommendation Service&#10;  recommendation-service:&#10;    build:&#10;      context: ./recommendation-service&#10;    container_name: recommendation-service&#10;    ports:&#10;      - &quot;8080:8000&quot;&#10;    environment:&#10;      - SPRING_PROFILES_ACTIVE=docker&#10;      - DATABASE_URL=postgresql+asyncpg://postgres:${POSTGRES_PASSWORD}@postgres:5432/ctuconnect_db&#10;      - REDIS_URL=redis://recommendation-redis:6379&#10;      - KAFKA_BOOTSTRAP_SERVERS=kafka:9092&#10;      - SECRET_KEY=${RECOMMENDATION_SECRET_KEY:-recommendation-secret-key}&#10;      - EUREKA_CLIENT_SERVICE_URL_DEFAULTZONE=http://eureka-server:8761/eureka&#10;      - MLFLOW_TRACKING_URI=http://mlflow-server:5000&#10;      - DEBUG=false&#10;      - API_GATEWAY_URL=http://api-gateway:8090&#10;    depends_on:&#10;      postgres:&#10;        condition: service_healthy&#10;      recommendation-redis:&#10;        condition: service_healthy&#10;      eureka-server:&#10;        condition: service_healthy&#10;      kafka:&#10;        condition: service_started&#10;    networks:&#10;      - ctuconnect-network&#10;    volumes:&#10;      - ./recommendation-service/models:/app/models&#10;    healthcheck:&#10;      test: [&quot;CMD&quot;, &quot;curl&quot;, &quot;-f&quot;, &quot;http://localhost:8000/health&quot;]&#10;      interval: 30s&#10;      timeout: 10s&#10;      retries: 3&#10;    restart: unless-stopped&#10;&#10;volumes:&#10;  auth_db_data:&#10;  redis-data:&#10;  neo4j-data:&#10;  kafka-data:&#10;  media_data:&#10;  post-data:&#10;  recommendation_redis_data:&#10;  mlflow_data:&#10;&#10;networks:&#10;  ctuconnect-network:&#10;    driver: bridge&#10;" />
              <option name="updatedContent" value="services:&#10;  # Service Discovery&#10;  eureka-server:&#10;    build:&#10;      context: ./eureka-server&#10;    container_name: eureka-server&#10;    ports:&#10;      - &quot;${EUREKA_PORT}:8761&quot;&#10;    environment:&#10;      - SPRING_PROFILES_ACTIVE=docker&#10;    networks:&#10;      - ctuconnect-network&#10;    healthcheck:&#10;      test: [&quot;CMD&quot;, &quot;curl&quot;, &quot;-f&quot;, &quot;http://localhost:8761/actuator/health&quot;]&#10;      interval: 30s&#10;      timeout: 10s&#10;      retries: 1&#10;    develop: # Phần mới&#10;      watch:&#10;        - action: rebuild # Hoặc 'sync' nếu bạn muốn bind mount&#10;          path: . # Giám sát toàn bộ thư mục context của Dockerfile&#10;&#10;  # API Gateway&#10;  api-gateway:&#10;    build:&#10;      context: ./api-gateway&#10;    container_name: api-gateway&#10;    ports:&#10;      - &quot;${API_GATEWAY_PORT}:8090&quot;&#10;    depends_on:&#10;      eureka-server:&#10;        condition: service_healthy&#10;    environment:&#10;      - SPRING_PROFILES_ACTIVE=docker&#10;      - EUREKA_CLIENT_SERVICE_URL_DEFAULTZONE=http://eureka-server:8761/eureka&#10;    networks:&#10;      - ctuconnect-network&#10;    healthcheck:&#10;      test: [ &quot;CMD&quot;, &quot;curl&quot;, &quot;-f&quot;, &quot;http://localhost:8090/actuator/health&quot; ]&#10;      interval: 30s # Có thể tăng lên 45s hoặc 60s&#10;      timeout: 20s  # Tăng lên 20s (lớn hơn 13.617s)&#10;      retries: 5    # Tăng số lần thử lại để linh hoạt hơn&#10;    develop: # Phần mới&#10;      watch:&#10;        - action: rebuild # Hoặc 'sync' nếu bạn muốn bind mount&#10;          path: . # Giám sát toàn bộ thư mục context của Dockerfile&#10;&#10;  # Authentication Service&#10;  auth-service:&#10;    build:&#10;      context: ./auth-service&#10;    container_name: auth-service&#10;    ports:&#10;      - &quot;${AUTH_SERVICE_PORT}:8080&quot;&#10;    depends_on:&#10;      auth_db:&#10;        condition: service_healthy&#10;      redis:&#10;        condition: service_healthy&#10;      eureka-server:&#10;        condition: service_healthy&#10;      kafka:&#10;        condition: service_healthy&#10;    environment:&#10;      - SPRING_PROFILES_ACTIVE=docker&#10;      - SPRING_DATASOURCE_URL=jdbc:postgresql://auth_db:5432/auth_db&#10;      - SPRING_DATASOURCE_USERNAME=${POSTGRES_USER}&#10;      - SPRING_DATASOURCE_PASSWORD=${POSTGRES_PASSWORD}&#10;      - SPRING_DATA_REDIS_HOST=redis&#10;      - SPRING_DATA_REDIS_PORT=${REDIS_PORT}&#10;      - EUREKA_CLIENT_SERVICEURL_DEFAULTZONE=http://eureka-server:8761/eureka/&#10;      - SPRING_KAFKA_BOOTSTRAP_SERVERS=kafka:9092&#10;      - MAIL_HOST=${MAIL_HOST}&#10;      - MAIL_PORT=${MAIL_PORT}&#10;      - MAIL_USERNAME=${MAIL_USERNAME}&#10;      - MAIL_PASSWORD=${MAIL_PASSWORD}&#10;    restart: on-failure&#10;    networks:&#10;      - ctuconnect-network&#10;    healthcheck:&#10;      test: [ &quot;CMD&quot;, &quot;curl&quot;, &quot;-f&quot;, &quot;http://localhost:8080/actuator/health&quot; ]&#10;      interval: 30s&#10;      timeout: 10s&#10;      retries: 3&#10;      start_period: 60s&#10;    develop: # Phần mới&#10;      watch:&#10;        - action: rebuild # Hoặc 'sync' nếu bạn muốn bind mount&#10;          path: . # Giám sát toàn bộ thư mục context của Dockerfile&#10;&#10;  # User Service&#10;&#10;  user-service:&#10;      build:&#10;        context: ./user-service&#10;      container_name: user-service&#10;      ports:&#10;        - &quot;${USER_SERVICE_PORT}:8081&quot;&#10;      depends_on:&#10;        neo4j:&#10;            condition: service_healthy&#10;        auth_db:&#10;            condition: service_healthy&#10;        redis:&#10;            condition: service_healthy&#10;        eureka-server:&#10;            condition: service_healthy&#10;        kafka:&#10;            condition: service_healthy&#10;      environment:&#10;        - SPRING_PROFILES_ACTIVE=docker&#10;        - SPRING_DATA_NEO4J_URI=bolt://neo4j:7687&#10;        - SPRING_DATA_NEO4J_USERNAME=neo4j&#10;        - SPRING_DATA_NEO4J_PASSWORD=password&#10;        - SPRING_DATA_REDIS_HOST=redis&#10;        - SPRING_DATA_REDIS_PORT=6379&#10;        - EUREKA_CLIENT_SERVICEURL_DEFAULTZONE=http://eureka-server:8761/eureka/&#10;        - SPRING_KAFKA_BOOTSTRAP_SERVERS=kafka:9092&#10;      networks:&#10;        - ctuconnect-network&#10;      healthcheck:&#10;        test: [ &quot;CMD&quot;, &quot;curl&quot;, &quot;-f&quot;, &quot;http://localhost:8081/actuator/health&quot; ]&#10;        interval: 30s&#10;        timeout: 10s&#10;        retries: 3&#10;        start_period: 60s&#10;      develop: # Phần mới&#10;        watch:&#10;            - action: rebuild # Hoặc 'sync' nếu bạn muốn bind mount&#10;              path: . # Giám sát toàn bộ thư mục context của Dockerfile&#10;&#10;&#10;  # Media Service&#10;  media-service:&#10;    build:&#10;      context: ./media-service&#10;    container_name: media-service&#10;    ports:&#10;      - &quot;${MEDIA_SERVICE_PORT}:8084&quot;&#10;    depends_on:&#10;      media_db:&#10;        condition: service_healthy&#10;      kafka:&#10;        condition: service_healthy&#10;      eureka-server:&#10;        condition: service_healthy&#10;    environment:&#10;      - SPRING_PROFILES_ACTIVE=docker&#10;      - SPRING_DATASOURCE_URL=jdbc:postgresql://media_db:5432/media_db&#10;      - SPRING_DATASOURCE_USERNAME=${POSTGRES_USER}&#10;      - SPRING_DATASOURCE_PASSWORD=${POSTGRES_PASSWORD}&#10;      - EUREKA_CLIENT_SERVICEURL_DEFAULTZONE=http://eureka-server:8761/eureka/&#10;      - SPRING_KAFKA_BOOTSTRAP_SERVERS=kafka:9092&#10;      - CLOUDINARY_CLOUD_NAME=${CLOUDINARY_CLOUD_NAME}&#10;      - CLOUDINARY_API_KEY=${CLOUDINARY_API_KEY}&#10;      - CLOUDINARY_API_SECRET=${CLOUDINARY_API_SECRET}&#10;    networks:&#10;      - ctuconnect-network&#10;    healthcheck:&#10;      test: [ &quot;CMD&quot;, &quot;curl&quot;, &quot;-f&quot;, &quot;http://localhost:8084/actuator/health&quot; ]&#10;      interval: 30s&#10;      timeout: 10s&#10;      retries: 3&#10;      start_period: 60s&#10;    develop:&#10;      watch:&#10;        - action: rebuild&#10;          path: .&#10;&#10;  # Post Service&#10;  post-service:&#10;    build:&#10;      context: ./post-service&#10;    container_name: post-service&#10;    ports:&#10;      - &quot;8085:8085&quot;&#10;    depends_on:&#10;      post_db:&#10;        condition: service_healthy&#10;      redis:&#10;        condition: service_healthy&#10;      kafka:&#10;        condition: service_healthy&#10;      eureka-server:&#10;        condition: service_healthy&#10;#      media-service:&#10;#        condition: service_healthy&#10;    environment:&#10;      - SPRING_PROFILES_ACTIVE=docker&#10;      - SPRING_DATA_MONGODB_HOST=post_db&#10;      - SPRING_DATA_MONGODB_PORT=27017&#10;      - SPRING_DATA_MONGODB_DATABASE=post_db&#10;      - SPRING_DATA_REDIS_HOST=redis&#10;      - SPRING_DATA_REDIS_PORT=6379&#10;      - SPRING_KAFKA_BOOTSTRAP_SERVERS=kafka:9092&#10;      - EUREKA_CLIENT_SERVICEURL_DEFAULTZONE=http://eureka-server:8761/eureka/&#10;      - MEDIA_SERVICE_URL=http://media-service:8084&#10;    networks:&#10;      - ctuconnect-network&#10;    healthcheck:&#10;      test: [ &quot;CMD&quot;, &quot;curl&quot;, &quot;-f&quot;, &quot;http://localhost:8085/actuator/health&quot; ]&#10;      interval: 30s&#10;      timeout: 10s&#10;      retries: 3&#10;      start_period: 60s&#10;    develop:&#10;      watch:&#10;        - action: rebuild&#10;          path: .&#10;&#10;  # Neo4j Graph Database for User Service&#10;  neo4j:&#10;    image: neo4j:5.13.0&#10;    container_name: neo4j-graph-db&#10;    hostname: neo4j&#10;    ports:&#10;      - &quot;7474:7474&quot;&#10;      - &quot;7687:7687&quot;&#10;    volumes:&#10;      - neo4j-data:/data&#10;      - ./database/neo4j/conf/neo4j.conf:/conf/neo4j.conf&#10;      - ./database/neo4j/logs:/logs&#10;      - ./database/neo4j/plugins:/plugins&#10;      - ./database/neo4j/import:/import&#10;      - ./database/neo4j/init.sh:/docker-entrypoint-initdb.d/init.sh&#10;    environment:&#10;      - NEO4J_AUTH=neo4j/password&#10;      - NEO4J_ACCEPT_LICENSE_AGREEMENT=yes&#10;      - NEO4J_dbms_security_procedures_unrestricted=apoc.*&#10;      - NEO4J_dbms_security_procedures_allowlist=apoc.*&#10;      - NEO4J_server_config_strict__validation_enabled=false&#10;    networks:&#10;      - ctuconnect-network&#10;    healthcheck:&#10;      test: [ &quot;CMD&quot;, &quot;wget&quot;, &quot;--no-verbose&quot;, &quot;--tries=1&quot;, &quot;--spider&quot;, &quot;http://localhost:7474&quot; ]&#10;      interval: 30s&#10;      timeout: 10s&#10;      retries: 5&#10;      start_period: 40s&#10;&#10;&#10;  # Kafka for Event Streaming (No ZooKeeper needed)&#10;  kafka:&#10;    image: bitnami/kafka:3.4&#10;    container_name: kafka&#10;    ports:&#10;      - &quot;9092:9092&quot;&#10;      - &quot;9093:9093&quot;&#10;    environment:&#10;      # KRaft settings&#10;      - KAFKA_CFG_NODE_ID=0&#10;      - KAFKA_CFG_PROCESS_ROLES=controller,broker&#10;      - KAFKA_CFG_CONTROLLER_QUORUM_VOTERS=0@kafka:9093&#10;      - KAFKA_CFG_LISTENERS=PLAINTEXT://:9092,CONTROLLER://:9093&#10;      - KAFKA_CFG_ADVERTISED_LISTENERS=PLAINTEXT://kafka:9092&#10;      - KAFKA_CFG_CONTROLLER_LISTENER_NAMES=CONTROLLER&#10;      - KAFKA_CFG_LISTENER_SECURITY_PROTOCOL_MAP=CONTROLLER:PLAINTEXT,PLAINTEXT:PLAINTEXT&#10;      # Topic settings&#10;      - KAFKA_CFG_AUTO_CREATE_TOPICS_ENABLE=true&#10;      - KAFKA_CFG_NUM_PARTITIONS=3&#10;      - KAFKA_CFG_DEFAULT_REPLICATION_FACTOR=1&#10;      # Performance settings&#10;      - KAFKA_CFG_LOG_RETENTION_HOURS=168&#10;      - KAFKA_CFG_LOG_SEGMENT_BYTES=1073741824&#10;      - KAFKA_CFG_LOG_RETENTION_CHECK_INTERVAL_MS=300000&#10;    networks:&#10;      - ctuconnect-network&#10;    volumes:&#10;      - kafka-data:/bitnami/kafka&#10;    healthcheck:&#10;      test: [&quot;CMD-SHELL&quot;, &quot;kafka-topics.sh --bootstrap-server localhost:9092 --list || exit 1&quot;]&#10;      interval: 30s&#10;      timeout: 10s&#10;      retries: 5&#10;      start_period: 60s&#10;    develop: # Phần mới&#10;      watch:&#10;        - action: rebuild # Hoặc 'sync' nếu bạn muốn bind mount&#10;          path: . # Giám sát toàn bộ thư mục context của Dockerfile&#10;&#10;  # Auth Database&#10;  auth_db:&#10;    image: postgres:15-alpine&#10;    container_name: postgres_auth_db&#10;    volumes:&#10;      - auth_db_data:/var/lib/postgresql/data&#10;      - ./database/auth_db:/docker-entrypoint-initdb.d&#10;    ports:&#10;      - &quot;5433:${AUTH_DB_PORT}&quot;&#10;    environment:&#10;      - POSTGRES_USER=${POSTGRES_USER}&#10;      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}&#10;      - POSTGRES_DB=auth_db&#10;    networks:&#10;      - ctuconnect-network&#10;    healthcheck:&#10;      test: [&quot;CMD-SHELL&quot;, &quot;pg_isready -U ${POSTGRES_USER} -d auth_db&quot;]&#10;      interval: 10s&#10;      timeout: 5s&#10;      retries: 1&#10;    develop: # Phần mới&#10;      watch:&#10;        - action: rebuild # Hoặc 'sync' nếu bạn muốn bind mount&#10;          path: . # Giám sát toàn bộ thư mục context của Dockerfile&#10;&#10;  media_db:&#10;    image: postgres:15-alpine&#10;    container_name: media_db&#10;    environment:&#10;        - POSTGRES_USER=${POSTGRES_USER}&#10;        - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}&#10;        - POSTGRES_DB=media_db&#10;    ports:&#10;      - &quot;5434:5432&quot;&#10;    volumes:&#10;      - media_data:/var/lib/postgresql/data&#10;    networks:&#10;      - ctuconnect-network&#10;    healthcheck:&#10;        test: [&quot;CMD-SHELL&quot;, &quot;pg_isready -U ${POSTGRES_USER} -d media_db&quot;]&#10;        interval: 10s&#10;        timeout: 5s&#10;        retries: 1&#10;    develop: # Phần mới&#10;      watch:&#10;        - action: rebuild # Hoặc 'sync' nếu bạn muốn bind mount&#10;          path: . # Giám sát toàn bộ thư mục context của Dockerfile&#10;&#10;  # Redis Cache&#10;  redis:&#10;    image: redis:7-alpine&#10;    container_name: redis&#10;    ports:&#10;      - &quot;${REDIS_PORT}:6379&quot;&#10;    volumes:&#10;      - redis-data:/data&#10;    networks:&#10;      - ctuconnect-network&#10;    command: redis-server --save 60 1 --loglevel warning&#10;    healthcheck:&#10;      test: [&quot;CMD&quot;, &quot;redis-cli&quot;, &quot;ping&quot;]&#10;      interval: 10s&#10;      timeout: 5s&#10;      retries: 1&#10;    develop: # Phần mới&#10;      watch:&#10;        - action: rebuild # Hoặc 'sync' nếu bạn muốn bind mount&#10;          path: . # Giám sát toàn bộ thư mục context của Dockerfile&#10;&#10;  # MongoDB for Post Service&#10;  post_db:&#10;    image: mongo:7.0&#10;    container_name: mongodb&#10;    ports:&#10;      - &quot;27018:27017&quot;&#10;    environment:&#10;      - MONGO_INITDB_DATABASE=post_db&#10;    volumes:&#10;      - post-data:/data/db&#10;    networks:&#10;      - ctuconnect-network&#10;    healthcheck:&#10;      test: [&quot;CMD&quot;, &quot;mongosh&quot;, &quot;--eval&quot;, &quot;db.adminCommand('ping')&quot;]&#10;      interval: 10s&#10;      timeout: 5s&#10;      retries: 3&#10;    develop:&#10;      watch:&#10;        - action: rebuild&#10;          path: .&#10;&#10;  # Recommendation Service Redis&#10;  recommendation-redis:&#10;    image: redis:7-alpine&#10;    container_name: recommendation-redis&#10;    ports:&#10;      - &quot;6379:6379&quot;&#10;    command: redis-server --appendonly yes&#10;    volumes:&#10;      - recommendation_redis_data:/data&#10;    networks:&#10;      - ctuconnect-network&#10;    healthcheck:&#10;      test: [&quot;CMD&quot;, &quot;redis-cli&quot;, &quot;ping&quot;]&#10;      interval: 10s&#10;      timeout: 5s&#10;      retries: 3&#10;&#10;  # MLflow for ML experiment tracking&#10;  mlflow-server:&#10;    image: python:3.11-slim&#10;    container_name: mlflow-server&#10;    ports:&#10;      - &quot;5000:5000&quot;&#10;    environment:&#10;      - MLFLOW_BACKEND_STORE_URI=postgresql://postgres:${POSTGRES_PASSWORD}@auth_db:5432/auth_db&#10;    command: &gt;&#10;      bash -c &quot;&#10;        pip install mlflow psycopg2-binary &amp;&amp;&#10;        mlflow server &#10;          --backend-store-uri postgresql://postgres:${POSTGRES_PASSWORD}@auth_db:5432/auth_db&#10;          --default-artifact-root ./mlruns&#10;          --host 0.0.0.0&#10;          --port 5000&#10;      &quot;&#10;    depends_on:&#10;      auth_db:&#10;        condition: service_healthy&#10;    networks:&#10;      - ctuconnect-network&#10;    volumes:&#10;      - mlflow_data:/mlruns&#10;&#10;  # Recommendation Service&#10;  recommendation-service:&#10;    build:&#10;      context: ./recommendation-service&#10;    container_name: recommendation-service&#10;    ports:&#10;      - &quot;8080:8000&quot;&#10;    environment:&#10;      - SPRING_PROFILES_ACTIVE=docker&#10;      - DATABASE_URL=postgresql+asyncpg://postgres:${POSTGRES_PASSWORD}@auth_db:5432/auth_db&#10;      - REDIS_URL=redis://recommendation-redis:6379&#10;      - KAFKA_BOOTSTRAP_SERVERS=kafka:9092&#10;      - SECRET_KEY=${RECOMMENDATION_SECRET_KEY:-recommendation-secret-key}&#10;      - EUREKA_CLIENT_SERVICE_URL_DEFAULTZONE=http://eureka-server:8761/eureka&#10;      - MLFLOW_TRACKING_URI=http://mlflow-server:5000&#10;      - DEBUG=false&#10;      - API_GATEWAY_URL=http://api-gateway:8090&#10;    depends_on:&#10;      auth_db:&#10;        condition: service_healthy&#10;      recommendation-redis:&#10;        condition: service_healthy&#10;      eureka-server:&#10;        condition: service_healthy&#10;      kafka:&#10;        condition: service_started&#10;    networks:&#10;      - ctuconnect-network&#10;    volumes:&#10;      - ./recommendation-service/models:/app/models&#10;    healthcheck:&#10;      test: [&quot;CMD&quot;, &quot;curl&quot;, &quot;-f&quot;, &quot;http://localhost:8000/health&quot;]&#10;      interval: 30s&#10;      timeout: 10s&#10;      retries: 3&#10;    restart: unless-stopped&#10;&#10;volumes:&#10;  auth_db_data:&#10;  redis-data:&#10;  neo4j-data:&#10;  kafka-data:&#10;  media_data:&#10;  post-data:&#10;  recommendation_redis_data:&#10;  mlflow_data:&#10;&#10;networks:&#10;  ctuconnect-network:&#10;    driver: bridge" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/PostServiceApplication.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/PostServiceApplication.java" />
              <option name="originalContent" value="package com.ctuconnect;&#10;&#10;import org.springframework.boot.SpringApplication;&#10;import org.springframework.boot.autoconfigure.SpringBootApplication;&#10;import org.springframework.cloud.client.discovery.EnableDiscoveryClient;&#10;import org.springframework.cloud.openfeign.EnableFeignClients;&#10;import org.springframework.kafka.annotation.EnableKafka;&#10;&#10;@SpringBootApplication&#10;@EnableDiscoveryClient&#10;@EnableFeignClients&#10;@EnableKafka&#10;public class PostServiceApplication {&#10;&#10;    public static void main(String[] args) {&#10;        SpringApplication.run(PostServiceApplication.class, args);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.ctuconnect;&#13;&#10;&#13;&#10;import org.springframework.boot.SpringApplication;&#13;&#10;import org.springframework.boot.autoconfigure.SpringBootApplication;&#13;&#10;import org.springframework.cloud.client.discovery.EnableDiscoveryClient;&#13;&#10;import org.springframework.cloud.openfeign.EnableFeignClients;&#13;&#10;import org.springframework.kafka.annotation.EnableKafka;&#13;&#10;import org.springframework.data.mongodb.config.EnableMongoAuditing;&#13;&#10;&#13;&#10;@SpringBootApplication&#13;&#10;@EnableDiscoveryClient&#13;&#10;@EnableFeignClients&#13;&#10;@EnableKafka&#13;&#10;@EnableMongoAuditing // Enable MongoDB auditing for @CreatedDate and @LastModifiedDate&#13;&#10;public class PostServiceApplication {&#13;&#10;&#13;&#10;    public static void main(String[] args) {&#13;&#10;        SpringApplication.run(PostServiceApplication.class, args);&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/client/MediaServiceClient.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/client/MediaServiceClient.java" />
              <option name="originalContent" value="package com.ctuconnect.client;&#10;&#10;import lombok.Data;&#10;import org.springframework.cloud.openfeign.FeignClient;&#10;import org.springframework.http.MediaType;&#10;import org.springframework.web.bind.annotation.*;&#10;import org.springframework.web.multipart.MultipartFile;&#10;&#10;&#10;@FeignClient(name = &quot;media-service&quot;, url = &quot;${media-service.url:http://localhost:8080}&quot;)&#10;public interface MediaServiceClient {&#10;&#10;    @PostMapping(value = &quot;/api/media/upload&quot;, consumes = MediaType.MULTIPART_FORM_DATA_VALUE)&#10;    MediaUploadResponse uploadFile(@RequestPart(&quot;file&quot;) MultipartFile file,&#10;                                  @RequestParam(&quot;type&quot;) String type);&#10;&#10;    @DeleteMapping(&quot;/api/media/{id}&quot;)&#10;    void deleteFile(@PathVariable(&quot;id&quot;) String fileId);&#10;&#10;    @GetMapping(&quot;/api/media/{id}&quot;)&#10;    MediaResponse getFileInfo(@PathVariable(&quot;id&quot;) String fileId);&#10;&#10;    // Response DTOs for media service&#10;    class MediaUploadResponse {&#10;        private String id;&#10;        private String fileName;&#10;        private String fileUrl;&#10;        private String fileType;&#10;        private long fileSize;&#10;&#10;        // Getters and Setters&#10;        public String getId() {&#10;            return id;&#10;        }&#10;&#10;        public void setId(String id) {&#10;            this.id = id;&#10;        }&#10;&#10;        public String getFileName() {&#10;            return fileName;&#10;        }&#10;&#10;        public void setFileName(String fileName) {&#10;            this.fileName = fileName;&#10;        }&#10;&#10;        public String getFileUrl() {&#10;            return fileUrl;&#10;        }&#10;&#10;        public void setFileUrl(String fileUrl) {&#10;            this.fileUrl = fileUrl;&#10;        }&#10;&#10;        public String getFileType() {&#10;            return fileType;&#10;        }&#10;&#10;        public void setFileType(String fileType) {&#10;            this.fileType = fileType;&#10;        }&#10;&#10;        public long getFileSize() {&#10;            return fileSize;&#10;        }&#10;&#10;        public void setFileSize(long fileSize) {&#10;            this.fileSize = fileSize;&#10;        }&#10;    }&#10;&#10;    @Data&#10;    class MediaResponse {&#10;        private String id;&#10;        private String fileName;&#10;        private String fileUrl;&#10;        private String fileType;&#10;        private long fileSize;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.ctuconnect.client;&#13;&#10;&#13;&#10;import lombok.Data;&#13;&#10;import org.springframework.cloud.openfeign.FeignClient;&#13;&#10;import org.springframework.http.MediaType;&#13;&#10;import org.springframework.web.bind.annotation.*;&#13;&#10;import org.springframework.web.multipart.MultipartFile;&#13;&#10;import com.ctuconnect.config.FeignConfig;&#13;&#10;&#13;&#10;@FeignClient(&#13;&#10;    name = &quot;media-service&quot;, &#13;&#10;    url = &quot;${media-service.url}&quot;, &#13;&#10;    configuration = FeignConfig.class&#13;&#10;)&#13;&#10;public interface MediaServiceClient {&#13;&#10;&#13;&#10;    @PostMapping(value = &quot;/api/media/upload&quot;, consumes = MediaType.MULTIPART_FORM_DATA_VALUE)&#13;&#10;    MediaUploadResponse uploadFile(@RequestPart(&quot;file&quot;) MultipartFile file,&#13;&#10;                                  @RequestParam(&quot;type&quot;) String type);&#13;&#10;&#13;&#10;    @DeleteMapping(&quot;/api/media/{id}&quot;)&#13;&#10;    void deleteFile(@PathVariable(&quot;id&quot;) String fileId);&#13;&#10;&#13;&#10;    @GetMapping(&quot;/api/media/{id}&quot;)&#13;&#10;    MediaResponse getFileInfo(@PathVariable(&quot;id&quot;) String fileId);&#13;&#10;&#13;&#10;    // Response DTOs for media service&#13;&#10;    class MediaUploadResponse {&#13;&#10;        private String id;&#13;&#10;        private String fileName;&#13;&#10;        private String fileUrl;&#13;&#10;        private String fileType;&#13;&#10;        private long fileSize;&#13;&#10;&#13;&#10;        // Getters and Setters&#13;&#10;        public String getId() {&#13;&#10;            return id;&#13;&#10;        }&#13;&#10;&#13;&#10;        public void setId(String id) {&#13;&#10;            this.id = id;&#13;&#10;        }&#13;&#10;&#13;&#10;        public String getFileName() {&#13;&#10;            return fileName;&#13;&#10;        }&#13;&#10;&#13;&#10;        public void setFileName(String fileName) {&#13;&#10;            this.fileName = fileName;&#13;&#10;        }&#13;&#10;&#13;&#10;        public String getFileUrl() {&#13;&#10;            return fileUrl;&#13;&#10;        }&#13;&#10;&#13;&#10;        public void setFileUrl(String fileUrl) {&#13;&#10;            this.fileUrl = fileUrl;&#13;&#10;        }&#13;&#10;&#13;&#10;        public String getFileType() {&#13;&#10;            return fileType;&#13;&#10;        }&#13;&#10;&#13;&#10;        public void setFileType(String fileType) {&#13;&#10;            this.fileType = fileType;&#13;&#10;        }&#13;&#10;&#13;&#10;        public long getFileSize() {&#13;&#10;            return fileSize;&#13;&#10;        }&#13;&#10;&#13;&#10;        public void setFileSize(long fileSize) {&#13;&#10;            this.fileSize = fileSize;&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    @Data&#13;&#10;    class MediaResponse {&#13;&#10;        private String id;&#13;&#10;        private String fileName;&#13;&#10;        private String fileUrl;&#13;&#10;        private String fileType;&#13;&#10;        private long fileSize;&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/client/UserServiceClientFallback.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/client/UserServiceClientFallback.java" />
              <option name="updatedContent" value="package com.ctuconnect.client;&#10;&#10;import com.ctuconnect.dto.AuthorInfo;&#10;import lombok.extern.slf4j.Slf4j;&#10;import org.springframework.stereotype.Component;&#10;&#10;import java.util.HashSet;&#10;import java.util.Set;&#10;&#10;/**&#10; * Fallback implementation for UserServiceClient when user-service is unavailable&#10; * Provides default values to prevent service failures&#10; */&#10;@Component&#10;@Slf4j&#10;public class UserServiceClientFallback implements UserServiceClient {&#10;&#10;    @Override&#10;    public AuthorInfo getAuthorInfo(String authorId) {&#10;        log.warn(&quot;User service unavailable, returning fallback author info for user: {}&quot;, authorId);&#10;        return AuthorInfo.builder()&#10;                .userId(authorId)&#10;                .username(&quot;Unknown User&quot;)&#10;                .fullName(&quot;Unknown User&quot;)&#10;                .avatarUrl(null)&#10;                .isVerified(false)&#10;                .build();&#10;    }&#10;&#10;    @Override&#10;    public Set&lt;String&gt; getFriendIds(String userId) {&#10;        log.warn(&quot;User service unavailable, returning empty friend list for user: {}&quot;, userId);&#10;        return new HashSet&lt;&gt;();&#10;    }&#10;&#10;    @Override&#10;    public Set&lt;String&gt; getCloseInteractionIds(String userId) {&#10;        log.warn(&quot;User service unavailable, returning empty close interactions for user: {}&quot;, userId);&#10;        return new HashSet&lt;&gt;();&#10;    }&#10;&#10;    @Override&#10;    public Set&lt;String&gt; getSameFacultyUserIds(String userId) {&#10;        log.warn(&quot;User service unavailable, returning empty same faculty users for user: {}&quot;, userId);&#10;        return new HashSet&lt;&gt;();&#10;    }&#10;&#10;    @Override&#10;    public Set&lt;String&gt; getSameMajorUserIds(String userId) {&#10;        log.warn(&quot;User service unavailable, returning empty same major users for user: {}&quot;, userId);&#10;        return new HashSet&lt;&gt;();&#10;    }&#10;&#10;    @Override&#10;    public Set&lt;String&gt; getUserInterestTags(String userId) {&#10;        log.warn(&quot;User service unavailable, returning empty interest tags for user: {}&quot;, userId);&#10;        return new HashSet&lt;&gt;();&#10;    }&#10;&#10;    @Override&#10;    public Set&lt;String&gt; getUserPreferredCategories(String userId) {&#10;        log.warn(&quot;User service unavailable, returning empty preferred categories for user: {}&quot;, userId);&#10;        return new HashSet&lt;&gt;();&#10;    }&#10;&#10;    @Override&#10;    public String getUserFacultyId(String userId) {&#10;        log.warn(&quot;User service unavailable, returning null faculty ID for user: {}&quot;, userId);&#10;        return null;&#10;    }&#10;&#10;    @Override&#10;    public String getUserMajorId(String userId) {&#10;        log.warn(&quot;User service unavailable, returning null major ID for user: {}&quot;, userId);&#10;        return null;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/config/CacheConfig.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/config/CacheConfig.java" />
              <option name="updatedContent" value="package com.ctuconnect.config;&#10;&#10;import org.springframework.beans.factory.annotation.Value;&#10;import org.springframework.context.annotation.Bean;&#10;import org.springframework.context.annotation.Configuration;&#10;import org.springframework.data.redis.connection.RedisConnectionFactory;&#10;import org.springframework.data.redis.connection.lettuce.LettuceConnectionFactory;&#10;import org.springframework.data.redis.core.RedisTemplate;&#10;import org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer;&#10;import org.springframework.data.redis.serializer.StringRedisSerializer;&#10;&#10;@Configuration&#10;public class CacheConfig {&#10;&#10;    @Value(&quot;${spring.data.redis.host:localhost}&quot;)&#10;    private String redisHost;&#10;&#10;    @Value(&quot;${spring.data.redis.port:6379}&quot;)&#10;    private int redisPort;&#10;&#10;    @Bean&#10;    public RedisConnectionFactory redisConnectionFactory() {&#10;        return new LettuceConnectionFactory(redisHost, redisPort);&#10;    }&#10;&#10;    @Bean&#10;    public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory connectionFactory) {&#10;        RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;();&#10;        template.setConnectionFactory(connectionFactory);&#10;        &#10;        // Use String serializer for keys&#10;        template.setKeySerializer(new StringRedisSerializer());&#10;        template.setHashKeySerializer(new StringRedisSerializer());&#10;        &#10;        // Use JSON serializer for values&#10;        template.setValueSerializer(new GenericJackson2JsonRedisSerializer());&#10;        template.setHashValueSerializer(new GenericJackson2JsonRedisSerializer());&#10;        &#10;        template.afterPropertiesSet();&#10;        return template;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/config/FeignConfig.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/config/FeignConfig.java" />
              <option name="updatedContent" value="package com.ctuconnect.config;&#10;&#10;import feign.Logger;&#10;import feign.Request;&#10;import feign.Retryer;&#10;import feign.codec.ErrorDecoder;&#10;import org.springframework.context.annotation.Bean;&#10;import org.springframework.context.annotation.Configuration;&#10;&#10;import java.util.concurrent.TimeUnit;&#10;&#10;/**&#10; * Feign client configuration for better error handling and retry mechanism&#10; */&#10;@Configuration&#10;public class FeignConfig {&#10;&#10;    @Bean&#10;    Logger.Level feignLoggerLevel() {&#10;        return Logger.Level.BASIC;&#10;    }&#10;&#10;    @Bean&#10;    public Request.Options requestOptions() {&#10;        return new Request.Options(&#10;                10, TimeUnit.SECONDS, // connect timeout&#10;                60, TimeUnit.SECONDS, // read timeout&#10;                true // follow redirects&#10;        );&#10;    }&#10;&#10;    @Bean&#10;    public Retryer retryer() {&#10;        return new Retryer.Default(&#10;                1000, // initial interval&#10;                3000, // max interval&#10;                3     // max attempts&#10;        );&#10;    }&#10;&#10;    @Bean&#10;    public ErrorDecoder errorDecoder() {&#10;        return new CustomFeignErrorDecoder();&#10;    }&#10;&#10;    /**&#10;     * Custom error decoder to handle service communication errors gracefully&#10;     */&#10;    public static class CustomFeignErrorDecoder implements ErrorDecoder {&#10;        &#10;        @Override&#10;        public Exception decode(String methodKey, feign.Response response) {&#10;            switch (response.status()) {&#10;                case 400:&#10;                    return new IllegalArgumentException(&quot;Bad Request: &quot; + methodKey);&#10;                case 404:&#10;                    return new RuntimeException(&quot;Service not found: &quot; + methodKey);&#10;                case 500:&#10;                    return new RuntimeException(&quot;Internal Server Error in &quot; + methodKey);&#10;                case 503:&#10;                    return new RuntimeException(&quot;Service Unavailable: &quot; + methodKey);&#10;                default:&#10;                    return new RuntimeException(&quot;Unknown error occurred in &quot; + methodKey + &quot;: &quot; + response.status());&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/config/HealthCheckConfig.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/config/HealthCheckConfig.java" />
              <option name="updatedContent" value="package com.ctuconnect.config;&#10;&#10;import org.springframework.boot.actuator.health.Health;&#10;import org.springframework.boot.actuator.health.HealthIndicator;&#10;import org.springframework.context.annotation.Bean;&#10;import org.springframework.context.annotation.Configuration;&#10;import org.springframework.data.redis.connection.RedisConnectionFactory;&#10;import org.springframework.data.mongodb.core.MongoTemplate;&#10;&#10;@Configuration&#10;public class HealthCheckConfig {&#10;    &#10;    @Bean&#10;    public HealthIndicator redisHealthIndicator(RedisConnectionFactory redisConnectionFactory) {&#10;        return () -&gt; {&#10;            try {&#10;                redisConnectionFactory.getConnection().ping();&#10;                return Health.up()&#10;                    .withDetail(&quot;redis&quot;, &quot;Available&quot;)&#10;                    .build();&#10;            } catch (Exception e) {&#10;                return Health.down()&#10;                    .withDetail(&quot;redis&quot;, &quot;Unavailable&quot;)&#10;                    .withDetail(&quot;error&quot;, e.getMessage())&#10;                    .build();&#10;            }&#10;        };&#10;    }&#10;    &#10;    @Bean&#10;    public HealthIndicator mongoHealthIndicator(MongoTemplate mongoTemplate) {&#10;        return () -&gt; {&#10;            try {&#10;                mongoTemplate.getCollection(&quot;health_check&quot;).countDocuments();&#10;                return Health.up()&#10;                    .withDetail(&quot;mongodb&quot;, &quot;Available&quot;)&#10;                    .build();&#10;            } catch (Exception e) {&#10;                return Health.down()&#10;                    .withDetail(&quot;mongodb&quot;, &quot;Unavailable&quot;)&#10;                    .withDetail(&quot;error&quot;, e.getMessage())&#10;                    .build();&#10;            }&#10;        };&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/config/WebConfig.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/config/WebConfig.java" />
              <option name="updatedContent" value="package com.ctuconnect.config;&#10;&#10;import com.ctuconnect.security.AuthenticationInterceptor;&#10;import lombok.RequiredArgsConstructor;&#10;import org.springframework.context.annotation.Configuration;&#10;import org.springframework.web.servlet.config.annotation.InterceptorRegistry;&#10;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;&#10;&#10;/**&#10; * Web configuration to register security interceptors&#10; */&#10;@Configuration&#10;@RequiredArgsConstructor&#10;public class WebConfig implements WebMvcConfigurer {&#10;&#10;    private final AuthenticationInterceptor authenticationInterceptor;&#10;&#10;    @Override&#10;    public void addInterceptors(InterceptorRegistry registry) {&#10;        registry.addInterceptor(authenticationInterceptor)&#10;                .addPathPatterns(&quot;/api/**&quot;) // Apply to all API endpoints&#10;                .excludePathPatterns(&#10;                        &quot;/api/posts/health&quot;,&#10;                        &quot;/api/posts/actuator/**&quot;,&#10;                        &quot;/api/posts/swagger-ui/**&quot;,&#10;                        &quot;/api/posts/v3/api-docs/**&quot;&#10;                );&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/config/WebSocketConfig.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/config/WebSocketConfig.java" />
              <option name="updatedContent" value="package com.ctuconnect.config;&#10;&#10;import org.springframework.context.annotation.Configuration;&#10;import org.springframework.messaging.simp.config.MessageBrokerRegistry;&#10;import org.springframework.web.socket.config.annotation.EnableWebSocketMessageBroker;&#10;import org.springframework.web.socket.config.annotation.StompEndpointRegistry;&#10;import org.springframework.web.socket.config.annotation.WebSocketMessageBrokerConfigurer;&#10;&#10;@Configuration&#10;@EnableWebSocketMessageBroker&#10;public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {&#10;&#10;    @Override&#10;    public void configureMessageBroker(MessageBrokerRegistry config) {&#10;        // Enable simple message broker for in-memory message handling&#10;        config.enableSimpleBroker(&quot;/topic&quot;, &quot;/queue&quot;);&#10;        config.setApplicationDestinationPrefixes(&quot;/app&quot;);&#10;        config.setUserDestinationPrefix(&quot;/user&quot;);&#10;    }&#10;&#10;    @Override&#10;    public void registerStompEndpoints(StompEndpointRegistry registry) {&#10;        // Register STOMP endpoints for WebSocket connections&#10;        registry.addEndpoint(&quot;/ws&quot;)&#10;                .setAllowedOriginPatterns(&quot;*&quot;)&#10;                .withSockJS();&#10;        &#10;        registry.addEndpoint(&quot;/ws-notifications&quot;)&#10;                .setAllowedOriginPatterns(&quot;*&quot;)&#10;                .withSockJS();&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/controller/EnhancedPostController.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/controller/EnhancedPostController.java" />
              <option name="updatedContent" value="// This file has been merged into PostController.java&#10;// Delete this file to avoid conflicts" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/dto/request/InteractionRequest.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/dto/request/InteractionRequest.java" />
              <option name="originalContent" value="package com.ctuconnect.dto.request;&#10;&#10;import jakarta.validation.constraints.NotNull;&#10;import lombok.AllArgsConstructor;&#10;import lombok.Builder;&#10;import lombok.Data;&#10;import lombok.NoArgsConstructor;&#10;import com.ctuconnect.entity.InteractionEntity;&#10;&#10;import java.util.HashMap;&#10;import java.util.Map;&#10;&#10;@Data&#10;@AllArgsConstructor&#10;@NoArgsConstructor&#10;@Builder&#10;public class InteractionRequest {&#10;&#10;    @NotNull(message = &quot;Interaction type is required&quot;)&#10;    private InteractionEntity.InteractionType reaction;&#10;&#10;    private Map&lt;String, Object&gt; metadata = new HashMap&lt;&gt;();&#10;&#10;    public void setType(String s) {&#10;        if (s != null) {&#10;            try {&#10;                this.reaction = InteractionEntity.InteractionType.valueOf(s.toUpperCase());&#10;            } catch (IllegalArgumentException e) {&#10;                throw new IllegalArgumentException(&quot;Invalid interaction type: &quot; + s);&#10;            }&#10;        } else {&#10;            throw new IllegalArgumentException(&quot;Interaction type cannot be null&quot;);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.ctuconnect.dto.request;&#10;&#10;import jakarta.validation.constraints.NotNull;&#10;import lombok.AllArgsConstructor;&#10;import lombok.Builder;&#10;import lombok.Data;&#10;import lombok.NoArgsConstructor;&#10;import com.ctuconnect.entity.InteractionEntity;&#10;&#10;import java.util.HashMap;&#10;import java.util.Map;&#10;&#10;@Data&#10;@AllArgsConstructor&#10;@NoArgsConstructor&#10;@Builder&#10;public class InteractionRequest {&#10;&#10;    @NotNull(message = &quot;Interaction type is required&quot;)&#10;    private InteractionEntity.InteractionType reaction;&#10;&#10;    // Add missing reactionType field for specific reaction types&#10;    private InteractionEntity.ReactionType reactionType;&#10;&#10;    private Map&lt;String, Object&gt; metadata = new HashMap&lt;&gt;();&#10;&#10;    public void setType(String s) {&#10;        if (s != null) {&#10;            try {&#10;                this.reaction = InteractionEntity.InteractionType.valueOf(s.toUpperCase());&#10;            } catch (IllegalArgumentException e) {&#10;                throw new IllegalArgumentException(&quot;Invalid interaction type: &quot; + s);&#10;            }&#10;        } else {&#10;            throw new IllegalArgumentException(&quot;Interaction type cannot be null&quot;);&#10;        }&#10;    }&#10;&#10;    // Add missing setReactionType method&#10;    public void setReactionType(InteractionEntity.ReactionType reactionType) {&#10;        this.reactionType = reactionType;&#10;    }&#10;&#10;    // Add getter for reactionType&#10;    public InteractionEntity.ReactionType getReactionType() {&#10;        return this.reactionType;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/dto/response/InteractionResponse.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/dto/response/InteractionResponse.java" />
              <option name="originalContent" value="package com.ctuconnect.dto.response;&#10;&#10;import com.ctuconnect.entity.InteractionEntity;&#10;import lombok.*;&#10;&#10;import java.time.LocalDateTime;&#10;import java.util.Map;&#10;&#10;@Data&#10;@Builder&#10;@AllArgsConstructor&#10;public class InteractionResponse {&#10;&#10;    // Getters and Setters&#10;    private String id;&#10;    private String postId;&#10;    private String userId;&#10;    private InteractionEntity.InteractionType type;&#10;    private Map&lt;String, Object&gt; metadata;&#10;    private LocalDateTime createdAt;&#10;&#10;    // New fields for status responses&#10;    private boolean hasInteraction;&#10;    private String message;&#10;&#10;    // Constructors&#10;    public InteractionResponse() {}&#10;&#10;    public InteractionResponse(InteractionEntity interaction) {&#10;        this.id = interaction.getId();&#10;        this.postId = interaction.getPostId();&#10;        this.userId = interaction.getUserId();&#10;        this.type = interaction.getType();&#10;        this.metadata = interaction.getMetadata();&#10;        this.createdAt = interaction.getCreatedAt();&#10;        this.hasInteraction = true;&#10;    }&#10;&#10;    // Constructor for status responses&#10;    public InteractionResponse(boolean hasInteraction, String message) {&#10;        this.hasInteraction = hasInteraction;&#10;        this.message = message;&#10;    }&#10;&#10;}&#10;" />
              <option name="updatedContent" value="package com.ctuconnect.dto.response;&#13;&#10;&#13;&#10;import com.ctuconnect.entity.InteractionEntity;&#13;&#10;import lombok.*;&#13;&#10;&#13;&#10;import java.time.LocalDateTime;&#13;&#10;import java.util.Map;&#13;&#10;&#13;&#10;@Data&#13;&#10;@Builder&#13;&#10;@AllArgsConstructor&#13;&#10;public class InteractionResponse {&#13;&#10;&#13;&#10;    // Getters and Setters&#13;&#10;    private String id;&#13;&#10;    private String postId;&#13;&#10;    private String userId;&#13;&#10;    private InteractionEntity.InteractionType type;&#13;&#10;    private Map&lt;String, Object&gt; metadata;&#13;&#10;    private LocalDateTime createdAt;&#13;&#10;&#13;&#10;    // New fields for status responses&#13;&#10;    private boolean hasInteraction;&#13;&#10;    private String message;&#13;&#10;&#13;&#10;    // Constructors&#13;&#10;    public InteractionResponse() {}&#13;&#10;&#13;&#10;    public InteractionResponse(InteractionEntity interaction) {&#13;&#10;        this.id = interaction.getId();&#13;&#10;        this.postId = interaction.getPostId();&#13;&#10;        this.userId = interaction.getUserId();&#13;&#10;        this.type = interaction.getType();&#13;&#10;        this.metadata = interaction.getMetadata();&#13;&#10;        this.createdAt = interaction.getCreatedAt();&#13;&#10;        this.hasInteraction = true;&#13;&#10;    }&#13;&#10;&#13;&#10;    // Constructor for status responses&#13;&#10;    public InteractionResponse(boolean hasInteraction, String message) {&#13;&#10;        this.hasInteraction = hasInteraction;&#13;&#10;        this.message = message;&#13;&#10;    }&#13;&#10;&#13;&#10;    // Add missing isActive method - this determines if the interaction is currently active&#13;&#10;    public boolean isActive() {&#13;&#10;        return this.hasInteraction;&#13;&#10;    }&#13;&#10;&#13;&#10;    // Alternative method name for clarity&#13;&#10;    public boolean hasActiveInteraction() {&#13;&#10;        return this.hasInteraction;&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/entity/InteractionEntity.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/entity/InteractionEntity.java" />
              <option name="originalContent" value="package com.ctuconnect.entity;&#10;&#10;import lombok.*;&#10;import org.springframework.data.annotation.Id;&#10;import org.springframework.data.mongodb.core.mapping.Document;&#10;import org.springframework.data.mongodb.core.mapping.Field;&#10;import com.ctuconnect.dto.AuthorInfo;&#10;&#10;import java.time.LocalDateTime;&#10;import java.util.HashMap;&#10;import java.util.Map;&#10;import java.util.Objects;&#10;&#10;@Data&#10;@NoArgsConstructor&#10;@AllArgsConstructor&#10;@Builder&#10;@Document(collection = &quot;interactions&quot;)&#10;public class InteractionEntity {&#10;&#10;    @Id&#10;    private String id;&#10;&#10;    @Field(&quot;post_id&quot;)&#10;    private String postId;&#10;&#10;    @Field(&quot;author&quot;)&#10;    private AuthorInfo author;&#10;&#10;    private InteractionType type;&#10;&#10;    // Getter for reaction type (backwards compatibility)&#10;    // Add reactionType field for REACTION interactions&#10;    private ReactionType reactionType;&#10;&#10;    private Map&lt;String, Object&gt; metadata = new HashMap&lt;&gt;();&#10;&#10;    @Field(&quot;created_at&quot;)&#10;    private LocalDateTime createdAt;&#10;&#10;    // Constructors&#10;    public InteractionEntity(String postId, AuthorInfo author, InteractionType type) {&#10;        this.postId = postId;&#10;        this.author = author;&#10;        this.type = type;&#10;        this.createdAt = LocalDateTime.now();&#10;        this.metadata = new HashMap&lt;&gt;();&#10;    }&#10;&#10;    // Pre-persist hook&#10;    public void prePersist() {&#10;        if (this.createdAt == null) {&#10;            this.createdAt = LocalDateTime.now();&#10;        }&#10;        if (this.metadata == null) {&#10;            this.metadata = new HashMap&lt;&gt;();&#10;        }&#10;    }&#10;&#10;    public String getUserId() {&#10;        return author != null ? author.getId() : null;&#10;    }&#10;&#10;    public void setReaction(InteractionType newReaction) {&#10;        if (newReaction == null) {&#10;            throw new IllegalArgumentException(&quot;Interaction type cannot be null&quot;);&#10;        }&#10;        this.type = newReaction;&#10;        if (newReaction == InteractionType.REACTION) {&#10;            this.reactionType = newReaction.getReactionType();&#10;        } else {&#10;            this.reactionType = null; // Clear reaction type for non-REACTION interactions&#10;        }&#10;    }&#10;&#10;    // Enum for interaction types&#10;    public enum InteractionType {&#10;        LIKE,&#10;        SHARE,&#10;        BOOKMARK,&#10;        VIEW,&#10;        COMMENT,&#10;        REACTION // Add REACTION type&#10;        ;&#10;&#10;        public ReactionType getReactionType() {&#10;            if (this == REACTION) {&#10;                return ReactionType.LIKE; // Default to LIKE for REACTION type&#10;            }&#10;            return null; // No reaction type for other interaction types&#10;        }&#10;    }&#10;&#10;    // Enum for reaction types (for REACTION interactions)&#10;    public enum ReactionType {&#10;        LIKE,&#10;        LOVE,&#10;        HAHA,&#10;        WOW,&#10;        SAD,&#10;        ANGRY&#10;    }&#10;&#10;    // Helper methods&#10;    public boolean isReaction() {&#10;        return this.type == InteractionType.REACTION;&#10;    }&#10;&#10;    public boolean isLike() {&#10;        return this.type == InteractionType.LIKE ||&#10;               (this.type == InteractionType.REACTION &amp;&amp; this.reactionType == ReactionType.LIKE);&#10;    }&#10;&#10;    public boolean isView() {&#10;        return this.type == InteractionType.VIEW;&#10;    }&#10;&#10;    public boolean isShare() {&#10;        return this.type == InteractionType.SHARE;&#10;    }&#10;&#10;    public boolean isBookmark() {&#10;        return this.type == InteractionType.BOOKMARK;&#10;    }&#10;&#10;    public boolean isComment() {&#10;        return this.type == InteractionType.COMMENT;&#10;    }&#10;&#10;    // Equals and hashCode&#10;    @Override&#10;    public boolean equals(Object o) {&#10;        if (this == o) return true;&#10;        if (o == null || getClass() != o.getClass()) return false;&#10;        InteractionEntity that = (InteractionEntity) o;&#10;        return Objects.equals(id, that.id) &amp;&amp;&#10;               Objects.equals(postId, that.postId) &amp;&amp;&#10;               Objects.equals(author, that.author) &amp;&amp;&#10;               type == that.type &amp;&amp;&#10;               reactionType == that.reactionType;&#10;    }&#10;&#10;    @Override&#10;    public int hashCode() {&#10;        return Objects.hash(id, postId, author, type, reactionType);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.ctuconnect.entity;&#13;&#10;&#13;&#10;import lombok.*;&#13;&#10;import org.springframework.data.annotation.Id;&#13;&#10;import org.springframework.data.mongodb.core.mapping.Document;&#13;&#10;import org.springframework.data.mongodb.core.mapping.Field;&#13;&#10;import com.ctuconnect.dto.AuthorInfo;&#13;&#10;&#13;&#10;import java.time.LocalDateTime;&#13;&#10;import java.util.HashMap;&#13;&#10;import java.util.Map;&#13;&#10;&#13;&#10;@Data&#13;&#10;@NoArgsConstructor&#13;&#10;@AllArgsConstructor&#13;&#10;@Builder&#13;&#10;@Document(collection = &quot;interactions&quot;)&#13;&#10;public class InteractionEntity {&#13;&#10;&#13;&#10;    @Id&#13;&#10;    private String id;&#13;&#10;&#13;&#10;    @Field(&quot;post_id&quot;)&#13;&#10;    private String postId;&#13;&#10;&#13;&#10;    @Field(&quot;author&quot;)&#13;&#10;    private AuthorInfo author;&#13;&#10;&#13;&#10;    private InteractionType type;&#13;&#10;&#13;&#10;    // For REACTION type interactions, store the specific reaction&#13;&#10;    private ReactionType reactionType;&#13;&#10;&#13;&#10;    private Map&lt;String, Object&gt; metadata = new HashMap&lt;&gt;();&#13;&#10;&#13;&#10;    @Field(&quot;created_at&quot;)&#13;&#10;    private LocalDateTime createdAt;&#13;&#10;&#13;&#10;    // Constructor&#13;&#10;    public InteractionEntity(String postId, AuthorInfo author, InteractionType type) {&#13;&#10;        this.postId = postId;&#13;&#10;        this.author = author;&#13;&#10;        this.type = type;&#13;&#10;        this.createdAt = LocalDateTime.now();&#13;&#10;        this.metadata = new HashMap&lt;&gt;();&#13;&#10;    }&#13;&#10;&#13;&#10;    // Constructor with reaction type&#13;&#10;    public InteractionEntity(String postId, AuthorInfo author, InteractionType type, ReactionType reactionType) {&#13;&#10;        this.postId = postId;&#13;&#10;        this.author = author;&#13;&#10;        this.type = type;&#13;&#10;        this.reactionType = reactionType;&#13;&#10;        this.createdAt = LocalDateTime.now();&#13;&#10;        this.metadata = new HashMap&lt;&gt;();&#13;&#10;    }&#13;&#10;&#13;&#10;    // Pre-persist hook&#13;&#10;    public void prePersist() {&#13;&#10;        if (this.createdAt == null) {&#13;&#10;            this.createdAt = LocalDateTime.now();&#13;&#10;        }&#13;&#10;        if (this.metadata == null) {&#13;&#10;            this.metadata = new HashMap&lt;&gt;();&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    public String getUserId() {&#13;&#10;        return author != null ? author.getId() : null;&#13;&#10;    }&#13;&#10;&#13;&#10;    // Enum for interaction types&#13;&#10;    public enum InteractionType {&#13;&#10;        LIKE,&#13;&#10;        SHARE,&#13;&#10;        BOOKMARK,&#13;&#10;        VIEW,&#13;&#10;        COMMENT,&#13;&#10;        REACTION&#13;&#10;    }&#13;&#10;&#13;&#10;    // Enum for reaction types&#13;&#10;    public enum ReactionType {&#13;&#10;        LIKE,&#13;&#10;        LOVE,&#13;&#10;        HAHA,&#13;&#10;        WOW,&#13;&#10;        SAD,&#13;&#10;        ANGRY,&#13;&#10;        BOOKMARK&#13;&#10;    }&#13;&#10;&#13;&#10;    // Helper methods&#13;&#10;    public boolean isReaction() {&#13;&#10;        return this.type == InteractionType.REACTION;&#13;&#10;    }&#13;&#10;&#13;&#10;    public boolean isLike() {&#13;&#10;        return this.type == InteractionType.LIKE || &#13;&#10;               (this.type == InteractionType.REACTION &amp;&amp; this.reactionType == ReactionType.LIKE);&#13;&#10;    }&#13;&#10;&#13;&#10;    public boolean isBookmark() {&#13;&#10;        return this.type == InteractionType.BOOKMARK ||&#13;&#10;               (this.type == InteractionType.REACTION &amp;&amp; this.reactionType == ReactionType.BOOKMARK);&#13;&#10;    }&#13;&#10;&#13;&#10;    public boolean isView() {&#13;&#10;        return this.type == InteractionType.VIEW;&#13;&#10;    }&#13;&#10;&#13;&#10;    public boolean isShare() {&#13;&#10;        return this.type == InteractionType.SHARE;&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/repository/CommentRepository.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/repository/CommentRepository.java" />
              <option name="originalContent" value="package com.ctuconnect.repository;&#10;&#10;import org.springframework.data.domain.Page;&#10;import org.springframework.data.domain.Pageable;&#10;import org.springframework.data.mongodb.repository.MongoRepository;&#10;import org.springframework.data.mongodb.repository.Query;&#10;import org.springframework.stereotype.Repository;&#10;import com.ctuconnect.entity.CommentEntity;&#10;&#10;import java.util.List;&#10;&#10;@Repository&#10;public interface CommentRepository extends MongoRepository&lt;CommentEntity, String&gt; {&#10;&#10;    Page&lt;CommentEntity&gt; findByPostId(String postId, Pageable pageable);&#10;&#10;    List&lt;CommentEntity&gt; findByPostIdAndParentCommentIdIsNull(String postId);&#10;&#10;    List&lt;CommentEntity&gt; findByParentCommentId(String parentCommentId);&#10;&#10;    long countByPostId(String postId);&#10;&#10;    // Fix: Use MongoDB query for nested author object&#10;    @Query(value = &quot;{ 'author.id': ?0 }&quot;, count = true)&#10;    long countByAuthor_Id(String authorId);&#10;&#10;    void deleteByPostId(String postId);&#10;&#10;    // Additional useful queries for nested author structure&#10;    @Query(&quot;{ 'author.id': ?0 }&quot;)&#10;    Page&lt;CommentEntity&gt; findByAuthor_Id(String authorId, Pageable pageable);&#10;&#10;    // Add method that AdminController is calling (without underscore)&#10;    @Query(value = &quot;{ 'author.id': ?0 }&quot;, count = true)&#10;    long countByAuthorId(String authorId);&#10;}&#10;" />
              <option name="updatedContent" value="package com.ctuconnect.repository;&#13;&#10;&#13;&#10;import org.springframework.data.domain.Page;&#13;&#10;import org.springframework.data.domain.Pageable;&#13;&#10;import org.springframework.data.mongodb.repository.MongoRepository;&#13;&#10;import org.springframework.data.mongodb.repository.Query;&#13;&#10;import org.springframework.stereotype.Repository;&#13;&#10;import com.ctuconnect.entity.CommentEntity;&#13;&#10;&#13;&#10;import java.util.List;&#13;&#10;&#13;&#10;@Repository&#13;&#10;public interface CommentRepository extends MongoRepository&lt;CommentEntity, String&gt; {&#13;&#10;&#13;&#10;    Page&lt;CommentEntity&gt; findByPostId(String postId, Pageable pageable);&#13;&#10;&#13;&#10;    List&lt;CommentEntity&gt; findByPostIdAndParentCommentIdIsNull(String postId);&#13;&#10;&#13;&#10;    List&lt;CommentEntity&gt; findByParentCommentId(String parentCommentId);&#13;&#10;&#13;&#10;    long countByPostId(String postId);&#13;&#10;&#13;&#10;    // Fix: Use MongoDB query for nested author object&#13;&#10;    @Query(value = &quot;{ 'author.id': ?0 }&quot;, count = true)&#13;&#10;    long countByAuthor_Id(String authorId);&#13;&#10;&#13;&#10;    void deleteByPostId(String postId);&#13;&#10;&#13;&#10;    // Additional useful queries for nested author structure&#13;&#10;    @Query(&quot;{ 'author.id': ?0 }&quot;)&#13;&#10;    Page&lt;CommentEntity&gt; findByAuthor_Id(String authorId, Pageable pageable);&#13;&#10;&#13;&#10;    // Add method that AdminController is calling (without underscore)&#13;&#10;    @Query(value = &quot;{ 'author.id': ?0 }&quot;, count = true)&#13;&#10;    long countByAuthorId(String authorId);&#13;&#10;&#13;&#10;    // Method for user profile synchronization - find all comments by author ID&#13;&#10;    @Query(&quot;{ 'author.id': ?0 }&quot;)&#13;&#10;    List&lt;CommentEntity&gt; findByAuthor_Id(String authorId);&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/service/InteractionService.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/service/InteractionService.java" />
              <option name="originalContent" value="package com.ctuconnect.service;&#10;&#10;import org.springframework.beans.factory.annotation.Autowired;&#10;import org.springframework.stereotype.Service;&#10;import com.ctuconnect.client.UserServiceClient;&#10;import com.ctuconnect.dto.AuthorInfo;&#10;import com.ctuconnect.dto.request.InteractionRequest;&#10;import com.ctuconnect.dto.response.InteractionResponse;&#10;import com.ctuconnect.entity.InteractionEntity;&#10;import com.ctuconnect.entity.PostEntity;&#10;import com.ctuconnect.repository.InteractionRepository;&#10;import com.ctuconnect.repository.PostRepository;&#10;&#10;import java.util.Objects;&#10;import java.util.Optional;&#10;import java.util.List;&#10;&#10;@Service&#10;public class InteractionService {&#10;&#10;    @Autowired&#10;    private InteractionRepository interactionRepository;&#10;&#10;    @Autowired&#10;    private PostRepository postRepository;&#10;&#10;    @Autowired&#10;    private UserServiceClient userServiceClient;&#10;&#10;    @Autowired&#10;    private EventService eventService;&#10;&#10;    /**&#10;     * Create or toggle interaction (like/bookmark)&#10;     * Fixed to properly handle state persistence and prevent duplicates&#10;     */&#10;    public InteractionResponse createInteraction(String postId, InteractionRequest request, String authorId) {&#10;        AuthorInfo author = userServiceClient.getAuthorInfo(authorId);&#10;        if (author == null) {&#10;            throw new RuntimeException(&quot;Author not found with id: &quot; + authorId);&#10;        }&#10;&#10;        PostEntity post = postRepository.findById(postId)&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;Post not found with id: &quot; + postId));&#10;&#10;        // Check if user already has this type of interaction with the post&#10;        Optional&lt;InteractionEntity&gt; existingInteraction = interactionRepository&#10;                .findByPostIdAndAuthor_IdAndType(postId, authorId, request.getReaction());&#10;&#10;        if (existingInteraction.isPresent()) {&#10;            // User already has this interaction - remove it (toggle off)&#10;            interactionRepository.delete(existingInteraction.get());&#10;&#10;            // Update post stats&#10;            updatePostStatsOnRemove(post, request.getReaction());&#10;            postRepository.save(post);&#10;&#10;            eventService.publishInteractionEvent(postId, authorId, &quot;UN-&quot; + request.getReaction().toString());&#10;            return new InteractionResponse(false, &quot;Interaction removed&quot;); // Interaction removed&#10;        } else {&#10;            // Create new interaction&#10;            InteractionEntity interaction = new InteractionEntity(postId, author, request.getReaction());&#10;            if (request.getMetadata() != null) {&#10;                interaction.setMetadata(request.getMetadata());&#10;            }&#10;            InteractionEntity saved = interactionRepository.save(interaction);&#10;&#10;            // Update post stats&#10;            updatePostStatsOnAdd(post, request.getReaction());&#10;            postRepository.save(post);&#10;&#10;            eventService.publishInteractionEvent(postId, authorId, request.getReaction().toString());&#10;            return new InteractionResponse(saved);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get user's interaction status for a post&#10;     * This method helps frontend determine current interaction state&#10;     */&#10;    public InteractionResponse getUserInteractionStatus(String postId, String userId) {&#10;        List&lt;InteractionEntity&gt; userInteractions = interactionRepository.findByPostIdAndAuthor_Id(postId, userId);&#10;&#10;        if (userInteractions.isEmpty()) {&#10;            return new InteractionResponse(false, &quot;No interactions found&quot;);&#10;        }&#10;&#10;        // Return the first interaction (in case of multiple, though there shouldn't be)&#10;        return new InteractionResponse(userInteractions.get(0));&#10;    }&#10;&#10;    /**&#10;     * Check if user has liked a specific post&#10;     */&#10;    public boolean hasUserLikedPost(String postId, String userId) {&#10;        return interactionRepository.findByPostIdAndAuthor_IdAndType(&#10;            postId, userId, InteractionEntity.InteractionType.LIKE).isPresent();&#10;    }&#10;&#10;    /**&#10;     * Check if user has bookmarked a specific post&#10;     */&#10;    public boolean hasUserBookmarkedPost(String postId, String userId) {&#10;        return interactionRepository.findByPostIdAndAuthor_IdAndType(&#10;            postId, userId, InteractionEntity.InteractionType.BOOKMARK).isPresent();&#10;    }&#10;&#10;    private void updatePostStatsOnAdd(PostEntity post, InteractionEntity.InteractionType type) {&#10;        switch (type) {&#10;            case LIKE:&#10;&#10;                post.getStats().incrementReaction(InteractionEntity.ReactionType.LIKE);&#10;                break;&#10;            case BOOKMARK:&#10;                // Handle bookmark stats if needed&#10;                break;&#10;            case SHARE:&#10;                post.getStats().incrementShares();&#10;                break;&#10;            default:&#10;                break;&#10;        }&#10;    }&#10;&#10;    private void updatePostStatsOnRemove(PostEntity post, InteractionEntity.InteractionType type) {&#10;        switch (type) {&#10;            case LIKE:&#10;&#10;                post.getStats().decrementReaction(InteractionEntity.ReactionType.LIKE);&#10;                break;&#10;            case BOOKMARK:&#10;                // Handle bookmark stats if needed&#10;                break;&#10;            case SHARE:&#10;                post.getStats().decrementShares();&#10;                break;&#10;            default:&#10;                break;&#10;        }&#10;    }&#10;&#10;    public long getInteractionCount(String postId, InteractionEntity.InteractionType type) {&#10;        return interactionRepository.countByPostIdAndType(postId, type);&#10;    }&#10;&#10;    /**&#10;     * Check if user has reacted to a post (for legacy compatibility)&#10;     */&#10;    public boolean hasUserReacted(String postId, String userId) {&#10;        return hasUserLikedPost(postId, userId);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.ctuconnect.service;&#10;&#10;import org.springframework.beans.factory.annotation.Autowired;&#10;import org.springframework.stereotype.Service;&#10;import com.ctuconnect.client.UserServiceClient;&#10;import com.ctuconnect.dto.AuthorInfo;&#10;import com.ctuconnect.dto.request.InteractionRequest;&#10;import com.ctuconnect.dto.response.InteractionResponse;&#10;import com.ctuconnect.entity.InteractionEntity;&#10;import com.ctuconnect.entity.PostEntity;&#10;import com.ctuconnect.repository.InteractionRepository;&#10;import com.ctuconnect.repository.PostRepository;&#10;&#10;import java.util.Objects;&#10;import java.util.Optional;&#10;import java.util.List;&#10;&#10;@Service&#10;public class InteractionService {&#10;&#10;    @Autowired&#10;    private InteractionRepository interactionRepository;&#10;&#10;    @Autowired&#10;    private PostRepository postRepository;&#10;&#10;    @Autowired&#10;    private UserServiceClient userServiceClient;&#10;&#10;    @Autowired&#10;    private EventService eventService;&#10;&#10;    /**&#10;     * Create or toggle interaction (like/bookmark)&#10;     * Fixed to properly handle state persistence and prevent duplicates&#10;     */&#10;    public InteractionResponse createInteraction(String postId, InteractionRequest request, String authorId) {&#10;        AuthorInfo author = userServiceClient.getAuthorInfo(authorId);&#10;        if (author == null) {&#10;            throw new RuntimeException(&quot;Author not found with id: &quot; + authorId);&#10;        }&#10;&#10;        PostEntity post = postRepository.findById(postId)&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;Post not found with id: &quot; + postId));&#10;&#10;        // For reaction-based interactions, check if user already has ANY reaction on this post&#10;        if (request.getReaction() == InteractionEntity.InteractionType.LIKE ||&#10;            request.getReaction() == InteractionEntity.InteractionType.REACTION) {&#10;&#10;            // Remove any existing reactions from this user on this post&#10;            List&lt;InteractionEntity&gt; existingReactions = interactionRepository&#10;                    .findByPostIdAndAuthor_Id(postId, authorId);&#10;&#10;            for (InteractionEntity existing : existingReactions) {&#10;                if (existing.isLike() || existing.isReaction()) {&#10;                    interactionRepository.delete(existing);&#10;                    updatePostStatsOnRemove(post, existing.getType());&#10;                }&#10;            }&#10;&#10;            // Check if this is the same reaction being toggled off&#10;            boolean sameReaction = existingReactions.stream()&#10;                    .anyMatch(existing -&gt; isSameReaction(existing, request));&#10;&#10;            if (sameReaction) {&#10;                // Same reaction clicked again - just remove it (toggle off)&#10;                postRepository.save(post);&#10;                eventService.publishInteractionEvent(postId, authorId, &quot;UN-&quot; + request.getReaction().toString());&#10;                return new InteractionResponse(false, &quot;Reaction removed&quot;);&#10;            }&#10;        } else {&#10;            // For non-reaction interactions (bookmark, share, etc.), check for exact match&#10;            Optional&lt;InteractionEntity&gt; existingInteraction = interactionRepository&#10;                    .findByPostIdAndAuthor_IdAndType(postId, authorId, request.getReaction());&#10;&#10;            if (existingInteraction.isPresent()) {&#10;                // Toggle off the exact interaction&#10;                interactionRepository.delete(existingInteraction.get());&#10;                updatePostStatsOnRemove(post, request.getReaction());&#10;                postRepository.save(post);&#10;                eventService.publishInteractionEvent(postId, authorId, &quot;UN-&quot; + request.getReaction().toString());&#10;                return new InteractionResponse(false, &quot;Interaction removed&quot;);&#10;            }&#10;        }&#10;&#10;        // Create new interaction&#10;        InteractionEntity interaction;&#10;        if (request.getReactionType() != null) {&#10;            interaction = new InteractionEntity(postId, author, request.getReaction(), request.getReactionType());&#10;        } else {&#10;            interaction = new InteractionEntity(postId, author, request.getReaction());&#10;        }&#10;&#10;        if (request.getMetadata() != null) {&#10;            interaction.setMetadata(request.getMetadata());&#10;        }&#10;&#10;        InteractionEntity saved = interactionRepository.save(interaction);&#10;&#10;        // Update post stats&#10;        updatePostStatsOnAdd(post, request.getReaction());&#10;        postRepository.save(post);&#10;&#10;        eventService.publishInteractionEvent(postId, authorId, request.getReaction().toString());&#10;        return new InteractionResponse(saved);&#10;    }&#10;&#10;    private boolean isSameReaction(InteractionEntity existing, InteractionRequest request) {&#10;        if (existing.getType() == InteractionEntity.InteractionType.LIKE &amp;&amp;&#10;            request.getReaction() == InteractionEntity.InteractionType.LIKE) {&#10;            return true;&#10;        }&#10;        if (existing.getType() == InteractionEntity.InteractionType.REACTION &amp;&amp;&#10;            request.getReaction() == InteractionEntity.InteractionType.REACTION) {&#10;            return Objects.equals(existing.getReactionType(), request.getReactionType());&#10;        }&#10;        return false;&#10;    }&#10;&#10;    /**&#10;     * Get user's interaction status for a post&#10;     */&#10;    public InteractionResponse getUserInteractionStatus(String postId, String userId) {&#10;        List&lt;InteractionEntity&gt; userInteractions = interactionRepository.findByPostIdAndAuthor_Id(postId, userId);&#10;&#10;        if (userInteractions.isEmpty()) {&#10;            return new InteractionResponse(false, &quot;No interactions found&quot;);&#10;        }&#10;&#10;        // Return the most recent interaction&#10;        InteractionEntity mostRecent = userInteractions.stream()&#10;                .max((i1, i2) -&gt; i1.getCreatedAt().compareTo(i2.getCreatedAt()))&#10;                .orElse(userInteractions.get(0));&#10;&#10;        return new InteractionResponse(mostRecent);&#10;    }&#10;&#10;    /**&#10;     * Check if user has liked a specific post&#10;     */&#10;    public boolean hasUserLikedPost(String postId, String userId) {&#10;        List&lt;InteractionEntity&gt; interactions = interactionRepository.findByPostIdAndAuthor_Id(postId, userId);&#10;        return interactions.stream().anyMatch(InteractionEntity::isLike);&#10;    }&#10;&#10;    /**&#10;     * Check if user has bookmarked a specific post&#10;     */&#10;    public boolean hasUserBookmarkedPost(String postId, String userId) {&#10;        List&lt;InteractionEntity&gt; interactions = interactionRepository.findByPostIdAndAuthor_Id(postId, userId);&#10;        return interactions.stream().anyMatch(InteractionEntity::isBookmark);&#10;    }&#10;&#10;    private void updatePostStatsOnAdd(PostEntity post, InteractionEntity.InteractionType type) {&#10;        switch (type) {&#10;            case LIKE:&#10;                post.getStats().incrementReaction(InteractionEntity.ReactionType.LIKE);&#10;                break;&#10;            case BOOKMARK:&#10;                // Handle bookmark stats if needed&#10;                break;&#10;            case SHARE:&#10;                post.getStats().incrementShares();&#10;                break;&#10;            case VIEW:&#10;                post.getStats().incrementViews();&#10;                break;&#10;            case COMMENT:&#10;                post.getStats().incrementComments();&#10;                break;&#10;            default:&#10;                break;&#10;        }&#10;    }&#10;&#10;    private void updatePostStatsOnRemove(PostEntity post, InteractionEntity.InteractionType type) {&#10;        switch (type) {&#10;            case LIKE:&#10;                post.getStats().decrementReaction(InteractionEntity.ReactionType.LIKE);&#10;                break;&#10;            case BOOKMARK:&#10;                // Handle bookmark stats if needed&#10;                break;&#10;            case SHARE:&#10;                post.getStats().decrementShares();&#10;                break;&#10;            case COMMENT:&#10;                post.getStats().decrementComments();&#10;                break;&#10;            default:&#10;                break;&#10;        }&#10;    }&#10;&#10;    public long getInteractionCount(String postId, InteractionEntity.InteractionType type) {&#10;        return interactionRepository.countByPostIdAndType(postId, type);&#10;    }&#10;&#10;    /**&#10;     * Check if user has reacted to a post (for legacy compatibility)&#10;     */&#10;    public boolean hasUserReacted(String postId, String userId) {&#10;        return hasUserLikedPost(postId, userId);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/service/PostService.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/service/PostService.java" />
              <option name="originalContent" value="package com.ctuconnect.service;&#10;&#10;import org.springframework.beans.factory.annotation.Autowired;&#10;import org.springframework.data.domain.Page;&#10;import org.springframework.data.domain.Pageable;&#10;import org.springframework.stereotype.Service;&#10;import org.springframework.web.multipart.MultipartFile;&#10;import com.ctuconnect.client.MediaServiceClient;&#10;import com.ctuconnect.client.UserServiceClient;&#10;import com.ctuconnect.dto.AuthorInfo;&#10;import com.ctuconnect.dto.request.PostRequest;&#10;import com.ctuconnect.dto.request.ScheduledPostRequest;&#10;import com.ctuconnect.dto.response.PostResponse;&#10;import com.ctuconnect.dto.response.PostAnalyticsResponse;&#10;import com.ctuconnect.entity.InteractionEntity;&#10;import com.ctuconnect.entity.PostEntity;&#10;import com.ctuconnect.entity.CommentEntity;&#10;import com.ctuconnect.repository.CommentRepository;&#10;import com.ctuconnect.repository.InteractionRepository;&#10;import com.ctuconnect.repository.PostRepository;&#10;import com.ctuconnect.security.AuthenticatedUser;&#10;&#10;import java.util.ArrayList;&#10;import java.util.HashSet;&#10;import java.util.List;&#10;import java.util.Optional;&#10;import java.util.Set;&#10;import java.util.stream.Collectors;&#10;&#10;@Service&#10;public class PostService {&#10;&#10;    @Autowired&#10;    private PostRepository postRepository;&#10;&#10;    @Autowired&#10;    private CommentRepository commentRepository;&#10;&#10;    @Autowired&#10;    private InteractionRepository interactionRepository;&#10;&#10;    @Autowired&#10;    private MediaServiceClient mediaServiceClient;&#10;&#10;    @Autowired&#10;    private UserServiceClient userServiceClient;&#10;&#10;    @Autowired&#10;    private EventService eventService;&#10;&#10;    public PostResponse createPost(PostRequest request, List&lt;MultipartFile&gt; files, String authorId) {&#10;        AuthorInfo author = userServiceClient.getAuthorInfo(authorId);&#10;        if (author == null) {&#10;            throw new RuntimeException(&quot;Author not found with id: &quot; + authorId);&#10;        }&#10;&#10;        PostEntity post = PostEntity.builder()&#10;                .title(request.getTitle())&#10;                .content(request.getContent())&#10;                .author(author)&#10;                .images(new ArrayList&lt;&gt;())&#10;                .tags(request.getTags() != null ? request.getTags() : new ArrayList&lt;&gt;())&#10;                .category(request.getCategory())&#10;                .privacy(request.getVisibility() != null ? request.getVisibility() : &quot;PUBLIC&quot;)&#10;                .stats(new PostEntity.PostStats())&#10;                .build();&#10;&#10;        // Upload files to media-service&#10;        if (files != null &amp;&amp; !files.isEmpty()) {&#10;            List&lt;String&gt; imageUrls = new ArrayList&lt;&gt;();&#10;            for (MultipartFile file : files) {&#10;                if (!file.isEmpty()) {&#10;                    try {&#10;                        MediaServiceClient.MediaUploadResponse uploadResponse =&#10;                            mediaServiceClient.uploadFile(file, getFileType(file));&#10;                        imageUrls.add(uploadResponse.getFileUrl());&#10;                    } catch (Exception e) {&#10;                        // Log error but continue processing&#10;                        System.err.println(&quot;Failed to upload file: &quot; + e.getMessage());&#10;                    }&#10;                }&#10;            }&#10;            post.setImages(imageUrls);&#10;        }&#10;&#10;        PostEntity savedPost = postRepository.save(post);&#10;&#10;        // Publish event&#10;        eventService.publishPostEvent(&quot;POST_CREATED&quot;, savedPost.getId(), savedPost.getAuthorId(), savedPost);&#10;&#10;        return new PostResponse(savedPost);&#10;    }&#10;&#10;    public Page&lt;PostResponse&gt; getAllPosts(Pageable pageable) {&#10;        Page&lt;PostEntity&gt; posts = postRepository.findAll(pageable);&#10;        &#10;        // Recalculate stats for each post before returning&#10;        posts.forEach(this::recalculatePostStats);&#10;        postRepository.saveAll(posts.getContent());&#10;        &#10;        return posts.map(PostResponse::new);&#10;    }&#10;&#10;    public Page&lt;PostResponse&gt; getPostsByAuthor(String authorId, Pageable pageable) {&#10;        Page&lt;PostEntity&gt; posts = postRepository.findByAuthor_Id(authorId, pageable);&#10;        &#10;        // Recalculate stats for each post before returning&#10;        posts.forEach(this::recalculatePostStats);&#10;        postRepository.saveAll(posts.getContent());&#10;        &#10;        return posts.map(PostResponse::new);&#10;    }&#10;&#10;    public Page&lt;PostResponse&gt; getPostsByCategory(String category, Pageable pageable) {&#10;        return postRepository.findByCategory(category, pageable)&#10;                .map(PostResponse::new);&#10;    }&#10;&#10;    public Page&lt;PostResponse&gt; searchPosts(String searchTerm, Pageable pageable) {&#10;        return postRepository.findByTitleContainingOrContentContaining(searchTerm, searchTerm, pageable)&#10;                .map(PostResponse::new);&#10;    }&#10;&#10;    public PostResponse getPostById(String id, String currentUserId) {&#10;        Optional&lt;PostEntity&gt; postOpt = postRepository.findById(id);&#10;        if (postOpt.isPresent()) {&#10;            PostEntity post = postOpt.get();&#10;&#10;            // Record view interaction if user is different from author&#10;            if (currentUserId != null &amp;&amp; !currentUserId.equals(post.getAuthorId())) {&#10;                recordViewInteraction(post.getId(), currentUserId);&#10;            }&#10;&#10;            // Recalculate stats from database before returning&#10;            recalculatePostStats(post);&#10;            postRepository.save(post);&#10;            &#10;            return new PostResponse(post);&#10;        }&#10;        throw new RuntimeException(&quot;Post not found with id: &quot; + id);&#10;    }&#10;&#10;    /**&#10;     * Recalculate post stats from actual interactions in database&#10;     * This fixes the issue where stats show 0 even when interactions exist&#10;     */&#10;    private void recalculatePostStats(PostEntity post) {&#10;        // Count actual likes from interactions&#10;        long likeCount = interactionRepository.countByPostIdAndType(post.getId(), InteractionEntity.InteractionType.LIKE);&#10;        long bookmarkCount = interactionRepository.countByPostIdAndType(post.getId(), InteractionEntity.InteractionType.BOOKMARK);&#10;        long shareCount = interactionRepository.countByPostIdAndType(post.getId(), InteractionEntity.InteractionType.SHARE);&#10;        &#10;        // Count comments&#10;        long commentCount = commentRepository.countByPostId(post.getId());&#10;        &#10;        // Update post stats&#10;        post.getStats().setLikes(likeCount);&#10;        post.getStats().setComments(commentCount); &#10;        post.getStats().setShares(shareCount);&#10;        &#10;        // Update reactions map for LIKE type&#10;        post.getStats().getReactions().put(InteractionEntity.ReactionType.LIKE, (int) likeCount);&#10;    }&#10;&#10;    public PostResponse updatePost(String id, PostRequest request, String authorId) {&#10;        Optional&lt;PostEntity&gt; postOpt = postRepository.findById(id);&#10;        if (postOpt.isPresent()) {&#10;            PostEntity post = postOpt.get();&#10;&#10;            // Check if user is the author&#10;            if (!post.getAuthorId().equals(authorId)) {&#10;                throw new RuntimeException(&quot;Only the author can update this post&quot;);&#10;            }&#10;&#10;            if (request.getTitle() != null) {&#10;                post.setTitle(request.getTitle());&#10;            }&#10;            if (request.getContent() != null) {&#10;                post.setContent(request.getContent());&#10;            }&#10;            if (request.getTags() != null) {&#10;                post.setTags(request.getTags());&#10;            }&#10;            if (request.getCategory() != null) {&#10;                post.setCategory(request.getCategory());&#10;            }&#10;            if (request.getVisibility() != null) {&#10;                post.setVisibility(request.getVisibility());&#10;            }&#10;&#10;            PostEntity savedPost = postRepository.save(post);&#10;&#10;            // Publish event&#10;            eventService.publishPostEvent(&quot;POST_UPDATED&quot;, savedPost.getId(), savedPost.getAuthorId(), savedPost);&#10;&#10;            return new PostResponse(savedPost);&#10;        }&#10;        throw new RuntimeException(&quot;Post not found with id: &quot; + id);&#10;    }&#10;&#10;    public void deletePost(String id, String authorId) {&#10;        Optional&lt;PostEntity&gt; postOpt = postRepository.findById(id);&#10;        if (postOpt.isPresent()) {&#10;            PostEntity post = postOpt.get();&#10;&#10;            // Check if user is the author&#10;            if (!post.getAuthorId().equals(authorId)) {&#10;                throw new RuntimeException(&quot;Only the author can delete this post&quot;);&#10;            }&#10;&#10;            // Delete associated comments and interactions&#10;            commentRepository.deleteByPostId(id);&#10;            interactionRepository.deleteByPostId(id);&#10;&#10;            // Delete the post&#10;            postRepository.deleteById(id);&#10;&#10;            // Publish event&#10;            eventService.publishPostEvent(&quot;POST_DELETED&quot;, id, authorId, post);&#10;        } else {&#10;            throw new RuntimeException(&quot;Post not found with id: &quot; + id);&#10;        }&#10;    }&#10;&#10;    private void recordViewInteraction(String postId, String userId) {&#10;        try {&#10;            AuthorInfo author = userServiceClient.getAuthorInfo(userId);&#10;            if (author == null) return;&#10;&#10;            // Check if user already viewed this post recently (within last hour)&#10;            Optional&lt;InteractionEntity&gt; existingView = interactionRepository&#10;                    .findByPostIdAndAuthor_IdAndType(postId, userId, InteractionEntity.InteractionType.VIEW);&#10;&#10;            if (existingView.isEmpty()) {&#10;                // Create view interaction&#10;                InteractionEntity viewInteraction = new InteractionEntity(postId, author, InteractionEntity.InteractionType.VIEW);&#10;                interactionRepository.save(viewInteraction);&#10;&#10;                // Update post stats&#10;                Optional&lt;PostEntity&gt; postOpt = postRepository.findById(postId);&#10;                if (postOpt.isPresent()) {&#10;                    PostEntity post = postOpt.get();&#10;                    post.getStats().incrementViews();&#10;                    postRepository.save(post);&#10;                }&#10;&#10;                // Publish interaction event&#10;                eventService.publishInteractionEvent(postId, userId, &quot;VIEW&quot;);&#10;            }&#10;        } catch (Exception e) {&#10;            // Log error but don't fail the main operation&#10;            System.err.println(&quot;Failed to record view interaction: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    private String getFileType(MultipartFile file) {&#10;        String contentType = file.getContentType();&#10;        if (contentType != null) {&#10;            if (contentType.startsWith(&quot;image/&quot;)) return &quot;IMAGE&quot;;&#10;            if (contentType.startsWith(&quot;video/&quot;)) return &quot;VIDEO&quot;;&#10;            if (contentType.startsWith(&quot;audio/&quot;)) return &quot;AUDIO&quot;;&#10;            if (contentType.equals(&quot;application/pdf&quot;)) return &quot;PDF&quot;;&#10;        }&#10;        return &quot;DOCUMENT&quot;;&#10;    }&#10;&#10;    public List&lt;PostResponse&gt; getTopViewedPosts() {&#10;        return postRepository.findTop10ByOrderByStatsViewsDesc()&#10;                .stream()&#10;                .map(PostResponse::new)&#10;                .toList();&#10;    }&#10;&#10;    public List&lt;PostResponse&gt; getTopLikedPosts() {&#10;        return postRepository.findTop10ByOrderByStatsLikesDesc()&#10;                .stream()&#10;                .map(PostResponse::new)&#10;                .toList();&#10;    }&#10;&#10;    /**&#10;     * Enhanced post creation with Facebook-like features&#10;     */&#10;    public PostResponse createEnhancedPost(PostRequest request, AuthenticatedUser user) {&#10;        AuthorInfo author = userServiceClient.getAuthorInfo(user.getId());&#10;        if (author == null) {&#10;            throw new RuntimeException(&quot;Author not found with id: &quot; + user.getId());&#10;        }&#10;&#10;        PostEntity post = PostEntity.builder()&#10;                .title(request.getTitle())&#10;                .content(request.getContent())&#10;                .author(author)&#10;                .images(request.getImages() != null ? request.getImages() : new ArrayList&lt;&gt;())&#10;                .videos(request.getVideos() != null ? request.getVideos() : new ArrayList&lt;&gt;())&#10;                .tags(request.getTags() != null ? request.getTags() : new ArrayList&lt;&gt;())&#10;                .category(request.getCategory())&#10;                .privacy(request.getVisibility() != null ? request.getVisibility() : &quot;PUBLIC&quot;)&#10;                .postType(request.getPostType() != null ? PostEntity.PostType.valueOf(request.getPostType()) : PostEntity.PostType.TEXT)&#10;                .stats(new PostEntity.PostStats())&#10;                .audienceSettings(new PostEntity.AudienceSettings())&#10;                .engagement(new PostEntity.EngagementMetrics())&#10;                .build();&#10;&#10;        // Set audience settings if provided&#10;        if (request.getAudienceSettings() != null) {&#10;            post.setAudienceSettings(request.getAudienceSettings());&#10;        }&#10;&#10;        // Handle scheduled posts&#10;        if (request.getScheduledAt() != null) {&#10;            post.setScheduledAt(request.getScheduledAt());&#10;            post.setScheduled(true);&#10;        }&#10;&#10;        PostEntity savedPost = postRepository.save(post);&#10;&#10;        // Publish event&#10;        eventService.publishPostEvent(&quot;POST_CREATED&quot;, savedPost.getId(), savedPost.getAuthorId(), savedPost);&#10;&#10;        return new PostResponse(savedPost);&#10;    }&#10;&#10;    /**&#10;     * Get users affected by a post (for cache invalidation)&#10;     */&#10;    public Set&lt;String&gt; getAffectedUserIds(String postId) {&#10;        Optional&lt;PostEntity&gt; postOpt = postRepository.findById(postId);&#10;        if (postOpt.isPresent()) {&#10;            PostEntity post = postOpt.get();&#10;            Set&lt;String&gt; affectedUsers = new HashSet&lt;&gt;();&#10;&#10;            // Add author&#10;            affectedUsers.add(post.getAuthorId());&#10;&#10;            // Add friends if post is visible to friends&#10;            if (&quot;FRIENDS&quot;.equals(post.getPrivacy()) || &quot;PUBLIC&quot;.equals(post.getPrivacy())) {&#10;                Set&lt;String&gt; authorFriends = userServiceClient.getFriendIds(post.getAuthorId());&#10;                affectedUsers.addAll(authorFriends);&#10;            }&#10;&#10;            return affectedUsers;&#10;        }&#10;        return new HashSet&lt;&gt;();&#10;    }&#10;&#10;    /**&#10;     * Handle post interactions (like, comment, share)&#10;     */&#10;    public void handlePostInteraction(String postId, String userId, String action, String reactionType) {&#10;        Optional&lt;PostEntity&gt; postOpt = postRepository.findById(postId);&#10;        if (postOpt.isEmpty()) {&#10;            throw new RuntimeException(&quot;Post not found with id: &quot; + postId);&#10;        }&#10;&#10;        PostEntity post = postOpt.get();&#10;        AuthorInfo user = userServiceClient.getAuthorInfo(userId);&#10;        if (user == null) {&#10;            throw new RuntimeException(&quot;User not found with id: &quot; + userId);&#10;        }&#10;&#10;        switch (action.toUpperCase()) {&#10;            case &quot;LIKE&quot;:&#10;                handleLikeInteraction(postId, userId, reactionType, post, user);&#10;                break;&#10;            case &quot;UNLIKE&quot;:&#10;                handleUnlikeInteraction(postId, userId, post);&#10;                break;&#10;            case &quot;SHARE&quot;:&#10;                handleShareInteraction(postId, userId, post, user);&#10;                break;&#10;            default:&#10;                throw new RuntimeException(&quot;Unsupported action: &quot; + action);&#10;        }&#10;&#10;        // Update engagement metrics&#10;        updateEngagementMetrics(post);&#10;        postRepository.save(post);&#10;    }&#10;&#10;    /**&#10;     * Get post author ID&#10;     */&#10;    public String getPostAuthorId(String postId) {&#10;        Optional&lt;PostEntity&gt; postOpt = postRepository.findById(postId);&#10;        if (postOpt.isPresent()) {&#10;            return postOpt.get().getAuthorId();&#10;        }&#10;        throw new RuntimeException(&quot;Post not found with id: &quot; + postId);&#10;    }&#10;&#10;    /**&#10;     * Add comment to post&#10;     */&#10;    public void addComment(String postId, String userId, String content) {&#10;        Optional&lt;PostEntity&gt; postOpt = postRepository.findById(postId);&#10;        if (postOpt.isEmpty()) {&#10;            throw new RuntimeException(&quot;Post not found with id: &quot; + postId);&#10;        }&#10;&#10;        AuthorInfo author = userServiceClient.getAuthorInfo(userId);&#10;        if (author == null) {&#10;            throw new RuntimeException(&quot;User not found with id: &quot; + userId);&#10;        }&#10;&#10;        CommentEntity comment = CommentEntity.builder()&#10;                .postId(postId)&#10;                .author(author)&#10;                .content(content)&#10;                .build();&#10;&#10;        commentRepository.save(comment);&#10;&#10;        // Update post comment count&#10;        PostEntity post = postOpt.get();&#10;        post.getStats().incrementComments();&#10;        updateEngagementMetrics(post);&#10;        postRepository.save(post);&#10;&#10;        // Publish event&#10;        eventService.publishPostEvent(&quot;COMMENT_ADDED&quot;, postId, userId, comment);&#10;    }&#10;&#10;    /**&#10;     * Get post analytics&#10;     */&#10;    public PostAnalyticsResponse getPostAnalytics(String postId, String userId) {&#10;        Optional&lt;PostEntity&gt; postOpt = postRepository.findById(postId);&#10;        if (postOpt.isEmpty()) {&#10;            throw new RuntimeException(&quot;Post not found with id: &quot; + postId);&#10;        }&#10;&#10;        PostEntity post = postOpt.get();&#10;&#10;        // Check if user is the post author&#10;        if (!post.getAuthorId().equals(userId)) {&#10;            throw new RuntimeException(&quot;Only post author can view analytics&quot;);&#10;        }&#10;&#10;        return PostAnalyticsResponse.builder()&#10;                .postId(postId)&#10;                .views(post.getStats().getViews())&#10;                .likes(post.getStats().getLikes())&#10;                .comments(post.getStats().getComments())&#10;                .shares(post.getStats().getShares())&#10;                .engagementRate(post.getEngagement().getEngagementRate())&#10;                .reactions(post.getStats().getReactions())&#10;                .build();&#10;    }&#10;&#10;    /**&#10;     * Schedule post for later publishing&#10;     */&#10;    public PostResponse schedulePost(ScheduledPostRequest request, AuthenticatedUser user) {&#10;        AuthorInfo author = userServiceClient.getAuthorInfo(user.getId());&#10;        if (author == null) {&#10;            throw new RuntimeException(&quot;Author not found with id: &quot; + user.getId());&#10;        }&#10;&#10;        PostEntity post = PostEntity.builder()&#10;                .title(request.getTitle())&#10;                .content(request.getContent())&#10;                .author(author)&#10;                .images(request.getImages() != null ? request.getImages() : new ArrayList&lt;&gt;())&#10;                .tags(request.getTags() != null ? request.getTags() : new ArrayList&lt;&gt;())&#10;                .category(request.getCategory())&#10;                .privacy(request.getVisibility() != null ? request.getVisibility() : &quot;PUBLIC&quot;)&#10;                .scheduledAt(request.getScheduledAt())&#10;                .isScheduled(true)&#10;                .stats(new PostEntity.PostStats())&#10;                .build();&#10;&#10;        PostEntity savedPost = postRepository.save(post);&#10;        return new PostResponse(savedPost);&#10;    }&#10;&#10;    /**&#10;     * Enhanced search with filters&#10;     */&#10;    public List&lt;PostResponse&gt; searchPosts(String query, String category, String faculty,&#10;                                        String dateRange, Pageable pageable) {&#10;        // This would need to be implemented with proper MongoDB queries&#10;        // For now, implementing basic search&#10;        Page&lt;PostEntity&gt; posts;&#10;&#10;        if (category != null &amp;&amp; !category.isEmpty()) {&#10;            posts = postRepository.findByCategoryAndTitleContainingOrContentContaining(&#10;                category, query, query, pageable);&#10;        } else {&#10;            posts = postRepository.findByTitleContainingOrContentContaining(query, query, pageable);&#10;        }&#10;&#10;        return posts.stream()&#10;                .map(PostResponse::new)&#10;                .collect(Collectors.toList());&#10;    }&#10;&#10;    /**&#10;     * Update author information in posts (for data consistency)&#10;     */&#10;    public void updateAuthorInfoInPosts(String userId, String fullName, String avatarUrl) {&#10;        List&lt;PostEntity&gt; userPosts = postRepository.findByAuthor_Id(userId);&#10;&#10;        for (PostEntity post : userPosts) {&#10;            AuthorInfo updatedAuthor = post.getAuthor();&#10;            updatedAuthor.setFullName(fullName);&#10;            updatedAuthor.setAvatarUrl(avatarUrl);&#10;            post.setAuthor(updatedAuthor);&#10;        }&#10;&#10;        if (!userPosts.isEmpty()) {&#10;            postRepository.saveAll(userPosts);&#10;        }&#10;    }&#10;&#10;    // Helper methods&#10;    private void handleLikeInteraction(String postId, String userId, String reactionType,&#10;                                     PostEntity post, AuthorInfo user) {&#10;        InteractionEntity.ReactionType reaction =&#10;            reactionType != null ?&#10;            InteractionEntity.ReactionType.valueOf(reactionType.toUpperCase()) :&#10;            InteractionEntity.ReactionType.LIKE;&#10;&#10;        // Check if user already reacted&#10;        Optional&lt;InteractionEntity&gt; existingInteraction = interactionRepository&#10;                .findByPostIdAndAuthor_IdAndType(postId, userId, InteractionEntity.InteractionType.REACTION);&#10;&#10;        if (existingInteraction.isEmpty()) {&#10;            // Create new reaction&#10;            InteractionEntity interaction = InteractionEntity.builder()&#10;                    .postId(postId)&#10;                    .author(user)&#10;                    .type(InteractionEntity.InteractionType.REACTION)&#10;                    .reactionType(reaction)&#10;                    .build();&#10;&#10;            interactionRepository.save(interaction);&#10;            post.getStats().incrementReaction(reaction);&#10;        }&#10;    }&#10;&#10;    private void handleUnlikeInteraction(String postId, String userId, PostEntity post) {&#10;        Optional&lt;InteractionEntity&gt; existingInteraction = interactionRepository&#10;                .findByPostIdAndAuthor_IdAndType(postId, userId, InteractionEntity.InteractionType.REACTION);&#10;&#10;        if (existingInteraction.isPresent()) {&#10;            InteractionEntity interaction = existingInteraction.get();&#10;            post.getStats().decrementReaction(interaction.getReactionType());&#10;            interactionRepository.delete(interaction);&#10;        }&#10;    }&#10;&#10;    private void handleShareInteraction(String postId, String userId, PostEntity post, AuthorInfo user) {&#10;        InteractionEntity interaction = InteractionEntity.builder()&#10;                .postId(postId)&#10;                .author(user)&#10;                .type(InteractionEntity.InteractionType.SHARE)&#10;                .build();&#10;&#10;        interactionRepository.save(interaction);&#10;        post.getStats().incrementShares();&#10;    }&#10;&#10;    private void updateEngagementMetrics(PostEntity post) {&#10;        PostEntity.EngagementMetrics engagement = post.getEngagement();&#10;        PostEntity.PostStats stats = post.getStats();&#10;&#10;        engagement.updateEngagement(&#10;            (int) stats.getLikes(),&#10;            (int) stats.getComments(),&#10;            (int) stats.getShares(),&#10;            (int) stats.getViews()&#10;        );&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.ctuconnect.service;&#13;&#10;&#13;&#10;import org.springframework.beans.factory.annotation.Autowired;&#13;&#10;import org.springframework.data.domain.Page;&#13;&#10;import org.springframework.data.domain.Pageable;&#13;&#10;import org.springframework.stereotype.Service;&#13;&#10;import org.springframework.web.multipart.MultipartFile;&#13;&#10;import com.ctuconnect.client.MediaServiceClient;&#13;&#10;import com.ctuconnect.client.UserServiceClient;&#13;&#10;import com.ctuconnect.dto.AuthorInfo;&#13;&#10;import com.ctuconnect.dto.request.PostRequest;&#13;&#10;import com.ctuconnect.dto.request.ScheduledPostRequest;&#13;&#10;import com.ctuconnect.dto.response.PostResponse;&#13;&#10;import com.ctuconnect.dto.response.PostAnalyticsResponse;&#13;&#10;import com.ctuconnect.entity.InteractionEntity;&#13;&#10;import com.ctuconnect.entity.PostEntity;&#13;&#10;import com.ctuconnect.entity.CommentEntity;&#13;&#10;import com.ctuconnect.repository.CommentRepository;&#13;&#10;import com.ctuconnect.repository.InteractionRepository;&#13;&#10;import com.ctuconnect.repository.PostRepository;&#13;&#10;import com.ctuconnect.security.AuthenticatedUser;&#13;&#10;&#13;&#10;import java.util.ArrayList;&#13;&#10;import java.util.HashSet;&#13;&#10;import java.util.List;&#13;&#10;import java.util.Optional;&#13;&#10;import java.util.Set;&#13;&#10;import java.util.stream.Collectors;&#13;&#10;&#13;&#10;@Service&#13;&#10;public class PostService {&#13;&#10;&#13;&#10;    @Autowired&#13;&#10;    private PostRepository postRepository;&#13;&#10;&#13;&#10;    @Autowired&#13;&#10;    private CommentRepository commentRepository;&#13;&#10;&#13;&#10;    @Autowired&#13;&#10;    private InteractionRepository interactionRepository;&#13;&#10;&#13;&#10;    @Autowired&#13;&#10;    private MediaServiceClient mediaServiceClient;&#13;&#10;&#13;&#10;    @Autowired&#13;&#10;    private UserServiceClient userServiceClient;&#13;&#10;&#13;&#10;    @Autowired&#13;&#10;    private EventService eventService;&#13;&#10;&#13;&#10;    public PostResponse createPost(PostRequest request, List&lt;MultipartFile&gt; files, String authorId) {&#13;&#10;        AuthorInfo author = userServiceClient.getAuthorInfo(authorId);&#13;&#10;        if (author == null) {&#13;&#10;            throw new RuntimeException(&quot;Author not found with id: &quot; + authorId);&#13;&#10;        }&#13;&#10;&#13;&#10;        PostEntity post = PostEntity.builder()&#13;&#10;                .title(request.getTitle())&#13;&#10;                .content(request.getContent())&#13;&#10;                .author(author)&#13;&#10;                .images(new ArrayList&lt;&gt;())&#13;&#10;                .tags(request.getTags() != null ? request.getTags() : new ArrayList&lt;&gt;())&#13;&#10;                .category(request.getCategory())&#13;&#10;                .privacy(request.getVisibility() != null ? request.getVisibility() : &quot;PUBLIC&quot;)&#13;&#10;                .stats(new PostEntity.PostStats())&#13;&#10;                .build();&#13;&#10;&#13;&#10;        // Upload files to media-service&#13;&#10;        if (files != null &amp;&amp; !files.isEmpty()) {&#13;&#10;            List&lt;String&gt; imageUrls = new ArrayList&lt;&gt;();&#13;&#10;            for (MultipartFile file : files) {&#13;&#10;                if (!file.isEmpty()) {&#13;&#10;                    try {&#13;&#10;                        MediaServiceClient.MediaUploadResponse uploadResponse =&#13;&#10;                            mediaServiceClient.uploadFile(file, getFileType(file));&#13;&#10;                        imageUrls.add(uploadResponse.getFileUrl());&#13;&#10;                    } catch (Exception e) {&#13;&#10;                        // Log error but continue processing&#13;&#10;                        System.err.println(&quot;Failed to upload file: &quot; + e.getMessage());&#13;&#10;                    }&#13;&#10;                }&#13;&#10;            }&#13;&#10;            post.setImages(imageUrls);&#13;&#10;        }&#13;&#10;&#13;&#10;        PostEntity savedPost = postRepository.save(post);&#13;&#10;&#13;&#10;        // Publish event&#13;&#10;        eventService.publishPostEvent(&quot;POST_CREATED&quot;, savedPost.getId(), savedPost.getAuthorId(), savedPost);&#13;&#10;&#13;&#10;        return new PostResponse(savedPost);&#13;&#10;    }&#13;&#10;&#13;&#10;    public Page&lt;PostResponse&gt; getAllPosts(Pageable pageable) {&#13;&#10;        Page&lt;PostEntity&gt; posts = postRepository.findAll(pageable);&#13;&#10;        &#13;&#10;        // Recalculate stats for each post before returning&#13;&#10;        posts.forEach(this::recalculatePostStats);&#13;&#10;        postRepository.saveAll(posts.getContent());&#13;&#10;        &#13;&#10;        return posts.map(PostResponse::new);&#13;&#10;    }&#13;&#10;&#13;&#10;    public Page&lt;PostResponse&gt; getPostsByAuthor(String authorId, Pageable pageable) {&#13;&#10;        System.out.println(&quot;DEBUG: PostService.getPostsByAuthor called with authorId: &quot; + authorId);&#13;&#10;        &#13;&#10;        Page&lt;PostEntity&gt; posts = postRepository.findByAuthor_Id(authorId, pageable);&#13;&#10;        System.out.println(&quot;DEBUG: Repository query returned &quot; + posts.getTotalElements() + &quot; posts&quot;);&#13;&#10;        &#13;&#10;        // Debug first few posts from repository&#13;&#10;        posts.getContent().stream().limit(3).forEach(post -&gt; {&#13;&#10;            System.out.println(&quot;DEBUG: Repository returned post ID: &quot; + post.getId() + &#13;&#10;                &quot;, Author ID: &quot; + (post.getAuthor() != null ? post.getAuthor().getId() : &quot;null&quot;) +&#13;&#10;                &quot;, Author Name: &quot; + (post.getAuthor() != null ? post.getAuthor().getName() : &quot;null&quot;));&#13;&#10;        });&#13;&#10;        &#13;&#10;        // Recalculate stats for each post before returning&#13;&#10;        posts.forEach(this::recalculatePostStats);&#13;&#10;        postRepository.saveAll(posts.getContent());&#13;&#10;        &#13;&#10;        return posts.map(PostResponse::new);&#13;&#10;    }&#13;&#10;&#13;&#10;    public Page&lt;PostResponse&gt; getPostsByCategory(String category, Pageable pageable) {&#13;&#10;        return postRepository.findByCategory(category, pageable)&#13;&#10;                .map(PostResponse::new);&#13;&#10;    }&#13;&#10;&#13;&#10;    public Page&lt;PostResponse&gt; searchPosts(String searchTerm, Pageable pageable) {&#13;&#10;        return postRepository.findByTitleContainingOrContentContaining(searchTerm, searchTerm, pageable)&#13;&#10;                .map(PostResponse::new);&#13;&#10;    }&#13;&#10;&#13;&#10;    public PostResponse getPostById(String id, String currentUserId) {&#13;&#10;        Optional&lt;PostEntity&gt; postOpt = postRepository.findById(id);&#13;&#10;        if (postOpt.isPresent()) {&#13;&#10;            PostEntity post = postOpt.get();&#13;&#10;&#13;&#10;            // Record view interaction if user is different from author&#13;&#10;            if (currentUserId != null &amp;&amp; !currentUserId.equals(post.getAuthorId())) {&#13;&#10;                recordViewInteraction(post.getId(), currentUserId);&#13;&#10;            }&#13;&#10;&#13;&#10;            // Recalculate stats from database before returning&#13;&#10;            recalculatePostStats(post);&#13;&#10;            postRepository.save(post);&#13;&#10;            &#13;&#10;            return new PostResponse(post);&#13;&#10;        }&#13;&#10;        throw new RuntimeException(&quot;Post not found with id: &quot; + id);&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Recalculate post stats from actual interactions in database&#13;&#10;     * This fixes the issue where stats show 0 even when interactions exist&#13;&#10;     */&#13;&#10;    private void recalculatePostStats(PostEntity post) {&#13;&#10;        // Count actual likes from interactions&#13;&#10;        long likeCount = interactionRepository.countByPostIdAndType(post.getId(), InteractionEntity.InteractionType.LIKE);&#13;&#10;        long bookmarkCount = interactionRepository.countByPostIdAndType(post.getId(), InteractionEntity.InteractionType.BOOKMARK);&#13;&#10;        long shareCount = interactionRepository.countByPostIdAndType(post.getId(), InteractionEntity.InteractionType.SHARE);&#13;&#10;        &#13;&#10;        // Count comments&#13;&#10;        long commentCount = commentRepository.countByPostId(post.getId());&#13;&#10;        &#13;&#10;        // Update post stats&#13;&#10;        post.getStats().setLikes(likeCount);&#13;&#10;        post.getStats().setComments(commentCount); &#13;&#10;        post.getStats().setShares(shareCount);&#13;&#10;        &#13;&#10;        // Update reactions map for LIKE type&#13;&#10;        post.getStats().getReactions().put(InteractionEntity.ReactionType.LIKE, (int) likeCount);&#13;&#10;    }&#13;&#10;&#13;&#10;    public PostResponse updatePost(String id, PostRequest request, String authorId) {&#13;&#10;        Optional&lt;PostEntity&gt; postOpt = postRepository.findById(id);&#13;&#10;        if (postOpt.isPresent()) {&#13;&#10;            PostEntity post = postOpt.get();&#13;&#10;&#13;&#10;            // Check if user is the author&#13;&#10;            if (!post.getAuthorId().equals(authorId)) {&#13;&#10;                throw new RuntimeException(&quot;Only the author can update this post&quot;);&#13;&#10;            }&#13;&#10;&#13;&#10;            if (request.getTitle() != null) {&#13;&#10;                post.setTitle(request.getTitle());&#13;&#10;            }&#13;&#10;            if (request.getContent() != null) {&#13;&#10;                post.setContent(request.getContent());&#13;&#10;            }&#13;&#10;            if (request.getTags() != null) {&#13;&#10;                post.setTags(request.getTags());&#13;&#10;            }&#13;&#10;            if (request.getCategory() != null) {&#13;&#10;                post.setCategory(request.getCategory());&#13;&#10;            }&#13;&#10;            if (request.getVisibility() != null) {&#13;&#10;                post.setVisibility(request.getVisibility());&#13;&#10;            }&#13;&#10;&#13;&#10;            PostEntity savedPost = postRepository.save(post);&#13;&#10;&#13;&#10;            // Publish event&#13;&#10;            eventService.publishPostEvent(&quot;POST_UPDATED&quot;, savedPost.getId(), savedPost.getAuthorId(), savedPost);&#13;&#10;&#13;&#10;            return new PostResponse(savedPost);&#13;&#10;        }&#13;&#10;        throw new RuntimeException(&quot;Post not found with id: &quot; + id);&#13;&#10;    }&#13;&#10;&#13;&#10;    public void deletePost(String id, String authorId) {&#13;&#10;        Optional&lt;PostEntity&gt; postOpt = postRepository.findById(id);&#13;&#10;        if (postOpt.isPresent()) {&#13;&#10;            PostEntity post = postOpt.get();&#13;&#10;&#13;&#10;            // Check if user is the author&#13;&#10;            if (!post.getAuthorId().equals(authorId)) {&#13;&#10;                throw new RuntimeException(&quot;Only the author can delete this post&quot;);&#13;&#10;            }&#13;&#10;&#13;&#10;            // Delete associated comments and interactions&#13;&#10;            commentRepository.deleteByPostId(id);&#13;&#10;            interactionRepository.deleteByPostId(id);&#13;&#10;&#13;&#10;            // Delete the post&#13;&#10;            postRepository.deleteById(id);&#13;&#10;&#13;&#10;            // Publish event&#13;&#10;            eventService.publishPostEvent(&quot;POST_DELETED&quot;, id, authorId, post);&#13;&#10;        } else {&#13;&#10;            throw new RuntimeException(&quot;Post not found with id: &quot; + id);&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    private void recordViewInteraction(String postId, String userId) {&#13;&#10;        try {&#13;&#10;            AuthorInfo author = userServiceClient.getAuthorInfo(userId);&#13;&#10;            if (author == null) return;&#13;&#10;&#13;&#10;            // Check if user already viewed this post recently (within last hour)&#13;&#10;            Optional&lt;InteractionEntity&gt; existingView = interactionRepository&#13;&#10;                    .findByPostIdAndAuthor_IdAndType(postId, userId, InteractionEntity.InteractionType.VIEW);&#13;&#10;&#13;&#10;            if (existingView.isEmpty()) {&#13;&#10;                // Create view interaction&#13;&#10;                InteractionEntity viewInteraction = new InteractionEntity(postId, author, InteractionEntity.InteractionType.VIEW);&#13;&#10;                interactionRepository.save(viewInteraction);&#13;&#10;&#13;&#10;                // Update post stats&#13;&#10;                Optional&lt;PostEntity&gt; postOpt = postRepository.findById(postId);&#13;&#10;                if (postOpt.isPresent()) {&#13;&#10;                    PostEntity post = postOpt.get();&#13;&#10;                    post.getStats().incrementViews();&#13;&#10;                    postRepository.save(post);&#13;&#10;                }&#13;&#10;&#13;&#10;                // Publish interaction event&#13;&#10;                eventService.publishInteractionEvent(postId, userId, &quot;VIEW&quot;);&#13;&#10;            }&#13;&#10;        } catch (Exception e) {&#13;&#10;            // Log error but don't fail the main operation&#13;&#10;            System.err.println(&quot;Failed to record view interaction: &quot; + e.getMessage());&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    private String getFileType(MultipartFile file) {&#13;&#10;        String contentType = file.getContentType();&#13;&#10;        if (contentType != null) {&#13;&#10;            if (contentType.startsWith(&quot;image/&quot;)) return &quot;IMAGE&quot;;&#13;&#10;            if (contentType.startsWith(&quot;video/&quot;)) return &quot;VIDEO&quot;;&#13;&#10;            if (contentType.startsWith(&quot;audio/&quot;)) return &quot;AUDIO&quot;;&#13;&#10;            if (contentType.equals(&quot;application/pdf&quot;)) return &quot;PDF&quot;;&#13;&#10;        }&#13;&#10;        return &quot;DOCUMENT&quot;;&#13;&#10;    }&#13;&#10;&#13;&#10;    public List&lt;PostResponse&gt; getTopViewedPosts() {&#13;&#10;        return postRepository.findTop10ByOrderByStatsViewsDesc()&#13;&#10;                .stream()&#13;&#10;                .map(PostResponse::new)&#13;&#10;                .toList();&#13;&#10;    }&#13;&#10;&#13;&#10;    public List&lt;PostResponse&gt; getTopLikedPosts() {&#13;&#10;        return postRepository.findTop10ByOrderByStatsLikesDesc()&#13;&#10;                .stream()&#13;&#10;                .map(PostResponse::new)&#13;&#10;                .toList();&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Enhanced post creation with Facebook-like features&#13;&#10;     */&#13;&#10;    public PostResponse createEnhancedPost(PostRequest request, AuthenticatedUser user) {&#13;&#10;        AuthorInfo author = userServiceClient.getAuthorInfo(user.getId());&#13;&#10;        if (author == null) {&#13;&#10;            throw new RuntimeException(&quot;Author not found with id: &quot; + user.getId());&#13;&#10;        }&#13;&#10;&#13;&#10;        PostEntity post = PostEntity.builder()&#13;&#10;                .title(request.getTitle())&#13;&#10;                .content(request.getContent())&#13;&#10;                .author(author)&#13;&#10;                .images(request.getImages() != null ? request.getImages() : new ArrayList&lt;&gt;())&#13;&#10;                .videos(request.getVideos() != null ? request.getVideos() : new ArrayList&lt;&gt;())&#13;&#10;                .tags(request.getTags() != null ? request.getTags() : new ArrayList&lt;&gt;())&#13;&#10;                .category(request.getCategory())&#13;&#10;                .privacy(request.getVisibility() != null ? request.getVisibility() : &quot;PUBLIC&quot;)&#13;&#10;                .postType(request.getPostType() != null ? PostEntity.PostType.valueOf(request.getPostType()) : PostEntity.PostType.TEXT)&#13;&#10;                .stats(new PostEntity.PostStats())&#13;&#10;                .audienceSettings(new PostEntity.AudienceSettings())&#13;&#10;                .engagement(new PostEntity.EngagementMetrics())&#13;&#10;                .build();&#13;&#10;&#13;&#10;        // Set audience settings if provided&#13;&#10;        if (request.getAudienceSettings() != null) {&#13;&#10;            post.setAudienceSettings(request.getAudienceSettings());&#13;&#10;        }&#13;&#10;&#13;&#10;        // Handle scheduled posts&#13;&#10;        if (request.getScheduledAt() != null) {&#13;&#10;            post.setScheduledAt(request.getScheduledAt());&#13;&#10;            post.setScheduled(true);&#13;&#10;        }&#13;&#10;&#13;&#10;        PostEntity savedPost = postRepository.save(post);&#13;&#10;&#13;&#10;        // Publish event&#13;&#10;        eventService.publishPostEvent(&quot;POST_CREATED&quot;, savedPost.getId(), savedPost.getAuthorId(), savedPost);&#13;&#10;&#13;&#10;        return new PostResponse(savedPost);&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Get users affected by a post (for cache invalidation)&#13;&#10;     */&#13;&#10;    public Set&lt;String&gt; getAffectedUserIds(String postId) {&#13;&#10;        Optional&lt;PostEntity&gt; postOpt = postRepository.findById(postId);&#13;&#10;        if (postOpt.isPresent()) {&#13;&#10;            PostEntity post = postOpt.get();&#13;&#10;            Set&lt;String&gt; affectedUsers = new HashSet&lt;&gt;();&#13;&#10;&#13;&#10;            // Add author&#13;&#10;            affectedUsers.add(post.getAuthorId());&#13;&#10;&#13;&#10;            // Add friends if post is visible to friends&#13;&#10;            if (&quot;FRIENDS&quot;.equals(post.getPrivacy()) || &quot;PUBLIC&quot;.equals(post.getPrivacy())) {&#13;&#10;                Set&lt;String&gt; authorFriends = userServiceClient.getFriendIds(post.getAuthorId());&#13;&#10;                affectedUsers.addAll(authorFriends);&#13;&#10;            }&#13;&#10;&#13;&#10;            return affectedUsers;&#13;&#10;        }&#13;&#10;        return new HashSet&lt;&gt;();&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Handle post interactions (like, comment, share)&#13;&#10;     */&#13;&#10;    public void handlePostInteraction(String postId, String userId, String action, String reactionType) {&#13;&#10;        Optional&lt;PostEntity&gt; postOpt = postRepository.findById(postId);&#13;&#10;        if (postOpt.isEmpty()) {&#13;&#10;            throw new RuntimeException(&quot;Post not found with id: &quot; + postId);&#13;&#10;        }&#13;&#10;&#13;&#10;        PostEntity post = postOpt.get();&#13;&#10;        AuthorInfo user = userServiceClient.getAuthorInfo(userId);&#13;&#10;        if (user == null) {&#13;&#10;            throw new RuntimeException(&quot;User not found with id: &quot; + userId);&#13;&#10;        }&#13;&#10;&#13;&#10;        switch (action.toUpperCase()) {&#13;&#10;            case &quot;LIKE&quot;:&#13;&#10;                handleLikeInteraction(postId, userId, reactionType, post, user);&#13;&#10;                break;&#13;&#10;            case &quot;UNLIKE&quot;:&#13;&#10;                handleUnlikeInteraction(postId, userId, post);&#13;&#10;                break;&#13;&#10;            case &quot;SHARE&quot;:&#13;&#10;                handleShareInteraction(postId, userId, post, user);&#13;&#10;                break;&#13;&#10;            default:&#13;&#10;                throw new RuntimeException(&quot;Unsupported action: &quot; + action);&#13;&#10;        }&#13;&#10;&#13;&#10;        // Update engagement metrics&#13;&#10;        updateEngagementMetrics(post);&#13;&#10;        postRepository.save(post);&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Get post author ID&#13;&#10;     */&#13;&#10;    public String getPostAuthorId(String postId) {&#13;&#10;        Optional&lt;PostEntity&gt; postOpt = postRepository.findById(postId);&#13;&#10;        if (postOpt.isPresent()) {&#13;&#10;            return postOpt.get().getAuthorId();&#13;&#10;        }&#13;&#10;        throw new RuntimeException(&quot;Post not found with id: &quot; + postId);&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Add comment to post&#13;&#10;     */&#13;&#10;    public void addComment(String postId, String userId, String content) {&#13;&#10;        Optional&lt;PostEntity&gt; postOpt = postRepository.findById(postId);&#13;&#10;        if (postOpt.isEmpty()) {&#13;&#10;            throw new RuntimeException(&quot;Post not found with id: &quot; + postId);&#13;&#10;        }&#13;&#10;&#13;&#10;        AuthorInfo author = userServiceClient.getAuthorInfo(userId);&#13;&#10;        if (author == null) {&#13;&#10;            throw new RuntimeException(&quot;User not found with id: &quot; + userId);&#13;&#10;        }&#13;&#10;&#13;&#10;        CommentEntity comment = CommentEntity.builder()&#13;&#10;                .postId(postId)&#13;&#10;                .author(author)&#13;&#10;                .content(content)&#13;&#10;                .build();&#13;&#10;&#13;&#10;        commentRepository.save(comment);&#13;&#10;&#13;&#10;        // Update post comment count&#13;&#10;        PostEntity post = postOpt.get();&#13;&#10;        post.getStats().incrementComments();&#13;&#10;        updateEngagementMetrics(post);&#13;&#10;        postRepository.save(post);&#13;&#10;&#13;&#10;        // Publish event&#13;&#10;        eventService.publishPostEvent(&quot;COMMENT_ADDED&quot;, postId, userId, comment);&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Get post analytics&#13;&#10;     */&#13;&#10;    public PostAnalyticsResponse getPostAnalytics(String postId, String userId) {&#13;&#10;        Optional&lt;PostEntity&gt; postOpt = postRepository.findById(postId);&#13;&#10;        if (postOpt.isEmpty()) {&#13;&#10;            throw new RuntimeException(&quot;Post not found with id: &quot; + postId);&#13;&#10;        }&#13;&#10;&#13;&#10;        PostEntity post = postOpt.get();&#13;&#10;&#13;&#10;        // Check if user is the post author&#13;&#10;        if (!post.getAuthorId().equals(userId)) {&#13;&#10;            throw new RuntimeException(&quot;Only post author can view analytics&quot;);&#13;&#10;        }&#13;&#10;&#13;&#10;        return PostAnalyticsResponse.builder()&#13;&#10;                .postId(postId)&#13;&#10;                .views(post.getStats().getViews())&#13;&#10;                .likes(post.getStats().getLikes())&#13;&#10;                .comments(post.getStats().getComments())&#13;&#10;                .shares(post.getStats().getShares())&#13;&#10;                .engagementRate(post.getEngagement().getEngagementRate())&#13;&#10;                .reactions(post.getStats().getReactions())&#13;&#10;                .build();&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Schedule post for later publishing&#13;&#10;     */&#13;&#10;    public PostResponse schedulePost(ScheduledPostRequest request, AuthenticatedUser user) {&#13;&#10;        AuthorInfo author = userServiceClient.getAuthorInfo(user.getId());&#13;&#10;        if (author == null) {&#13;&#10;            throw new RuntimeException(&quot;Author not found with id: &quot; + user.getId());&#13;&#10;        }&#13;&#10;&#13;&#10;        PostEntity post = PostEntity.builder()&#13;&#10;                .title(request.getTitle())&#13;&#10;                .content(request.getContent())&#13;&#10;                .author(author)&#13;&#10;                .images(request.getImages() != null ? request.getImages() : new ArrayList&lt;&gt;())&#13;&#10;                .tags(request.getTags() != null ? request.getTags() : new ArrayList&lt;&gt;())&#13;&#10;                .category(request.getCategory())&#13;&#10;                .privacy(request.getVisibility() != null ? request.getVisibility() : &quot;PUBLIC&quot;)&#13;&#10;                .scheduledAt(request.getScheduledAt())&#13;&#10;                .isScheduled(true)&#13;&#10;                .stats(new PostEntity.PostStats())&#13;&#10;                .build();&#13;&#10;&#13;&#10;        PostEntity savedPost = postRepository.save(post);&#13;&#10;        return new PostResponse(savedPost);&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Enhanced search with filters&#13;&#10;     */&#13;&#10;    public List&lt;PostResponse&gt; searchPosts(String query, String category, String faculty,&#13;&#10;                                        String dateRange, Pageable pageable) {&#13;&#10;        // This would need to be implemented with proper MongoDB queries&#13;&#10;        // For now, implementing basic search&#13;&#10;        Page&lt;PostEntity&gt; posts;&#13;&#10;&#13;&#10;        if (category != null &amp;&amp; !category.isEmpty()) {&#13;&#10;            posts = postRepository.findByCategoryAndTitleContainingOrContentContaining(&#13;&#10;                category, query, query, pageable);&#13;&#10;        } else {&#13;&#10;            posts = postRepository.findByTitleContainingOrContentContaining(query, query, pageable);&#13;&#10;        }&#13;&#10;&#13;&#10;        return posts.stream()&#13;&#10;                .map(PostResponse::new)&#13;&#10;                .collect(Collectors.toList());&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Update author information in posts (for data consistency)&#13;&#10;     */&#13;&#10;    public void updateAuthorInfoInPosts(String userId, String fullName, String avatarUrl) {&#13;&#10;        List&lt;PostEntity&gt; userPosts = postRepository.findByAuthor_Id(userId);&#13;&#10;&#13;&#10;        for (PostEntity post : userPosts) {&#13;&#10;            AuthorInfo updatedAuthor = post.getAuthor();&#13;&#10;            updatedAuthor.setFullName(fullName);&#13;&#10;            updatedAuthor.setAvatarUrl(avatarUrl);&#13;&#10;            post.setAuthor(updatedAuthor);&#13;&#10;        }&#13;&#10;&#13;&#10;        if (!userPosts.isEmpty()) {&#13;&#10;            postRepository.saveAll(userPosts);&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    // Helper methods&#13;&#10;    private void handleLikeInteraction(String postId, String userId, String reactionType,&#13;&#10;                                     PostEntity post, AuthorInfo user) {&#13;&#10;        InteractionEntity.ReactionType reaction =&#13;&#10;            reactionType != null ?&#13;&#10;            InteractionEntity.ReactionType.valueOf(reactionType.toUpperCase()) :&#13;&#10;            InteractionEntity.ReactionType.LIKE;&#13;&#10;&#13;&#10;        // Check if user already reacted&#13;&#10;        Optional&lt;InteractionEntity&gt; existingInteraction = interactionRepository&#13;&#10;                .findByPostIdAndAuthor_IdAndType(postId, userId, InteractionEntity.InteractionType.REACTION);&#13;&#10;&#13;&#10;        if (existingInteraction.isEmpty()) {&#13;&#10;            // Create new reaction&#13;&#10;            InteractionEntity interaction = InteractionEntity.builder()&#13;&#10;                    .postId(postId)&#13;&#10;                    .author(user)&#13;&#10;                    .type(InteractionEntity.InteractionType.REACTION)&#13;&#10;                    .reactionType(reaction)&#13;&#10;                    .build();&#13;&#10;&#13;&#10;            interactionRepository.save(interaction);&#13;&#10;            post.getStats().incrementReaction(reaction);&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    private void handleUnlikeInteraction(String postId, String userId, PostEntity post) {&#13;&#10;        Optional&lt;InteractionEntity&gt; existingInteraction = interactionRepository&#13;&#10;                .findByPostIdAndAuthor_IdAndType(postId, userId, InteractionEntity.InteractionType.REACTION);&#13;&#10;&#13;&#10;        if (existingInteraction.isPresent()) {&#13;&#10;            InteractionEntity interaction = existingInteraction.get();&#13;&#10;            post.getStats().decrementReaction(interaction.getReactionType());&#13;&#10;            interactionRepository.delete(interaction);&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    private void handleShareInteraction(String postId, String userId, PostEntity post, AuthorInfo user) {&#13;&#10;        InteractionEntity interaction = InteractionEntity.builder()&#13;&#10;                .postId(postId)&#13;&#10;                .author(user)&#13;&#10;                .type(InteractionEntity.InteractionType.SHARE)&#13;&#10;                .build();&#13;&#10;&#13;&#10;        interactionRepository.save(interaction);&#13;&#10;        post.getStats().incrementShares();&#13;&#10;    }&#13;&#10;&#13;&#10;    private void updateEngagementMetrics(PostEntity post) {&#13;&#10;        PostEntity.EngagementMetrics engagement = post.getEngagement();&#13;&#10;        PostEntity.PostStats stats = post.getStats();&#13;&#10;&#13;&#10;        engagement.updateEngagement(&#13;&#10;            (int) stats.getLikes(),&#13;&#10;            (int) stats.getComments(),&#13;&#10;            (int) stats.getShares(),&#13;&#10;            (int) stats.getViews()&#13;&#10;        );&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/service/UserServiceClient.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/service/UserServiceClient.java" />
              <option name="updatedContent" value="package com.ctuconnect.service;&#10;&#10;import org.springframework.cloud.openfeign.FeignClient;&#10;import org.springframework.web.bind.annotation.GetMapping;&#10;import org.springframework.web.bind.annotation.PathVariable;&#10;&#10;import java.util.Set;&#10;&#10;@FeignClient(name = &quot;user-service&quot;, url = &quot;${user-service.url:http://user-service:8081}&quot;)&#10;public interface UserServiceClient {&#10;    &#10;    @GetMapping(&quot;/api/users/{userId}/friends/ids&quot;)&#10;    Set&lt;String&gt; getFriendIds(@PathVariable String userId);&#10;    &#10;    @GetMapping(&quot;/api/users/{userId}/close-interactions&quot;)&#10;    Set&lt;String&gt; getCloseInteractionIds(@PathVariable String userId);&#10;    &#10;    @GetMapping(&quot;/api/users/{userId}/same-faculty&quot;)&#10;    Set&lt;String&gt; getSameFacultyUserIds(@PathVariable String userId);&#10;    &#10;    @GetMapping(&quot;/api/users/{userId}/same-major&quot;)&#10;    Set&lt;String&gt; getSameMajorUserIds(@PathVariable String userId);&#10;    &#10;    @GetMapping(&quot;/api/users/{userId}/interest-tags&quot;)&#10;    Set&lt;String&gt; getUserInterestTags(@PathVariable String userId);&#10;    &#10;    @GetMapping(&quot;/api/users/{userId}/preferred-categories&quot;)&#10;    Set&lt;String&gt; getUserPreferredCategories(@PathVariable String userId);&#10;    &#10;    @GetMapping(&quot;/api/users/{userId}/faculty-id&quot;)&#10;    String getUserFacultyId(@PathVariable String userId);&#10;    &#10;    @GetMapping(&quot;/api/users/{userId}/major-id&quot;)&#10;    String getUserMajorId(@PathVariable String userId);&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/post-service/src/main/resources/application-docker.properties">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/post-service/src/main/resources/application-docker.properties" />
              <option name="originalContent" value="# Docker-specific configuration for post-service&#10;spring.application.name=post-service&#10;server.port=8085&#10;&#10;# MongoDB Configuration - Docker service name&#10;spring.data.mongodb.database=post_db&#10;spring.data.mongodb.host=post_db&#10;spring.data.mongodb.port=27017&#10;&#10;# Redis Configuration - Docker service name&#10;spring.data.redis.host=redis&#10;spring.data.redis.port=6379&#10;spring.data.redis.timeout=60000ms&#10;spring.data.redis.lettuce.pool.max-active=8&#10;spring.data.redis.lettuce.pool.max-idle=8&#10;spring.data.redis.lettuce.pool.min-idle=0&#10;&#10;# Kafka Configuration - Docker service name&#10;spring.kafka.bootstrap-servers=kafka:9092&#10;spring.kafka.producer.key-serializer=org.apache.kafka.common.serialization.StringSerializer&#10;spring.kafka.producer.value-serializer=org.springframework.kafka.support.serializer.JsonSerializer&#10;&#10;spring.kafka.consumer.group-id=post-service-group&#10;spring.kafka.consumer.key-deserializer=org.apache.kafka.common.serialization.StringDeserializer&#10;spring.kafka.consumer.value-deserializer=org.springframework.kafka.support.serializer.JsonDeserializer&#10;spring.kafka.consumer.properties.spring.json.trusted.packages=*&#10;spring.kafka.consumer.auto-offset-reset=earliest&#10;spring.kafka.consumer.enable-auto-commit=true&#10;&#10;# Eureka Configuration - Docker service name&#10;eureka.client.service-url.defaultZone=http://eureka-server:8761/eureka/&#10;eureka.instance.prefer-ip-address=true&#10;eureka.instance.instance-id=${spring.application.name}:${server.port}&#10;&#10;# Media Service Configuration - Docker service name&#10;media-service.url=http://media-service:8084&#10;&#10;# File Upload Configuration&#10;spring.servlet.multipart.max-file-size=10MB&#10;spring.servlet.multipart.max-request-size=50MB&#10;&#10;# Actuator Configuration&#10;management.endpoints.web.exposure.include=health,info,metrics&#10;management.endpoint.health.show-details=always&#10;&#10;# Logging Configuration&#10;logging.level.com.ctuconnect=DEBUG&#10;logging.level.org.springframework.kafka=INFO&#10;logging.level.org.springframework.data.mongodb=INFO&#10;" />
              <option name="updatedContent" value="# Docker-specific configuration for post-service&#13;&#10;spring.application.name=post-service&#13;&#10;server.port=8085&#13;&#10;&#13;&#10;# MongoDB Configuration - Docker service name&#13;&#10;spring.data.mongodb.database=post_db&#13;&#10;spring.data.mongodb.host=post_db&#13;&#10;spring.data.mongodb.port=27017&#13;&#10;&#13;&#10;# Redis Configuration - Docker service name&#13;&#10;spring.data.redis.host=redis&#13;&#10;spring.data.redis.port=6379&#13;&#10;spring.data.redis.timeout=60000ms&#13;&#10;spring.data.redis.lettuce.pool.max-active=8&#13;&#10;spring.data.redis.lettuce.pool.min-idle=0&#13;&#10;&#13;&#10;# Kafka Configuration - Docker service name&#13;&#10;spring.kafka.bootstrap-servers=kafka:9092&#13;&#10;spring.kafka.producer.key-serializer=org.apache.kafka.common.serialization.StringSerializer&#13;&#10;spring.kafka.producer.value-serializer=org.springframework.kafka.support.serializer.JsonSerializer&#13;&#10;&#13;&#10;spring.kafka.consumer.group-id=post-service-group&#13;&#10;spring.kafka.consumer.key-deserializer=org.apache.kafka.common.serialization.StringDeserializer&#13;&#10;spring.kafka.consumer.value-deserializer=org.springframework.kafka.support.serializer.JsonDeserializer&#13;&#10;spring.kafka.consumer.properties.spring.json.trusted.packages=*&#13;&#10;spring.kafka.consumer.auto-offset-reset=earliest&#13;&#10;spring.kafka.consumer.enable-auto-commit=true&#13;&#10;&#13;&#10;# Eureka Configuration - Docker service name&#13;&#10;eureka.client.service-url.defaultZone=http://eureka-server:8761/eureka/&#13;&#10;eureka.instance.prefer-ip-address=true&#13;&#10;eureka.instance.instance-id=${spring.application.name}:${server.port}&#13;&#10;&#13;&#10;# User Service Configuration - Docker service name&#13;&#10;user-service.url=http://user-service:8081&#13;&#10;&#13;&#10;# Media Service Configuration - Docker service name&#13;&#10;media-service.url=http://media-service:8084&#13;&#10;&#13;&#10;# Feign Configuration&#13;&#10;feign.client.config.default.connect-timeout=10000&#13;&#10;feign.client.config.default.read-timeout=10000&#13;&#10;feign.client.config.default.logger-level=basic&#13;&#10;&#13;&#10;# File Upload Configuration&#13;&#10;spring.servlet.multipart.max-file-size=10MB&#13;&#10;spring.servlet.multipart.max-request-size=50MB&#13;&#10;&#13;&#10;# Actuator Configuration&#13;&#10;management.endpoints.web.exposure.include=health,info,metrics&#13;&#10;management.endpoint.health.show-details=always&#13;&#10;&#13;&#10;# Logging Configuration&#13;&#10;logging.level.com.ctuconnect=DEBUG&#13;&#10;logging.level.org.springframework.kafka=INFO&#13;&#10;logging.level.org.springframework.data.mongodb=INFO" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/post-service/src/main/resources/application.properties">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/post-service/src/main/resources/application.properties" />
              <option name="originalContent" value="spring.application.name=post-service&#10;server.port=8085&#10;&#10;# MongoDB Configuration&#10;spring.data.mongodb.database=post_db&#10;spring.data.mongodb.host=localhost&#10;spring.data.mongodb.port=27018&#10;&#10;# Kafka Configuration&#10;spring.kafka.bootstrap-servers=localhost:9092&#10;spring.kafka.producer.key-serializer=org.apache.kafka.common.serialization.StringSerializer&#10;spring.kafka.producer.value-serializer=org.springframework.kafka.support.serializer.JsonSerializer&#10;&#10;# Kafka Consumer Configuration - Fix missing group-id error&#10;spring.kafka.consumer.group-id=post-service-group&#10;spring.kafka.consumer.key-deserializer=org.apache.kafka.common.serialization.StringDeserializer&#10;spring.kafka.consumer.value-deserializer=org.springframework.kafka.support.serializer.JsonDeserializer&#10;spring.kafka.consumer.properties.spring.json.trusted.packages=*&#10;spring.kafka.consumer.auto-offset-reset=earliest&#10;spring.kafka.consumer.enable-auto-commit=true&#10;&#10;# Eureka Configuration&#10;eureka.client.service-url.defaultZone=http://localhost:8761/eureka/&#10;eureka.instance.prefer-ip-address=true&#10;eureka.instance.instance-id=${spring.application.name}:${server.port}&#10;&#10;# Redis Configuration - Fix for Docker container networking&#10;spring.data.redis.host=redis&#10;spring.data.redis.port=6379&#10;spring.data.redis.timeout=60000ms&#10;spring.data.redis.lettuce.pool.max-active=8&#10;spring.data.redis.lettuce.pool.max-idle=8&#10;spring.data.redis.lettuce.pool.min-idle=0&#10;&#10;# Media Service Configuration&#10;media-service.url=http://localhost:8084&#10;&#10;# File Upload Configuration&#10;spring.servlet.multipart.max-file-size=10MB&#10;spring.servlet.multipart.max-request-size=50MB&#10;&#10;# Actuator Configuration&#10;management.endpoints.web.exposure.include=health,info,metrics&#10;management.endpoint.health.show-details=always&#10;&#10;# Logging Configuration&#10;logging.level.vn.ctu.edu.postservice=DEBUG&#10;logging.level.org.springframework.kafka=INFO&#10;logging.level.org.springframework.data.mongodb=INFO&#10;" />
              <option name="updatedContent" value="spring.application.name=post-service&#10;server.port=8085&#10;&#10;# MongoDB Configuration&#10;spring.data.mongodb.database=post_db&#10;spring.data.mongodb.host=localhost&#10;spring.data.mongodb.port=27018&#10;&#10;# Kafka Configuration&#10;spring.kafka.bootstrap-servers=localhost:9092&#10;spring.kafka.producer.key-serializer=org.apache.kafka.common.serialization.StringSerializer&#10;spring.kafka.producer.value-serializer=org.springframework.kafka.support.serializer.JsonSerializer&#10;&#10;# Kafka Consumer Configuration - Fix missing group-id error&#10;spring.kafka.consumer.group-id=post-service-group&#10;spring.kafka.consumer.key-deserializer=org.apache.kafka.common.serialization.StringDeserializer&#10;spring.kafka.consumer.value-deserializer=org.springframework.kafka.support.serializer.JsonDeserializer&#10;spring.kafka.consumer.properties.spring.json.trusted.packages=*&#10;spring.kafka.consumer.auto-offset-reset=earliest&#10;spring.kafka.consumer.enable-auto-commit=true&#10;&#10;# Eureka Configuration&#10;eureka.client.service-url.defaultZone=http://localhost:8761/eureka/&#10;eureka.instance.prefer-ip-address=true&#10;eureka.instance.instance-id=${spring.application.name}:${server.port}&#10;&#10;# Redis Configuration - Fix for Docker container networking&#10;spring.data.redis.host=redis&#10;spring.data.redis.port=6379&#10;spring.data.redis.timeout=60000ms&#10;spring.data.redis.lettuce.pool.max-active=8&#10;spring.data.redis.lettuce.pool.max-idle=8&#10;spring.data.redis.lettuce.pool.min-idle=0&#10;&#10;# User Service Configuration&#10;user-service.url=http://localhost:8081&#10;&#10;# Media Service Configuration&#10;media-service.url=http://localhost:8084&#10;&#10;# Feign Configuration&#10;feign.client.config.default.connect-timeout=5000&#10;feign.client.config.default.read-timeout=5000&#10;feign.client.config.default.logger-level=basic&#10;&#10;# File Upload Configuration&#10;spring.servlet.multipart.max-file-size=10MB&#10;spring.servlet.multipart.max-request-size=50MB&#10;&#10;# Actuator Configuration&#10;management.endpoints.web.exposure.include=health,info,metrics&#10;management.endpoint.health.show-details=always&#10;&#10;# Logging Configuration&#10;logging.level.vn.ctu.edu.postservice=DEBUG&#10;logging.level.org.springframework.kafka=INFO&#10;logging.level.org.springframework.data.mongodb=INFO" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/recommendation-service/Dockerfile">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/recommendation-service/Dockerfile" />
              <option name="originalContent" value="FROM python:3.11-slim&#10;&#10;# Set working directory&#10;WORKDIR /app&#10;&#10;# Install system dependencies&#10;RUN apt-get update &amp;&amp; apt-get install -y \&#10;    gcc \&#10;    g++ \&#10;    curl \&#10;    &amp;&amp; rm -rf /var/lib/apt/lists/*&#10;&#10;# Copy requirements first for better caching&#10;COPY requirements.txt .&#10;&#10;# Install Python dependencies&#10;RUN pip install --no-cache-dir -r requirements.txt&#10;&#10;# Copy application code&#10;COPY . .&#10;&#10;# Create non-root user&#10;RUN useradd --create-home --shell /bin/bash app \&#10;    &amp;&amp; chown -R app:app /app&#10;USER app&#10;&#10;# Expose port&#10;EXPOSE 8000&#10;&#10;# Health check&#10;HEALTHCHECK --interval=30s --timeout=30s --start-period=5s --retries=3 \&#10;    CMD curl -f http://localhost:8000/health || exit 1&#10;&#10;# Run the application&#10;CMD [&quot;python&quot;, &quot;-m&quot;, &quot;uvicorn&quot;, &quot;main:app&quot;, &quot;--host&quot;, &quot;0.0.0.0&quot;, &quot;--port&quot;, &quot;8000&quot;]&#10;" />
              <option name="updatedContent" value="FROM python:3.11-slim&#10;&#10;# Set working directory&#10;WORKDIR /app&#10;&#10;# Install system dependencies&#10;RUN apt-get update &amp;&amp; apt-get install -y \&#10;    gcc \&#10;    g++ \&#10;    curl \&#10;    wget \&#10;    &amp;&amp; rm -rf /var/lib/apt/lists/*&#10;&#10;# Copy requirements first for better caching&#10;COPY requirements.txt .&#10;&#10;# Install Python dependencies&#10;RUN pip install --no-cache-dir --upgrade pip &amp;&amp; \&#10;    pip install --no-cache-dir -r requirements.txt&#10;&#10;# Copy application code&#10;COPY . .&#10;&#10;# Create models directory&#10;RUN mkdir -p models&#10;&#10;# Create non-root user for security&#10;RUN useradd --create-home --shell /bin/bash --uid 1000 app \&#10;    &amp;&amp; chown -R app:app /app&#10;USER app&#10;&#10;# Expose port&#10;EXPOSE 8000&#10;&#10;# Health check compatible with Spring Boot actuator format&#10;HEALTHCHECK --interval=30s --timeout=30s --start-period=60s --retries=3 \&#10;    CMD curl -f http://localhost:8000/health || exit 1&#10;&#10;# Environment variables for production&#10;ENV PYTHONPATH=/app&#10;ENV PYTHONUNBUFFERED=1&#10;ENV PYTHONDONTWRITEBYTECODE=1&#10;&#10;# Run the application with gunicorn for production&#10;CMD [&quot;python&quot;, &quot;-m&quot;, &quot;uvicorn&quot;, &quot;main:app&quot;, &quot;--host&quot;, &quot;0.0.0.0&quot;, &quot;--port&quot;, &quot;8000&quot;, &quot;--workers&quot;, &quot;1&quot;]" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/recommendation-service/README.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/recommendation-service/README.md" />
              <option name="updatedContent" value="# CTU Connect Recommendation Service&#10;&#10;A comprehensive AI-powered recommendation microservice for the CTU Connect social platform, featuring deep learning models, reinforcement learning, A/B testing, and real-time personalization.&#10;&#10;## Features&#10;&#10;### Core Capabilities&#10;- **Deep Learning Personalization**: Uses PyTorch with PhoBERT for Vietnamese content understanding&#10;- **Multi-head Attention**: Advanced attention mechanisms for user-post relevance scoring&#10;- **Reinforcement Learning**: DQN-based continuous learning from user feedback&#10;- **A/B Testing**: Built-in experimentation framework with multiple model variants&#10;- **Real-time Processing**: Kafka-based streaming for instant recommendation updates&#10;- **Caching**: Redis-powered caching for sub-100ms response times&#10;- **Monitoring**: Prometheus metrics and comprehensive logging&#10;&#10;### Technical Architecture&#10;- **Framework**: FastAPI with async/await for high performance&#10;- **Database**: PostgreSQL with async SQLAlchemy&#10;- **Message Queue**: Apache Kafka for real-time data streaming&#10;- **Caching**: Redis for recommendation and feature caching&#10;- **ML Ops**: MLflow for experiment tracking and model versioning&#10;- **Deployment**: Docker and Kubernetes with auto-scaling&#10;&#10;## Quick Start&#10;&#10;### Prerequisites&#10;- Python 3.11+&#10;- PostgreSQL 12+&#10;- Redis 6+&#10;- Apache Kafka 2.8+&#10;&#10;### Installation&#10;&#10;1. **Clone and setup environment**:&#10;```bash&#10;cd recommendation-service&#10;python -m venv venv&#10;source venv/bin/activate  # Windows: venv\Scripts\activate&#10;pip install -r requirements.txt&#10;```&#10;&#10;2. **Configure environment variables**:&#10;```bash&#10;export DATABASE_URL=&quot;postgresql+asyncpg://user:pass@localhost:5432/recommendation_db&quot;&#10;export REDIS_URL=&quot;redis://localhost:6379&quot;&#10;export KAFKA_BOOTSTRAP_SERVERS=&quot;localhost:9092&quot;&#10;export SECRET_KEY=&quot;your-secret-key&quot;&#10;```&#10;&#10;3. **Initialize database**:&#10;```bash&#10;python -c &quot;&#10;import asyncio&#10;from db.models import create_tables&#10;asyncio.run(create_tables())&#10;&quot;&#10;```&#10;&#10;4. **Start the service**:&#10;```bash&#10;python main.py&#10;```&#10;&#10;The service will be available at `http://localhost:8000`&#10;&#10;## API Documentation&#10;&#10;### Authentication&#10;All endpoints require an API key in the Authorization header:&#10;```&#10;Authorization: Bearer your-api-key&#10;```&#10;&#10;### Endpoints&#10;&#10;#### GET /health&#10;Health check endpoint&#10;```json&#10;{&#10;  &quot;status&quot;: &quot;healthy&quot;,&#10;  &quot;timestamp&quot;: &quot;2025-08-05T10:30:00Z&quot;,&#10;  &quot;version&quot;: &quot;1.0.0&quot;,&#10;  &quot;services&quot;: {&#10;    &quot;redis&quot;: &quot;healthy&quot;,&#10;    &quot;recommendation_engine&quot;: &quot;healthy&quot;&#10;  }&#10;}&#10;```&#10;&#10;#### POST /recommendations&#10;Get personalized recommendations for a user&#10;&#10;**Request**:&#10;```json&#10;{&#10;  &quot;user_id&quot;: &quot;user_123&quot;,&#10;  &quot;context&quot;: {&#10;    &quot;device_type&quot;: &quot;mobile&quot;,&#10;    &quot;location&quot;: &quot;Vietnam&quot;&#10;  },&#10;  &quot;k&quot;: 10,&#10;  &quot;include_explanations&quot;: true&#10;}&#10;```&#10;&#10;**Response**:&#10;```json&#10;{&#10;  &quot;recommendations&quot;: [&#10;    {&#10;      &quot;post_id&quot;: &quot;post_456&quot;,&#10;      &quot;title&quot;: &quot;Khoa học máy tính&quot;,&#10;      &quot;content&quot;: &quot;Bài viết về AI...&quot;,&#10;      &quot;author_id&quot;: &quot;author_789&quot;,&#10;      &quot;category&quot;: &quot;Khoa Hoc&quot;,&#10;      &quot;tags&quot;: [&quot;AI&quot;, &quot;machine-learning&quot;],&#10;      &quot;engagement_rate&quot;: 0.15,&#10;      &quot;relevance_score&quot;: 0.95,&#10;      &quot;rank&quot;: 1,&#10;      &quot;reason&quot;: &quot;Recommended because you're interested in Khoa Hoc&quot;&#10;    }&#10;  ],&#10;  &quot;ab_variant&quot;: &quot;personalized_v1&quot;,&#10;  &quot;timestamp&quot;: &quot;2025-08-05T10:30:00Z&quot;,&#10;  &quot;user_id&quot;: &quot;user_123&quot;,&#10;  &quot;total_count&quot;: 10,&#10;  &quot;processing_time_ms&quot;: 45.2&#10;}&#10;```&#10;&#10;#### POST /feedback&#10;Record user interaction feedback&#10;&#10;**Request**:&#10;```json&#10;{&#10;  &quot;user_id&quot;: &quot;user_123&quot;,&#10;  &quot;post_id&quot;: &quot;post_456&quot;,&#10;  &quot;feedback_type&quot;: &quot;like&quot;,&#10;  &quot;context&quot;: {&#10;    &quot;device_type&quot;: &quot;mobile&quot;,&#10;    &quot;session_id&quot;: &quot;session_abc&quot;&#10;  }&#10;}&#10;```&#10;&#10;**Response**:&#10;```json&#10;{&#10;  &quot;success&quot;: true,&#10;  &quot;message&quot;: &quot;Feedback recorded successfully&quot;,&#10;  &quot;timestamp&quot;: &quot;2025-08-05T10:30:00Z&quot;&#10;}&#10;```&#10;&#10;#### GET /recommendations/{user_id}/history&#10;Get recommendation history for a user&#10;&#10;**Response**:&#10;```json&#10;{&#10;  &quot;user_id&quot;: &quot;user_123&quot;,&#10;  &quot;history&quot;: [&#10;    {&#10;      &quot;timestamp&quot;: &quot;2025-08-05T10:30:00Z&quot;,&#10;      &quot;post_ids&quot;: [&quot;post_1&quot;, &quot;post_2&quot;],&#10;      &quot;model_version&quot;: &quot;v1.0&quot;,&#10;      &quot;ab_test_variant&quot;: &quot;personalized_v1&quot;,&#10;      &quot;served_count&quot;: 10,&#10;      &quot;clicked_count&quot;: 3,&#10;      &quot;ctr&quot;: 0.3&#10;    }&#10;  ],&#10;  &quot;total_count&quot;: 50&#10;}&#10;```&#10;&#10;## Model Training&#10;&#10;### Training Data Preparation&#10;The system automatically collects training data from user interactions:&#10;- **Positive samples**: Likes, comments, shares (weighted by engagement strength)&#10;- **Negative samples**: Posts viewed but not interacted with&#10;- **Features**: User profile, post content, temporal context&#10;&#10;### Training Pipeline&#10;```bash&#10;# Start training&#10;python core/training.py&#10;```&#10;&#10;The training pipeline includes:&#10;1. **Data Collection**: Fetches recent interactions from database&#10;2. **Feature Engineering**: Extracts user/post embeddings and context features&#10;3. **Model Training**: Deep learning with attention mechanisms&#10;4. **Evaluation**: Precision, recall, F1-score, diversity metrics&#10;5. **Model Deployment**: Automatic model versioning and deployment&#10;&#10;### Model Architecture&#10;```&#10;User Features (Profile + Context) &#10;    ↓&#10;User Embedding (256d)&#10;    ↓&#10;Multi-Head Attention ← Post Embedding (256d)&#10;    ↓                      ↑&#10;Fusion Layer        Content Encoder (PhoBERT)&#10;    ↓                      ↑&#10;Prediction Head     Post Features + Metadata&#10;    ↓&#10;Relevance Score (0-1)&#10;```&#10;&#10;## A/B Testing&#10;&#10;The service supports multiple recommendation variants:&#10;- **personalized_v1**: Base deep learning model (40% traffic)&#10;- **personalized_v2**: Enhanced with reinforcement learning (40% traffic)  &#10;- **popularity_based**: Fallback algorithm (20% traffic)&#10;&#10;Users are consistently assigned to variants based on user ID hash.&#10;&#10;## Monitoring &amp; Analytics&#10;&#10;### Prometheus Metrics&#10;- `recommendation_requests_total`: Total API requests&#10;- `recommendations_served_total`: Recommendations served by variant&#10;- `feedback_received_total`: User feedback by type&#10;- `model_accuracy`: Current model performance&#10;- `cache_hits_total` / `cache_misses_total`: Caching performance&#10;&#10;### Dashboards&#10;Access metrics at `/metrics` endpoint for Prometheus scraping.&#10;&#10;### Logging&#10;Structured JSON logging with:&#10;- Request/response tracking&#10;- Model prediction details&#10;- Error tracking and debugging&#10;- Performance monitoring&#10;&#10;## Deployment&#10;&#10;### Docker&#10;```bash&#10;# Build image&#10;docker build -t ctu-connect/recommendation-service .&#10;&#10;# Run container&#10;docker run -p 8000:8000 \&#10;  -e DATABASE_URL=&quot;postgresql+asyncpg://...&quot; \&#10;  -e REDIS_URL=&quot;redis://...&quot; \&#10;  ctu-connect/recommendation-service&#10;```&#10;&#10;### Kubernetes&#10;```bash&#10;# Deploy to Kubernetes&#10;kubectl apply -f deployment/kubernetes.yaml&#10;&#10;# Check status&#10;kubectl get pods -l app=recommendation-service&#10;kubectl logs -f deployment/recommendation-service&#10;```&#10;&#10;The Kubernetes deployment includes:&#10;- **Auto-scaling**: 2-10 replicas based on CPU/memory usage&#10;- **Health checks**: Liveness and readiness probes&#10;- **Resource limits**: Memory and CPU constraints&#10;- **Config management**: ConfigMaps and Secrets&#10;&#10;### Production Configuration&#10;For production deployment:&#10;&#10;1. **Database**: Use managed PostgreSQL (AWS RDS, Google Cloud SQL)&#10;2. **Redis**: Use managed Redis cluster&#10;3. **Kafka**: Use managed Kafka service (Confluent, AWS MSK)&#10;4. **Monitoring**: Set up Prometheus + Grafana&#10;5. **Security**: Enable API authentication, rate limiting&#10;6. **SSL/TLS**: Configure HTTPS termination&#10;&#10;## Performance&#10;&#10;### Benchmarks&#10;- **Response Time**: &lt; 100ms for cached recommendations&#10;- **Throughput**: 1000+ RPS per instance&#10;- **Accuracy**: 85%+ precision on validation set&#10;- **Diversity**: 70%+ category diversity in recommendations&#10;&#10;### Optimization Tips&#10;1. **Caching Strategy**: Cache user features and popular recommendations&#10;2. **Batch Processing**: Group similar requests for efficient inference&#10;3. **Model Optimization**: Use TorchScript or ONNX for faster inference&#10;4. **Database**: Optimize queries with proper indexing&#10;5. **Scaling**: Use horizontal pod autoscaling in Kubernetes&#10;&#10;## Testing&#10;&#10;### Run Tests&#10;```bash&#10;# Unit tests&#10;pytest tests/ -v&#10;&#10;# Integration tests&#10;pytest tests/ -v -m integration&#10;&#10;# Load tests&#10;pytest tests/test_recommendation.py::TestPerformance -v&#10;```&#10;&#10;### Test Coverage&#10;- **API Endpoints**: Complete request/response testing&#10;- **Model Components**: Unit tests for all neural network layers&#10;- **Data Processing**: Feature extraction and transformation tests&#10;- **Integration**: End-to-end recommendation flow tests&#10;&#10;## Contributing&#10;&#10;### Development Setup&#10;1. Fork the repository&#10;2. Create feature branch: `git checkout -b feature/new-feature`&#10;3. Install dev dependencies: `pip install -r requirements.txt`&#10;4. Run tests: `pytest`&#10;5. Submit pull request&#10;&#10;### Code Standards&#10;- **Python**: Follow PEP 8, use Black formatter&#10;- **Documentation**: Add docstrings for all functions&#10;- **Testing**: Maintain &gt;90% test coverage&#10;- **Type Hints**: Use type annotations throughout&#10;&#10;## Troubleshooting&#10;&#10;### Common Issues&#10;&#10;**Service won't start**:&#10;- Check database connection string&#10;- Verify Redis is running&#10;- Ensure Kafka is accessible&#10;&#10;**Poor recommendation quality**:&#10;- Check training data quality and quantity&#10;- Verify user interaction tracking&#10;- Review model hyperparameters&#10;&#10;**High response times**:&#10;- Check Redis cache hit rates&#10;- Monitor database query performance&#10;- Review model inference time&#10;&#10;**Memory issues**:&#10;- Adjust batch sizes in training&#10;- Optimize model architecture&#10;- Configure appropriate resource limits&#10;&#10;### Debug Mode&#10;Enable debug mode for detailed logging:&#10;```bash&#10;export DEBUG=true&#10;python main.py&#10;```&#10;&#10;### Logs&#10;Check logs for debugging:&#10;```bash&#10;# Docker&#10;docker logs &lt;container-id&gt;&#10;&#10;# Kubernetes&#10;kubectl logs -f deployment/recommendation-service&#10;```&#10;&#10;## License&#10;&#10;MIT License - see LICENSE file for details.&#10;&#10;## Support&#10;&#10;For questions and support:&#10;- GitHub Issues: Create issue in repository&#10;- Documentation: Check API documentation at `/docs`&#10;- Monitoring: Check service health at `/health`" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/recommendation-service/api/eureka_client.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/recommendation-service/api/eureka_client.py" />
              <option name="updatedContent" value="import asyncio&#10;import httpx&#10;import logging&#10;from typing import Dict, Optional, List&#10;import json&#10;from datetime import datetime&#10;&#10;from config.settings import config&#10;&#10;logger = logging.getLogger(__name__)&#10;&#10;class EurekaClient:&#10;    &quot;&quot;&quot;Client để đăng ký và discovery services với Eureka Server&quot;&quot;&quot;&#10;    &#10;    def __init__(self):&#10;        self.eureka_url = config.EUREKA_SERVER_URL.rstrip('/eureka')&#10;        self.service_name = config.SERVICE_NAME&#10;        self.service_id = config.SERVICE_ID&#10;        self.host = config.HOST&#10;        self.port = config.PORT&#10;        self.session = None&#10;        self.registered = False&#10;        &#10;    async def initialize(self):&#10;        &quot;&quot;&quot;Khởi tạo Eureka client&quot;&quot;&quot;&#10;        self.session = httpx.AsyncClient(timeout=30.0)&#10;        &#10;    async def close(self):&#10;        &quot;&quot;&quot;Đóng Eureka client&quot;&quot;&quot;&#10;        if self.registered:&#10;            await self.deregister()&#10;        if self.session:&#10;            await self.session.aclose()&#10;    &#10;    async def register(self):&#10;        &quot;&quot;&quot;Đăng ký service với Eureka&quot;&quot;&quot;&#10;        try:&#10;            registration_data = {&#10;                &quot;instance&quot;: {&#10;                    &quot;instanceId&quot;: self.service_id,&#10;                    &quot;hostName&quot;: self.host,&#10;                    &quot;app&quot;: self.service_name.upper(),&#10;                    &quot;ipAddr&quot;: self.host,&#10;                    &quot;port&quot;: {&#10;                        &quot;$&quot;: self.port,&#10;                        &quot;@enabled&quot;: &quot;true&quot;&#10;                    },&#10;                    &quot;securePort&quot;: {&#10;                        &quot;$&quot;: 443,&#10;                        &quot;@enabled&quot;: &quot;false&quot;&#10;                    },&#10;                    &quot;status&quot;: &quot;UP&quot;,&#10;                    &quot;overriddenstatus&quot;: &quot;UNKNOWN&quot;,&#10;                    &quot;healthCheckUrl&quot;: f&quot;http://{self.host}:{self.port}/health&quot;,&#10;                    &quot;statusPageUrl&quot;: f&quot;http://{self.host}:{self.port}/health&quot;,&#10;                    &quot;homePageUrl&quot;: f&quot;http://{self.host}:{self.port}/&quot;,&#10;                    &quot;vipAddress&quot;: self.service_name,&#10;                    &quot;secureVipAddress&quot;: self.service_name,&#10;                    &quot;isCoordinatingDiscoveryServer&quot;: &quot;false&quot;,&#10;                    &quot;lastUpdatedTimestamp&quot;: str(int(datetime.now().timestamp() * 1000)),&#10;                    &quot;lastDirtyTimestamp&quot;: str(int(datetime.now().timestamp() * 1000)),&#10;                    &quot;actionType&quot;: &quot;ADDED&quot;,&#10;                    &quot;metadata&quot;: {&#10;                        &quot;@class&quot;: &quot;java.util.Collections$EmptyMap&quot;,&#10;                        &quot;management.port&quot;: str(self.port)&#10;                    },&#10;                    &quot;dataCenterInfo&quot;: {&#10;                        &quot;@class&quot;: &quot;com.netflix.appinfo.InstanceInfo$DefaultDataCenterInfo&quot;,&#10;                        &quot;name&quot;: &quot;MyOwn&quot;&#10;                    }&#10;                }&#10;            }&#10;            &#10;            url = f&quot;{self.eureka_url}/eureka/apps/{self.service_name.upper()}&quot;&#10;            headers = {&quot;Content-Type&quot;: &quot;application/json&quot;}&#10;            &#10;            response = await self.session.post(url, json=registration_data, headers=headers)&#10;            &#10;            if response.status_code in [200, 204]:&#10;                self.registered = True&#10;                logger.info(f&quot;Successfully registered {self.service_name} with Eureka&quot;)&#10;                &#10;                # Bắt đầu heartbeat&#10;                asyncio.create_task(self._heartbeat_loop())&#10;                return True&#10;            else:&#10;                logger.error(f&quot;Failed to register with Eureka: {response.status_code} - {response.text}&quot;)&#10;                return False&#10;                &#10;        except Exception as e:&#10;            logger.error(f&quot;Error registering with Eureka: {e}&quot;)&#10;            return False&#10;    &#10;    async def deregister(self):&#10;        &quot;&quot;&quot;Hủy đăng ký service với Eureka&quot;&quot;&quot;&#10;        try:&#10;            url = f&quot;{self.eureka_url}/eureka/apps/{self.service_name.upper()}/{self.service_id}&quot;&#10;            response = await self.session.delete(url)&#10;            &#10;            if response.status_code in [200, 204]:&#10;                logger.info(f&quot;Successfully deregistered {self.service_name} from Eureka&quot;)&#10;                self.registered = False&#10;            else:&#10;                logger.warning(f&quot;Failed to deregister from Eureka: {response.status_code}&quot;)&#10;                &#10;        except Exception as e:&#10;            logger.error(f&quot;Error deregistering from Eureka: {e}&quot;)&#10;    &#10;    async def send_heartbeat(self):&#10;        &quot;&quot;&quot;Gửi heartbeat đến Eureka&quot;&quot;&quot;&#10;        try:&#10;            url = f&quot;{self.eureka_url}/eureka/apps/{self.service_name.upper()}/{self.service_id}&quot;&#10;            response = await self.session.put(url)&#10;            &#10;            if response.status_code == 200:&#10;                logger.debug(&quot;Heartbeat sent successfully&quot;)&#10;                return True&#10;            elif response.status_code == 404:&#10;                logger.warning(&quot;Service not found in Eureka, re-registering...&quot;)&#10;                return await self.register()&#10;            else:&#10;                logger.warning(f&quot;Heartbeat failed: {response.status_code}&quot;)&#10;                return False&#10;                &#10;        except Exception as e:&#10;            logger.error(f&quot;Error sending heartbeat: {e}&quot;)&#10;            return False&#10;    &#10;    async def _heartbeat_loop(self):&#10;        &quot;&quot;&quot;Vòng lặp gửi heartbeat định kỳ&quot;&quot;&quot;&#10;        while self.registered:&#10;            try:&#10;                await asyncio.sleep(30)  # Heartbeat mỗi 30 giây&#10;                if self.registered:&#10;                    await self.send_heartbeat()&#10;            except Exception as e:&#10;                logger.error(f&quot;Error in heartbeat loop: {e}&quot;)&#10;                break&#10;    &#10;    async def discover_service(self, service_name: str) -&gt; Optional[Dict]:&#10;        &quot;&quot;&quot;Tìm kiếm service thông qua Eureka&quot;&quot;&quot;&#10;        try:&#10;            url = f&quot;{self.eureka_url}/eureka/apps/{service_name.upper()}&quot;&#10;            headers = {&quot;Accept&quot;: &quot;application/json&quot;}&#10;            &#10;            response = await self.session.get(url, headers=headers)&#10;            &#10;            if response.status_code == 200:&#10;                data = response.json()&#10;                instances = data.get(&quot;application&quot;, {}).get(&quot;instance&quot;, [])&#10;                &#10;                # Nếu chỉ có 1 instance, Eureka trả về dict thay vì list&#10;                if isinstance(instances, dict):&#10;                    instances = [instances]&#10;                &#10;                # Lọc chỉ các instance đang UP&#10;                healthy_instances = [&#10;                    instance for instance in instances&#10;                    if instance.get(&quot;status&quot;) == &quot;UP&quot;&#10;                ]&#10;                &#10;                return healthy_instances&#10;            else:&#10;                logger.warning(f&quot;Service {service_name} not found in Eureka&quot;)&#10;                return None&#10;                &#10;        except Exception as e:&#10;            logger.error(f&quot;Error discovering service {service_name}: {e}&quot;)&#10;            return None&#10;    &#10;    async def get_service_url(self, service_name: str) -&gt; Optional[str]:&#10;        &quot;&quot;&quot;Lấy URL của một service&quot;&quot;&quot;&#10;        instances = await self.discover_service(service_name)&#10;        &#10;        if instances:&#10;            # Chọn instance đầu tiên (có thể implement load balancing sau)&#10;            instance = instances[0]&#10;            host = instance.get(&quot;ipAddr&quot;) or instance.get(&quot;hostName&quot;)&#10;            port = instance.get(&quot;port&quot;, {}).get(&quot;$&quot;, 8080)&#10;            return f&quot;http://{host}:{port}&quot;&#10;        &#10;        return None&#10;    &#10;    async def get_all_services(self) -&gt; List[Dict]:&#10;        &quot;&quot;&quot;Lấy danh sách tất cả services đã đăng ký&quot;&quot;&quot;&#10;        try:&#10;            url = f&quot;{self.eureka_url}/eureka/apps&quot;&#10;            headers = {&quot;Accept&quot;: &quot;application/json&quot;}&#10;            &#10;            response = await self.session.get(url, headers=headers)&#10;            &#10;            if response.status_code == 200:&#10;                data = response.json()&#10;                applications = data.get(&quot;applications&quot;, {}).get(&quot;application&quot;, [])&#10;                &#10;                if isinstance(applications, dict):&#10;                    applications = [applications]&#10;                &#10;                return applications&#10;            else:&#10;                logger.error(f&quot;Failed to get services from Eureka: {response.status_code}&quot;)&#10;                return []&#10;                &#10;        except Exception as e:&#10;            logger.error(f&quot;Error getting services from Eureka: {e}&quot;)&#10;            return []&#10;&#10;# Global Eureka client instance&#10;eureka_client = EurekaClient()" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/recommendation-service/api/microservice_client.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/recommendation-service/api/microservice_client.py" />
              <option name="updatedContent" value="import httpx&#10;import asyncio&#10;import logging&#10;from typing import Dict, List, Optional, Any&#10;from datetime import datetime&#10;import json&#10;&#10;from config.settings import config&#10;&#10;logger = logging.getLogger(__name__)&#10;&#10;class MicroserviceClient:&#10;    &quot;&quot;&quot;Client để giao tiếp với các microservices khác trong hệ thống CTU Connect&quot;&quot;&quot;&#10;    &#10;    def __init__(self):&#10;        self.timeout = httpx.Timeout(config.REQUEST_TIMEOUT)&#10;        self.session = None&#10;        &#10;    async def initialize(self):&#10;        &quot;&quot;&quot;Khởi tạo HTTP client session&quot;&quot;&quot;&#10;        self.session = httpx.AsyncClient(timeout=self.timeout)&#10;        &#10;    async def close(self):&#10;        &quot;&quot;&quot;Đóng HTTP client session&quot;&quot;&quot;&#10;        if self.session:&#10;            await self.session.aclose()&#10;    &#10;    async def get_user_profile(self, user_id: str) -&gt; Optional[Dict[str, Any]]:&#10;        &quot;&quot;&quot;Lấy thông tin profile người dùng từ User Service&quot;&quot;&quot;&#10;        try:&#10;            url = f&quot;{config.USER_SERVICE_URL}/api/users/{user_id}/profile&quot;&#10;            response = await self.session.get(url)&#10;            &#10;            if response.status_code == 200:&#10;                return response.json()&#10;            elif response.status_code == 404:&#10;                logger.warning(f&quot;User profile not found: {user_id}&quot;)&#10;                return None&#10;            else:&#10;                logger.error(f&quot;Error fetching user profile: {response.status_code}&quot;)&#10;                return None&#10;                &#10;        except Exception as e:&#10;            logger.error(f&quot;Error connecting to user service: {e}&quot;)&#10;            return None&#10;    &#10;    async def get_user_interactions(self, user_id: str, limit: int = 100) -&gt; List[Dict[str, Any]]:&#10;        &quot;&quot;&quot;Lấy lịch sử tương tác của người dùng&quot;&quot;&quot;&#10;        try:&#10;            url = f&quot;{config.USER_SERVICE_URL}/api/users/{user_id}/interactions&quot;&#10;            params = {&quot;limit&quot;: limit}&#10;            response = await self.session.get(url, params=params)&#10;            &#10;            if response.status_code == 200:&#10;                return response.json().get(&quot;interactions&quot;, [])&#10;            else:&#10;                logger.error(f&quot;Error fetching user interactions: {response.status_code}&quot;)&#10;                return []&#10;                &#10;        except Exception as e:&#10;            logger.error(f&quot;Error fetching user interactions: {e}&quot;)&#10;            return []&#10;    &#10;    async def get_posts_batch(self, post_ids: List[str]) -&gt; List[Dict[str, Any]]:&#10;        &quot;&quot;&quot;Lấy thông tin nhiều bài viết từ Post Service&quot;&quot;&quot;&#10;        try:&#10;            url = f&quot;{config.POST_SERVICE_URL}/api/posts/batch&quot;&#10;            data = {&quot;postIds&quot;: post_ids}&#10;            response = await self.session.post(url, json=data)&#10;            &#10;            if response.status_code == 200:&#10;                return response.json().get(&quot;posts&quot;, [])&#10;            else:&#10;                logger.error(f&quot;Error fetching posts batch: {response.status_code}&quot;)&#10;                return []&#10;                &#10;        except Exception as e:&#10;            logger.error(f&quot;Error fetching posts batch: {e}&quot;)&#10;            return []&#10;    &#10;    async def get_trending_posts(self, category: Optional[str] = None, limit: int = 50) -&gt; List[Dict[str, Any]]:&#10;        &quot;&quot;&quot;Lấy danh sách bài viết trending từ Post Service&quot;&quot;&quot;&#10;        try:&#10;            url = f&quot;{config.POST_SERVICE_URL}/api/posts/trending&quot;&#10;            params = {&quot;limit&quot;: limit}&#10;            if category:&#10;                params[&quot;category&quot;] = category&#10;                &#10;            response = await self.session.get(url, params=params)&#10;            &#10;            if response.status_code == 200:&#10;                return response.json().get(&quot;posts&quot;, [])&#10;            else:&#10;                logger.error(f&quot;Error fetching trending posts: {response.status_code}&quot;)&#10;                return []&#10;                &#10;        except Exception as e:&#10;            logger.error(f&quot;Error fetching trending posts: {e}&quot;)&#10;            return []&#10;    &#10;    async def get_posts_by_category(self, category: str, limit: int = 50) -&gt; List[Dict[str, Any]]:&#10;        &quot;&quot;&quot;Lấy bài viết theo category&quot;&quot;&quot;&#10;        try:&#10;            url = f&quot;{config.POST_SERVICE_URL}/api/posts/category/{category}&quot;&#10;            params = {&quot;limit&quot;: limit}&#10;            response = await self.session.get(url, params=params)&#10;            &#10;            if response.status_code == 200:&#10;                return response.json().get(&quot;posts&quot;, [])&#10;            else:&#10;                logger.error(f&quot;Error fetching posts by category: {response.status_code}&quot;)&#10;                return []&#10;                &#10;        except Exception as e:&#10;            logger.error(f&quot;Error fetching posts by category: {e}&quot;)&#10;            return []&#10;    &#10;    async def validate_user_token(self, token: str) -&gt; Optional[Dict[str, Any]]:&#10;        &quot;&quot;&quot;Xác thực token người dùng với Auth Service&quot;&quot;&quot;&#10;        try:&#10;            url = f&quot;{config.AUTH_SERVICE_URL}/api/auth/validate&quot;&#10;            headers = {&quot;Authorization&quot;: f&quot;Bearer {token}&quot;}&#10;            response = await self.session.post(url, headers=headers)&#10;            &#10;            if response.status_code == 200:&#10;                return response.json()&#10;            else:&#10;                logger.warning(f&quot;Token validation failed: {response.status_code}&quot;)&#10;                return None&#10;                &#10;        except Exception as e:&#10;            logger.error(f&quot;Error validating token: {e}&quot;)&#10;            return None&#10;    &#10;    async def send_interaction_event(self, user_id: str, post_id: str, &#10;                                   interaction_type: str, context: Dict[str, Any]):&#10;        &quot;&quot;&quot;Gửi sự kiện tương tác đến các services khác&quot;&quot;&quot;&#10;        try:&#10;            # Gửi đến User Service để cập nhật profile&#10;            user_url = f&quot;{config.USER_SERVICE_URL}/api/users/{user_id}/interactions&quot;&#10;            user_data = {&#10;                &quot;postId&quot;: post_id,&#10;                &quot;interactionType&quot;: interaction_type,&#10;                &quot;timestamp&quot;: datetime.utcnow().isoformat(),&#10;                &quot;context&quot;: context&#10;            }&#10;            &#10;            # Gửi đến Post Service để cập nhật metrics&#10;            post_url = f&quot;{config.POST_SERVICE_URL}/api/posts/{post_id}/interactions&quot;&#10;            post_data = {&#10;                &quot;userId&quot;: user_id,&#10;                &quot;interactionType&quot;: interaction_type,&#10;                &quot;timestamp&quot;: datetime.utcnow().isoformat()&#10;            }&#10;            &#10;            # Gửi song song&#10;            responses = await asyncio.gather(&#10;                self.session.post(user_url, json=user_data),&#10;                self.session.post(post_url, json=post_data),&#10;                return_exceptions=True&#10;            )&#10;            &#10;            for i, response in enumerate(responses):&#10;                if isinstance(response, Exception):&#10;                    logger.error(f&quot;Error sending interaction event {i}: {response}&quot;)&#10;                elif response.status_code != 200:&#10;                    logger.warning(f&quot;Interaction event {i} failed: {response.status_code}&quot;)&#10;                    &#10;        except Exception as e:&#10;            logger.error(f&quot;Error sending interaction events: {e}&quot;)&#10;&#10;# Global client instance&#10;microservice_client = MicroserviceClient()" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/recommendation-service/api/monitoring.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/recommendation-service/api/monitoring.py" />
              <option name="updatedContent" value="from prometheus_client import Counter, Histogram, Gauge, Info&#10;from fastapi import FastAPI&#10;import structlog&#10;&#10;logger = structlog.get_logger()&#10;&#10;# Define Prometheus metrics&#10;class Metrics:&#10;    def __init__(self):&#10;        # Request metrics&#10;        self.request_count = Counter(&#10;            'recommendation_requests_total',&#10;            'Total number of requests',&#10;            ['method', 'endpoint', 'status_code']&#10;        )&#10;        &#10;        self.request_duration = Histogram(&#10;            'recommendation_request_duration_seconds',&#10;            'Request duration in seconds',&#10;            ['method', 'endpoint']&#10;        )&#10;        &#10;        # Recommendation metrics&#10;        self.recommendations_served = Counter(&#10;            'recommendations_served_total',&#10;            'Total recommendations served',&#10;            ['variant']&#10;        )&#10;        &#10;        self.feedback_received = Counter(&#10;            'feedback_received_total',&#10;            'Total feedback received',&#10;            ['feedback_type']&#10;        )&#10;        &#10;        # Model metrics&#10;        self.model_predictions = Counter(&#10;            'model_predictions_total',&#10;            'Total model predictions made'&#10;        )&#10;        &#10;        self.cache_hits = Counter(&#10;            'cache_hits_total',&#10;            'Cache hits',&#10;            ['cache_type']&#10;        )&#10;        &#10;        self.cache_misses = Counter(&#10;            'cache_misses_total',&#10;            'Cache misses',&#10;            ['cache_type']&#10;        )&#10;        &#10;        # Error metrics&#10;        self.error_count = Counter(&#10;            'errors_total',&#10;            'Total errors',&#10;            ['endpoint']&#10;        )&#10;        &#10;        # System metrics&#10;        self.active_users = Gauge(&#10;            'active_users',&#10;            'Number of active users'&#10;        )&#10;        &#10;        self.model_accuracy = Gauge(&#10;            'model_accuracy',&#10;            'Current model accuracy'&#10;        )&#10;        &#10;        # Service info&#10;        self.service_info = Info(&#10;            'recommendation_service_info',&#10;            'Service information'&#10;        )&#10;&#10;# Global metrics instance&#10;metrics = Metrics()&#10;&#10;def setup_monitoring(app: FastAPI):&#10;    &quot;&quot;&quot;Setup monitoring and metrics collection&quot;&quot;&quot;&#10;    try:&#10;        # Set service info&#10;        metrics.service_info.info({&#10;            'version': '1.0.0',&#10;            'environment': 'production',&#10;            'model_version': 'v1.0'&#10;        })&#10;        &#10;        logger.info(&quot;Monitoring setup completed&quot;)&#10;        &#10;    except Exception as e:&#10;        logger.error(f&quot;Failed to setup monitoring: {e}&quot;)&#10;        raise" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/recommendation-service/config/settings.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/recommendation-service/config/settings.py" />
              <option name="originalContent" value="import os&#10;from typing import Dict, Any&#10;&#10;class Config:&#10;    # Server Configuration&#10;    HOST: str = os.getenv(&quot;HOST&quot;, &quot;0.0.0.0&quot;)&#10;    PORT: int = int(os.getenv(&quot;PORT&quot;, &quot;8000&quot;))&#10;    DEBUG: bool = os.getenv(&quot;DEBUG&quot;, &quot;False&quot;).lower() == &quot;true&quot;&#10;&#10;    # Database Configuration&#10;    DATABASE_URL: str = os.getenv(&#10;        &quot;DATABASE_URL&quot;,&#10;        &quot;postgresql+asyncpg://postgres:password@localhost:5432/recommendation_db&quot;&#10;    )&#10;&#10;    # Redis Configuration&#10;    REDIS_URL: str = os.getenv(&quot;REDIS_URL&quot;, &quot;redis://localhost:6379&quot;)&#10;    REDIS_TTL: int = int(os.getenv(&quot;REDIS_TTL&quot;, &quot;3600&quot;))  # 1 hour&#10;&#10;    # Kafka Configuration&#10;    KAFKA_BOOTSTRAP_SERVERS: str = os.getenv(&quot;KAFKA_BOOTSTRAP_SERVERS&quot;, &quot;localhost:9092&quot;)&#10;    KAFKA_TOPIC_USER_INTERACTIONS: str = &quot;user_interactions&quot;&#10;    KAFKA_TOPIC_POST_UPDATES: str = &quot;post_updates&quot;&#10;    KAFKA_GROUP_ID: str = &quot;recommendation_service&quot;&#10;&#10;    # Model Configuration&#10;    MODEL_PATH: str = os.getenv(&quot;MODEL_PATH&quot;, &quot;./models/recommendation_model.pt&quot;)&#10;    BATCH_SIZE: int = int(os.getenv(&quot;BATCH_SIZE&quot;, &quot;32&quot;))&#10;    EMBEDDING_DIM: int = int(os.getenv(&quot;EMBEDDING_DIM&quot;, &quot;256&quot;))&#10;    NUM_HEADS: int = int(os.getenv(&quot;NUM_HEADS&quot;, &quot;8&quot;))&#10;&#10;    # Recommendation Settings&#10;    TOP_K_RECOMMENDATIONS: int = int(os.getenv(&quot;TOP_K_RECOMMENDATIONS&quot;, &quot;10&quot;))&#10;    DIVERSITY_THRESHOLD: float = float(os.getenv(&quot;DIVERSITY_THRESHOLD&quot;, &quot;0.7&quot;))&#10;&#10;    # A/B Testing&#10;    AB_TEST_VARIANTS: Dict[str, float] = {&#10;        &quot;personalized_v1&quot;: 0.4,&#10;        &quot;personalized_v2&quot;: 0.4,&#10;        &quot;popularity_based&quot;: 0.2&#10;    }&#10;&#10;    # MLflow Configuration&#10;    MLFLOW_TRACKING_URI: str = os.getenv(&quot;MLFLOW_TRACKING_URI&quot;, &quot;http://localhost:5000&quot;)&#10;    MLFLOW_EXPERIMENT_NAME: str = &quot;recommendation_experiments&quot;&#10;&#10;    # Security&#10;    SECRET_KEY: str = os.getenv(&quot;SECRET_KEY&quot;, &quot;your-secret-key-here&quot;)&#10;    API_KEY_HEADER: str = &quot;X-API-Key&quot;&#10;&#10;    # Performance&#10;    MAX_WORKERS: int = int(os.getenv(&quot;MAX_WORKERS&quot;, &quot;4&quot;))&#10;    REQUEST_TIMEOUT: int = int(os.getenv(&quot;REQUEST_TIMEOUT&quot;, &quot;30&quot;))&#10;&#10;config = Config()&#10;" />
              <option name="updatedContent" value="import os&#10;from typing import Dict, Any&#10;&#10;class Config:&#10;    # Server Configuration&#10;    HOST: str = os.getenv(&quot;HOST&quot;, &quot;0.0.0.0&quot;)&#10;    PORT: int = int(os.getenv(&quot;PORT&quot;, &quot;8000&quot;))&#10;    DEBUG: bool = os.getenv(&quot;DEBUG&quot;, &quot;False&quot;).lower() == &quot;true&quot;&#10;    &#10;    # Database Configuration - Sử dụng database chung với hệ thống&#10;    DATABASE_URL: str = os.getenv(&#10;        &quot;DATABASE_URL&quot;, &#10;        &quot;postgresql+asyncpg://postgres:password@auth_db:5432/auth_db&quot;&#10;    )&#10;    &#10;    # Redis Configuration - Riêng cho recommendation service&#10;    REDIS_URL: str = os.getenv(&quot;REDIS_URL&quot;, &quot;redis://recommendation-redis:6379&quot;)&#10;    REDIS_TTL: int = int(os.getenv(&quot;REDIS_TTL&quot;, &quot;3600&quot;))  # 1 hour&#10;    &#10;    # Kafka Configuration&#10;    KAFKA_BOOTSTRAP_SERVERS: str = os.getenv(&quot;KAFKA_BOOTSTRAP_SERVERS&quot;, &quot;kafka:9092&quot;)&#10;    KAFKA_TOPIC_USER_INTERACTIONS: str = &quot;user_interactions&quot;&#10;    KAFKA_TOPIC_POST_UPDATES: str = &quot;post_updates&quot;&#10;    KAFKA_GROUP_ID: str = &quot;recommendation_service&quot;&#10;    &#10;    # Eureka Service Discovery&#10;    EUREKA_SERVER_URL: str = os.getenv(&quot;EUREKA_CLIENT_SERVICE_URL_DEFAULTZONE&quot;, &quot;http://eureka-server:8761/eureka&quot;)&#10;    SERVICE_NAME: str = &quot;recommendation-service&quot;&#10;    SERVICE_ID: str = f&quot;{SERVICE_NAME}-{PORT}&quot;&#10;    &#10;    # API Gateway Integration&#10;    API_GATEWAY_URL: str = os.getenv(&quot;API_GATEWAY_URL&quot;, &quot;http://api-gateway:8090&quot;)&#10;    &#10;    # Microservices URLs&#10;    USER_SERVICE_URL: str = &quot;http://user-service:8081&quot;&#10;    POST_SERVICE_URL: str = &quot;http://post-service:8085&quot;&#10;    AUTH_SERVICE_URL: str = &quot;http://auth-service:8080&quot;&#10;    &#10;    # Model Configuration&#10;    MODEL_PATH: str = os.getenv(&quot;MODEL_PATH&quot;, &quot;./models/recommendation_model.pt&quot;)&#10;    BATCH_SIZE: int = int(os.getenv(&quot;BATCH_SIZE&quot;, &quot;32&quot;))&#10;    EMBEDDING_DIM: int = int(os.getenv(&quot;EMBEDDING_DIM&quot;, &quot;256&quot;))&#10;    NUM_HEADS: int = int(os.getenv(&quot;NUM_HEADS&quot;, &quot;8&quot;))&#10;    &#10;    # Recommendation Settings&#10;    TOP_K_RECOMMENDATIONS: int = int(os.getenv(&quot;TOP_K_RECOMMENDATIONS&quot;, &quot;10&quot;))&#10;    DIVERSITY_THRESHOLD: float = float(os.getenv(&quot;DIVERSITY_THRESHOLD&quot;, &quot;0.7&quot;))&#10;    &#10;    # A/B Testing&#10;    AB_TEST_VARIANTS: Dict[str, float] = {&#10;        &quot;personalized_v1&quot;: 0.4,&#10;        &quot;personalized_v2&quot;: 0.4,&#10;        &quot;popularity_based&quot;: 0.2&#10;    }&#10;    &#10;    # MLflow Configuration&#10;    MLFLOW_TRACKING_URI: str = os.getenv(&quot;MLFLOW_TRACKING_URI&quot;, &quot;http://mlflow-server:5000&quot;)&#10;    MLFLOW_EXPERIMENT_NAME: str = &quot;recommendation_experiments&quot;&#10;    &#10;    # Security&#10;    SECRET_KEY: str = os.getenv(&quot;SECRET_KEY&quot;, &quot;recommendation-secret-key&quot;)&#10;    API_KEY_HEADER: str = &quot;X-API-Key&quot;&#10;    &#10;    # Performance&#10;    MAX_WORKERS: int = int(os.getenv(&quot;MAX_WORKERS&quot;, &quot;4&quot;))&#10;    REQUEST_TIMEOUT: int = int(os.getenv(&quot;REQUEST_TIMEOUT&quot;, &quot;30&quot;))&#10;    &#10;    # Health Check&#10;    HEALTH_CHECK_INTERVAL: int = int(os.getenv(&quot;HEALTH_CHECK_INTERVAL&quot;, &quot;30&quot;))&#10;&#10;config = Config()" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/recommendation-service/core/models.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/recommendation-service/core/models.py" />
              <option name="updatedContent" value="import torch&#10;import torch.nn as nn&#10;import torch.nn.functional as F&#10;from typing import Dict, List, Optional, Tuple&#10;import numpy as np&#10;from transformers import AutoModel, AutoTokenizer&#10;&#10;class UserEmbedding(nn.Module):&#10;    &quot;&quot;&quot;User embedding layer with profile features&quot;&quot;&quot;&#10;    &#10;    def __init__(self, num_users: int, embedding_dim: int, profile_dim: int = 64):&#10;        super().__init__()&#10;        self.user_embedding = nn.Embedding(num_users, embedding_dim)&#10;        self.profile_encoder = nn.Sequential(&#10;            nn.Linear(profile_dim, embedding_dim // 2),&#10;            nn.ReLU(),&#10;            nn.Dropout(0.2),&#10;            nn.Linear(embedding_dim // 2, embedding_dim)&#10;        )&#10;        self.fusion = nn.Linear(embedding_dim * 2, embedding_dim)&#10;        &#10;    def forward(self, user_ids: torch.Tensor, profile_features: torch.Tensor) -&gt; torch.Tensor:&#10;        user_emb = self.user_embedding(user_ids)&#10;        profile_emb = self.profile_encoder(profile_features)&#10;        fused = torch.cat([user_emb, profile_emb], dim=-1)&#10;        return torch.tanh(self.fusion(fused))&#10;&#10;class PostEmbedding(nn.Module):&#10;    &quot;&quot;&quot;Post embedding with content and metadata features&quot;&quot;&quot;&#10;    &#10;    def __init__(self, num_posts: int, embedding_dim: int, content_dim: int = 768):&#10;        super().__init__()&#10;        self.post_embedding = nn.Embedding(num_posts, embedding_dim)&#10;        self.content_encoder = nn.Sequential(&#10;            nn.Linear(content_dim, embedding_dim),&#10;            nn.ReLU(),&#10;            nn.Dropout(0.2)&#10;        )&#10;        self.category_embedding = nn.Embedding(20, embedding_dim // 4)  # Assume 20 categories&#10;        self.fusion = nn.Linear(embedding_dim + embedding_dim // 4, embedding_dim)&#10;        &#10;    def forward(self, post_ids: torch.Tensor, content_features: torch.Tensor, &#10;                categories: torch.Tensor) -&gt; torch.Tensor:&#10;        post_emb = self.post_embedding(post_ids)&#10;        content_emb = self.content_encoder(content_features)&#10;        cat_emb = self.category_embedding(categories)&#10;        &#10;        # Combine embeddings&#10;        combined = torch.cat([post_emb + content_emb, cat_emb], dim=-1)&#10;        return torch.tanh(self.fusion(combined))&#10;&#10;class MultiHeadAttention(nn.Module):&#10;    &quot;&quot;&quot;Multi-head attention for user-post interaction&quot;&quot;&quot;&#10;    &#10;    def __init__(self, embedding_dim: int, num_heads: int = 8):&#10;        super().__init__()&#10;        self.num_heads = num_heads&#10;        self.head_dim = embedding_dim // num_heads&#10;        assert embedding_dim % num_heads == 0&#10;        &#10;        self.query = nn.Linear(embedding_dim, embedding_dim)&#10;        self.key = nn.Linear(embedding_dim, embedding_dim)&#10;        self.value = nn.Linear(embedding_dim, embedding_dim)&#10;        self.output = nn.Linear(embedding_dim, embedding_dim)&#10;        self.dropout = nn.Dropout(0.1)&#10;        &#10;    def forward(self, user_emb: torch.Tensor, post_emb: torch.Tensor) -&gt; torch.Tensor:&#10;        batch_size = user_emb.size(0)&#10;        &#10;        # Generate Q, K, V&#10;        Q = self.query(user_emb).view(batch_size, self.num_heads, self.head_dim)&#10;        K = self.key(post_emb).view(batch_size, self.num_heads, self.head_dim)&#10;        V = self.value(post_emb).view(batch_size, self.num_heads, self.head_dim)&#10;        &#10;        # Attention scores&#10;        scores = torch.matmul(Q, K.transpose(-2, -1)) / np.sqrt(self.head_dim)&#10;        attention_weights = F.softmax(scores, dim=-1)&#10;        attention_weights = self.dropout(attention_weights)&#10;        &#10;        # Apply attention&#10;        attended = torch.matmul(attention_weights, V)&#10;        attended = attended.view(batch_size, -1)&#10;        &#10;        return self.output(attended)&#10;&#10;class PersonalizedRecommendationModel(nn.Module):&#10;    &quot;&quot;&quot;Main recommendation model with deep learning and attention&quot;&quot;&quot;&#10;    &#10;    def __init__(self, num_users: int, num_posts: int, embedding_dim: int = 256, &#10;                 num_heads: int = 8, content_model_name: str = &quot;vinai/phobert-base&quot;):&#10;        super().__init__()&#10;        &#10;        self.embedding_dim = embedding_dim&#10;        &#10;        # Content encoder (PhoBERT for Vietnamese)&#10;        self.content_tokenizer = AutoTokenizer.from_pretrained(content_model_name)&#10;        self.content_encoder = AutoModel.from_pretrained(content_model_name)&#10;        &#10;        # Freeze PhoBERT parameters for efficiency&#10;        for param in self.content_encoder.parameters():&#10;            param.requires_grad = False&#10;            &#10;        # Embedding layers&#10;        self.user_embedding = UserEmbedding(num_users, embedding_dim)&#10;        self.post_embedding = PostEmbedding(num_posts, embedding_dim)&#10;        &#10;        # Attention mechanism&#10;        self.attention = MultiHeadAttention(embedding_dim, num_heads)&#10;        &#10;        # Prediction head&#10;        self.predictor = nn.Sequential(&#10;            nn.Linear(embedding_dim * 2, embedding_dim),&#10;            nn.ReLU(),&#10;            nn.Dropout(0.3),&#10;            nn.Linear(embedding_dim, embedding_dim // 2),&#10;            nn.ReLU(),&#10;            nn.Dropout(0.2),&#10;            nn.Linear(embedding_dim // 2, 1),&#10;            nn.Sigmoid()&#10;        )&#10;        &#10;        # Context encoder for temporal and situational features&#10;        self.context_encoder = nn.Sequential(&#10;            nn.Linear(32, embedding_dim // 2),  # time, device, location features&#10;            nn.ReLU(),&#10;            nn.Linear(embedding_dim // 2, embedding_dim // 4)&#10;        )&#10;        &#10;    def encode_content(self, texts: List[str]) -&gt; torch.Tensor:&#10;        &quot;&quot;&quot;Encode Vietnamese text content using PhiBERT&quot;&quot;&quot;&#10;        if not texts:&#10;            return torch.zeros(1, 768)&#10;            &#10;        inputs = self.content_tokenizer(&#10;            texts, padding=True, truncation=True, &#10;            max_length=512, return_tensors=&quot;pt&quot;&#10;        )&#10;        &#10;        with torch.no_grad():&#10;            outputs = self.content_encoder(**inputs)&#10;            return outputs.last_hidden_state.mean(dim=1)  # Average pooling&#10;    &#10;    def forward(self, user_ids: torch.Tensor, post_ids: torch.Tensor,&#10;                user_profiles: torch.Tensor, post_contents: torch.Tensor,&#10;                post_categories: torch.Tensor, context_features: torch.Tensor) -&gt; torch.Tensor:&#10;        &#10;        # Generate embeddings&#10;        user_emb = self.user_embedding(user_ids, user_profiles)&#10;        post_emb = self.post_embedding(post_ids, post_contents, post_categories)&#10;        &#10;        # Apply attention&#10;        attended_post = self.attention(user_emb, post_emb)&#10;        &#10;        # Encode context&#10;        context_emb = self.context_encoder(context_features)&#10;        &#10;        # Combine all features&#10;        combined = torch.cat([&#10;            user_emb, &#10;            attended_post,&#10;            context_emb.expand(-1, self.embedding_dim // 4)&#10;        ], dim=-1)&#10;        &#10;        # Predict relevance score&#10;        relevance_score = self.predictor(combined)&#10;        &#10;        return relevance_score.squeeze(-1)&#10;&#10;class ReinforcementLearningAgent(nn.Module):&#10;    &quot;&quot;&quot;DQN-based RL agent for recommendation optimization&quot;&quot;&quot;&#10;    &#10;    def __init__(self, state_dim: int, action_dim: int, hidden_dim: int = 512):&#10;        super().__init__()&#10;        &#10;        self.q_network = nn.Sequential(&#10;            nn.Linear(state_dim, hidden_dim),&#10;            nn.ReLU(),&#10;            nn.Dropout(0.2),&#10;            nn.Linear(hidden_dim, hidden_dim // 2),&#10;            nn.ReLU(),&#10;            nn.Dropout(0.2),&#10;            nn.Linear(hidden_dim // 2, action_dim)&#10;        )&#10;        &#10;        self.target_network = nn.Sequential(&#10;            nn.Linear(state_dim, hidden_dim),&#10;            nn.ReLU(),&#10;            nn.Dropout(0.2),&#10;            nn.Linear(hidden_dim, hidden_dim // 2),&#10;            nn.ReLU(),&#10;            nn.Dropout(0.2),&#10;            nn.Linear(hidden_dim // 2, action_dim)&#10;        )&#10;        &#10;        # Copy weights to target network&#10;        self.target_network.load_state_dict(self.q_network.state_dict())&#10;        &#10;    def forward(self, state: torch.Tensor) -&gt; torch.Tensor:&#10;        return self.q_network(state)&#10;    &#10;    def get_target_q_values(self, state: torch.Tensor) -&gt; torch.Tensor:&#10;        with torch.no_grad():&#10;            return self.target_network(state)&#10;    &#10;    def update_target_network(self):&#10;        &quot;&quot;&quot;Soft update of target network&quot;&quot;&quot;&#10;        tau = 0.005&#10;        for target_param, param in zip(self.target_network.parameters(), &#10;                                     self.q_network.parameters()):&#10;            target_param.data.copy_(tau * param.data + (1 - tau) * target_param.data)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/recommendation-service/core/recommendation_engine.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/recommendation-service/core/recommendation_engine.py" />
              <option name="updatedContent" value="import asyncio&#10;import random&#10;import logging&#10;from typing import Dict, List, Optional, Tuple, Any&#10;import numpy as np&#10;import torch&#10;from datetime import datetime, timedelta&#10;from sqlalchemy.ext.asyncio import AsyncSession&#10;from sqlalchemy import select, func&#10;import aioredis&#10;&#10;from core.models import PersonalizedRecommendationModel, ReinforcementLearningAgent&#10;from data.processor import DataProcessor, FeatureStore&#10;from db.models import UserProfile, PostFeatures, UserInteraction, RecommendationLog, ABTestExperiment&#10;from config.settings import config&#10;&#10;logger = logging.getLogger(__name__)&#10;&#10;class RecommendationEngine:&#10;    &quot;&quot;&quot;Core recommendation engine with multiple algorithms&quot;&quot;&quot;&#10;    &#10;    def __init__(self):&#10;        self.model = None&#10;        self.rl_agent = None&#10;        self.feature_store = None&#10;        self.data_processor = None&#10;        self.redis_client = None&#10;        self.is_initialized = False&#10;        &#10;    async def initialize(self):&#10;        &quot;&quot;&quot;Initialize the recommendation engine&quot;&quot;&quot;&#10;        try:&#10;            # Initialize Redis client&#10;            self.redis_client = aioredis.from_url(config.REDIS_URL)&#10;            &#10;            # Initialize feature store and data processor&#10;            self.feature_store = FeatureStore(self.redis_client)&#10;            self.data_processor = DataProcessor()&#10;            await self.data_processor.initialize()&#10;            &#10;            # Load pre-trained model if exists&#10;            await self.load_model()&#10;            &#10;            self.is_initialized = True&#10;            logger.info(&quot;Recommendation engine initialized successfully&quot;)&#10;            &#10;        except Exception as e:&#10;            logger.error(f&quot;Failed to initialize recommendation engine: {e}&quot;)&#10;            raise&#10;    &#10;    async def load_model(self):&#10;        &quot;&quot;&quot;Load the trained recommendation model&quot;&quot;&quot;&#10;        try:&#10;            if torch.cuda.is_available():&#10;                device = torch.device(&quot;cuda&quot;)&#10;            else:&#10;                device = torch.device(&quot;cpu&quot;)&#10;                &#10;            # Initialize model with default parameters&#10;            # These would be loaded from a configuration or model registry&#10;            num_users = 10000  # This should be dynamic based on actual user count&#10;            num_posts = 50000  # This should be dynamic based on actual post count&#10;            &#10;            self.model = PersonalizedRecommendationModel(&#10;                num_users=num_users,&#10;                num_posts=num_posts,&#10;                embedding_dim=config.EMBEDDING_DIM,&#10;                num_heads=config.NUM_HEADS&#10;            ).to(device)&#10;            &#10;            # Load pre-trained weights if available&#10;            try:&#10;                checkpoint = torch.load(config.MODEL_PATH, map_location=device)&#10;                self.model.load_state_dict(checkpoint['model_state_dict'])&#10;                logger.info(f&quot;Loaded pre-trained model from {config.MODEL_PATH}&quot;)&#10;            except FileNotFoundError:&#10;                logger.warning(&quot;No pre-trained model found, using randomly initialized model&quot;)&#10;            &#10;            # Initialize RL agent&#10;            state_dim = config.EMBEDDING_DIM + 32  # User embedding + context features&#10;            action_dim = config.TOP_K_RECOMMENDATIONS&#10;            &#10;            self.rl_agent = ReinforcementLearningAgent(&#10;                state_dim=state_dim,&#10;                action_dim=action_dim&#10;            ).to(device)&#10;            &#10;            self.model.eval()&#10;            &#10;        except Exception as e:&#10;            logger.error(f&quot;Failed to load model: {e}&quot;)&#10;            raise&#10;    &#10;    async def get_recommendations(self, user_id: str, context: Dict[str, Any],&#10;                                db_session: AsyncSession, k: int = None) -&gt; Dict[str, Any]:&#10;        &quot;&quot;&quot;Get personalized recommendations for a user&quot;&quot;&quot;&#10;        if not self.is_initialized:&#10;            raise RuntimeError(&quot;Recommendation engine not initialized&quot;)&#10;        &#10;        k = k or config.TOP_K_RECOMMENDATIONS&#10;        &#10;        # Check cache first&#10;        cache_key = f&quot;recommendations:{user_id}:{hash(str(sorted(context.items())))}&quot;&#10;        cached_result = await self.redis_client.get(cache_key)&#10;        &#10;        if cached_result:&#10;            import json&#10;            return json.loads(cached_result)&#10;        &#10;        # Get A/B test variant&#10;        ab_variant = await self.get_ab_test_variant(user_id, db_session)&#10;        &#10;        # Generate recommendations based on variant&#10;        if ab_variant == &quot;popularity_based&quot;:&#10;            recommendations = await self.get_popularity_based_recommendations(&#10;                user_id, context, db_session, k&#10;            )&#10;        else:&#10;            recommendations = await self.get_personalized_recommendations(&#10;                user_id, context, db_session, k, ab_variant&#10;            )&#10;        &#10;        # Add A/B test info&#10;        result = {&#10;            &quot;recommendations&quot;: recommendations,&#10;            &quot;ab_variant&quot;: ab_variant,&#10;            &quot;timestamp&quot;: datetime.utcnow().isoformat(),&#10;            &quot;user_id&quot;: user_id&#10;        }&#10;        &#10;        # Cache result&#10;        await self.redis_client.setex(&#10;            cache_key, &#10;            config.REDIS_TTL, &#10;            json.dumps(result, default=str)&#10;        )&#10;        &#10;        # Log recommendation&#10;        await self.log_recommendation(user_id, recommendations, ab_variant, context, db_session)&#10;        &#10;        return result&#10;    &#10;    async def get_personalized_recommendations(self, user_id: str, context: Dict[str, Any],&#10;                                             db_session: AsyncSession, k: int, &#10;                                             variant: str) -&gt; List[Dict[str, Any]]:&#10;        &quot;&quot;&quot;Generate personalized recommendations using deep learning model&quot;&quot;&quot;&#10;        try:&#10;            # Get user profile and features&#10;            user_profile = await self.get_user_profile(user_id, db_session)&#10;            if not user_profile:&#10;                # Fallback to popularity-based for new users&#10;                return await self.get_popularity_based_recommendations(&#10;                    user_id, context, db_session, k&#10;                )&#10;            &#10;            # Get candidate posts (exclude recently interacted posts)&#10;            candidate_posts = await self.get_candidate_posts(user_id, db_session, k * 5)&#10;            &#10;            if not candidate_posts:&#10;                return []&#10;            &#10;            # Prepare model inputs&#10;            user_features = self.prepare_user_features(user_profile, context)&#10;            post_features_list = []&#10;            &#10;            for post in candidate_posts:&#10;                post_features = await self.prepare_post_features(post, db_session)&#10;                post_features_list.append(post_features)&#10;            &#10;            # Get model predictions&#10;            scores = await self.predict_scores(user_features, post_features_list)&#10;            &#10;            # Apply reinforcement learning adjustment if available&#10;            if self.rl_agent and variant == &quot;personalized_v2&quot;:&#10;                scores = await self.apply_rl_adjustment(user_id, candidate_posts, scores, context)&#10;            &#10;            # Rank and select top-k&#10;            ranked_posts = self.rank_posts(candidate_posts, scores)&#10;            &#10;            # Apply diversity constraints&#10;            diverse_posts = self.apply_diversity_filter(ranked_posts, k)&#10;            &#10;            # Format results&#10;            recommendations = []&#10;            for i, (post, score) in enumerate(diverse_posts[:k]):&#10;                recommendations.append({&#10;                    &quot;post_id&quot;: post.post_id,&#10;                    &quot;title&quot;: post.title,&#10;                    &quot;content&quot;: post.content[:200] + &quot;...&quot; if len(post.content) &gt; 200 else post.content,&#10;                    &quot;author_id&quot;: post.author_id,&#10;                    &quot;category&quot;: post.category,&#10;                    &quot;tags&quot;: post.tags,&#10;                    &quot;engagement_rate&quot;: post.engagement_rate,&#10;                    &quot;relevance_score&quot;: float(score),&#10;                    &quot;rank&quot;: i + 1,&#10;                    &quot;reason&quot;: self.generate_explanation(user_profile, post)&#10;                })&#10;            &#10;            return recommendations&#10;            &#10;        except Exception as e:&#10;            logger.error(f&quot;Error generating personalized recommendations: {e}&quot;)&#10;            # Fallback to popularity-based&#10;            return await self.get_popularity_based_recommendations(&#10;                user_id, context, db_session, k&#10;            )&#10;    &#10;    async def get_popularity_based_recommendations(self, user_id: str, context: Dict[str, Any],&#10;                                                 db_session: AsyncSession, k: int) -&gt; List[Dict[str, Any]]:&#10;        &quot;&quot;&quot;Generate popularity-based recommendations as fallback&quot;&quot;&quot;&#10;        try:&#10;            # Get top posts by engagement in the last 7 days&#10;            week_ago = datetime.utcnow() - timedelta(days=7)&#10;            &#10;            result = await db_session.execute(&#10;                select(PostFeatures)&#10;                .where(PostFeatures.updated_at &gt;= week_ago)&#10;                .order_by(PostFeatures.engagement_rate.desc())&#10;                .limit(k * 2)&#10;            )&#10;            posts = result.scalars().all()&#10;            &#10;            # Filter out posts user has already interacted with&#10;            user_interactions = await db_session.execute(&#10;                select(UserInteraction.post_id)&#10;                .where(UserInteraction.user_id == user_id)&#10;                .where(UserInteraction.timestamp &gt;= week_ago)&#10;            )&#10;            interacted_post_ids = {row[0] for row in user_interactions.fetchall()}&#10;            &#10;            filtered_posts = [post for post in posts if post.post_id not in interacted_post_ids]&#10;            &#10;            recommendations = []&#10;            for i, post in enumerate(filtered_posts[:k]):&#10;                recommendations.append({&#10;                    &quot;post_id&quot;: post.post_id,&#10;                    &quot;title&quot;: post.title,&#10;                    &quot;content&quot;: post.content[:200] + &quot;...&quot; if len(post.content) &gt; 200 else post.content,&#10;                    &quot;author_id&quot;: post.author_id,&#10;                    &quot;category&quot;: post.category,&#10;                    &quot;tags&quot;: post.tags,&#10;                    &quot;engagement_rate&quot;: post.engagement_rate,&#10;                    &quot;relevance_score&quot;: post.engagement_rate,&#10;                    &quot;rank&quot;: i + 1,&#10;                    &quot;reason&quot;: &quot;Trending post&quot;&#10;                })&#10;            &#10;            return recommendations&#10;            &#10;        except Exception as e:&#10;            logger.error(f&quot;Error generating popularity-based recommendations: {e}&quot;)&#10;            return []&#10;    &#10;    async def get_user_profile(self, user_id: str, db_session: AsyncSession) -&gt; Optional[UserProfile]:&#10;        &quot;&quot;&quot;Get user profile from database&quot;&quot;&quot;&#10;        result = await db_session.execute(&#10;            select(UserProfile).where(UserProfile.user_id == user_id)&#10;        )&#10;        return result.scalar_one_or_none()&#10;    &#10;    async def get_candidate_posts(self, user_id: str, db_session: AsyncSession, &#10;                                limit: int = 100) -&gt; List[PostFeatures]:&#10;        &quot;&quot;&quot;Get candidate posts for recommendation&quot;&quot;&quot;&#10;        # Get posts from last 30 days, excluding user's own posts and already interacted posts&#10;        thirty_days_ago = datetime.utcnow() - timedelta(days=30)&#10;        &#10;        # Get user's recent interactions&#10;        user_interactions = await db_session.execute(&#10;            select(UserInteraction.post_id)&#10;            .where(UserInteraction.user_id == user_id)&#10;            .where(UserInteraction.timestamp &gt;= thirty_days_ago)&#10;        )&#10;        interacted_post_ids = {row[0] for row in user_interactions.fetchall()}&#10;        &#10;        # Get candidate posts&#10;        query = select(PostFeatures).where(&#10;            PostFeatures.updated_at &gt;= thirty_days_ago,&#10;            PostFeatures.author_id != user_id&#10;        )&#10;        &#10;        if interacted_post_ids:&#10;            query = query.where(~PostFeatures.post_id.in_(interacted_post_ids))&#10;        &#10;        result = await db_session.execute(&#10;            query.order_by(PostFeatures.updated_at.desc()).limit(limit)&#10;        )&#10;        &#10;        return result.scalars().all()&#10;    &#10;    def prepare_user_features(self, user_profile: UserProfile, context: Dict[str, Any]) -&gt; Dict[str, Any]:&#10;        &quot;&quot;&quot;Prepare user features for model input&quot;&quot;&quot;&#10;        # Extract user profile features&#10;        interests = user_profile.interests or {}&#10;        engagement_score = user_profile.engagement_score or 0.0&#10;        activity_pattern = user_profile.activity_pattern or {}&#10;        &#10;        # Create user profile vector&#10;        profile_features = np.zeros(64)  # 64-dimensional profile vector&#10;        &#10;        # Encode interests (top categories)&#10;        top_interests = sorted(interests.items(), key=lambda x: x[1], reverse=True)[:10]&#10;        for i, (category, score) in enumerate(top_interests):&#10;            if i &lt; 10:&#10;                profile_features[i] = min(score / 10.0, 1.0)  # Normalize&#10;        &#10;        # Add engagement score&#10;        profile_features[10] = min(engagement_score, 1.0)&#10;        &#10;        # Add activity pattern features&#10;        current_hour = datetime.now().hour&#10;        profile_features[11] = activity_pattern.get(str(current_hour), 0.0)&#10;        &#10;        # Context features&#10;        context_features = self.data_processor.extract_user_context(&#10;            user_profile.__dict__, context&#10;        )&#10;        &#10;        return {&#10;            'profile_features': profile_features,&#10;            'context_features': context_features&#10;        }&#10;    &#10;    async def prepare_post_features(self, post: PostFeatures, db_session: AsyncSession) -&gt; Dict[str, Any]:&#10;        &quot;&quot;&quot;Prepare post features for model input&quot;&quot;&quot;&#10;        # Content embedding (would be pre-computed and stored)&#10;        content_embedding = post.content_embedding or np.zeros(768).tolist()&#10;        &#10;        # Category encoding&#10;        categories = [&#10;            &quot;Van Hoc&quot;, &quot;Khoa Hoc&quot;, &quot;Cong Nghe&quot;, &quot;The Thao&quot;, &quot;Giai Tri&quot;,&#10;            &quot;Kinh Te&quot;, &quot;Chinh Tri&quot;, &quot;Xa Hoi&quot;, &quot;Giao Duc&quot;, &quot;Y Te&quot;&#10;        ]&#10;        category_id = categories.index(post.category) if post.category in categories else 0&#10;        &#10;        return {&#10;            'content_embedding': np.array(content_embedding),&#10;            'category_id': category_id,&#10;            'engagement_metrics': np.array([&#10;                post.likes_count / 100.0,  # Normalize&#10;                post.comments_count / 50.0,&#10;                post.shares_count / 20.0,&#10;                post.views_count / 1000.0,&#10;                post.engagement_rate&#10;            ])&#10;        }&#10;    &#10;    async def predict_scores(self, user_features: Dict[str, Any], &#10;                           post_features_list: List[Dict[str, Any]]) -&gt; np.ndarray:&#10;        &quot;&quot;&quot;Predict relevance scores using the deep learning model&quot;&quot;&quot;&#10;        if not self.model:&#10;            # Return random scores if model not available&#10;            return np.random.random(len(post_features_list))&#10;        &#10;        try:&#10;            self.model.eval()&#10;            with torch.no_grad():&#10;                batch_size = len(post_features_list)&#10;                &#10;                # Prepare batch tensors (simplified for this example)&#10;                user_ids = torch.zeros(batch_size, dtype=torch.long)  # Would be actual user ID mapping&#10;                post_ids = torch.zeros(batch_size, dtype=torch.long)  # Would be actual post ID mapping&#10;                &#10;                user_profiles = torch.tensor([user_features['profile_features']] * batch_size).float()&#10;                context_features = torch.tensor([user_features['context_features']] * batch_size).float()&#10;                &#10;                post_contents = torch.stack([&#10;                    torch.tensor(pf['content_embedding']).float() &#10;                    for pf in post_features_list&#10;                ])&#10;                &#10;                post_categories = torch.tensor([&#10;                    pf['category_id'] for pf in post_features_list&#10;                ], dtype=torch.long)&#10;                &#10;                # Get predictions&#10;                scores = self.model(&#10;                    user_ids, post_ids, user_profiles, &#10;                    post_contents, post_categories, context_features&#10;                )&#10;                &#10;                return scores.cpu().numpy()&#10;                &#10;        except Exception as e:&#10;            logger.error(f&quot;Error in model prediction: {e}&quot;)&#10;            return np.random.random(len(post_features_list))&#10;    &#10;    def rank_posts(self, posts: List[PostFeatures], scores: np.ndarray) -&gt; List[Tuple[PostFeatures, float]]:&#10;        &quot;&quot;&quot;Rank posts by predicted scores&quot;&quot;&quot;&#10;        ranked = list(zip(posts, scores))&#10;        ranked.sort(key=lambda x: x[1], reverse=True)&#10;        return ranked&#10;    &#10;    def apply_diversity_filter(self, ranked_posts: List[Tuple[PostFeatures, float]], &#10;                             k: int) -&gt; List[Tuple[PostFeatures, float]]:&#10;        &quot;&quot;&quot;Apply diversity constraints to recommendations&quot;&quot;&quot;&#10;        if len(ranked_posts) &lt;= k:&#10;            return ranked_posts&#10;        &#10;        diverse_posts = []&#10;        seen_categories = set()&#10;        seen_authors = set()&#10;        &#10;        # First pass: ensure category diversity&#10;        for post, score in ranked_posts:&#10;            if len(diverse_posts) &gt;= k:&#10;                break&#10;                &#10;            category = post.category or &quot;Unknown&quot;&#10;            author = post.author_id&#10;            &#10;            # Add if we haven't seen this category or if we have room&#10;            if category not in seen_categories or len(diverse_posts) &lt; k // 2:&#10;                diverse_posts.append((post, score))&#10;                seen_categories.add(category)&#10;                seen_authors.add(author)&#10;        &#10;        # Second pass: fill remaining slots with high-scoring posts&#10;        for post, score in ranked_posts:&#10;            if len(diverse_posts) &gt;= k:&#10;                break&#10;                &#10;            if (post, score) not in diverse_posts:&#10;                diverse_posts.append((post, score))&#10;        &#10;        return diverse_posts[:k]&#10;    &#10;    def generate_explanation(self, user_profile: UserProfile, post: PostFeatures) -&gt; str:&#10;        &quot;&quot;&quot;Generate explanation for why this post was recommended&quot;&quot;&quot;&#10;        interests = user_profile.interests or {}&#10;        &#10;        if post.category in interests:&#10;            return f&quot;Recommended because you're interested in {post.category}&quot;&#10;        elif post.engagement_rate &gt; 0.1:&#10;            return &quot;Trending post with high engagement&quot;&#10;        else:&#10;            return &quot;Recommended based on your activity pattern&quot;&#10;    &#10;    async def get_ab_test_variant(self, user_id: str, db_session: AsyncSession) -&gt; str:&#10;        &quot;&quot;&quot;Get A/B test variant for user&quot;&quot;&quot;&#10;        # Simple hash-based assignment&#10;        user_hash = hash(user_id) % 1000&#10;        &#10;        cumulative = 0&#10;        for variant, percentage in config.AB_TEST_VARIANTS.items():&#10;            cumulative += int(percentage * 1000)&#10;            if user_hash &lt; cumulative:&#10;                return variant&#10;        &#10;        return &quot;personalized_v1&quot;  # Default&#10;    &#10;    async def log_recommendation(self, user_id: str, recommendations: List[Dict[str, Any]],&#10;                               ab_variant: str, context: Dict[str, Any], &#10;                               db_session: AsyncSession):&#10;        &quot;&quot;&quot;Log recommendation for analytics&quot;&quot;&quot;&#10;        try:&#10;            post_ids = [rec[&quot;post_id&quot;] for rec in recommendations]&#10;            &#10;            log_entry = RecommendationLog(&#10;                user_id=user_id,&#10;                post_ids=post_ids,&#10;                model_version=&quot;v1.0&quot;,&#10;                ab_test_variant=ab_variant,&#10;                request_context=context,&#10;                served_count=len(post_ids)&#10;            )&#10;            &#10;            db_session.add(log_entry)&#10;            await db_session.commit()&#10;            &#10;        except Exception as e:&#10;            logger.error(f&quot;Error logging recommendation: {e}&quot;)&#10;    &#10;    async def record_feedback(self, user_id: str, post_id: str, feedback_type: str,&#10;                            context: Dict[str, Any], db_session: AsyncSession):&#10;        &quot;&quot;&quot;Record user feedback for reinforcement learning&quot;&quot;&quot;&#10;        try:&#10;            # Calculate reward based on feedback type&#10;            reward_map = {&#10;                'click': 0.2,&#10;                'like': 0.5,&#10;                'comment': 0.8,&#10;                'share': 1.0,&#10;                'skip': -0.1,&#10;                'dislike': -0.5&#10;            }&#10;            &#10;            reward = reward_map.get(feedback_type, 0.0)&#10;            &#10;            # Store interaction&#10;            interaction = UserInteraction(&#10;                user_id=user_id,&#10;                post_id=post_id,&#10;                interaction_type=feedback_type,&#10;                context_data=context,&#10;                reward=reward&#10;            )&#10;            &#10;            db_session.add(interaction)&#10;            await db_session.commit()&#10;            &#10;            # Update user profile&#10;            await self.data_processor.update_user_profile(user_id, {&#10;                'type': feedback_type,&#10;                'postId': post_id,&#10;                'timestamp': datetime.utcnow().isoformat(),&#10;                **context&#10;            }, db_session)&#10;            &#10;            # Invalidate cache&#10;            await self.redis_client.delete(f&quot;recommendations:{user_id}*&quot;)&#10;            &#10;            logger.info(f&quot;Recorded feedback: {user_id} -&gt; {post_id} ({feedback_type}, reward: {reward})&quot;)&#10;            &#10;        except Exception as e:&#10;            logger.error(f&quot;Error recording feedback: {e}&quot;)&#10;            await db_session.rollback()" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/recommendation-service/core/training.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/recommendation-service/core/training.py" />
              <option name="updatedContent" value="import torch&#10;import torch.nn as nn&#10;import torch.optim as optim&#10;from torch.utils.data import Dataset, DataLoader&#10;import numpy as np&#10;import pandas as pd&#10;from typing import Dict, List, Tuple, Any&#10;import logging&#10;from datetime import datetime, timedelta&#10;import mlflow&#10;import mlflow.pytorch&#10;from sklearn.metrics import precision_score, recall_score, f1_score, roc_auc_score&#10;from sqlalchemy.ext.asyncio import AsyncSession&#10;import asyncio&#10;&#10;from core.models import PersonalizedRecommendationModel, ReinforcementLearningAgent&#10;from data.processor import DataProcessor, BatchProcessor&#10;from db.models import UserInteraction, PostFeatures, UserProfile, ModelMetrics&#10;from config.settings import config&#10;&#10;logger = logging.getLogger(__name__)&#10;&#10;class RecommendationDataset(Dataset):&#10;    &quot;&quot;&quot;Dataset for training recommendation model&quot;&quot;&quot;&#10;    &#10;    def __init__(self, interactions: List[Dict], user_features: Dict, post_features: Dict):&#10;        self.interactions = interactions&#10;        self.user_features = user_features&#10;        self.post_features = post_features&#10;        &#10;    def __len__(self):&#10;        return len(self.interactions)&#10;    &#10;    def __getitem__(self, idx):&#10;        interaction = self.interactions[idx]&#10;        user_id = interaction['user_id']&#10;        post_id = interaction['post_id']&#10;        label = interaction['label']&#10;        &#10;        # Get features&#10;        user_profile = self.user_features.get(user_id, np.zeros(64))&#10;        post_content = self.post_features.get(post_id, {}).get('content_embedding', np.zeros(768))&#10;        post_category = self.post_features.get(post_id, {}).get('category_id', 0)&#10;        context = interaction.get('context', np.zeros(32))&#10;        &#10;        return {&#10;            'user_id': torch.tensor(hash(user_id) % 10000, dtype=torch.long),&#10;            'post_id': torch.tensor(hash(post_id) % 50000, dtype=torch.long),&#10;            'user_profile': torch.tensor(user_profile, dtype=torch.float32),&#10;            'post_content': torch.tensor(post_content, dtype=torch.float32),&#10;            'post_category': torch.tensor(post_category, dtype=torch.long),&#10;            'context': torch.tensor(context, dtype=torch.float32),&#10;            'label': torch.tensor(label, dtype=torch.float32)&#10;        }&#10;&#10;class ModelTrainer:&#10;    &quot;&quot;&quot;Handles model training and evaluation&quot;&quot;&quot;&#10;    &#10;    def __init__(self, db_session_factory):&#10;        self.db_session_factory = db_session_factory&#10;        self.device = torch.device(&quot;cuda&quot; if torch.cuda.is_available() else &quot;cpu&quot;)&#10;        self.model = None&#10;        self.optimizer = None&#10;        self.scheduler = None&#10;        &#10;    async def prepare_training_data(self, days_back: int = 30) -&gt; Tuple[DataLoader, DataLoader]:&#10;        &quot;&quot;&quot;Prepare training and validation data&quot;&quot;&quot;&#10;        try:&#10;            # Get data from last N days&#10;            end_date = datetime.utcnow()&#10;            start_date = end_date - timedelta(days=days_back)&#10;            &#10;            batch_processor = BatchProcessor(self.db_session_factory)&#10;            training_data = await batch_processor.prepare_training_data(start_date, end_date)&#10;            &#10;            # Load user and post features&#10;            user_features = await self.load_user_features()&#10;            post_features = await self.load_post_features()&#10;            &#10;            # Create positive and negative samples&#10;            interactions = []&#10;            for i in range(len(training_data['user_ids'])):&#10;                interactions.append({&#10;                    'user_id': training_data['user_ids'][i],&#10;                    'post_id': training_data['post_ids'][i],&#10;                    'label': training_data['labels'][i],&#10;                    'context': np.random.random(32)  # Simplified context&#10;                })&#10;            &#10;            # Add negative samples&#10;            negative_samples = await self.generate_negative_samples(interactions, user_features, post_features)&#10;            interactions.extend(negative_samples)&#10;            &#10;            # Split train/validation&#10;            split_idx = int(len(interactions) * 0.8)&#10;            train_interactions = interactions[:split_idx]&#10;            val_interactions = interactions[split_idx:]&#10;            &#10;            # Create datasets&#10;            train_dataset = RecommendationDataset(train_interactions, user_features, post_features)&#10;            val_dataset = RecommendationDataset(val_interactions, user_features, post_features)&#10;            &#10;            # Create data loaders&#10;            train_loader = DataLoader(&#10;                train_dataset, &#10;                batch_size=config.BATCH_SIZE, &#10;                shuffle=True,&#10;                num_workers=2&#10;            )&#10;            val_loader = DataLoader(&#10;                val_dataset, &#10;                batch_size=config.BATCH_SIZE, &#10;                shuffle=False,&#10;                num_workers=2&#10;            )&#10;            &#10;            logger.info(f&quot;Prepared {len(train_interactions)} training and {len(val_interactions)} validation samples&quot;)&#10;            &#10;            return train_loader, val_loader&#10;            &#10;        except Exception as e:&#10;            logger.error(f&quot;Error preparing training data: {e}&quot;)&#10;            raise&#10;    &#10;    async def load_user_features(self) -&gt; Dict[str, np.ndarray]:&#10;        &quot;&quot;&quot;Load user features from database&quot;&quot;&quot;&#10;        async with self.db_session_factory() as session:&#10;            from sqlalchemy import select&#10;            result = await session.execute(select(UserProfile))&#10;            profiles = result.scalars().all()&#10;            &#10;            user_features = {}&#10;            for profile in profiles:&#10;                # Create feature vector from profile&#10;                interests = profile.interests or {}&#10;                feature_vector = np.zeros(64)&#10;                &#10;                # Encode top interests&#10;                top_interests = sorted(interests.items(), key=lambda x: x[1], reverse=True)[:10]&#10;                for i, (category, score) in enumerate(top_interests):&#10;                    if i &lt; 10:&#10;                        feature_vector[i] = min(score / 10.0, 1.0)&#10;                &#10;                feature_vector[10] = min(profile.engagement_score or 0.0, 1.0)&#10;                user_features[profile.user_id] = feature_vector&#10;                &#10;            return user_features&#10;    &#10;    async def load_post_features(self) -&gt; Dict[str, Dict]:&#10;        &quot;&quot;&quot;Load post features from database&quot;&quot;&quot;&#10;        async with self.db_session_factory() as session:&#10;            from sqlalchemy import select&#10;            result = await session.execute(select(PostFeatures))&#10;            posts = result.scalars().all()&#10;            &#10;            post_features = {}&#10;            categories = [&quot;Van Hoc&quot;, &quot;Khoa Hoc&quot;, &quot;Cong Nghe&quot;, &quot;The Thao&quot;, &quot;Giai Tri&quot;]&#10;            &#10;            for post in posts:&#10;                category_id = categories.index(post.category) if post.category in categories else 0&#10;                &#10;                post_features[post.post_id] = {&#10;                    'content_embedding': post.content_embedding or np.zeros(768).tolist(),&#10;                    'category_id': category_id,&#10;                    'engagement_rate': post.engagement_rate or 0.0&#10;                }&#10;                &#10;            return post_features&#10;    &#10;    async def generate_negative_samples(self, positive_interactions: List[Dict],&#10;                                      user_features: Dict, post_features: Dict) -&gt; List[Dict]:&#10;        &quot;&quot;&quot;Generate negative samples for training&quot;&quot;&quot;&#10;        negative_samples = []&#10;        user_ids = list(user_features.keys())&#10;        post_ids = list(post_features.keys())&#10;        &#10;        # Generate negative samples (1:1 ratio with positive samples)&#10;        for _ in range(len(positive_interactions)):&#10;            user_id = np.random.choice(user_ids)&#10;            post_id = np.random.choice(post_ids)&#10;            &#10;            # Ensure it's not a positive interaction&#10;            is_positive = any(&#10;                int['user_id'] == user_id and int['post_id'] == post_id &#10;                for int in positive_interactions&#10;            )&#10;            &#10;            if not is_positive:&#10;                negative_samples.append({&#10;                    'user_id': user_id,&#10;                    'post_id': post_id,&#10;                    'label': 0.0,&#10;                    'context': np.random.random(32)&#10;                })&#10;        &#10;        return negative_samples&#10;    &#10;    def initialize_model(self):&#10;        &quot;&quot;&quot;Initialize model, optimizer, and scheduler&quot;&quot;&quot;&#10;        # Initialize model&#10;        self.model = PersonalizedRecommendationModel(&#10;            num_users=10000,  # Should be dynamic&#10;            num_posts=50000,   # Should be dynamic&#10;            embedding_dim=config.EMBEDDING_DIM,&#10;            num_heads=config.NUM_HEADS&#10;        ).to(self.device)&#10;        &#10;        # Initialize optimizer&#10;        self.optimizer = optim.AdamW(&#10;            self.model.parameters(),&#10;            lr=0.001,&#10;            weight_decay=0.01&#10;        )&#10;        &#10;        # Initialize scheduler&#10;        self.scheduler = optim.lr_scheduler.ReduceLROnPlateau(&#10;            self.optimizer,&#10;            mode='min',&#10;            factor=0.5,&#10;            patience=5,&#10;            verbose=True&#10;        )&#10;        &#10;        logger.info(f&quot;Model initialized with {sum(p.numel() for p in self.model.parameters())} parameters&quot;)&#10;    &#10;    async def train_epoch(self, train_loader: DataLoader) -&gt; float:&#10;        &quot;&quot;&quot;Train for one epoch&quot;&quot;&quot;&#10;        self.model.train()&#10;        total_loss = 0.0&#10;        num_batches = 0&#10;        &#10;        criterion = nn.BCELoss()&#10;        &#10;        for batch in train_loader:&#10;            # Move batch to device&#10;            batch = {k: v.to(self.device) for k, v in batch.items()}&#10;            &#10;            # Forward pass&#10;            self.optimizer.zero_grad()&#10;            &#10;            predictions = self.model(&#10;                batch['user_id'],&#10;                batch['post_id'],&#10;                batch['user_profile'],&#10;                batch['post_content'],&#10;                batch['post_category'],&#10;                batch['context']&#10;            )&#10;            &#10;            loss = criterion(predictions, batch['label'])&#10;            &#10;            # Backward pass&#10;            loss.backward()&#10;            torch.nn.utils.clip_grad_norm_(self.model.parameters(), max_norm=1.0)&#10;            self.optimizer.step()&#10;            &#10;            total_loss += loss.item()&#10;            num_batches += 1&#10;        &#10;        return total_loss / num_batches&#10;    &#10;    async def validate(self, val_loader: DataLoader) -&gt; Dict[str, float]:&#10;        &quot;&quot;&quot;Validate model performance&quot;&quot;&quot;&#10;        self.model.eval()&#10;        all_predictions = []&#10;        all_labels = []&#10;        total_loss = 0.0&#10;        num_batches = 0&#10;        &#10;        criterion = nn.BCELoss()&#10;        &#10;        with torch.no_grad():&#10;            for batch in val_loader:&#10;                batch = {k: v.to(self.device) for k, v in batch.items()}&#10;                &#10;                predictions = self.model(&#10;                    batch['user_id'],&#10;                    batch['post_id'],&#10;                    batch['user_profile'],&#10;                    batch['post_content'],&#10;                    batch['post_category'],&#10;                    batch['context']&#10;                )&#10;                &#10;                loss = criterion(predictions, batch['label'])&#10;                total_loss += loss.item()&#10;                num_batches += 1&#10;                &#10;                all_predictions.extend(predictions.cpu().numpy())&#10;                all_labels.extend(batch['label'].cpu().numpy())&#10;        &#10;        # Calculate metrics&#10;        predictions_binary = [1 if p &gt; 0.5 else 0 for p in all_predictions]&#10;        &#10;        metrics = {&#10;            'loss': total_loss / num_batches,&#10;            'precision': precision_score(all_labels, predictions_binary, zero_division=0),&#10;            'recall': recall_score(all_labels, predictions_binary, zero_division=0),&#10;            'f1': f1_score(all_labels, predictions_binary, zero_division=0),&#10;            'auc': roc_auc_score(all_labels, all_predictions) if len(set(all_labels)) &gt; 1 else 0.0&#10;        }&#10;        &#10;        return metrics&#10;    &#10;    async def train(self, epochs: int = 10) -&gt; Dict[str, Any]:&#10;        &quot;&quot;&quot;Full training pipeline&quot;&quot;&quot;&#10;        try:&#10;            # Start MLflow run&#10;            with mlflow.start_run():&#10;                # Log parameters&#10;                mlflow.log_params({&#10;                    'epochs': epochs,&#10;                    'batch_size': config.BATCH_SIZE,&#10;                    'embedding_dim': config.EMBEDDING_DIM,&#10;                    'num_heads': config.NUM_HEADS,&#10;                    'learning_rate': 0.001&#10;                })&#10;                &#10;                # Prepare data&#10;                train_loader, val_loader = await self.prepare_training_data()&#10;                &#10;                # Initialize model&#10;                self.initialize_model()&#10;                &#10;                best_val_loss = float('inf')&#10;                training_history = []&#10;                &#10;                for epoch in range(epochs):&#10;                    logger.info(f&quot;Training epoch {epoch + 1}/{epochs}&quot;)&#10;                    &#10;                    # Train&#10;                    train_loss = await self.train_epoch(train_loader)&#10;                    &#10;                    # Validate&#10;                    val_metrics = await self.validate(val_loader)&#10;                    &#10;                    # Log metrics&#10;                    mlflow.log_metrics({&#10;                        'train_loss': train_loss,&#10;                        'val_loss': val_metrics['loss'],&#10;                        'val_precision': val_metrics['precision'],&#10;                        'val_recall': val_metrics['recall'],&#10;                        'val_f1': val_metrics['f1'],&#10;                        'val_auc': val_metrics['auc']&#10;                    }, step=epoch)&#10;                    &#10;                    # Update learning rate&#10;                    self.scheduler.step(val_metrics['loss'])&#10;                    &#10;                    # Save best model&#10;                    if val_metrics['loss'] &lt; best_val_loss:&#10;                        best_val_loss = val_metrics['loss']&#10;                        await self.save_model(epoch, val_metrics)&#10;                    &#10;                    training_history.append({&#10;                        'epoch': epoch,&#10;                        'train_loss': train_loss,&#10;                        'val_metrics': val_metrics&#10;                    })&#10;                    &#10;                    logger.info(f&quot;Epoch {epoch + 1}: train_loss={train_loss:.4f}, val_loss={val_metrics['loss']:.4f}&quot;)&#10;                &#10;                # Log model&#10;                mlflow.pytorch.log_model(self.model, &quot;model&quot;)&#10;                &#10;                # Save final metrics to database&#10;                await self.save_metrics_to_db(val_metrics)&#10;                &#10;                return {&#10;                    'best_val_loss': best_val_loss,&#10;                    'final_metrics': val_metrics,&#10;                    'training_history': training_history&#10;                }&#10;                &#10;        except Exception as e:&#10;            logger.error(f&quot;Error during training: {e}&quot;)&#10;            raise&#10;    &#10;    async def save_model(self, epoch: int, metrics: Dict[str, float]):&#10;        &quot;&quot;&quot;Save model checkpoint&quot;&quot;&quot;&#10;        checkpoint = {&#10;            'epoch': epoch,&#10;            'model_state_dict': self.model.state_dict(),&#10;            'optimizer_state_dict': self.optimizer.state_dict(),&#10;            'scheduler_state_dict': self.scheduler.state_dict(),&#10;            'metrics': metrics&#10;        }&#10;        &#10;        torch.save(checkpoint, config.MODEL_PATH)&#10;        logger.info(f&quot;Model saved at epoch {epoch}&quot;)&#10;    &#10;    async def save_metrics_to_db(self, metrics: Dict[str, float]):&#10;        &quot;&quot;&quot;Save training metrics to database&quot;&quot;&quot;&#10;        async with self.db_session_factory() as session:&#10;            try:&#10;                for metric_name, metric_value in metrics.items():&#10;                    if metric_name != 'loss':  # Skip loss, save others&#10;                        metric_record = ModelMetrics(&#10;                            model_version=&quot;v1.0&quot;,&#10;                            metric_name=metric_name,&#10;                            metric_value=metric_value,&#10;                            dataset_size=1000,  # Should be actual dataset size&#10;                            evaluation_config={'training': True}&#10;                        )&#10;                        session.add(metric_record)&#10;                &#10;                await session.commit()&#10;                logger.info(&quot;Metrics saved to database&quot;)&#10;                &#10;            except Exception as e:&#10;                logger.error(f&quot;Error saving metrics to database: {e}&quot;)&#10;                await session.rollback()&#10;&#10;class RLTrainer:&#10;    &quot;&quot;&quot;Reinforcement learning trainer for recommendation optimization&quot;&quot;&quot;&#10;    &#10;    def __init__(self, db_session_factory):&#10;        self.db_session_factory = db_session_factory&#10;        self.device = torch.device(&quot;cuda&quot; if torch.cuda.is_available() else &quot;cpu&quot;)&#10;        self.agent = None&#10;        self.replay_buffer = []&#10;        self.batch_size = 32&#10;        self.gamma = 0.99&#10;        &#10;    def initialize_agent(self):&#10;        &quot;&quot;&quot;Initialize RL agent&quot;&quot;&quot;&#10;        state_dim = config.EMBEDDING_DIM + 32&#10;        action_dim = config.TOP_K_RECOMMENDATIONS&#10;        &#10;        self.agent = ReinforcementLearningAgent(&#10;            state_dim=state_dim,&#10;            action_dim=action_dim&#10;        ).to(self.device)&#10;        &#10;        self.optimizer = optim.Adam(self.agent.parameters(), lr=0.0001)&#10;        &#10;    async def collect_experiences(self, days_back: int = 7):&#10;        &quot;&quot;&quot;Collect experiences from recent interactions&quot;&quot;&quot;&#10;        async with self.db_session_factory() as session:&#10;            from sqlalchemy import select&#10;            &#10;            # Get recent interactions with rewards&#10;            end_date = datetime.utcnow()&#10;            start_date = end_date - timedelta(days=days_back)&#10;            &#10;            result = await session.execute(&#10;                select(UserInteraction)&#10;                .where(UserInteraction.timestamp.between(start_date, end_date))&#10;                .where(UserInteraction.reward != 0.0)&#10;            )&#10;            &#10;            interactions = result.scalars().all()&#10;            &#10;            experiences = []&#10;            for interaction in interactions:&#10;                # Simplified state representation&#10;                state = np.random.random(config.EMBEDDING_DIM + 32)&#10;                action = np.random.randint(0, config.TOP_K_RECOMMENDATIONS)&#10;                reward = interaction.reward&#10;                next_state = np.random.random(config.EMBEDDING_DIM + 32)&#10;                &#10;                experiences.append({&#10;                    'state': state,&#10;                    'action': action,&#10;                    'reward': reward,&#10;                    'next_state': next_state,&#10;                    'done': False&#10;                })&#10;            &#10;            self.replay_buffer.extend(experiences)&#10;            logger.info(f&quot;Collected {len(experiences)} experiences&quot;)&#10;    &#10;    def train_step(self):&#10;        &quot;&quot;&quot;Single training step for RL agent&quot;&quot;&quot;&#10;        if len(self.replay_buffer) &lt; self.batch_size:&#10;            return&#10;        &#10;        # Sample batch from replay buffer&#10;        batch = np.random.choice(self.replay_buffer, self.batch_size, replace=False)&#10;        &#10;        states = torch.tensor([exp['state'] for exp in batch], dtype=torch.float32).to(self.device)&#10;        actions = torch.tensor([exp['action'] for exp in batch], dtype=torch.long).to(self.device)&#10;        rewards = torch.tensor([exp['reward'] for exp in batch], dtype=torch.float32).to(self.device)&#10;        next_states = torch.tensor([exp['next_state'] for exp in batch], dtype=torch.float32).to(self.device)&#10;        dones = torch.tensor([exp['done'] for exp in batch], dtype=torch.bool).to(self.device)&#10;        &#10;        # Current Q values&#10;        current_q_values = self.agent(states).gather(1, actions.unsqueeze(1))&#10;        &#10;        # Next Q values&#10;        next_q_values = self.agent.get_target_q_values(next_states).max(1)[0].detach()&#10;        target_q_values = rewards + (self.gamma * next_q_values * ~dones)&#10;        &#10;        # Compute loss&#10;        loss = nn.MSELoss()(current_q_values.squeeze(), target_q_values)&#10;        &#10;        # Optimize&#10;        self.optimizer.zero_grad()&#10;        loss.backward()&#10;        self.optimizer.step()&#10;        &#10;        # Update target network&#10;        self.agent.update_target_network()&#10;        &#10;        return loss.item()&#10;&#10;# Training script&#10;async def main():&#10;    &quot;&quot;&quot;Main training script&quot;&quot;&quot;&#10;    from db.models import AsyncSessionLocal&#10;    &#10;    # Setup MLflow&#10;    mlflow.set_tracking_uri(config.MLFLOW_TRACKING_URI)&#10;    mlflow.set_experiment(config.MLFLOW_EXPERIMENT_NAME)&#10;    &#10;    # Initialize trainer&#10;    trainer = ModelTrainer(AsyncSessionLocal)&#10;    &#10;    # Train model&#10;    results = await trainer.train(epochs=20)&#10;    &#10;    logger.info(&quot;Training completed!&quot;)&#10;    logger.info(f&quot;Best validation loss: {results['best_val_loss']:.4f}&quot;)&#10;    logger.info(f&quot;Final metrics: {results['final_metrics']}&quot;)&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    asyncio.run(main())" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/recommendation-service/data/processor.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/recommendation-service/data/processor.py" />
              <option name="updatedContent" value="import asyncio&#10;import json&#10;import logging&#10;from typing import Dict, List, Optional, Any&#10;from datetime import datetime&#10;import numpy as np&#10;import pandas as pd&#10;from aiokafka import AIOKafkaConsumer, AIOKafkaProducer&#10;from sqlalchemy.ext.asyncio import AsyncSession&#10;from sqlalchemy import select, update, insert&#10;import aioredis&#10;from core.models import PersonalizedRecommendationModel&#10;from db.models import UserInteraction, PostFeatures, UserProfile&#10;from config.settings import config&#10;&#10;logger = logging.getLogger(__name__)&#10;&#10;class DataProcessor:&#10;    &quot;&quot;&quot;Handles data ingestion, processing, and feature engineering&quot;&quot;&quot;&#10;    &#10;    def __init__(self):&#10;        self.kafka_consumer = None&#10;        self.kafka_producer = None&#10;        self.redis_client = None&#10;        &#10;    async def initialize(self):&#10;        &quot;&quot;&quot;Initialize Kafka and Redis connections&quot;&quot;&quot;&#10;        self.kafka_consumer = AIOKafkaConsumer(&#10;            config.KAFKA_TOPIC_USER_INTERACTIONS,&#10;            config.KAFKA_TOPIC_POST_UPDATES,&#10;            bootstrap_servers=config.KAFKA_BOOTSTRAP_SERVERS,&#10;            group_id=config.KAFKA_GROUP_ID,&#10;            value_deserializer=lambda x: json.loads(x.decode('utf-8'))&#10;        )&#10;        &#10;        self.kafka_producer = AIOKafkaProducer(&#10;            bootstrap_servers=config.KAFKA_BOOTSTRAP_SERVERS,&#10;            value_serializer=lambda x: json.dumps(x).encode('utf-8')&#10;        )&#10;        &#10;        self.redis_client = aioredis.from_url(config.REDIS_URL)&#10;        &#10;        await self.kafka_consumer.start()&#10;        await self.kafka_producer.start()&#10;        &#10;    async def process_user_interaction(self, interaction_data: Dict[str, Any], &#10;                                     db_session: AsyncSession):&#10;        &quot;&quot;&quot;Process real-time user interaction data&quot;&quot;&quot;&#10;        try:&#10;            # Extract interaction features&#10;            user_id = interaction_data.get('userId')&#10;            post_id = interaction_data.get('postId')&#10;            interaction_type = interaction_data.get('type')  # like, comment, share, view&#10;            timestamp = datetime.fromisoformat(interaction_data.get('timestamp'))&#10;            &#10;            # Store in database&#10;            interaction = UserInteraction(&#10;                user_id=user_id,&#10;                post_id=post_id,&#10;                interaction_type=interaction_type,&#10;                timestamp=timestamp,&#10;                context_data=interaction_data.get('context', {})&#10;            )&#10;            &#10;            db_session.add(interaction)&#10;            await db_session.commit()&#10;            &#10;            # Update user profile in real-time&#10;            await self.update_user_profile(user_id, interaction_data, db_session)&#10;            &#10;            # Invalidate cached recommendations&#10;            cache_key = f&quot;recommendations:{user_id}&quot;&#10;            await self.redis_client.delete(cache_key)&#10;            &#10;            logger.info(f&quot;Processed interaction: {user_id} -&gt; {post_id} ({interaction_type})&quot;)&#10;            &#10;        except Exception as e:&#10;            logger.error(f&quot;Error processing interaction: {e}&quot;)&#10;            await db_session.rollback()&#10;    &#10;    async def update_user_profile(self, user_id: str, interaction_data: Dict[str, Any],&#10;                                db_session: AsyncSession):&#10;        &quot;&quot;&quot;Update user profile based on interactions&quot;&quot;&quot;&#10;        # Get current profile&#10;        result = await db_session.execute(&#10;            select(UserProfile).where(UserProfile.user_id == user_id)&#10;        )&#10;        profile = result.scalar_one_or_none()&#10;        &#10;        if not profile:&#10;            # Create new profile&#10;            profile = UserProfile(&#10;                user_id=user_id,&#10;                interests={},&#10;                engagement_score=0.0,&#10;                activity_pattern={}&#10;            )&#10;            db_session.add(profile)&#10;        &#10;        # Update interests based on post category&#10;        post_category = interaction_data.get('postCategory')&#10;        if post_category:&#10;            current_interests = profile.interests or {}&#10;            current_interests[post_category] = current_interests.get(post_category, 0) + 1&#10;            profile.interests = current_interests&#10;        &#10;        # Update engagement score&#10;        interaction_weights = {&#10;            'view': 0.1,&#10;            'like': 0.5,&#10;            'comment': 0.8,&#10;            'share': 1.0&#10;        }&#10;        &#10;        weight = interaction_weights.get(interaction_data.get('type'), 0.1)&#10;        profile.engagement_score = (profile.engagement_score * 0.9) + (weight * 0.1)&#10;        &#10;        await db_session.commit()&#10;    &#10;    def extract_post_features(self, post_data: Dict[str, Any]) -&gt; Dict[str, Any]:&#10;        &quot;&quot;&quot;Extract comprehensive features from post data&quot;&quot;&quot;&#10;        features = {&#10;            'post_id': post_data.get('id'),&#10;            'title': post_data.get('title', ''),&#10;            'content': post_data.get('content', ''),&#10;            'author_id': post_data.get('authorId'),&#10;            'category': post_data.get('category', ''),&#10;            'tags': post_data.get('tags', []),&#10;            'created_at': post_data.get('createdAt'),&#10;            'stats': post_data.get('stats', {}),&#10;            'has_images': len(post_data.get('images', [])) &gt; 0,&#10;            'has_videos': len(post_data.get('videos', [])) &gt; 0,&#10;            'post_type': post_data.get('postType', 'TEXT')&#10;        }&#10;        &#10;        # Extract engagement metrics&#10;        stats = post_data.get('stats', {})&#10;        features.update({&#10;            'likes_count': stats.get('likes', 0),&#10;            'comments_count': stats.get('comments', 0),&#10;            'shares_count': stats.get('shares', 0),&#10;            'views_count': stats.get('views', 0)&#10;        })&#10;        &#10;        # Calculate engagement rate&#10;        total_interactions = sum([&#10;            features['likes_count'],&#10;            features['comments_count'],&#10;            features['shares_count']&#10;        ])&#10;        features['engagement_rate'] = total_interactions / max(features['views_count'], 1)&#10;        &#10;        return features&#10;    &#10;    def extract_user_context(self, user_data: Dict[str, Any], &#10;                           request_context: Dict[str, Any]) -&gt; np.ndarray:&#10;        &quot;&quot;&quot;Extract contextual features for recommendations&quot;&quot;&quot;&#10;        now = datetime.now()&#10;        &#10;        # Temporal features&#10;        hour_of_day = now.hour / 24.0&#10;        day_of_week = now.weekday() / 7.0&#10;        &#10;        # User activity pattern&#10;        user_activity = user_data.get('activity_pattern', {})&#10;        current_hour_activity = user_activity.get(str(now.hour), 0.0)&#10;        &#10;        # Device and location context&#10;        device_type = request_context.get('device_type', 'desktop')&#10;        device_features = {&#10;            'mobile': [1.0, 0.0, 0.0],&#10;            'tablet': [0.0, 1.0, 0.0],&#10;            'desktop': [0.0, 0.0, 1.0]&#10;        }&#10;        device_vec = device_features.get(device_type, [0.0, 0.0, 1.0])&#10;        &#10;        # Combine all context features&#10;        context_vector = np.array([&#10;            hour_of_day,&#10;            day_of_week,&#10;            current_hour_activity,&#10;            user_data.get('engagement_score', 0.0),&#10;            len(user_data.get('interests', {})),&#10;            *device_vec,&#10;            # Padding to reach 32 dimensions&#10;            *[0.0] * 23&#10;        ])&#10;        &#10;        return context_vector[:32]  # Ensure exactly 32 dimensions&#10;&#10;class FeatureStore:&#10;    &quot;&quot;&quot;Manages feature storage and retrieval&quot;&quot;&quot;&#10;    &#10;    def __init__(self, redis_client: aioredis.Redis):&#10;        self.redis = redis_client&#10;    &#10;    async def store_user_features(self, user_id: str, features: Dict[str, Any]):&#10;        &quot;&quot;&quot;Store user features in Redis&quot;&quot;&quot;&#10;        key = f&quot;user_features:{user_id}&quot;&#10;        await self.redis.hset(key, mapping={&#10;            k: json.dumps(v) if isinstance(v, (dict, list)) else str(v)&#10;            for k, v in features.items()&#10;        })&#10;        await self.redis.expire(key, config.REDIS_TTL)&#10;    &#10;    async def get_user_features(self, user_id: str) -&gt; Optional[Dict[str, Any]]:&#10;        &quot;&quot;&quot;Retrieve user features from Redis&quot;&quot;&quot;&#10;        key = f&quot;user_features:{user_id}&quot;&#10;        features = await self.redis.hgetall(key)&#10;        &#10;        if not features:&#10;            return None&#10;            &#10;        # Deserialize JSON fields&#10;        result = {}&#10;        for k, v in features.items():&#10;            k = k.decode('utf-8')&#10;            v = v.decode('utf-8')&#10;            try:&#10;                result[k] = json.loads(v)&#10;            except (json.JSONDecodeError, ValueError):&#10;                result[k] = v&#10;                &#10;        return result&#10;    &#10;    async def store_post_features(self, post_id: str, features: Dict[str, Any]):&#10;        &quot;&quot;&quot;Store post features in Redis&quot;&quot;&quot;&#10;        key = f&quot;post_features:{post_id}&quot;&#10;        await self.redis.hset(key, mapping={&#10;            k: json.dumps(v) if isinstance(v, (dict, list)) else str(v)&#10;            for k, v in features.items()&#10;        })&#10;        await self.redis.expire(key, config.REDIS_TTL)&#10;    &#10;    async def get_post_features(self, post_id: str) -&gt; Optional[Dict[str, Any]]:&#10;        &quot;&quot;&quot;Retrieve post features from Redis&quot;&quot;&quot;&#10;        key = f&quot;post_features:{post_id}&quot;&#10;        features = await self.redis.hgetall(key)&#10;        &#10;        if not features:&#10;            return None&#10;            &#10;        result = {}&#10;        for k, v in features.items():&#10;            k = k.decode('utf-8')&#10;            v = v.decode('utf-8')&#10;            try:&#10;                result[k] = json.loads(v)&#10;            except (json.JSONDecodeError, ValueError):&#10;                result[k] = v&#10;                &#10;        return result&#10;&#10;class BatchProcessor:&#10;    &quot;&quot;&quot;Handles batch processing for model training&quot;&quot;&quot;&#10;    &#10;    def __init__(self, db_session_factory):&#10;        self.db_session_factory = db_session_factory&#10;    &#10;    async def prepare_training_data(self, start_date: datetime, &#10;                                  end_date: datetime) -&gt; Dict[str, Any]:&#10;        &quot;&quot;&quot;Prepare training data from user interactions&quot;&quot;&quot;&#10;        async with self.db_session_factory() as session:&#10;            # Get interactions in date range&#10;            result = await session.execute(&#10;                select(UserInteraction)&#10;                .where(UserInteraction.timestamp.between(start_date, end_date))&#10;                .order_by(UserInteraction.timestamp)&#10;            )&#10;            interactions = result.scalars().all()&#10;            &#10;            # Convert to training format&#10;            training_data = {&#10;                'user_ids': [],&#10;                'post_ids': [],&#10;                'labels': [],&#10;                'timestamps': []&#10;            }&#10;            &#10;            # Create positive and negative samples&#10;            for interaction in interactions:&#10;                training_data['user_ids'].append(interaction.user_id)&#10;                training_data['post_ids'].append(interaction.post_id)&#10;                &#10;                # Label based on interaction type&#10;                label_map = {&#10;                    'view': 0.1,&#10;                    'like': 0.7,&#10;                    'comment': 0.9,&#10;                    'share': 1.0&#10;                }&#10;                training_data['labels'].append(&#10;                    label_map.get(interaction.interaction_type, 0.1)&#10;                )&#10;                training_data['timestamps'].append(interaction.timestamp)&#10;            &#10;            return training_data" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/recommendation-service/db/models.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/recommendation-service/db/models.py" />
              <option name="updatedContent" value="from sqlalchemy import Column, String, Integer, Float, DateTime, JSON, Boolean, Text, ForeignKey&#10;from sqlalchemy.ext.declarative import declarative_base&#10;from sqlalchemy.orm import relationship&#10;from sqlalchemy.dialects.postgresql import UUID&#10;import uuid&#10;from datetime import datetime&#10;&#10;Base = declarative_base()&#10;&#10;class UserProfile(Base):&#10;    &quot;&quot;&quot;User profile with preferences and behavior patterns&quot;&quot;&quot;&#10;    __tablename__ = &quot;user_profiles&quot;&#10;    &#10;    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)&#10;    user_id = Column(String, unique=True, nullable=False, index=True)&#10;    interests = Column(JSON, default=dict)  # Category preferences&#10;    engagement_score = Column(Float, default=0.0)&#10;    activity_pattern = Column(JSON, default=dict)  # Hourly activity patterns&#10;    demographics = Column(JSON, default=dict)  # Age, faculty, major, etc.&#10;    created_at = Column(DateTime, default=datetime.utcnow)&#10;    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)&#10;    &#10;    # Relationships&#10;    interactions = relationship(&quot;UserInteraction&quot;, back_populates=&quot;user_profile&quot;)&#10;&#10;class PostFeatures(Base):&#10;    &quot;&quot;&quot;Post features for recommendation model&quot;&quot;&quot;&#10;    __tablename__ = &quot;post_features&quot;&#10;    &#10;    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)&#10;    post_id = Column(String, unique=True, nullable=False, index=True)&#10;    title = Column(Text)&#10;    content = Column(Text)&#10;    author_id = Column(String, nullable=False)&#10;    category = Column(String)&#10;    tags = Column(JSON, default=list)&#10;    post_type = Column(String)  # TEXT, IMAGE, VIDEO&#10;    &#10;    # Engagement metrics&#10;    likes_count = Column(Integer, default=0)&#10;    comments_count = Column(Integer, default=0)&#10;    shares_count = Column(Integer, default=0)&#10;    views_count = Column(Integer, default=0)&#10;    engagement_rate = Column(Float, default=0.0)&#10;    &#10;    # Content features&#10;    has_images = Column(Boolean, default=False)&#10;    has_videos = Column(Boolean, default=False)&#10;    content_length = Column(Integer, default=0)&#10;    &#10;    # Embeddings (stored as JSON arrays)&#10;    content_embedding = Column(JSON)  # PhoBERT embeddings&#10;    &#10;    created_at = Column(DateTime, default=datetime.utcnow)&#10;    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)&#10;    &#10;    # Relationships&#10;    interactions = relationship(&quot;UserInteraction&quot;, back_populates=&quot;post_features&quot;)&#10;&#10;class UserInteraction(Base):&#10;    &quot;&quot;&quot;User-Post interaction records&quot;&quot;&quot;&#10;    __tablename__ = &quot;user_interactions&quot;&#10;    &#10;    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)&#10;    user_id = Column(String, nullable=False, index=True)&#10;    post_id = Column(String, nullable=False, index=True)&#10;    interaction_type = Column(String, nullable=False)  # view, like, comment, share&#10;    &#10;    # Context information&#10;    timestamp = Column(DateTime, default=datetime.utcnow, index=True)&#10;    context_data = Column(JSON, default=dict)  # Device, location, etc.&#10;    &#10;    # Feedback for reinforcement learning&#10;    reward = Column(Float, default=0.0)&#10;    session_id = Column(String)&#10;    &#10;    # Relationships&#10;    user_profile = relationship(&quot;UserProfile&quot;, back_populates=&quot;interactions&quot;)&#10;    post_features = relationship(&quot;PostFeatures&quot;, back_populates=&quot;interactions&quot;)&#10;&#10;class RecommendationLog(Base):&#10;    &quot;&quot;&quot;Log of recommendations served to users&quot;&quot;&quot;&#10;    __tablename__ = &quot;recommendation_logs&quot;&#10;    &#10;    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)&#10;    user_id = Column(String, nullable=False, index=True)&#10;    post_ids = Column(JSON, nullable=False)  # Array of recommended post IDs&#10;    model_version = Column(String, nullable=False)&#10;    ab_test_variant = Column(String)&#10;    &#10;    # Context&#10;    request_context = Column(JSON, default=dict)&#10;    timestamp = Column(DateTime, default=datetime.utcnow, index=True)&#10;    &#10;    # Performance metrics&#10;    served_count = Column(Integer, default=0)&#10;    clicked_count = Column(Integer, default=0)&#10;    ctr = Column(Float, default=0.0)&#10;&#10;class ModelMetrics(Base):&#10;    &quot;&quot;&quot;Model performance metrics&quot;&quot;&quot;&#10;    __tablename__ = &quot;model_metrics&quot;&#10;    &#10;    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)&#10;    model_version = Column(String, nullable=False)&#10;    metric_name = Column(String, nullable=False)  # precision, recall, f1, diversity&#10;    metric_value = Column(Float, nullable=False)&#10;    &#10;    # Evaluation context&#10;    evaluation_date = Column(DateTime, default=datetime.utcnow)&#10;    dataset_size = Column(Integer)&#10;    evaluation_config = Column(JSON, default=dict)&#10;&#10;class ABTestExperiment(Base):&#10;    &quot;&quot;&quot;A/B testing experiments&quot;&quot;&quot;&#10;    __tablename__ = &quot;ab_test_experiments&quot;&#10;    &#10;    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)&#10;    experiment_name = Column(String, unique=True, nullable=False)&#10;    variants = Column(JSON, nullable=False)  # Dict of variant_name: traffic_percentage&#10;    &#10;    # Experiment status&#10;    is_active = Column(Boolean, default=True)&#10;    start_date = Column(DateTime, default=datetime.utcnow)&#10;    end_date = Column(DateTime)&#10;    &#10;    # Results&#10;    results = Column(JSON, default=dict)  # Statistical results per variant&#10;    winner = Column(String)  # Winning variant&#10;    &#10;    created_at = Column(DateTime, default=datetime.utcnow)&#10;    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)&#10;&#10;class ReplayBuffer(Base):&#10;    &quot;&quot;&quot;Reinforcement learning replay buffer&quot;&quot;&quot;&#10;    __tablename__ = &quot;replay_buffer&quot;&#10;    &#10;    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)&#10;    user_id = Column(String, nullable=False, index=True)&#10;    &#10;    # RL components (state, action, reward, next_state)&#10;    state = Column(JSON, nullable=False)  # User and context features&#10;    action = Column(JSON, nullable=False)  # Recommended posts&#10;    reward = Column(Float, nullable=False)&#10;    next_state = Column(JSON)&#10;    done = Column(Boolean, default=False)&#10;    &#10;    timestamp = Column(DateTime, default=datetime.utcnow, index=True)&#10;&#10;# Database utility functions&#10;from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession&#10;from sqlalchemy.orm import sessionmaker&#10;from config.settings import config&#10;&#10;# Create async engine&#10;engine = create_async_engine(&#10;    config.DATABASE_URL,&#10;    echo=config.DEBUG,&#10;    pool_size=10,&#10;    max_overflow=20,&#10;    pool_pre_ping=True&#10;)&#10;&#10;# Create session factory&#10;AsyncSessionLocal = sessionmaker(&#10;    engine, class_=AsyncSession, expire_on_commit=False&#10;)&#10;&#10;async def get_db_session() -&gt; AsyncSession:&#10;    &quot;&quot;&quot;Dependency to get database session&quot;&quot;&quot;&#10;    async with AsyncSessionLocal() as session:&#10;        try:&#10;            yield session&#10;        finally:&#10;            await session.close()&#10;&#10;async def create_tables():&#10;    &quot;&quot;&quot;Create all database tables&quot;&quot;&quot;&#10;    async with engine.begin() as conn:&#10;        await conn.run_sync(Base.metadata.create_all)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/recommendation-service/deployment/kubernetes.yaml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/recommendation-service/deployment/kubernetes.yaml" />
              <option name="updatedContent" value="apiVersion: apps/v1&#10;kind: Deployment&#10;metadata:&#10;  name: recommendation-service&#10;  labels:&#10;    app: recommendation-service&#10;spec:&#10;  replicas: 3&#10;  selector:&#10;    matchLabels:&#10;      app: recommendation-service&#10;  template:&#10;    metadata:&#10;      labels:&#10;        app: recommendation-service&#10;    spec:&#10;      containers:&#10;      - name: recommendation-service&#10;        image: ctu-connect/recommendation-service:latest&#10;        ports:&#10;        - containerPort: 8000&#10;        env:&#10;        - name: DATABASE_URL&#10;          valueFrom:&#10;            secretKeyRef:&#10;              name: recommendation-secrets&#10;              key: database-url&#10;        - name: REDIS_URL&#10;          valueFrom:&#10;            configMapKeyRef:&#10;              name: recommendation-config&#10;              key: redis-url&#10;        - name: KAFKA_BOOTSTRAP_SERVERS&#10;          valueFrom:&#10;            configMapKeyRef:&#10;              name: recommendation-config&#10;              key: kafka-servers&#10;        - name: SECRET_KEY&#10;          valueFrom:&#10;            secretKeyRef:&#10;              name: recommendation-secrets&#10;              key: secret-key&#10;        - name: MLFLOW_TRACKING_URI&#10;          valueFrom:&#10;            configMapKeyRef:&#10;              name: recommendation-config&#10;              key: mlflow-uri&#10;        resources:&#10;          requests:&#10;            memory: &quot;512Mi&quot;&#10;            cpu: &quot;250m&quot;&#10;          limits:&#10;            memory: &quot;2Gi&quot;&#10;            cpu: &quot;1000m&quot;&#10;        livenessProbe:&#10;          httpGet:&#10;            path: /health&#10;            port: 8000&#10;          initialDelaySeconds: 30&#10;          periodSeconds: 10&#10;        readinessProbe:&#10;          httpGet:&#10;            path: /health&#10;            port: 8000&#10;          initialDelaySeconds: 5&#10;          periodSeconds: 5&#10;---&#10;apiVersion: v1&#10;kind: Service&#10;metadata:&#10;  name: recommendation-service&#10;spec:&#10;  selector:&#10;    app: recommendation-service&#10;  ports:&#10;    - protocol: TCP&#10;      port: 80&#10;      targetPort: 8000&#10;  type: ClusterIP&#10;---&#10;apiVersion: v1&#10;kind: ConfigMap&#10;metadata:&#10;  name: recommendation-config&#10;data:&#10;  redis-url: &quot;redis://redis-service:6379&quot;&#10;  kafka-servers: &quot;kafka-service:9092&quot;&#10;  mlflow-uri: &quot;http://mlflow-service:5000&quot;&#10;  debug: &quot;false&quot;&#10;---&#10;apiVersion: v1&#10;kind: Secret&#10;metadata:&#10;  name: recommendation-secrets&#10;type: Opaque&#10;data:&#10;  database-url: cG9zdGdyZXNxbCthc3luY3BnOi8vcG9zdGdyZXM6cGFzc3dvcmRAbG9jYWxob3N0OjU0MzIvcmVjb21tZW5kYXRpb25fZGI=&#10;  secret-key: eW91ci1zZWNyZXQta2V5LWhlcmU=&#10;---&#10;apiVersion: autoscaling/v2&#10;kind: HorizontalPodAutoscaler&#10;metadata:&#10;  name: recommendation-service-hpa&#10;spec:&#10;  scaleTargetRef:&#10;    apiVersion: apps/v1&#10;    kind: Deployment&#10;    name: recommendation-service&#10;  minReplicas: 2&#10;  maxReplicas: 10&#10;  metrics:&#10;  - type: Resource&#10;    resource:&#10;      name: cpu&#10;      target:&#10;        type: Utilization&#10;        averageUtilization: 70&#10;  - type: Resource&#10;    resource:&#10;      name: memory&#10;      target:&#10;        type: Utilization&#10;        averageUtilization: 80" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/recommendation-service/docker-compose.yml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/recommendation-service/docker-compose.yml" />
              <option name="updatedContent" value="version: '3.8'&#10;&#10;services:&#10;  recommendation-db:&#10;    image: postgres:15&#10;    environment:&#10;      POSTGRES_DB: recommendation_db&#10;      POSTGRES_USER: postgres&#10;      POSTGRES_PASSWORD: password&#10;    ports:&#10;      - &quot;5433:5432&quot;&#10;    volumes:&#10;      - recommendation_db_data:/var/lib/postgresql/data&#10;    networks:&#10;      - recommendation-network&#10;&#10;  recommendation-redis:&#10;    image: redis:7-alpine&#10;    ports:&#10;      - &quot;6380:6379&quot;&#10;    command: redis-server --appendonly yes&#10;    volumes:&#10;      - recommendation_redis_data:/data&#10;    networks:&#10;      - recommendation-network&#10;&#10;  recommendation-service:&#10;    build: .&#10;    ports:&#10;      - &quot;8001:8000&quot;&#10;    environment:&#10;      - DATABASE_URL=postgresql+asyncpg://postgres:password@recommendation-db:5432/recommendation_db&#10;      - REDIS_URL=redis://recommendation-redis:6379&#10;      - KAFKA_BOOTSTRAP_SERVERS=kafka:9092&#10;      - DEBUG=true&#10;      - SECRET_KEY=dev-secret-key&#10;    depends_on:&#10;      - recommendation-db&#10;      - recommendation-redis&#10;    networks:&#10;      - recommendation-network&#10;      - ctu-connect-network&#10;    volumes:&#10;      - ./models:/app/models&#10;    restart: unless-stopped&#10;&#10;  mlflow:&#10;    image: python:3.11-slim&#10;    ports:&#10;      - &quot;5001:5000&quot;&#10;    environment:&#10;      - MLFLOW_BACKEND_STORE_URI=postgresql://postgres:password@recommendation-db:5432/recommendation_db&#10;    command: &gt;&#10;      bash -c &quot;&#10;        pip install mlflow psycopg2-binary &amp;&amp;&#10;        mlflow server &#10;          --backend-store-uri postgresql://postgres:password@recommendation-db:5432/recommendation_db&#10;          --default-artifact-root ./mlruns&#10;          --host 0.0.0.0&#10;          --port 5000&#10;      &quot;&#10;    depends_on:&#10;      - recommendation-db&#10;    networks:&#10;      - recommendation-network&#10;    volumes:&#10;      - mlflow_data:/mlruns&#10;&#10;volumes:&#10;  recommendation_db_data:&#10;  recommendation_redis_data:&#10;  mlflow_data:&#10;&#10;networks:&#10;  recommendation-network:&#10;    driver: bridge&#10;  ctu-connect-network:&#10;    external: true" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/recommendation-service/main.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/recommendation-service/main.py" />
              <option name="originalContent" value="from fastapi import FastAPI, HTTPException, Depends, BackgroundTasks, Request&#10;from fastapi.middleware.cors import CORSMiddleware&#10;from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials&#10;from pydantic import BaseModel, Field&#10;from typing import List, Dict, Optional, Any&#10;import asyncio&#10;import logging&#10;from datetime import datetime&#10;import uvicorn&#10;from contextlib import asynccontextmanager&#10;&#10;from core.recommendation_engine import RecommendationEngine&#10;from db.models import get_db_session, create_tables, AsyncSession&#10;from config.settings import config&#10;from api.monitoring import setup_monitoring, metrics&#10;import structlog&#10;&#10;# Configure structured logging&#10;logging.basicConfig(level=logging.INFO)&#10;logger = structlog.get_logger()&#10;&#10;# Pydantic models for API requests/responses&#10;class RecommendationRequest(BaseModel):&#10;    user_id: str = Field(..., description=&quot;User ID requesting recommendations&quot;)&#10;    context: Dict[str, Any] = Field(default_factory=dict, description=&quot;Request context (device, location, etc.)&quot;)&#10;    k: Optional[int] = Field(default=None, description=&quot;Number of recommendations (default: 10)&quot;)&#10;    include_explanations: bool = Field(default=True, description=&quot;Include recommendation explanations&quot;)&#10;&#10;class RecommendationResponse(BaseModel):&#10;    recommendations: List[Dict[str, Any]]&#10;    ab_variant: str&#10;    timestamp: str&#10;    user_id: str&#10;    total_count: int&#10;    processing_time_ms: float&#10;&#10;class FeedbackRequest(BaseModel):&#10;    user_id: str = Field(..., description=&quot;User ID providing feedback&quot;)&#10;    post_id: str = Field(..., description=&quot;Post ID being interacted with&quot;)&#10;    feedback_type: str = Field(..., description=&quot;Type of feedback: click, like, comment, share, skip, dislike&quot;)&#10;    context: Dict[str, Any] = Field(default_factory=dict, description=&quot;Interaction context&quot;)&#10;    session_id: Optional[str] = Field(default=None, description=&quot;Session identifier&quot;)&#10;&#10;class FeedbackResponse(BaseModel):&#10;    success: bool&#10;    message: str&#10;    timestamp: str&#10;&#10;class HealthResponse(BaseModel):&#10;    status: str&#10;    timestamp: str&#10;    version: str&#10;    services: Dict[str, str]&#10;&#10;# Global recommendation engine instance&#10;recommendation_engine = None&#10;&#10;@asynccontextmanager&#10;async def lifespan(app: FastAPI):&#10;    &quot;&quot;&quot;Application lifespan management&quot;&quot;&quot;&#10;    global recommendation_engine&#10;&#10;    # Startup&#10;    logger.info(&quot;Starting recommendation service...&quot;)&#10;&#10;    try:&#10;        # Create database tables&#10;        await create_tables()&#10;        logger.info(&quot;Database tables created/verified&quot;)&#10;&#10;        # Initialize recommendation engine&#10;        recommendation_engine = RecommendationEngine()&#10;        await recommendation_engine.initialize()&#10;        logger.info(&quot;Recommendation engine initialized&quot;)&#10;&#10;        # Setup monitoring&#10;        setup_monitoring(app)&#10;        logger.info(&quot;Monitoring setup completed&quot;)&#10;&#10;        yield&#10;&#10;    except Exception as e:&#10;        logger.error(f&quot;Failed to start recommendation service: {e}&quot;)&#10;        raise&#10;&#10;    # Shutdown&#10;    logger.info(&quot;Shutting down recommendation service...&quot;)&#10;    if recommendation_engine and recommendation_engine.redis_client:&#10;        await recommendation_engine.redis_client.close()&#10;&#10;# Create FastAPI application&#10;app = FastAPI(&#10;    title=&quot;CTU Connect Recommendation Service&quot;,&#10;    description=&quot;AI-powered personalized post recommendation system&quot;,&#10;    version=&quot;1.0.0&quot;,&#10;    lifespan=lifespan&#10;)&#10;&#10;# Add CORS middleware&#10;app.add_middleware(&#10;    CORSMiddleware,&#10;    allow_origins=[&quot;*&quot;],  # Configure appropriately for production&#10;    allow_credentials=True,&#10;    allow_methods=[&quot;*&quot;],&#10;    allow_headers=[&quot;*&quot;],&#10;)&#10;&#10;# Security&#10;security = HTTPBearer()&#10;&#10;async def verify_api_key(credentials: HTTPAuthorizationCredentials = Depends(security)):&#10;    &quot;&quot;&quot;Verify API key for authentication&quot;&quot;&quot;&#10;    if config.SECRET_KEY and credentials.credentials != config.SECRET_KEY:&#10;        raise HTTPException(status_code=401, detail=&quot;Invalid API key&quot;)&#10;    return credentials.credentials&#10;&#10;@app.middleware(&quot;http&quot;)&#10;async def log_requests(request: Request, call_next):&#10;    &quot;&quot;&quot;Log all requests for monitoring&quot;&quot;&quot;&#10;    start_time = datetime.utcnow()&#10;&#10;    response = await call_next(request)&#10;&#10;    processing_time = (datetime.utcnow() - start_time).total_seconds() * 1000&#10;&#10;    logger.info(&#10;        &quot;Request processed&quot;,&#10;        method=request.method,&#10;        url=str(request.url),&#10;        status_code=response.status_code,&#10;        processing_time_ms=processing_time&#10;    )&#10;&#10;    # Update metrics&#10;    metrics.request_count.labels(&#10;        method=request.method,&#10;        endpoint=request.url.path,&#10;        status_code=response.status_code&#10;    ).inc()&#10;&#10;    metrics.request_duration.labels(&#10;        method=request.method,&#10;        endpoint=request.url.path&#10;    ).observe(processing_time / 1000)&#10;&#10;    return response&#10;&#10;@app.get(&quot;/health&quot;, response_model=HealthResponse)&#10;async def health_check():&#10;    &quot;&quot;&quot;Health check endpoint&quot;&quot;&quot;&#10;    services_status = {}&#10;&#10;    # Check Redis connection&#10;    try:&#10;        if recommendation_engine and recommendation_engine.redis_client:&#10;            await recommendation_engine.redis_client.ping()&#10;            services_status[&quot;redis&quot;] = &quot;healthy&quot;&#10;        else:&#10;            services_status[&quot;redis&quot;] = &quot;not_initialized&quot;&#10;    except Exception:&#10;        services_status[&quot;redis&quot;] = &quot;unhealthy&quot;&#10;&#10;    # Check recommendation engine&#10;    if recommendation_engine and recommendation_engine.is_initialized:&#10;        services_status[&quot;recommendation_engine&quot;] = &quot;healthy&quot;&#10;    else:&#10;        services_status[&quot;recommendation_engine&quot;] = &quot;unhealthy&quot;&#10;&#10;    overall_status = &quot;healthy&quot; if all(&#10;        status == &quot;healthy&quot; for status in services_status.values()&#10;    ) else &quot;degraded&quot;&#10;&#10;    return HealthResponse(&#10;        status=overall_status,&#10;        timestamp=datetime.utcnow().isoformat(),&#10;        version=&quot;1.0.0&quot;,&#10;        services=services_status&#10;    )&#10;&#10;@app.post(&quot;/recommendations&quot;, response_model=RecommendationResponse)&#10;async def get_recommendations(&#10;    request: RecommendationRequest,&#10;    db_session: AsyncSession = Depends(get_db_session),&#10;    api_key: str = Depends(verify_api_key)&#10;):&#10;    &quot;&quot;&quot;Get personalized recommendations for a user&quot;&quot;&quot;&#10;    start_time = datetime.utcnow()&#10;&#10;    try:&#10;        if not recommendation_engine or not recommendation_engine.is_initialized:&#10;            raise HTTPException(status_code=503, detail=&quot;Recommendation engine not available&quot;)&#10;&#10;        # Get recommendations&#10;        result = await recommendation_engine.get_recommendations(&#10;            user_id=request.user_id,&#10;            context=request.context,&#10;            db_session=db_session,&#10;            k=request.k&#10;        )&#10;&#10;        processing_time = (datetime.utcnow() - start_time).total_seconds() * 1000&#10;&#10;        # Update metrics&#10;        metrics.recommendations_served.labels(&#10;            variant=result.get(&quot;ab_variant&quot;, &quot;unknown&quot;)&#10;        ).inc()&#10;&#10;        return RecommendationResponse(&#10;            recommendations=result[&quot;recommendations&quot;],&#10;            ab_variant=result[&quot;ab_variant&quot;],&#10;            timestamp=result[&quot;timestamp&quot;],&#10;            user_id=result[&quot;user_id&quot;],&#10;            total_count=len(result[&quot;recommendations&quot;]),&#10;            processing_time_ms=processing_time&#10;        )&#10;&#10;    except Exception as e:&#10;        logger.error(f&quot;Error getting recommendations for user {request.user_id}: {e}&quot;)&#10;        metrics.error_count.labels(endpoint=&quot;/recommendations&quot;).inc()&#10;        raise HTTPException(status_code=500, detail=f&quot;Internal server error: {str(e)}&quot;)&#10;&#10;@app.post(&quot;/feedback&quot;, response_model=FeedbackResponse)&#10;async def record_feedback(&#10;    request: FeedbackRequest,&#10;    background_tasks: BackgroundTasks,&#10;    db_session: AsyncSession = Depends(get_db_session),&#10;    api_key: str = Depends(verify_api_key)&#10;):&#10;    &quot;&quot;&quot;Record user feedback for reinforcement learning&quot;&quot;&quot;&#10;    try:&#10;        if not recommendation_engine or not recommendation_engine.is_initialized:&#10;            raise HTTPException(status_code=503, detail=&quot;Recommendation engine not available&quot;)&#10;&#10;        # Record feedback asynchronously&#10;        background_tasks.add_task(&#10;            recommendation_engine.record_feedback,&#10;            request.user_id,&#10;            request.post_id,&#10;            request.feedback_type,&#10;            request.context,&#10;            db_session&#10;        )&#10;&#10;        # Update metrics&#10;        metrics.feedback_received.labels(&#10;            feedback_type=request.feedback_type&#10;        ).inc()&#10;&#10;        return FeedbackResponse(&#10;            success=True,&#10;            message=&quot;Feedback recorded successfully&quot;,&#10;            timestamp=datetime.utcnow().isoformat()&#10;        )&#10;&#10;    except Exception as e:&#10;        logger.error(f&quot;Error recording feedback: {e}&quot;)&#10;        metrics.error_count.labels(endpoint=&quot;/feedback&quot;).inc()&#10;        raise HTTPException(status_code=500, detail=f&quot;Internal server error: {str(e)}&quot;)&#10;&#10;@app.get(&quot;/recommendations/{user_id}/history&quot;)&#10;async def get_recommendation_history(&#10;    user_id: str,&#10;    limit: int = 50,&#10;    db_session: AsyncSession = Depends(get_db_session),&#10;    api_key: str = Depends(verify_api_key)&#10;):&#10;    &quot;&quot;&quot;Get recommendation history for a user&quot;&quot;&quot;&#10;    try:&#10;        from sqlalchemy import select&#10;        from db.models import RecommendationLog&#10;&#10;        result = await db_session.execute(&#10;            select(RecommendationLog)&#10;            .where(RecommendationLog.user_id == user_id)&#10;            .order_by(RecommendationLog.timestamp.desc())&#10;            .limit(limit)&#10;        )&#10;&#10;        logs = result.scalars().all()&#10;&#10;        history = []&#10;        for log in logs:&#10;            history.append({&#10;                &quot;timestamp&quot;: log.timestamp.isoformat(),&#10;                &quot;post_ids&quot;: log.post_ids,&#10;                &quot;model_version&quot;: log.model_version,&#10;                &quot;ab_test_variant&quot;: log.ab_test_variant,&#10;                &quot;served_count&quot;: log.served_count,&#10;                &quot;clicked_count&quot;: log.clicked_count,&#10;                &quot;ctr&quot;: log.ctr&#10;            })&#10;&#10;        return {&#10;            &quot;user_id&quot;: user_id,&#10;            &quot;history&quot;: history,&#10;            &quot;total_count&quot;: len(history)&#10;        }&#10;&#10;    except Exception as e:&#10;        logger.error(f&quot;Error getting recommendation history: {e}&quot;)&#10;        raise HTTPException(status_code=500, detail=f&quot;Internal server error: {str(e)}&quot;)&#10;&#10;@app.get(&quot;/metrics/model&quot;)&#10;async def get_model_metrics(&#10;    db_session: AsyncSession = Depends(get_db_session),&#10;    api_key: str = Depends(verify_api_key)&#10;):&#10;    &quot;&quot;&quot;Get model performance metrics&quot;&quot;&quot;&#10;    try:&#10;        from sqlalchemy import select&#10;        from db.models import ModelMetrics&#10;&#10;        # Get latest metrics&#10;        result = await db_session.execute(&#10;            select(ModelMetrics)&#10;            .order_by(ModelMetrics.evaluation_date.desc())&#10;            .limit(20)&#10;        )&#10;&#10;        metrics_data = result.scalars().all()&#10;&#10;        metrics_by_name = {}&#10;        for metric in metrics_data:&#10;            if metric.metric_name not in metrics_by_name:&#10;                metrics_by_name[metric.metric_name] = []&#10;&#10;            metrics_by_name[metric.metric_name].append({&#10;                &quot;value&quot;: metric.metric_value,&#10;                &quot;date&quot;: metric.evaluation_date.isoformat(),&#10;                &quot;model_version&quot;: metric.model_version&#10;            })&#10;&#10;        return {&#10;            &quot;metrics&quot;: metrics_by_name,&#10;            &quot;timestamp&quot;: datetime.utcnow().isoformat()&#10;        }&#10;&#10;    except Exception as e:&#10;        logger.error(f&quot;Error getting model metrics: {e}&quot;)&#10;        raise HTTPException(status_code=500, detail=f&quot;Internal server error: {str(e)}&quot;)&#10;&#10;@app.get(&quot;/ab-tests&quot;)&#10;async def get_ab_test_status(&#10;    db_session: AsyncSession = Depends(get_db_session),&#10;    api_key: str = Depends(verify_api_key)&#10;):&#10;    &quot;&quot;&quot;Get A/B test experiment status&quot;&quot;&quot;&#10;    try:&#10;        from sqlalchemy import select&#10;        from db.models import ABTestExperiment&#10;&#10;        result = await db_session.execute(&#10;            select(ABTestExperiment)&#10;            .where(ABTestExperiment.is_active == True)&#10;        )&#10;&#10;        experiments = result.scalars().all()&#10;&#10;        active_experiments = []&#10;        for exp in experiments:&#10;            active_experiments.append({&#10;                &quot;experiment_name&quot;: exp.experiment_name,&#10;                &quot;variants&quot;: exp.variants,&#10;                &quot;start_date&quot;: exp.start_date.isoformat(),&#10;                &quot;end_date&quot;: exp.end_date.isoformat() if exp.end_date else None,&#10;                &quot;results&quot;: exp.results,&#10;                &quot;winner&quot;: exp.winner&#10;            })&#10;&#10;        return {&#10;            &quot;active_experiments&quot;: active_experiments,&#10;            &quot;default_variants&quot;: config.AB_TEST_VARIANTS&#10;        }&#10;&#10;    except Exception as e:&#10;        logger.error(f&quot;Error getting A/B test status: {e}&quot;)&#10;        raise HTTPException(status_code=500, detail=f&quot;Internal server error: {str(e)}&quot;)&#10;&#10;# Prometheus metrics endpoint&#10;@app.get(&quot;/metrics&quot;)&#10;async def prometheus_metrics():&#10;    &quot;&quot;&quot;Prometheus metrics endpoint&quot;&quot;&quot;&#10;    from prometheus_client import generate_latest, CONTENT_TYPE_LATEST&#10;    from fastapi import Response&#10;&#10;    return Response(generate_latest(), media_type=CONTENT_TYPE_LATEST)&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    uvicorn.run(&#10;        &quot;main:app&quot;,&#10;        host=config.HOST,&#10;        port=config.PORT,&#10;        reload=config.DEBUG,&#10;        workers=1  # Use 1 worker for development, scale in production&#10;    )&#10;" />
              <option name="updatedContent" value="from fastapi import FastAPI, HTTPException, Depends, BackgroundTasks, Request&#13;&#10;from fastapi.middleware.cors import CORSMiddleware&#13;&#10;from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials&#13;&#10;from pydantic import BaseModel, Field&#13;&#10;from typing import List, Dict, Optional, Any&#13;&#10;import asyncio&#13;&#10;import logging&#13;&#10;from datetime import datetime&#13;&#10;import uvicorn&#13;&#10;from contextlib import asynccontextmanager&#13;&#10;&#13;&#10;from core.recommendation_engine import RecommendationEngine&#13;&#10;from db.models import get_db_session, create_tables, AsyncSession&#13;&#10;from config.settings import config&#13;&#10;from api.monitoring import setup_monitoring, metrics&#13;&#10;from api.eureka_client import eureka_client&#13;&#10;from api.microservice_client import microservice_client&#13;&#10;import structlog&#13;&#10;&#13;&#10;# Configure structured logging&#13;&#10;logging.basicConfig(level=logging.INFO)&#13;&#10;logger = structlog.get_logger()&#13;&#10;&#13;&#10;# Pydantic models for API requests/responses&#13;&#10;class RecommendationRequest(BaseModel):&#13;&#10;    user_id: str = Field(..., description=&quot;User ID requesting recommendations&quot;)&#13;&#10;    context: Dict[str, Any] = Field(default_factory=dict, description=&quot;Request context (device, location, etc.)&quot;)&#13;&#10;    k: Optional[int] = Field(default=None, description=&quot;Number of recommendations (default: 10)&quot;)&#13;&#10;    include_explanations: bool = Field(default=True, description=&quot;Include recommendation explanations&quot;)&#13;&#10;&#13;&#10;class RecommendationResponse(BaseModel):&#13;&#10;    recommendations: List[Dict[str, Any]]&#13;&#10;    ab_variant: str&#13;&#10;    timestamp: str&#13;&#10;    user_id: str&#13;&#10;    total_count: int&#13;&#10;    processing_time_ms: float&#13;&#10;&#13;&#10;class FeedbackRequest(BaseModel):&#13;&#10;    user_id: str = Field(..., description=&quot;User ID providing feedback&quot;)&#13;&#10;    post_id: str = Field(..., description=&quot;Post ID being interacted with&quot;)&#13;&#10;    feedback_type: str = Field(..., description=&quot;Type of feedback: click, like, comment, share, skip, dislike&quot;)&#13;&#10;    context: Dict[str, Any] = Field(default_factory=dict, description=&quot;Interaction context&quot;)&#13;&#10;    session_id: Optional[str] = Field(default=None, description=&quot;Session identifier&quot;)&#13;&#10;&#13;&#10;class FeedbackResponse(BaseModel):&#13;&#10;    success: bool&#13;&#10;    message: str&#13;&#10;    timestamp: str&#13;&#10;&#13;&#10;class HealthResponse(BaseModel):&#13;&#10;    status: str&#13;&#10;    timestamp: str&#13;&#10;    version: str&#13;&#10;    services: Dict[str, str]&#13;&#10;&#13;&#10;# Global recommendation engine instance&#13;&#10;recommendation_engine = None&#13;&#10;&#13;&#10;@asynccontextmanager&#13;&#10;async def lifespan(app: FastAPI):&#13;&#10;    &quot;&quot;&quot;Application lifespan management with Eureka integration&quot;&quot;&quot;&#13;&#10;    global recommendation_engine&#13;&#10;    &#13;&#10;    # Startup&#13;&#10;    logger.info(&quot;Starting CTU Connect Recommendation Service...&quot;)&#13;&#10;    &#13;&#10;    try:&#13;&#10;        # Initialize Eureka client&#13;&#10;        await eureka_client.initialize()&#13;&#10;        logger.info(&quot;Eureka client initialized&quot;)&#13;&#10;        &#13;&#10;        # Initialize microservice client&#13;&#10;        await microservice_client.initialize()&#13;&#10;        logger.info(&quot;Microservice client initialized&quot;)&#13;&#10;        &#13;&#10;        # Register with Eureka&#13;&#10;        if await eureka_client.register():&#13;&#10;            logger.info(&quot;Successfully registered with Eureka server&quot;)&#13;&#10;        else:&#13;&#10;            logger.warning(&quot;Failed to register with Eureka, continuing without service discovery&quot;)&#13;&#10;        &#13;&#10;        # Create database tables&#13;&#10;        await create_tables()&#13;&#10;        logger.info(&quot;Database tables created/verified&quot;)&#13;&#10;        &#13;&#10;        # Initialize recommendation engine&#13;&#10;        recommendation_engine = RecommendationEngine()&#13;&#10;        recommendation_engine.microservice_client = microservice_client&#13;&#10;        await recommendation_engine.initialize()&#13;&#10;        logger.info(&quot;Recommendation engine initialized&quot;)&#13;&#10;        &#13;&#10;        # Setup monitoring&#13;&#10;        setup_monitoring(app)&#13;&#10;        logger.info(&quot;Monitoring setup completed&quot;)&#13;&#10;        &#13;&#10;        yield&#13;&#10;        &#13;&#10;    except Exception as e:&#13;&#10;        logger.error(f&quot;Failed to start recommendation service: {e}&quot;)&#13;&#10;        raise&#13;&#10;    &#13;&#10;    # Shutdown&#13;&#10;    logger.info(&quot;Shutting down CTU Connect Recommendation Service...&quot;)&#13;&#10;    &#13;&#10;    # Cleanup&#13;&#10;    if eureka_client:&#13;&#10;        await eureka_client.close()&#13;&#10;    if microservice_client:&#13;&#10;        await microservice_client.close()&#13;&#10;    if recommendation_engine and recommendation_engine.redis_client:&#13;&#10;        await recommendation_engine.redis_client.close()&#13;&#10;&#13;&#10;# Create FastAPI application&#13;&#10;app = FastAPI(&#13;&#10;    title=&quot;CTU Connect Recommendation Service&quot;,&#13;&#10;    description=&quot;AI-powered personalized post recommendation system for CTU Connect&quot;,&#13;&#10;    version=&quot;1.0.0&quot;,&#13;&#10;    lifespan=lifespan&#13;&#10;)&#13;&#10;&#13;&#10;# Add CORS middleware for CTU Connect frontend&#13;&#10;app.add_middleware(&#13;&#10;    CORSMiddleware,&#13;&#10;    allow_origins=[&quot;http://localhost:3000&quot;, &quot;http://localhost:3001&quot;],  # CTU Connect frontends&#13;&#10;    allow_credentials=True,&#13;&#10;    allow_methods=[&quot;*&quot;],&#13;&#10;    allow_headers=[&quot;*&quot;],&#13;&#10;)&#13;&#10;&#13;&#10;# Security&#13;&#10;security = HTTPBearer()&#13;&#10;&#13;&#10;async def verify_api_key(credentials: HTTPAuthorizationCredentials = Depends(security)):&#13;&#10;    &quot;&quot;&quot;Verify API key or JWT token&quot;&quot;&quot;&#13;&#10;    token = credentials.credentials&#13;&#10;    &#13;&#10;    # Try to validate with Auth Service first&#13;&#10;    if microservice_client:&#13;&#10;        user_info = await microservice_client.validate_user_token(token)&#13;&#10;        if user_info:&#13;&#10;            return user_info&#13;&#10;    &#13;&#10;    # Fallback to API key validation&#13;&#10;    if config.SECRET_KEY and token != config.SECRET_KEY:&#13;&#10;        raise HTTPException(status_code=401, detail=&quot;Invalid authentication&quot;)&#13;&#10;    &#13;&#10;    return {&quot;authenticated&quot;: True}&#13;&#10;&#13;&#10;@app.middleware(&quot;http&quot;)&#13;&#10;async def log_requests(request: Request, call_next):&#13;&#10;    &quot;&quot;&quot;Log all requests for monitoring&quot;&quot;&quot;&#13;&#10;    start_time = datetime.utcnow()&#13;&#10;&#13;&#10;    response = await call_next(request)&#13;&#10;&#13;&#10;    processing_time = (datetime.utcnow() - start_time).total_seconds() * 1000&#13;&#10;&#13;&#10;    logger.info(&#13;&#10;        &quot;Request processed&quot;,&#13;&#10;        method=request.method,&#13;&#10;        url=str(request.url),&#13;&#10;        status_code=response.status_code,&#13;&#10;        processing_time_ms=processing_time&#13;&#10;    )&#13;&#10;&#13;&#10;    # Update metrics&#13;&#10;    metrics.request_count.labels(&#13;&#10;        method=request.method,&#13;&#10;        endpoint=request.url.path,&#13;&#10;        status_code=response.status_code&#13;&#10;    ).inc()&#13;&#10;&#13;&#10;    metrics.request_duration.labels(&#13;&#10;        method=request.method,&#13;&#10;        endpoint=request.url.path&#13;&#10;    ).observe(processing_time / 1000)&#13;&#10;&#13;&#10;    return response&#13;&#10;&#13;&#10;@app.get(&quot;/health&quot;, response_model=HealthResponse)&#13;&#10;async def health_check():&#13;&#10;    &quot;&quot;&quot;Health check endpoint compatible with Spring Boot actuator&quot;&quot;&quot;&#13;&#10;    services_status = {}&#13;&#10;    &#13;&#10;    # Check Redis connection&#13;&#10;    try:&#13;&#10;        if recommendation_engine and recommendation_engine.redis_client:&#13;&#10;            await recommendation_engine.redis_client.ping()&#13;&#10;            services_status[&quot;redis&quot;] = &quot;UP&quot;&#13;&#10;        else:&#13;&#10;            services_status[&quot;redis&quot;] = &quot;DOWN&quot;&#13;&#10;    except Exception:&#13;&#10;        services_status[&quot;redis&quot;] = &quot;DOWN&quot;&#13;&#10;    &#13;&#10;    # Check recommendation engine&#13;&#10;    if recommendation_engine and recommendation_engine.is_initialized:&#13;&#10;        services_status[&quot;recommendation_engine&quot;] = &quot;UP&quot;&#13;&#10;    else:&#13;&#10;        services_status[&quot;recommendation_engine&quot;] = &quot;DOWN&quot;&#13;&#10;    &#13;&#10;    # Check Eureka connection&#13;&#10;    try:&#13;&#10;        if eureka_client.registered:&#13;&#10;            services_status[&quot;eureka&quot;] = &quot;UP&quot;&#13;&#10;        else:&#13;&#10;            services_status[&quot;eureka&quot;] = &quot;DOWN&quot;&#13;&#10;    except Exception:&#13;&#10;        services_status[&quot;eureka&quot;] = &quot;DOWN&quot;&#13;&#10;    &#13;&#10;    # Check microservice connectivity&#13;&#10;    try:&#13;&#10;        if microservice_client.session:&#13;&#10;            services_status[&quot;microservices&quot;] = &quot;UP&quot;&#13;&#10;        else:&#13;&#10;            services_status[&quot;microservices&quot;] = &quot;DOWN&quot;&#13;&#10;    except Exception:&#13;&#10;        services_status[&quot;microservices&quot;] = &quot;DOWN&quot;&#13;&#10;    &#13;&#10;    overall_status = &quot;UP&quot; if all(&#13;&#10;        status == &quot;UP&quot; for status in services_status.values()&#13;&#10;    ) else &quot;DOWN&quot;&#13;&#10;    &#13;&#10;    return HealthResponse(&#13;&#10;        status=overall_status,&#13;&#10;        timestamp=datetime.utcnow().isoformat(),&#13;&#10;        version=&quot;1.0.0&quot;,&#13;&#10;        services=services_status&#13;&#10;    )&#13;&#10;&#13;&#10;@app.post(&quot;/api/recommendations&quot;, response_model=RecommendationResponse)&#13;&#10;async def get_recommendations(&#13;&#10;    request: RecommendationRequest,&#13;&#10;    db_session: AsyncSession = Depends(get_db_session),&#13;&#10;    auth_info: dict = Depends(verify_api_key)&#13;&#10;):&#13;&#10;    &quot;&quot;&quot;Get personalized recommendations for a user (API Gateway compatible path)&quot;&quot;&quot;&#13;&#10;    start_time = datetime.utcnow()&#13;&#10;    &#13;&#10;    try:&#13;&#10;        if not recommendation_engine or not recommendation_engine.is_initialized:&#13;&#10;            raise HTTPException(status_code=503, detail=&quot;Recommendation engine not available&quot;)&#13;&#10;        &#13;&#10;        # Get enhanced user context from User Service&#13;&#10;        if microservice_client and 'user_id' in str(auth_info):&#13;&#10;            user_profile = await microservice_client.get_user_profile(request.user_id)&#13;&#10;            if user_profile:&#13;&#10;                request.context.update({&#13;&#10;                    &quot;user_interests&quot;: user_profile.get(&quot;interests&quot;, {}),&#13;&#10;                    &quot;user_activity&quot;: user_profile.get(&quot;activityPattern&quot;, {}),&#13;&#10;                    &quot;user_demographics&quot;: user_profile.get(&quot;demographics&quot;, {})&#13;&#10;                })&#13;&#10;        &#13;&#10;        # Get recommendations&#13;&#10;        result = await recommendation_engine.get_recommendations(&#13;&#10;            user_id=request.user_id,&#13;&#10;            context=request.context,&#13;&#10;            db_session=db_session,&#13;&#10;            k=request.k&#13;&#10;        )&#13;&#10;        &#13;&#10;        processing_time = (datetime.utcnow() - start_time).total_seconds() * 1000&#13;&#10;        &#13;&#10;        # Update metrics&#13;&#10;        metrics.recommendations_served.labels(&#13;&#10;            variant=result.get(&quot;ab_variant&quot;, &quot;unknown&quot;)&#13;&#10;        ).inc()&#13;&#10;        &#13;&#10;        return RecommendationResponse(&#13;&#10;            recommendations=result[&quot;recommendations&quot;],&#13;&#10;            ab_variant=result[&quot;ab_variant&quot;],&#13;&#10;            timestamp=result[&quot;timestamp&quot;],&#13;&#10;            user_id=result[&quot;user_id&quot;],&#13;&#10;            total_count=len(result[&quot;recommendations&quot;]),&#13;&#10;            processing_time_ms=processing_time&#13;&#10;        )&#13;&#10;        &#13;&#10;    except Exception as e:&#13;&#10;        logger.error(f&quot;Error getting recommendations for user {request.user_id}: {e}&quot;)&#13;&#10;        metrics.error_count.labels(endpoint=&quot;/api/recommendations&quot;).inc()&#13;&#10;        raise HTTPException(status_code=500, detail=f&quot;Internal server error: {str(e)}&quot;)&#13;&#10;&#13;&#10;@app.post(&quot;/api/feedback&quot;, response_model=FeedbackResponse)&#13;&#10;async def record_feedback(&#13;&#10;    request: FeedbackRequest,&#13;&#10;    background_tasks: BackgroundTasks,&#13;&#10;    db_session: AsyncSession = Depends(get_db_session),&#13;&#10;    auth_info: dict = Depends(verify_api_key)&#13;&#10;):&#13;&#10;    &quot;&quot;&quot;Record user feedback for reinforcement learning (API Gateway compatible path)&quot;&quot;&quot;&#13;&#10;    try:&#13;&#10;        if not recommendation_engine or not recommendation_engine.is_initialized:&#13;&#10;            raise HTTPException(status_code=503, detail=&quot;Recommendation engine not available&quot;)&#13;&#10;        &#13;&#10;        # Record feedback asynchronously&#13;&#10;        background_tasks.add_task(&#13;&#10;            recommendation_engine.record_feedback,&#13;&#10;            request.user_id,&#13;&#10;            request.post_id,&#13;&#10;            request.feedback_type,&#13;&#10;            request.context,&#13;&#10;            db_session&#13;&#10;        )&#13;&#10;        &#13;&#10;        # Send interaction event to other microservices&#13;&#10;        if microservice_client:&#13;&#10;            background_tasks.add_task(&#13;&#10;                microservice_client.send_interaction_event,&#13;&#10;                request.user_id,&#13;&#10;                request.post_id,&#13;&#10;                request.feedback_type,&#13;&#10;                request.context&#13;&#10;            )&#13;&#10;        &#13;&#10;        # Update metrics&#13;&#10;        metrics.feedback_received.labels(&#13;&#10;            feedback_type=request.feedback_type&#13;&#10;        ).inc()&#13;&#10;        &#13;&#10;        return FeedbackResponse(&#13;&#10;            success=True,&#13;&#10;            message=&quot;Feedback recorded successfully&quot;,&#13;&#10;            timestamp=datetime.utcnow().isoformat()&#13;&#10;        )&#13;&#10;        &#13;&#10;    except Exception as e:&#13;&#10;        logger.error(f&quot;Error recording feedback: {e}&quot;)&#13;&#10;        metrics.error_count.labels(endpoint=&quot;/api/feedback&quot;).inc()&#13;&#10;        raise HTTPException(status_code=500, detail=f&quot;Internal server error: {str(e)}&quot;)&#13;&#10;&#13;&#10;# Service discovery endpoints&#13;&#10;@app.get(&quot;/api/services&quot;)&#13;&#10;async def get_registered_services(auth_info: dict = Depends(verify_api_key)):&#13;&#10;    &quot;&quot;&quot;Get all registered services from Eureka&quot;&quot;&quot;&#13;&#10;    try:&#13;&#10;        services = await eureka_client.get_all_services()&#13;&#10;        return {&#13;&#10;            &quot;services&quot;: services,&#13;&#10;            &quot;timestamp&quot;: datetime.utcnow().isoformat()&#13;&#10;        }&#13;&#10;    except Exception as e:&#13;&#10;        logger.error(f&quot;Error getting services: {e}&quot;)&#13;&#10;        raise HTTPException(status_code=500, detail=str(e))&#13;&#10;&#13;&#10;@app.get(&quot;/api/services/{service_name}&quot;)&#13;&#10;async def get_service_instances(service_name: str, auth_info: dict = Depends(verify_api_key)):&#13;&#10;    &quot;&quot;&quot;Get instances of a specific service&quot;&quot;&quot;&#13;&#10;    try:&#13;&#10;        instances = await eureka_client.discover_service(service_name)&#13;&#10;        return {&#13;&#10;            &quot;service_name&quot;: service_name,&#13;&#10;            &quot;instances&quot;: instances or [],&#13;&#10;            &quot;timestamp&quot;: datetime.utcnow().isoformat()&#13;&#10;        }&#13;&#10;    except Exception as e:&#13;&#10;        logger.error(f&quot;Error getting service instances: {e}&quot;)&#13;&#10;        raise HTTPException(status_code=500, detail=str(e))&#13;&#10;&#13;&#10;# Prometheus metrics endpoint&#13;&#10;@app.get(&quot;/metrics&quot;)&#13;&#10;async def prometheus_metrics():&#13;&#10;    &quot;&quot;&quot;Prometheus metrics endpoint&quot;&quot;&quot;&#13;&#10;    from prometheus_client import generate_latest, CONTENT_TYPE_LATEST&#13;&#10;    from fastapi import Response&#13;&#10;&#13;&#10;    return Response(generate_latest(), media_type=CONTENT_TYPE_LATEST)&#13;&#10;&#13;&#10;if __name__ == &quot;__main__&quot;:&#13;&#10;    uvicorn.run(&#13;&#10;        &quot;main:app&quot;,&#13;&#10;        host=config.HOST,&#13;&#10;        port=config.PORT,&#13;&#10;        reload=config.DEBUG,&#13;&#10;        workers=1  # Use 1 worker for development, scale in production&#13;&#10;    )" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/recommendation-service/requirements.txt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/recommendation-service/requirements.txt" />
              <option name="updatedContent" value="# Core Framework&#10;fastapi==0.104.1&#10;uvicorn[standard]==0.24.0&#10;pydantic==2.5.0&#10;python-multipart==0.0.6&#10;&#10;# Deep Learning &amp; ML&#10;torch==2.1.0&#10;torchvision==0.16.0&#10;transformers==4.35.0&#10;scikit-learn==1.3.2&#10;numpy==1.24.3&#10;pandas==2.0.3&#10;&#10;# Vietnamese NLP&#10;underthesea==6.7.0&#10;py-vncorenlp==1.0.3&#10;&#10;# Database &amp; Caching&#10;asyncpg==0.29.0&#10;aioredis==2.0.1&#10;sqlalchemy[asyncio]==2.0.23&#10;&#10;# Message Queue &amp; Streaming&#10;kafka-python==2.0.2&#10;aiokafka==0.9.0&#10;pyspark==3.5.0&#10;&#10;# Monitoring &amp; Logging&#10;prometheus-client==0.19.0&#10;structlog==23.2.0&#10;mlflow==2.8.1&#10;&#10;# HTTP &amp; Async&#10;httpx==0.25.2&#10;aiofiles==23.2.0&#10;&#10;# Testing&#10;pytest==7.4.3&#10;pytest-asyncio==0.21.1&#10;pytest-mock==3.12.0&#10;&#10;# Development&#10;black==23.11.0&#10;flake8==6.1.0&#10;mypy==1.7.1&#10;&#10;# Deployment&#10;gunicorn==21.2.0" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/recommendation-service/start.sh">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/recommendation-service/start.sh" />
              <option name="updatedContent" value="#!/bin/bash&#10;&#10;# CTU Connect Recommendation Service Startup Script&#10;&#10;set -e&#10;&#10;echo &quot; Starting CTU Connect Recommendation Service...&quot;&#10;&#10;# Check if Python is installed&#10;if ! command -v python3 &amp;&gt; /dev/null; then&#10;    echo &quot;❌ Python 3 is required but not installed.&quot;&#10;    exit 1&#10;fi&#10;&#10;# Check if Docker is installed&#10;if ! command -v docker &amp;&gt; /dev/null; then&#10;    echo &quot;❌ Docker is required but not installed.&quot;&#10;    exit 1&#10;fi&#10;&#10;# Create virtual environment if it doesn't exist&#10;if [ ! -d &quot;venv&quot; ]; then&#10;    echo &quot; Creating virtual environment...&quot;&#10;    python3 -m venv venv&#10;fi&#10;&#10;# Activate virtual environment&#10;echo &quot; Activating virtual environment...&quot;&#10;source venv/bin/activate&#10;&#10;# Install dependencies&#10;echo &quot; Installing dependencies...&quot;&#10;pip install -r requirements.txt&#10;&#10;# Check if .env exists, if not create a template&#10;if [ ! -f &quot;.env&quot; ]; then&#10;    echo &quot;⚙️ Creating environment configuration...&quot;&#10;    cat &gt; .env &lt;&lt; EOF&#10;# Database Configuration&#10;DATABASE_URL=postgresql+asyncpg://postgres:password@localhost:5433/recommendation_db&#10;&#10;# Redis Configuration&#10;REDIS_URL=redis://localhost:6380&#10;&#10;# Kafka Configuration&#10;KAFKA_BOOTSTRAP_SERVERS=localhost:9092&#10;&#10;# Service Configuration&#10;SECRET_KEY=your-secret-key-here&#10;DEBUG=true&#10;HOST=0.0.0.0&#10;PORT=8000&#10;&#10;# ML Configuration&#10;MLFLOW_TRACKING_URI=http://localhost:5001&#10;MODEL_PATH=./models/recommendation_model.pt&#10;&#10;# Recommendation Settings&#10;TOP_K_RECOMMENDATIONS=10&#10;EMBEDDING_DIM=256&#10;NUM_HEADS=8&#10;EOF&#10;    echo &quot;✅ Created .env file. Please review and update the configuration.&quot;&#10;fi&#10;&#10;# Load environment variables&#10;if [ -f &quot;.env&quot; ]; then&#10;    export $(cat .env | grep -v '^#' | xargs)&#10;fi&#10;&#10;# Start supporting services with Docker Compose&#10;echo &quot; Starting supporting services (Database, Redis, MLflow)...&quot;&#10;docker-compose up -d recommendation-db recommendation-redis mlflow&#10;&#10;# Wait for services to be ready&#10;echo &quot;⏳ Waiting for services to be ready...&quot;&#10;sleep 10&#10;&#10;# Check if database is ready&#10;echo &quot; Checking database connection...&quot;&#10;python3 -c &quot;&#10;import asyncio&#10;import asyncpg&#10;import sys&#10;&#10;async def check_db():&#10;    try:&#10;        conn = await asyncpg.connect('postgresql://postgres:password@localhost:5433/recommendation_db')&#10;        await conn.close()&#10;        print('✅ Database connection successful')&#10;        return True&#10;    except Exception as e:&#10;        print(f'❌ Database connection failed: {e}')&#10;        return False&#10;&#10;if not asyncio.run(check_db()):&#10;    sys.exit(1)&#10;&quot;&#10;&#10;# Initialize database tables&#10;echo &quot;️ Initializing database tables...&quot;&#10;python3 -c &quot;&#10;import asyncio&#10;from db.models import create_tables&#10;&#10;async def init_db():&#10;    try:&#10;        await create_tables()&#10;        print('✅ Database tables created successfully')&#10;    except Exception as e:&#10;        print(f'❌ Database initialization failed: {e}')&#10;        raise&#10;&#10;asyncio.run(init_db())&#10;&quot;&#10;&#10;# Create models directory if it doesn't exist&#10;mkdir -p models&#10;&#10;# Start the recommendation service&#10;echo &quot; Starting recommendation service...&quot;&#10;echo &quot; Service will be available at: http://localhost:${PORT:-8000}&quot;&#10;echo &quot; MLflow UI available at: http://localhost:5001&quot;&#10;echo &quot; API Documentation available at: http://localhost:${PORT:-8000}/docs&quot;&#10;echo &quot;&quot;&#10;echo &quot; To stop the service, press Ctrl+C&quot;&#10;echo &quot; To stop all services, run: docker-compose down&quot;&#10;echo &quot;&quot;&#10;&#10;# Start the main application&#10;python3 main.py" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/recommendation-service/tests/test_recommendation.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/recommendation-service/tests/test_recommendation.py" />
              <option name="updatedContent" value="import pytest&#10;import asyncio&#10;import json&#10;from httpx import AsyncClient&#10;from fastapi.testclient import TestClient&#10;from unittest.mock import Mock, AsyncMock, patch&#10;import numpy as np&#10;from datetime import datetime&#10;&#10;from main import app&#10;from core.recommendation_engine import RecommendationEngine&#10;from db.models import UserProfile, PostFeatures, UserInteraction&#10;from config.settings import config&#10;&#10;# Test client&#10;client = TestClient(app)&#10;&#10;@pytest.fixture&#10;def mock_recommendation_engine():&#10;    &quot;&quot;&quot;Mock recommendation engine for testing&quot;&quot;&quot;&#10;    engine = Mock(spec=RecommendationEngine)&#10;    engine.is_initialized = True&#10;    engine.get_recommendations = AsyncMock()&#10;    engine.record_feedback = AsyncMock()&#10;    return engine&#10;&#10;@pytest.fixture&#10;def sample_user_profile():&#10;    &quot;&quot;&quot;Sample user profile for testing&quot;&quot;&quot;&#10;    return UserProfile(&#10;        user_id=&quot;test_user_123&quot;,&#10;        interests={&quot;Khoa Hoc&quot;: 5, &quot;Cong Nghe&quot;: 3},&#10;        engagement_score=0.7,&#10;        activity_pattern={&quot;14&quot;: 0.8, &quot;15&quot;: 0.6}&#10;    )&#10;&#10;@pytest.fixture&#10;def sample_post_features():&#10;    &quot;&quot;&quot;Sample post features for testing&quot;&quot;&quot;&#10;    return PostFeatures(&#10;        post_id=&quot;test_post_456&quot;,&#10;        title=&quot;Test Post Title&quot;,&#10;        content=&quot;This is a test post content&quot;,&#10;        author_id=&quot;author_123&quot;,&#10;        category=&quot;Khoa Hoc&quot;,&#10;        tags=[&quot;test&quot;, &quot;science&quot;],&#10;        likes_count=10,&#10;        comments_count=5,&#10;        shares_count=2,&#10;        views_count=100,&#10;        engagement_rate=0.17&#10;    )&#10;&#10;@pytest.fixture&#10;def sample_recommendations():&#10;    &quot;&quot;&quot;Sample recommendations response&quot;&quot;&quot;&#10;    return {&#10;        &quot;recommendations&quot;: [&#10;            {&#10;                &quot;post_id&quot;: &quot;post_1&quot;,&#10;                &quot;title&quot;: &quot;Test Post 1&quot;,&#10;                &quot;content&quot;: &quot;Content 1&quot;,&#10;                &quot;author_id&quot;: &quot;author_1&quot;,&#10;                &quot;category&quot;: &quot;Khoa Hoc&quot;,&#10;                &quot;tags&quot;: [&quot;science&quot;],&#10;                &quot;engagement_rate&quot;: 0.15,&#10;                &quot;relevance_score&quot;: 0.95,&#10;                &quot;rank&quot;: 1,&#10;                &quot;reason&quot;: &quot;Recommended because you're interested in Khoa Hoc&quot;&#10;            },&#10;            {&#10;                &quot;post_id&quot;: &quot;post_2&quot;,&#10;                &quot;title&quot;: &quot;Test Post 2&quot;,&#10;                &quot;content&quot;: &quot;Content 2&quot;,&#10;                &quot;author_id&quot;: &quot;author_2&quot;,&#10;                &quot;category&quot;: &quot;Cong Nghe&quot;,&#10;                &quot;tags&quot;: [&quot;technology&quot;],&#10;                &quot;engagement_rate&quot;: 0.12,&#10;                &quot;relevance_score&quot;: 0.87,&#10;                &quot;rank&quot;: 2,&#10;                &quot;reason&quot;: &quot;Trending post with high engagement&quot;&#10;            }&#10;        ],&#10;        &quot;ab_variant&quot;: &quot;personalized_v1&quot;,&#10;        &quot;timestamp&quot;: datetime.utcnow().isoformat(),&#10;        &quot;user_id&quot;: &quot;test_user_123&quot;&#10;    }&#10;&#10;class TestAPI:&#10;    &quot;&quot;&quot;Test API endpoints&quot;&quot;&quot;&#10;    &#10;    def test_health_check(self):&#10;        &quot;&quot;&quot;Test health check endpoint&quot;&quot;&quot;&#10;        response = client.get(&quot;/health&quot;)&#10;        assert response.status_code == 200&#10;        &#10;        data = response.json()&#10;        assert &quot;status&quot; in data&#10;        assert &quot;timestamp&quot; in data&#10;        assert &quot;version&quot; in data&#10;        assert &quot;services&quot; in data&#10;    &#10;    @patch('main.recommendation_engine')&#10;    def test_get_recommendations_success(self, mock_engine, sample_recommendations):&#10;        &quot;&quot;&quot;Test successful recommendation request&quot;&quot;&quot;&#10;        mock_engine.is_initialized = True&#10;        mock_engine.get_recommendations = AsyncMock(return_value=sample_recommendations)&#10;        &#10;        request_data = {&#10;            &quot;user_id&quot;: &quot;test_user_123&quot;,&#10;            &quot;context&quot;: {&quot;device_type&quot;: &quot;mobile&quot;},&#10;            &quot;k&quot;: 5&#10;        }&#10;        &#10;        response = client.post(&#10;            &quot;/recommendations&quot;,&#10;            json=request_data,&#10;            headers={&quot;Authorization&quot;: f&quot;Bearer {config.SECRET_KEY}&quot;}&#10;        )&#10;        &#10;        assert response.status_code == 200&#10;        data = response.json()&#10;        &#10;        assert &quot;recommendations&quot; in data&#10;        assert &quot;ab_variant&quot; in data&#10;        assert &quot;user_id&quot; in data&#10;        assert data[&quot;user_id&quot;] == &quot;test_user_123&quot;&#10;        assert len(data[&quot;recommendations&quot;]) &lt;= 5&#10;    &#10;    @patch('main.recommendation_engine')&#10;    def test_get_recommendations_engine_not_initialized(self, mock_engine):&#10;        &quot;&quot;&quot;Test recommendation request when engine not initialized&quot;&quot;&quot;&#10;        mock_engine.is_initialized = False&#10;        &#10;        request_data = {&#10;            &quot;user_id&quot;: &quot;test_user_123&quot;,&#10;            &quot;context&quot;: {}&#10;        }&#10;        &#10;        response = client.post(&#10;            &quot;/recommendations&quot;,&#10;            json=request_data,&#10;            headers={&quot;Authorization&quot;: f&quot;Bearer {config.SECRET_KEY}&quot;}&#10;        )&#10;        &#10;        assert response.status_code == 503&#10;    &#10;    def test_get_recommendations_unauthorized(self):&#10;        &quot;&quot;&quot;Test recommendation request without authorization&quot;&quot;&quot;&#10;        request_data = {&#10;            &quot;user_id&quot;: &quot;test_user_123&quot;,&#10;            &quot;context&quot;: {}&#10;        }&#10;        &#10;        response = client.post(&quot;/recommendations&quot;, json=request_data)&#10;        assert response.status_code == 403&#10;    &#10;    @patch('main.recommendation_engine')&#10;    def test_record_feedback_success(self, mock_engine):&#10;        &quot;&quot;&quot;Test successful feedback recording&quot;&quot;&quot;&#10;        mock_engine.is_initialized = True&#10;        mock_engine.record_feedback = AsyncMock()&#10;        &#10;        request_data = {&#10;            &quot;user_id&quot;: &quot;test_user_123&quot;,&#10;            &quot;post_id&quot;: &quot;test_post_456&quot;,&#10;            &quot;feedback_type&quot;: &quot;like&quot;,&#10;            &quot;context&quot;: {&quot;device_type&quot;: &quot;desktop&quot;}&#10;        }&#10;        &#10;        response = client.post(&#10;            &quot;/feedback&quot;,&#10;            json=request_data,&#10;            headers={&quot;Authorization&quot;: f&quot;Bearer {config.SECRET_KEY}&quot;}&#10;        )&#10;        &#10;        assert response.status_code == 200&#10;        data = response.json()&#10;        &#10;        assert data[&quot;success&quot;] is True&#10;        assert &quot;message&quot; in data&#10;        assert &quot;timestamp&quot; in data&#10;    &#10;    def test_record_feedback_invalid_type(self):&#10;        &quot;&quot;&quot;Test feedback recording with invalid feedback type&quot;&quot;&quot;&#10;        request_data = {&#10;            &quot;user_id&quot;: &quot;test_user_123&quot;,&#10;            &quot;post_id&quot;: &quot;test_post_456&quot;,&#10;            &quot;feedback_type&quot;: &quot;invalid_type&quot;,&#10;            &quot;context&quot;: {}&#10;        }&#10;        &#10;        response = client.post(&#10;            &quot;/feedback&quot;,&#10;            json=request_data,&#10;            headers={&quot;Authorization&quot;: f&quot;Bearer {config.SECRET_KEY}&quot;}&#10;        )&#10;        &#10;        # Should still accept but with different processing&#10;        assert response.status_code == 200&#10;&#10;class TestRecommendationEngine:&#10;    &quot;&quot;&quot;Test recommendation engine logic&quot;&quot;&quot;&#10;    &#10;    @pytest.mark.asyncio&#10;    async def test_initialize_engine(self):&#10;        &quot;&quot;&quot;Test engine initialization&quot;&quot;&quot;&#10;        engine = RecommendationEngine()&#10;        &#10;        # Mock dependencies&#10;        with patch('core.recommendation_engine.aioredis.from_url') as mock_redis, \&#10;             patch.object(engine, 'load_model') as mock_load_model:&#10;            &#10;            mock_redis.return_value = AsyncMock()&#10;            mock_load_model.return_value = None&#10;            &#10;            await engine.initialize()&#10;            &#10;            assert engine.is_initialized is True&#10;            assert engine.redis_client is not None&#10;    &#10;    @pytest.mark.asyncio&#10;    async def test_get_user_profile(self, sample_user_profile):&#10;        &quot;&quot;&quot;Test user profile retrieval&quot;&quot;&quot;&#10;        engine = RecommendationEngine()&#10;        &#10;        # Mock database session&#10;        mock_session = AsyncMock()&#10;        mock_result = Mock()&#10;        mock_result.scalar_one_or_none.return_value = sample_user_profile&#10;        mock_session.execute.return_value = mock_result&#10;        &#10;        profile = await engine.get_user_profile(&quot;test_user_123&quot;, mock_session)&#10;        &#10;        assert profile is not None&#10;        assert profile.user_id == &quot;test_user_123&quot;&#10;        assert profile.engagement_score == 0.7&#10;    &#10;    @pytest.mark.asyncio&#10;    async def test_prepare_user_features(self, sample_user_profile):&#10;        &quot;&quot;&quot;Test user feature preparation&quot;&quot;&quot;&#10;        engine = RecommendationEngine()&#10;        engine.data_processor = Mock()&#10;        engine.data_processor.extract_user_context.return_value = np.zeros(32)&#10;        &#10;        context = {&quot;device_type&quot;: &quot;mobile&quot;}&#10;        features = engine.prepare_user_features(sample_user_profile, context)&#10;        &#10;        assert &quot;profile_features&quot; in features&#10;        assert &quot;context_features&quot; in features&#10;        assert len(features[&quot;profile_features&quot;]) == 64&#10;        assert len(features[&quot;context_features&quot;]) == 32&#10;    &#10;    def test_rank_posts(self, sample_post_features):&#10;        &quot;&quot;&quot;Test post ranking&quot;&quot;&quot;&#10;        engine = RecommendationEngine()&#10;        &#10;        posts = [sample_post_features] * 3&#10;        scores = np.array([0.9, 0.7, 0.8])&#10;        &#10;        ranked = engine.rank_posts(posts, scores)&#10;        &#10;        assert len(ranked) == 3&#10;        assert ranked[0][1] == 0.9  # Highest score first&#10;        assert ranked[1][1] == 0.8&#10;        assert ranked[2][1] == 0.7&#10;    &#10;    def test_apply_diversity_filter(self, sample_post_features):&#10;        &quot;&quot;&quot;Test diversity filtering&quot;&quot;&quot;&#10;        engine = RecommendationEngine()&#10;        &#10;        # Create posts with different categories&#10;        posts = []&#10;        for i, category in enumerate([&quot;Khoa Hoc&quot;, &quot;Cong Nghe&quot;, &quot;Van Hoc&quot;, &quot;Khoa Hoc&quot;]):&#10;            post = PostFeatures(&#10;                post_id=f&quot;post_{i}&quot;,&#10;                title=f&quot;Title {i}&quot;,&#10;                content=f&quot;Content {i}&quot;,&#10;                author_id=f&quot;author_{i}&quot;,&#10;                category=category,&#10;                engagement_rate=0.1&#10;            )&#10;            posts.append(post)&#10;        &#10;        scores = [0.9, 0.8, 0.7, 0.6]&#10;        ranked_posts = list(zip(posts, scores))&#10;        &#10;        diverse_posts = engine.apply_diversity_filter(ranked_posts, k=3)&#10;        &#10;        assert len(diverse_posts) &lt;= 3&#10;        # Should prefer diverse categories&#10;        categories = [post[0].category for post in diverse_posts]&#10;        assert len(set(categories)) &gt;= 2&#10;&#10;class TestDataProcessor:&#10;    &quot;&quot;&quot;Test data processing functions&quot;&quot;&quot;&#10;    &#10;    def test_extract_post_features(self):&#10;        &quot;&quot;&quot;Test post feature extraction&quot;&quot;&quot;&#10;        from data.processor import DataProcessor&#10;        &#10;        processor = DataProcessor()&#10;        &#10;        post_data = {&#10;            &quot;id&quot;: &quot;test_post_123&quot;,&#10;            &quot;title&quot;: &quot;Test Title&quot;,&#10;            &quot;content&quot;: &quot;Test content&quot;,&#10;            &quot;authorId&quot;: &quot;author_123&quot;,&#10;            &quot;category&quot;: &quot;Khoa Hoc&quot;,&#10;            &quot;tags&quot;: [&quot;science&quot;, &quot;test&quot;],&#10;            &quot;stats&quot;: {&#10;                &quot;likes&quot;: 10,&#10;                &quot;comments&quot;: 5,&#10;                &quot;shares&quot;: 2,&#10;                &quot;views&quot;: 100&#10;            },&#10;            &quot;images&quot;: [&quot;image1.jpg&quot;],&#10;            &quot;videos&quot;: [],&#10;            &quot;postType&quot;: &quot;TEXT&quot;&#10;        }&#10;        &#10;        features = processor.extract_post_features(post_data)&#10;        &#10;        assert features[&quot;post_id&quot;] == &quot;test_post_123&quot;&#10;        assert features[&quot;category&quot;] == &quot;Khoa Hoc&quot;&#10;        assert features[&quot;likes_count&quot;] == 10&#10;        assert features[&quot;has_images&quot;] is True&#10;        assert features[&quot;has_videos&quot;] is False&#10;        assert features[&quot;engagement_rate&quot;] == 0.17  # (10+5+2)/100&#10;    &#10;    def test_extract_user_context(self):&#10;        &quot;&quot;&quot;Test user context extraction&quot;&quot;&quot;&#10;        from data.processor import DataProcessor&#10;        &#10;        processor = DataProcessor()&#10;        &#10;        user_data = {&#10;            &quot;engagement_score&quot;: 0.8,&#10;            &quot;interests&quot;: {&quot;Khoa Hoc&quot;: 5, &quot;Cong Nghe&quot;: 3},&#10;            &quot;activity_pattern&quot;: {&quot;14&quot;: 0.9}&#10;        }&#10;        &#10;        request_context = {&#10;            &quot;device_type&quot;: &quot;mobile&quot;&#10;        }&#10;        &#10;        context_vector = processor.extract_user_context(user_data, request_context)&#10;        &#10;        assert len(context_vector) == 32&#10;        assert context_vector[3] == 0.8  # engagement_score&#10;        assert context_vector[4] == 2    # number of interests&#10;        assert context_vector[5] == 1.0  # mobile device&#10;&#10;class TestModelComponents:&#10;    &quot;&quot;&quot;Test deep learning model components&quot;&quot;&quot;&#10;    &#10;    def test_user_embedding_forward(self):&#10;        &quot;&quot;&quot;Test user embedding forward pass&quot;&quot;&quot;&#10;        from core.models import UserEmbedding&#10;        import torch&#10;        &#10;        model = UserEmbedding(num_users=1000, embedding_dim=256)&#10;        &#10;        user_ids = torch.tensor([1, 2, 3])&#10;        profile_features = torch.randn(3, 64)&#10;        &#10;        output = model(user_ids, profile_features)&#10;        &#10;        assert output.shape == (3, 256)&#10;        assert torch.all(torch.abs(output) &lt;= 1)  # tanh output&#10;    &#10;    def test_post_embedding_forward(self):&#10;        &quot;&quot;&quot;Test post embedding forward pass&quot;&quot;&quot;&#10;        from core.models import PostEmbedding&#10;        import torch&#10;        &#10;        model = PostEmbedding(num_posts=5000, embedding_dim=256)&#10;        &#10;        post_ids = torch.tensor([1, 2, 3])&#10;        content_features = torch.randn(3, 768)&#10;        categories = torch.tensor([0, 1, 2])&#10;        &#10;        output = model(post_ids, content_features, categories)&#10;        &#10;        assert output.shape == (3, 256)&#10;        assert torch.all(torch.abs(output) &lt;= 1)  # tanh output&#10;    &#10;    def test_attention_mechanism(self):&#10;        &quot;&quot;&quot;Test multi-head attention&quot;&quot;&quot;&#10;        from core.models import MultiHeadAttention&#10;        import torch&#10;        &#10;        attention = MultiHeadAttention(embedding_dim=256, num_heads=8)&#10;        &#10;        user_emb = torch.randn(3, 256)&#10;        post_emb = torch.randn(3, 256)&#10;        &#10;        output = attention(user_emb, post_emb)&#10;        &#10;        assert output.shape == (3, 256)&#10;&#10;# Load testing&#10;class TestPerformance:&#10;    &quot;&quot;&quot;Performance and load testing&quot;&quot;&quot;&#10;    &#10;    @pytest.mark.asyncio&#10;    async def test_concurrent_recommendations(self):&#10;        &quot;&quot;&quot;Test concurrent recommendation requests&quot;&quot;&quot;&#10;        import asyncio&#10;        import time&#10;        &#10;        async def make_request():&#10;            async with AsyncClient(app=app, base_url=&quot;http://test&quot;) as ac:&#10;                response = await ac.post(&#10;                    &quot;/recommendations&quot;,&#10;                    json={&#10;                        &quot;user_id&quot;: f&quot;user_{np.random.randint(1000)}&quot;,&#10;                        &quot;context&quot;: {&quot;device_type&quot;: &quot;mobile&quot;}&#10;                    },&#10;                    headers={&quot;Authorization&quot;: f&quot;Bearer {config.SECRET_KEY}&quot;}&#10;                )&#10;                return response.status_code&#10;        &#10;        # Skip if recommendation engine not available&#10;        if not hasattr(app.state, 'recommendation_engine'):&#10;            pytest.skip(&quot;Recommendation engine not available&quot;)&#10;        &#10;        start_time = time.time()&#10;        &#10;        # Make 10 concurrent requests&#10;        tasks = [make_request() for _ in range(10)]&#10;        results = await asyncio.gather(*tasks, return_exceptions=True)&#10;        &#10;        end_time = time.time()&#10;        duration = end_time - start_time&#10;        &#10;        # Most requests should succeed or return 503 (service unavailable)&#10;        success_count = sum(1 for r in results if isinstance(r, int) and r in [200, 503])&#10;        assert success_count &gt;= 8  # Allow some failures&#10;        &#10;        # Should complete within reasonable time&#10;        assert duration &lt; 10.0  # 10 seconds max for 10 requests&#10;&#10;# Integration tests&#10;class TestIntegration:&#10;    &quot;&quot;&quot;Integration tests&quot;&quot;&quot;&#10;    &#10;    @pytest.mark.asyncio&#10;    @pytest.mark.integration&#10;    async def test_full_recommendation_flow(self, sample_user_profile, sample_post_features):&#10;        &quot;&quot;&quot;Test full recommendation flow&quot;&quot;&quot;&#10;        # This would require a test database and full setup&#10;        # Skip for unit tests&#10;        pytest.skip(&quot;Integration test - requires full setup&quot;)&#10;    &#10;    @pytest.mark.asyncio&#10;    @pytest.mark.integration&#10;    async def test_feedback_processing(self):&#10;        &quot;&quot;&quot;Test feedback processing integration&quot;&quot;&quot;&#10;        # This would test the full feedback pipeline&#10;        pytest.skip(&quot;Integration test - requires full setup&quot;)&#10;&#10;# Fixtures for database testing&#10;@pytest.fixture&#10;async def test_db_session():&#10;    &quot;&quot;&quot;Test database session&quot;&quot;&quot;&#10;    # This would set up a test database&#10;    # For now, return a mock&#10;    return AsyncMock()&#10;&#10;# Run tests&#10;if __name__ == &quot;__main__&quot;:&#10;    pytest.main([__file__, &quot;-v&quot;, &quot;--tb=short&quot;])" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/user-service/src/main/java/com/ctuconnect/controller/UserSyncController.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/user-service/src/main/java/com/ctuconnect/controller/UserSyncController.java" />
              <option name="originalContent" value="package com.ctuconnect.controller;&#10;&#10;import com.ctuconnect.dto.AuthorDTO;&#10;import com.ctuconnect.dto.UserDTO;&#10;import com.ctuconnect.security.annotation.RequireAuth;&#10;import com.ctuconnect.service.UserSyncService;&#10;import com.ctuconnect.service.UserService;&#10;import org.springframework.beans.factory.annotation.Autowired;&#10;import org.springframework.http.ResponseEntity;&#10;import org.springframework.web.bind.annotation.*;&#10;&#10;import java.util.Set;&#10;&#10;/**&#10; * Controller để xử lý đồng bộ dữ liệu giữa auth-db và user-db&#10; * Các endpoint này được gọi từ auth-service hoặc các microservices khác&#10; */&#10;@RestController&#10;@RequestMapping(&quot;/api/users/sync&quot;)&#10;public class UserSyncController {&#10;&#10;    @Autowired&#10;    private UserSyncService userSyncService;&#10;&#10;    @Autowired&#10;    private UserService userService;&#10;&#10;    /**&#10;     * Tạo user profile trong user-db khi user được tạo ở auth-db&#10;     * Endpoint này được gọi từ auth-service&#10;     */&#10;    @PostMapping(&quot;/create&quot;)&#10;    @RequireAuth(roles = {&quot;SYSTEM&quot;, &quot;ADMIN&quot;}) // Chỉ system hoặc admin mới có thể gọi&#10;    public ResponseEntity&lt;UserDTO&gt; syncUserFromAuth(&#10;            @RequestParam String userId,&#10;            @RequestParam String email,&#10;            @RequestParam String role) {&#10;        UserDTO userDTO = userSyncService.syncUserFromAuth(userId, email, role);&#10;        return ResponseEntity.ok(userDTO);&#10;    }&#10;&#10;    /**&#10;     * Cập nhật thông tin user khi có thay đổi từ auth-db&#10;     */&#10;    @PutMapping(&quot;/update&quot;)&#10;    @RequireAuth(roles = {&quot;SYSTEM&quot;, &quot;ADMIN&quot;})&#10;    public ResponseEntity&lt;UserDTO&gt; updateUserFromAuth(&#10;            @RequestParam String userId,&#10;            @RequestParam String email,&#10;            @RequestParam String role) {&#10;        UserDTO userDTO = userSyncService.updateUserFromAuth(userId, email, role);&#10;        return ResponseEntity.ok(userDTO);&#10;    }&#10;&#10;    /**&#10;     * Xóa user khỏi user-db khi user bị xóa ở auth-db&#10;     */&#10;    @DeleteMapping(&quot;/delete&quot;)&#10;    @RequireAuth(roles = {&quot;SYSTEM&quot;, &quot;ADMIN&quot;})&#10;    public ResponseEntity&lt;String&gt; deleteUserFromAuth(@RequestParam String userId) {&#10;        userSyncService.deleteUserFromAuth(userId);&#10;        return ResponseEntity.ok(&quot;User deleted from user database successfully&quot;);&#10;    }&#10;&#10;    /**&#10;     * Kiểm tra tính nhất quán dữ liệu giữa auth-db và user-db&#10;     */&#10;    @GetMapping(&quot;/check&quot;)&#10;    @RequireAuth(roles = {&quot;SYSTEM&quot;, &quot;ADMIN&quot;})&#10;    public ResponseEntity&lt;Boolean&gt; checkUserSync(&#10;            @RequestParam String userId,&#10;            @RequestParam String email,&#10;            @RequestParam String role) {&#10;        boolean isSynced = userSyncService.isUserSynced(userId, email, role);&#10;        return ResponseEntity.ok(isSynced);&#10;    }&#10;&#10;    /**&#10;     * Lấy thông tin tác giả cho post-service&#10;     * Endpoint này được gọi từ post-service để lấy author info&#10;     */&#10;    @GetMapping(&quot;/authors/{id}&quot;)&#10;    public ResponseEntity&lt;AuthorDTO&gt; getAuthorInfo(@PathVariable(&quot;id&quot;) String authorId) {&#10;        AuthorDTO authorInfo = userSyncService.getAuthorInfo(authorId);&#10;        return ResponseEntity.ok(authorInfo);&#10;    }&#10;&#10;    /**&#10;     * Lấy danh sách ID bạn bè của user&#10;     * Endpoint này được gọi từ post-service cho news feed algorithm&#10;     */&#10;    @GetMapping(&quot;/{userId}/friends/ids&quot;)&#10;    public ResponseEntity&lt;Set&lt;String&gt;&gt; getFriendIds(@PathVariable(&quot;userId&quot;) String userId) {&#10;        Set&lt;String&gt; friendIds = userService.getFriendIds(userId);&#10;        return ResponseEntity.ok(friendIds);&#10;    }&#10;&#10;    /**&#10;     * Lấy danh sách user có tương tác gần với user&#10;     * Endpoint này được gọi từ post-service cho news feed algorithm&#10;     */&#10;    @GetMapping(&quot;/{userId}/close-interactions&quot;)&#10;    public ResponseEntity&lt;Set&lt;String&gt;&gt; getCloseInteractionIds(@PathVariable(&quot;userId&quot;) String userId) {&#10;        Set&lt;String&gt; closeInteractionIds = userService.getCloseInteractionIds(userId);&#10;        return ResponseEntity.ok(closeInteractionIds);&#10;    }&#10;&#10;    /**&#10;     * Lấy danh sách user cùng khoa&#10;     * Endpoint này được gọi từ post-service cho news feed algorithm&#10;     */&#10;    @GetMapping(&quot;/{userId}/same-faculty&quot;)&#10;    public ResponseEntity&lt;Set&lt;String&gt;&gt; getSameFacultyUserIds(@PathVariable(&quot;userId&quot;) String userId) {&#10;        Set&lt;String&gt; sameFacultyIds = userService.getSameFacultyUserIds(userId);&#10;        return ResponseEntity.ok(sameFacultyIds);&#10;    }&#10;&#10;    /**&#10;     * Lấy danh sách user cùng ngành&#10;     * Endpoint này được gọi từ post-service cho news feed algorithm&#10;     */&#10;    @GetMapping(&quot;/{userId}/same-major&quot;)&#10;    public ResponseEntity&lt;Set&lt;String&gt;&gt; getSameMajorUserIds(@PathVariable(&quot;userId&quot;) String userId) {&#10;        Set&lt;String&gt; sameMajorIds = userService.getSameMajorUserIds(userId);&#10;        return ResponseEntity.ok(sameMajorIds);&#10;    }&#10;&#10;    /**&#10;     * Lấy danh sách interest tags của user&#10;     * Endpoint này được gọi từ post-service cho content recommendation&#10;     */&#10;    @GetMapping(&quot;/{userId}/interest-tags&quot;)&#10;    public ResponseEntity&lt;Set&lt;String&gt;&gt; getUserInterestTags(@PathVariable(&quot;userId&quot;) String userId) {&#10;        Set&lt;String&gt; interestTags = userService.getUserInterestTags(userId);&#10;        return ResponseEntity.ok(interestTags);&#10;    }&#10;&#10;    /**&#10;     * Lấy danh sách preferred categories của user&#10;     * Endpoint này được gọi từ post-service cho content filtering&#10;     */&#10;    @GetMapping(&quot;/{userId}/preferred-categories&quot;)&#10;    public ResponseEntity&lt;Set&lt;String&gt;&gt; getUserPreferredCategories(@PathVariable(&quot;userId&quot;) String userId) {&#10;        Set&lt;String&gt; preferredCategories = userService.getUserPreferredCategories(userId);&#10;        return ResponseEntity.ok(preferredCategories);&#10;    }&#10;&#10;    /**&#10;     * Lấy faculty ID của user&#10;     * Endpoint này được gọi từ post-service cho group filtering&#10;     */&#10;    @GetMapping(&quot;/{userId}/faculty-id&quot;)&#10;    public ResponseEntity&lt;String&gt; getUserFacultyId(@PathVariable(&quot;userId&quot;) String userId) {&#10;        String facultyId = userService.getUserFacultyId(userId);&#10;        return ResponseEntity.ok(facultyId);&#10;    }&#10;&#10;    /**&#10;     * Lấy major ID của user&#10;     * Endpoint này được gọi từ post-service cho group filtering&#10;     */&#10;    @GetMapping(&quot;/{userId}/major-id&quot;)&#10;    public ResponseEntity&lt;String&gt; getUserMajorId(@PathVariable(&quot;userId&quot;) String userId) {&#10;        String majorId = userService.getUserMajorId(userId);&#10;        return ResponseEntity.ok(majorId);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.ctuconnect.controller;&#10;&#10;import com.ctuconnect.dto.AuthorDTO;&#10;import com.ctuconnect.dto.UserDTO;&#10;import com.ctuconnect.security.annotation.RequireAuth;&#10;import com.ctuconnect.service.UserSyncService;&#10;import com.ctuconnect.service.UserService;&#10;import org.springframework.beans.factory.annotation.Autowired;&#10;import org.springframework.http.ResponseEntity;&#10;import org.springframework.web.bind.annotation.*;&#10;&#10;import java.util.Set;&#10;&#10;/**&#10; * Controller để xử lý đồng bộ dữ liệu giữa auth-db và user-db&#10; * Các endpoint này được gọi từ auth-service hoặc các microservices khác&#10; */&#10;@RestController&#10;@RequestMapping(&quot;/api/users/sync&quot;)&#10;public class UserSyncController {&#10;&#10;    @Autowired&#10;    private UserSyncService userSyncService;&#10;&#10;    @Autowired&#10;    private UserService userService;&#10;&#10;    /**&#10;     * Tạo user profile trong user-db khi user được tạo ở auth-db&#10;     * Endpoint này được gọi từ auth-service&#10;     */&#10;    @PostMapping(&quot;/create&quot;)&#10;    @RequireAuth(roles = {&quot;SYSTEM&quot;, &quot;ADMIN&quot;}) // Chỉ system hoặc admin mới có thể gọi&#10;    public ResponseEntity&lt;UserDTO&gt; syncUserFromAuth(&#10;            @RequestParam String userId,&#10;            @RequestParam String email,&#10;            @RequestParam String role) {&#10;        UserDTO userDTO = userSyncService.syncUserFromAuth(userId, email, role);&#10;        return ResponseEntity.ok(userDTO);&#10;    }&#10;&#10;    /**&#10;     * Cập nhật thông tin user khi có thay đổi từ auth-db&#10;     */&#10;    @PutMapping(&quot;/update&quot;)&#10;    @RequireAuth(roles = {&quot;SYSTEM&quot;, &quot;ADMIN&quot;})&#10;    public ResponseEntity&lt;UserDTO&gt; updateUserFromAuth(&#10;            @RequestParam String userId,&#10;            @RequestParam String email,&#10;            @RequestParam String role) {&#10;        UserDTO userDTO = userSyncService.updateUserFromAuth(userId, email, role);&#10;        return ResponseEntity.ok(userDTO);&#10;    }&#10;&#10;    /**&#10;     * Xóa user khỏi user-db khi user bị xóa ở auth-db&#10;     */&#10;    @DeleteMapping(&quot;/delete&quot;)&#10;    @RequireAuth(roles = {&quot;SYSTEM&quot;, &quot;ADMIN&quot;})&#10;    public ResponseEntity&lt;String&gt; deleteUserFromAuth(@RequestParam String userId) {&#10;        userSyncService.deleteUserFromAuth(userId);&#10;        return ResponseEntity.ok(&quot;User deleted from user database successfully&quot;);&#10;    }&#10;&#10;    /**&#10;     * Kiểm tra tính nhất quán dữ liệu giữa auth-db và user-db&#10;     */&#10;    @GetMapping(&quot;/check&quot;)&#10;    @RequireAuth(roles = {&quot;SYSTEM&quot;, &quot;ADMIN&quot;})&#10;    public ResponseEntity&lt;Boolean&gt; checkUserSync(&#10;            @RequestParam String userId,&#10;            @RequestParam String email,&#10;            @RequestParam String role) {&#10;        boolean isSynced = userSyncService.isUserSynced(userId, email, role);&#10;        return ResponseEntity.ok(isSynced);&#10;    }&#10;&#10;    /**&#10;     * Lấy thông tin tác giả cho post-service&#10;     * Endpoint này được gọi từ post-service để lấy author info&#10;     * Không yêu cầu authentication vì đây là internal service call&#10;     */&#10;    @GetMapping(&quot;/authors/{id}&quot;)&#10;    public ResponseEntity&lt;AuthorDTO&gt; getAuthorInfo(@PathVariable(&quot;id&quot;) String authorId) {&#10;        AuthorDTO authorInfo = userSyncService.getAuthorInfo(authorId);&#10;        return ResponseEntity.ok(authorInfo);&#10;    }&#10;&#10;    /**&#10;     * Lấy danh sách ID bạn bè của user&#10;     * Endpoint này được gọi từ post-service cho news feed algorithm&#10;     * Không yêu cầu authentication vì đây là internal service call&#10;     */&#10;    @GetMapping(&quot;/{userId}/friends/ids&quot;)&#10;    public ResponseEntity&lt;Set&lt;String&gt;&gt; getFriendIds(@PathVariable(&quot;userId&quot;) String userId) {&#10;        Set&lt;String&gt; friendIds = userService.getFriendIds(userId);&#10;        return ResponseEntity.ok(friendIds);&#10;    }&#10;&#10;    /**&#10;     * Lấy danh sách user có tương tác gần với user&#10;     * Endpoint này được gọi từ post-service cho news feed algorithm&#10;     */&#10;    @GetMapping(&quot;/{userId}/close-interactions&quot;)&#10;    public ResponseEntity&lt;Set&lt;String&gt;&gt; getCloseInteractionIds(@PathVariable(&quot;userId&quot;) String userId) {&#10;        Set&lt;String&gt; closeInteractionIds = userService.getCloseInteractionIds(userId);&#10;        return ResponseEntity.ok(closeInteractionIds);&#10;    }&#10;&#10;    /**&#10;     * Lấy danh sách user cùng khoa&#10;     * Endpoint này được gọi từ post-service cho news feed algorithm&#10;     */&#10;    @GetMapping(&quot;/{userId}/same-faculty&quot;)&#10;    public ResponseEntity&lt;Set&lt;String&gt;&gt; getSameFacultyUserIds(@PathVariable(&quot;userId&quot;) String userId) {&#10;        Set&lt;String&gt; sameFacultyIds = userService.getSameFacultyUserIds(userId);&#10;        return ResponseEntity.ok(sameFacultyIds);&#10;    }&#10;&#10;    /**&#10;     * Lấy danh sách user cùng ngành&#10;     * Endpoint này được gọi từ post-service cho news feed algorithm&#10;     */&#10;    @GetMapping(&quot;/{userId}/same-major&quot;)&#10;    public ResponseEntity&lt;Set&lt;String&gt;&gt; getSameMajorUserIds(@PathVariable(&quot;userId&quot;) String userId) {&#10;        Set&lt;String&gt; sameMajorIds = userService.getSameMajorUserIds(userId);&#10;        return ResponseEntity.ok(sameMajorIds);&#10;    }&#10;&#10;    /**&#10;     * Lấy danh sách interest tags của user&#10;     * Endpoint này được gọi từ post-service cho content recommendation&#10;     */&#10;    @GetMapping(&quot;/{userId}/interest-tags&quot;)&#10;    public ResponseEntity&lt;Set&lt;String&gt;&gt; getUserInterestTags(@PathVariable(&quot;userId&quot;) String userId) {&#10;        Set&lt;String&gt; interestTags = userService.getUserInterestTags(userId);&#10;        return ResponseEntity.ok(interestTags);&#10;    }&#10;&#10;    /**&#10;     * Lấy danh sách preferred categories của user&#10;     * Endpoint này được gọi từ post-service cho content filtering&#10;     */&#10;    @GetMapping(&quot;/{userId}/preferred-categories&quot;)&#10;    public ResponseEntity&lt;Set&lt;String&gt;&gt; getUserPreferredCategories(@PathVariable(&quot;userId&quot;) String userId) {&#10;        Set&lt;String&gt; preferredCategories = userService.getUserPreferredCategories(userId);&#10;        return ResponseEntity.ok(preferredCategories);&#10;    }&#10;&#10;    /**&#10;     * Lấy faculty ID của user&#10;     * Endpoint này được gọi từ post-service cho group filtering&#10;     */&#10;    @GetMapping(&quot;/{userId}/faculty-id&quot;)&#10;    public ResponseEntity&lt;String&gt; getUserFacultyId(@PathVariable(&quot;userId&quot;) String userId) {&#10;        String facultyId = userService.getUserFacultyId(userId);&#10;        return ResponseEntity.ok(facultyId);&#10;    }&#10;&#10;    /**&#10;     * Lấy major ID của user&#10;     * Endpoint này được gọi từ post-service cho group filtering&#10;     */&#10;    @GetMapping(&quot;/{userId}/major-id&quot;)&#10;    public ResponseEntity&lt;String&gt; getUserMajorId(@PathVariable(&quot;userId&quot;) String userId) {&#10;        String majorId = userService.getUserMajorId(userId);&#10;        return ResponseEntity.ok(majorId);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/user-service/src/main/java/com/ctuconnect/dto/ActivityDTO.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/user-service/src/main/java/com/ctuconnect/dto/ActivityDTO.java" />
              <option name="originalContent" value="package com.ctuconnect.dto;&#10;&#10;import lombok.AllArgsConstructor;&#10;import lombok.Builder;&#10;import lombok.Data;&#10;import lombok.NoArgsConstructor;&#10;&#10;import java.time.LocalDateTime;&#10;&#10;@Data&#10;@Builder&#10;@NoArgsConstructor&#10;@AllArgsConstructor&#10;public class ActivityDTO {&#10;    private String id;&#10;    private String userId;&#10;    private String activityType; // POST_CREATED, POST_LIKED, COMMENT_ADDED, etc.&#10;    private String targetType; // POST, COMMENT, USER&#10;    private String targetId;&#10;    private String actorName;&#10;    private String actorAvatarUrl;&#10;&#10;    // For activity feed display&#10;    private String displayText;&#10;    private String actionUrl;&#10;    private boolean isRead;&#10;&#10;    public enum ActivityType {&#10;        POST_CREATED,&#10;        POST_LIKED,&#10;        POST_SHARED,&#10;        COMMENT_ADDED,&#10;        FRIEND_REQUEST_SENT,&#10;        FRIEND_REQUEST_ACCEPTED,&#10;        PROFILE_UPDATED&#10;    }&#10;&#10;    public enum TargetType {&#10;        POST,&#10;        COMMENT,&#10;        USER,&#10;        PROFILE&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.ctuconnect.dto;&#10;&#10;import lombok.AllArgsConstructor;&#10;import lombok.Builder;&#10;import lombok.Data;&#10;import lombok.NoArgsConstructor;&#10;&#10;import java.time.LocalDateTime;&#10;&#10;@Data&#10;@Builder&#10;@NoArgsConstructor&#10;@AllArgsConstructor&#10;public class ActivityDTO {&#10;    private String id;&#10;    private String userId;&#10;    private String activityType; // POST_CREATED, POST_LIKED, COMMENT_ADDED, etc.&#10;    private String targetType; // POST, COMMENT, USER&#10;    private String targetId;&#10;    private String entityType; // Add missing entityType field&#10;    private String entityId; // Add missing entityId field&#10;    private String description;&#10;    private LocalDateTime timestamp;&#10;    private String actorName;&#10;    private String actorAvatarUrl;&#10;&#10;    // For activity feed display&#10;    private String displayText;&#10;    private String actionUrl;&#10;    private boolean isRead;&#10;&#10;    public enum ActivityType {&#10;        POST_CREATED,&#10;        POST_LIKED,&#10;        POST_SHARED,&#10;        COMMENT_ADDED,&#10;        FRIEND_REQUEST_SENT,&#10;        FRIEND_REQUEST_ACCEPTED,&#10;        PROFILE_UPDATED&#10;    }&#10;&#10;    public enum TargetType {&#10;        POST,&#10;        COMMENT,&#10;        USER,&#10;        PROFILE&#10;    }&#10;&#10;    public enum EntityType {&#10;        POST,&#10;        COMMENT,&#10;        USER,&#10;        PROFILE&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/user-service/src/main/java/com/ctuconnect/event/UserEventPublisher.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/user-service/src/main/java/com/ctuconnect/event/UserEventPublisher.java" />
              <option name="updatedContent" value="package com.ctuconnect.event;&#10;&#10;import org.springframework.beans.factory.annotation.Autowired;&#10;import org.springframework.kafka.core.KafkaTemplate;&#10;import org.springframework.stereotype.Service;&#10;import com.fasterxml.jackson.databind.ObjectMapper;&#10;import lombok.extern.slf4j.Slf4j;&#10;&#10;import java.util.HashMap;&#10;import java.util.Map;&#10;&#10;/**&#10; * Service to publish user profile update events to Kafka&#10; * This notifies other services (like post-service) when user profiles are updated&#10; */&#10;@Service&#10;@Slf4j&#10;public class UserEventPublisher {&#10;&#10;    @Autowired&#10;    private KafkaTemplate&lt;String, String&gt; kafkaTemplate;&#10;&#10;    @Autowired&#10;    private ObjectMapper objectMapper;&#10;&#10;    private static final String USER_PROFILE_UPDATED_TOPIC = &quot;user-profile-updated&quot;;&#10;&#10;    /**&#10;     * Publish user profile update event&#10;     */&#10;    public void publishUserProfileUpdateEvent(String userId, String fullName, String email, String avatarUrl, String role) {&#10;        try {&#10;            Map&lt;String, Object&gt; eventData = new HashMap&lt;&gt;();&#10;            eventData.put(&quot;userId&quot;, userId);&#10;            eventData.put(&quot;fullName&quot;, fullName);&#10;            eventData.put(&quot;email&quot;, email);&#10;            eventData.put(&quot;avatarUrl&quot;, avatarUrl);&#10;            eventData.put(&quot;role&quot;, role);&#10;            eventData.put(&quot;eventType&quot;, &quot;USER_PROFILE_UPDATED&quot;);&#10;            eventData.put(&quot;timestamp&quot;, System.currentTimeMillis());&#10;&#10;            String eventMessage = objectMapper.writeValueAsString(eventData);&#10;            &#10;            kafkaTemplate.send(USER_PROFILE_UPDATED_TOPIC, userId, eventMessage);&#10;            log.info(&quot;Published user profile update event for user: {}&quot;, userId);&#10;            &#10;        } catch (Exception e) {&#10;            log.error(&quot;Failed to publish user profile update event for user {}: {}&quot;, userId, e.getMessage(), e);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Publish user profile update event with user entity data&#10;     */&#10;    public void publishUserProfileUpdateEvent(String userId, Map&lt;String, Object&gt; userData) {&#10;        try {&#10;            Map&lt;String, Object&gt; eventData = new HashMap&lt;&gt;();&#10;            eventData.put(&quot;userId&quot;, userId);&#10;            eventData.put(&quot;userData&quot;, userData);&#10;            eventData.put(&quot;eventType&quot;, &quot;USER_PROFILE_UPDATED&quot;);&#10;            eventData.put(&quot;timestamp&quot;, System.currentTimeMillis());&#10;&#10;            String eventMessage = objectMapper.writeValueAsString(eventData);&#10;            &#10;            kafkaTemplate.send(USER_PROFILE_UPDATED_TOPIC, userId, eventMessage);&#10;            log.info(&quot;Published user profile update event for user: {}&quot;, userId);&#10;            &#10;        } catch (Exception e) {&#10;            log.error(&quot;Failed to publish user profile update event for user {}: {}&quot;, userId, e.getMessage(), e);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>