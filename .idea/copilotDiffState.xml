<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/ARCHITECTURE_OPTIMIZATION.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ARCHITECTURE_OPTIMIZATION.md" />
              <option name="originalContent" value="# CTU-Connect Architecture Optimization Plan&#10;## Based on Facebook's Social Network Model&#10;&#10;### Current Architecture Analysis&#10;- ✅ Microservices architecture with proper service separation&#10;- ✅ Event-driven communication via Kafka&#10;- ✅ Multiple database technologies (PostgreSQL, MongoDB, Neo4j, Redis)&#10;- ✅ API Gateway for centralized routing&#10;- ✅ Service discovery with Eureka&#10;&#10;### Key Optimizations Required&#10;- Implement eventual consistency patterns&#10;#### 1. Data Consistency &amp; Flow Optimization&#10;- Implement eventual consistency patterns&#10;- Add distributed transaction management&#10;- Optimize cross-service data synchronization&#10;&#10;#### 3. Social Graph Optimization&#10;- Friend suggestion algorithms&#10;#### 2. Enhanced Post System (Facebook-like)&#10;- Timeline generation algorithms&#10;- News feed ranking and personalization&#10;- Real-time updates and notifications&#10;- Database optimization and indexing&#10;- Load balancing and horizontal scaling&#10;&#10;#### 5. Real-time Features&#10;#### 3. Social Graph Optimization&#10;- Friend suggestion algorithms&#10;- Privacy controls and audience targeting&#10;- Activity feed generation&#10;- Real-time chat and comments&#10;- Activity status tracking&#10;#### 4. Performance &amp; Scalability&#10;- Caching strategies at multiple levels&#10;#### 5. Real-time Features&#10;- Live notifications&#10;- Real-time chat and comments&#10;- Activity status tracking&#10;" />
              <option name="updatedContent" value="# CTU-Connect Architecture Optimization Plan&#10;## Based on Facebook's Social Network Model&#10;&#10;### Current Architecture Analysis&#10;- ✅ Microservices architecture with proper service separation&#10;- ✅ Event-driven communication via Kafka&#10;- ✅ Multiple database technologies (PostgreSQL, MongoDB, Neo4j, Redis)&#10;- ✅ API Gateway for centralized routing&#10;- ✅ Service discovery with Eureka&#10;&#10;## COMPLETED OPTIMIZATIONS&#10;&#10;### 1. Enhanced Data Models (Facebook-like)&#10;&#10;#### Enhanced PostEntity&#10;- **Audience Targeting**: Similar to Facebook's privacy controls with granular audience settings&#10;- **Engagement Metrics**: Real-time engagement scoring for feed ranking algorithms&#10;- **Post Types**: Support for TEXT, IMAGE, VIDEO, LINK, POLL, EVENT, SHARED&#10;- **Location Support**: Geographic tagging capabilities&#10;- **Scheduled Posts**: Ability to schedule posts for future publishing&#10;- **Edit History**: Track post modifications with timestamps&#10;&#10;#### Advanced Social Graph (Neo4j)&#10;- **Friend Suggestions**: Multi-signal algorithm using mutual friends, academic connections, profile viewers&#10;- **Relationship Types**: FRIENDS_WITH, FRIEND_REQUEST_SENT, VIEWED_PROFILE, BLOCKED&#10;- **Academic Context**: Faculty, major, and batch-based connections&#10;- **Interaction History**: Track user interactions for personalization&#10;&#10;### 2. Facebook-like News Feed Algorithm&#10;&#10;#### NewsFeedService Implementation&#10;- **Personalized Ranking**: Multi-factor scoring system&#10;  - Friend relationship weight (1.0)&#10;  - Engagement score weight (0.8)&#10;  - Recency weight (0.6)&#10;  - Content relevance weight (0.7)&#10;- **Cache Strategy**: 30-minute feed cache with intelligent invalidation&#10;- **Over-fetching**: Retrieve 3x posts for optimal ranking&#10;- **Diversity Control**: Prevent feed domination by single authors&#10;&#10;#### Feed Types&#10;- **Personalized Feed**: User-specific content based on social graph&#10;- **Trending Posts**: Engagement-based trending algorithm&#10;- **User Timeline**: Profile-specific post timeline with privacy filtering&#10;&#10;### 3. Real-time Notification System&#10;&#10;#### NotificationService Features&#10;- **Real-time WebSocket**: Instant notifications via SimpMessagingTemplate&#10;- **Event-driven**: Kafka integration for scalable notification processing&#10;- **Notification Types**: POST_LIKED, COMMENTED, SHARED, FRIEND_REQUEST, etc.&#10;- **Bulk Notifications**: Efficient handling of viral content notifications&#10;- **Unread Counters**: Redis-cached unread notification counts&#10;&#10;### 4. Data Consistency Management&#10;&#10;#### DataConsistencyService&#10;- **Eventual Consistency**: Cross-service data synchronization&#10;- **Cache Invalidation**: Smart cache invalidation on data changes&#10;- **Compensation Logic**: Failure handling and retry mechanisms&#10;- **Event Sourcing**: Kafka-based event propagation&#10;&#10;### 5. Advanced Caching Strategy&#10;&#10;#### Multi-level Caching&#10;- **Redis Caching**: &#10;  - User data (24 hours TTL)&#10;  - Posts (6 hours TTL)&#10;  - Friend suggestions (6 hours TTL)&#10;  - News feed (30 minutes TTL)&#10;- **Application-level**: In-memory caching for frequently accessed data&#10;- **Database-level**: Optimized queries and indexing&#10;&#10;### 6. Social Graph Optimization&#10;&#10;#### SocialGraphService Features&#10;- **Friend Suggestions Algorithm**:&#10;  - Mutual friends (highest priority)&#10;  - Academic connections (faculty/major/batch)&#10;  - Friends of friends&#10;  - Profile viewers&#10;  - Similar interests&#10;- **Relevance Scoring**: Multi-factor relevance calculation&#10;- **Cache Management**: 6-hour TTL with smart invalidation&#10;&#10;### 7. Performance Enhancements&#10;&#10;#### Database Optimizations&#10;- **MongoDB**: Compound indexes for posts, engagement-based sorting&#10;- **Neo4j**: Optimized Cypher queries for relationship traversal&#10;- **PostgreSQL**: Proper indexing for auth and media services&#10;- **Redis**: Strategic caching and session management&#10;&#10;#### API Optimizations&#10;- **Pagination**: Consistent pagination across all endpoints&#10;- **Bulk Operations**: Efficient batch processing for notifications&#10;- **Async Processing**: CompletableFuture for non-blocking operations&#10;&#10;### 8. Enhanced Security &amp; Privacy&#10;&#10;#### Privacy Controls&#10;- **Audience Settings**: PUBLIC, FRIENDS, CUSTOM, ONLY_ME&#10;- **Academic Targeting**: Faculty/major/batch-specific visibility&#10;- **Block Lists**: User blocking functionality&#10;- **Profile Privacy**: Granular profile visibility controls&#10;&#10;### 9. Real-time Features&#10;&#10;#### WebSocket Integration&#10;- **Live Notifications**: Real-time notification delivery&#10;- **Activity Status**: User online/offline status tracking&#10;- **Real-time Comments**: Live comment updates on posts&#10;&#10;### 10. Monitoring &amp; Health Checks&#10;&#10;#### System Monitoring&#10;- **Health Indicators**: Redis, MongoDB, Neo4j health checks&#10;- **Performance Metrics**: Engagement rates, cache hit ratios&#10;- **Error Tracking**: Comprehensive logging and error handling&#10;&#10;## IMPLEMENTATION SUMMARY&#10;&#10;### New Services Created&#10;1. **NewsFeedService** - Facebook-like feed generation&#10;2. **NotificationService** - Real-time notification system&#10;3. **SocialGraphService** - Advanced friend suggestions&#10;4. **DataConsistencyService** - Cross-service data synchronization&#10;&#10;### Enhanced Controllers&#10;1. **EnhancedPostController** - Advanced post management&#10;2. **EnhancedUserController** - Social graph operations&#10;&#10;### Data Models Enhanced&#10;- **PostEntity** - Facebook-like post features&#10;- **NotificationEntity** - Rich notification system&#10;- **FriendSuggestionDTO** - Comprehensive suggestion data&#10;&#10;### Configuration Added&#10;- **CacheConfig** - Multi-level caching strategy&#10;- **HealthCheckConfig** - System health monitoring&#10;&#10;## FACEBOOK-INSPIRED FEATURES IMPLEMENTED&#10;&#10;### Content &amp; Engagement&#10;✅ **News Feed Algorithm** - Personalized content ranking&#10;✅ **Post Types** - Text, image, video, link, poll support&#10;✅ **Reactions System** - Like, love, laugh, etc.&#10;✅ **Comments &amp; Replies** - Threaded comment system&#10;✅ **Share Functionality** - Post sharing with attribution&#10;✅ **Trending Posts** - Viral content discovery&#10;&#10;### Social Features&#10;✅ **Friend Suggestions** - Multi-signal recommendation engine&#10;✅ **Mutual Friends** - Connection discovery&#10;✅ **Academic Networks** - University-specific connections&#10;✅ **People You May Know** - Profile viewer suggestions&#10;✅ **Friend Requests** - Connection management&#10;&#10;### Privacy &amp; Security&#10;✅ **Audience Controls** - Granular post visibility&#10;✅ **Academic Targeting** - Faculty/major-based sharing&#10;✅ **Block/Unblock** - User blocking system&#10;✅ **Profile Privacy** - Customizable profile visibility&#10;&#10;### Real-time Features&#10;✅ **Live Notifications** - Instant activity updates  &#10;✅ **Real-time Comments** - Live comment updates&#10;✅ **Activity Status** - Online presence tracking&#10;✅ **WebSocket Integration** - Real-time communication&#10;&#10;### Performance &amp; Scale&#10;✅ **Multi-level Caching** - Redis + application caching&#10;✅ **Event-driven Architecture** - Kafka message streaming&#10;✅ **Database Optimization** - Proper indexing and queries&#10;✅ **Load Balancing Ready** - Horizontal scaling support&#10;&#10;## DEPLOYMENT RECOMMENDATIONS&#10;&#10;### 1. Database Scaling&#10;- **MongoDB Sharding** for post data&#10;- **Neo4j Clustering** for social graph&#10;- **Redis Clustering** for caching layer&#10;&#10;### 2. Performance Monitoring&#10;- Implement APM tools (New Relic, DataDog)&#10;- Set up alerts for cache hit ratios&#10;- Monitor database query performance&#10;&#10;### 3. Content Delivery&#10;- Integrate CDN for media files&#10;- Implement image/video optimization&#10;- Add progressive loading for feeds&#10;&#10;### 4. Security Enhancements&#10;- Rate limiting on API endpoints&#10;- Content moderation system&#10;- Spam detection algorithms&#10;&#10;This comprehensive optimization transforms your CTU-Connect platform into a robust, scalable social network with Facebook-like capabilities while maintaining the academic focus of your original vision." />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/client-frontend/src/app/posts/page.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/client-frontend/src/app/posts/page.tsx" />
              <option name="updatedContent" value="'use client';&#10;&#10;import React, { useState, useEffect } from 'react';&#10;import { Post, PaginatedResponse } from '@/types';&#10;import { postService } from '@/services/postService';&#10;import { CreatePost } from '@/components/post/CreatePost';&#10;import { PostCard } from '@/components/post/PostCard';&#10;import { LoadingSpinner } from '@/components/ui/LoadingSpinner';&#10;import { ErrorAlert } from '@/components/ui/ErrorAlert';&#10;import { Button } from '@/components/ui/Button';&#10;import { Plus, RefreshCw } from 'lucide-react';&#10;&#10;export default function PostsPage() {&#10;  const [posts, setPosts] = useState&lt;Post[]&gt;([]);&#10;  const [isLoading, setIsLoading] = useState(true);&#10;  const [error, setError] = useState&lt;string | null&gt;(null);&#10;  const [showCreatePost, setShowCreatePost] = useState(false);&#10;&#10;  const loadPosts = async () =&gt; {&#10;    try {&#10;      setIsLoading(true);&#10;      setError(null);&#10;      const response: PaginatedResponse&lt;Post&gt; = await postService.getPosts();&#10;      setPosts(response.content);&#10;    } catch (err: any) {&#10;      console.error('Failed to load posts:', err);&#10;      setError(err.response?.data?.message || err.message || 'Failed to load posts');&#10;    } finally {&#10;      setIsLoading(false);&#10;    }&#10;  };&#10;&#10;  useEffect(() =&gt; {&#10;    loadPosts();&#10;  }, []);&#10;&#10;  const handlePostCreated = (newPost: Post) =&gt; {&#10;    setPosts(prev =&gt; [newPost, ...prev]);&#10;    setShowCreatePost(false);&#10;  };&#10;&#10;  const handlePostUpdate = (updatedPost: Post) =&gt; {&#10;    setPosts(prev =&gt; prev.map(post =&gt; &#10;      post.id === updatedPost.id ? updatedPost : post&#10;    ));&#10;  };&#10;&#10;  const handlePostDelete = (postId: string) =&gt; {&#10;    setPosts(prev =&gt; prev.filter(post =&gt; post.id !== postId));&#10;  };&#10;&#10;  if (isLoading) {&#10;    return (&#10;      &lt;div className=&quot;min-h-screen bg-gray-50 flex items-center justify-center&quot;&gt;&#10;        &lt;LoadingSpinner size=&quot;lg&quot; /&gt;&#10;      &lt;/div&gt;&#10;    );&#10;  }&#10;&#10;  return (&#10;    &lt;div className=&quot;min-h-screen bg-gray-50&quot;&gt;&#10;      &lt;div className=&quot;max-w-2xl mx-auto py-8 px-4&quot;&gt;&#10;        {/* Header */}&#10;        &lt;div className=&quot;flex items-center justify-between mb-6&quot;&gt;&#10;          &lt;h1 className=&quot;text-2xl font-bold text-gray-900&quot;&gt;Posts&lt;/h1&gt;&#10;          &lt;div className=&quot;flex gap-2&quot;&gt;&#10;            &lt;Button&#10;              variant=&quot;secondary&quot;&#10;              onClick={loadPosts}&#10;              disabled={isLoading}&#10;              className=&quot;flex items-center gap-2&quot;&#10;            &gt;&#10;              &lt;RefreshCw className={`w-4 h-4 ${isLoading ? 'animate-spin' : ''}`} /&gt;&#10;              Refresh&#10;            &lt;/Button&gt;&#10;            &lt;Button&#10;              onClick={() =&gt; setShowCreatePost(true)}&#10;              className=&quot;flex items-center gap-2&quot;&#10;            &gt;&#10;              &lt;Plus className=&quot;w-4 h-4&quot; /&gt;&#10;              Create Post&#10;            &lt;/Button&gt;&#10;          &lt;/div&gt;&#10;        &lt;/div&gt;&#10;&#10;        {/* Create Post Form */}&#10;        {showCreatePost &amp;&amp; (&#10;          &lt;div className=&quot;mb-6&quot;&gt;&#10;            &lt;CreatePost&#10;              onPostCreated={handlePostCreated}&#10;              onCancel={() =&gt; setShowCreatePost(false)}&#10;            /&gt;&#10;          &lt;/div&gt;&#10;        )}&#10;&#10;        {/* Error Display */}&#10;        {error &amp;&amp; (&#10;          &lt;div className=&quot;mb-6&quot;&gt;&#10;            &lt;ErrorAlert message={error} /&gt;&#10;          &lt;/div&gt;&#10;        )}&#10;&#10;        {/* Posts List */}&#10;        {posts.length === 0 ? (&#10;          &lt;div className=&quot;text-center py-12&quot;&gt;&#10;            &lt;div className=&quot;text-gray-400 mb-4&quot;&gt;&#10;              &lt;Plus className=&quot;w-16 h-16 mx-auto&quot; /&gt;&#10;            &lt;/div&gt;&#10;            &lt;h3 className=&quot;text-lg font-medium text-gray-900 mb-2&quot;&gt;No posts yet&lt;/h3&gt;&#10;            &lt;p className=&quot;text-gray-500 mb-4&quot;&gt;Be the first to create a post!&lt;/p&gt;&#10;            &lt;Button onClick={() =&gt; setShowCreatePost(true)}&gt;&#10;              Create First Post&#10;            &lt;/Button&gt;&#10;          &lt;/div&gt;&#10;        ) : (&#10;          &lt;div className=&quot;space-y-6&quot;&gt;&#10;            {posts.map((post) =&gt; (&#10;              &lt;PostCard&#10;                key={post.id}&#10;                post={post}&#10;                onPostUpdate={handlePostUpdate}&#10;                onPostDelete={handlePostDelete}&#10;              /&gt;&#10;            ))}&#10;          &lt;/div&gt;&#10;        )}&#10;      &lt;/div&gt;&#10;    &lt;/div&gt;&#10;  );&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/client-frontend/src/components/post/PostFeed.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/client-frontend/src/components/post/PostFeed.tsx" />
              <option name="originalContent" value="'use client';&#10;&#10;import React, { useState, useEffect, useCallback } from 'react';&#10;import { Post, PaginatedResponse } from '@/types';&#10;import { postService } from '@/services/postService';&#10;import { PostCard } from './PostCard';&#10;import { CreatePost } from './CreatePost';&#10;import { LoadingSpinner } from '@/components/ui/LoadingSpinner';&#10;import { ErrorAlert } from '@/components/ui/ErrorAlert';&#10;import { Button } from '@/components/ui/Button';&#10;import { RefreshCw, Plus, TrendingUp, Heart, Filter } from 'lucide-react';&#10;&#10;interface PostFeedProps {&#10;  authorId?: string;&#10;  authorName?: string;&#10;  category?: string;&#10;  search?: string;&#10;  className?: string;&#10;}&#10;&#10;export const PostFeed: React.FC&lt;PostFeedProps&gt; = ({&#10;                                                    authorId,&#10;                                                    authorName,&#10;                                                    category,&#10;                                                    search,&#10;                                                    className = ''&#10;                                                  }) =&gt; {&#10;  const [posts, setPosts] = useState&lt;Post[]&gt;([]);&#10;  const [isLoading, setIsLoading] = useState(true);&#10;  const [isLoadingMore, setIsLoadingMore] = useState(false);&#10;  const [error, setError] = useState&lt;string | null&gt;(null);&#10;  const [hasMore, setHasMore] = useState(true);&#10;  const [currentPage, setCurrentPage] = useState(0);&#10;  const [showCreatePost, setShowCreatePost] = useState(false);&#10;  const [activeTab, setActiveTab] = useState&lt;'latest' | 'trending' | 'top-liked'&gt;('latest');&#10;&#10;  const loadPosts = useCallback(&#10;      async (page = 0, append = false) =&gt; {&#10;        try {&#10;          if (!append) {&#10;            setIsLoading(true);&#10;            setError(null);&#10;          } else {&#10;            setIsLoadingMore(true);&#10;          }&#10;&#10;          let response: PaginatedResponse&lt;Post&gt;;&#10;&#10;          if (activeTab === 'trending') {&#10;            const trendingPosts = await postService.getTopViewedPosts();&#10;            response = {&#10;              content: trendingPosts,&#10;              totalElements: trendingPosts.length,&#10;              totalPages: 1,&#10;              size: trendingPosts.length,&#10;              number: 0,&#10;              first: true,&#10;              last: true,&#10;            };&#10;          } else if (activeTab === 'top-liked') {&#10;            const topLikedPosts = await postService.getTopLikedPosts();&#10;            response = {&#10;              content: topLikedPosts,&#10;              totalElements: topLikedPosts.length,&#10;              totalPages: 1,&#10;              size: topLikedPosts.length,&#10;              number: 0,&#10;              first: true,&#10;              last: true,&#10;            };&#10;          } else {&#10;            response = await postService.getPosts(&#10;                page,&#10;                10,&#10;                'createdAt',&#10;                'desc',&#10;                authorId,&#10;                category,&#10;                search&#10;            );&#10;          }&#10;&#10;          if (append) {&#10;            setPosts((prev) =&gt; [...prev, ...response.content]);&#10;          } else {&#10;            setPosts(response.content);&#10;          }&#10;&#10;          setHasMore(!response.last &amp;&amp; response.content.length &gt; 0);&#10;          setCurrentPage(response.number);&#10;        } catch (err: any) {&#10;          setError(err.response?.data?.message || 'Failed to load posts');&#10;        } finally {&#10;          setIsLoading(false);&#10;          setIsLoadingMore(false);&#10;        }&#10;      },&#10;      [activeTab, authorId, category, search]&#10;  );&#10;&#10;  useEffect(() =&gt; {&#10;    loadPosts(0, false);&#10;  }, [loadPosts]);&#10;&#10;  const handleLoadMore = () =&gt; {&#10;    if (hasMore &amp;&amp; !isLoadingMore) {&#10;      loadPosts(currentPage + 1, true);&#10;    }&#10;  };&#10;&#10;  const handleRefresh = () =&gt; {&#10;    setCurrentPage(0);&#10;    loadPosts(0, false);&#10;  };&#10;&#10;  const handleTabChange = (tab: 'latest' | 'trending' | 'top-liked') =&gt; {&#10;    if (tab !== activeTab) {&#10;      setActiveTab(tab);&#10;      setCurrentPage(0);&#10;      setPosts([]);&#10;    }&#10;  };&#10;&#10;  const handlePostCreated = (newPost: Post) =&gt; {&#10;    setPosts((prev) =&gt; [newPost, ...prev]);&#10;    setShowCreatePost(false);&#10;  };&#10;&#10;  const handlePostUpdate = (updatedPost: Post) =&gt; {&#10;    setPosts((prev) =&gt; prev.map((p) =&gt; (p.id === updatedPost.id ? updatedPost : p)));&#10;  };&#10;&#10;  const handlePostDelete = (postId: string) =&gt; {&#10;    setPosts((prev) =&gt; prev.filter((p) =&gt; p.id !== postId));&#10;  };&#10;&#10;  const tabs = [&#10;    { key: 'latest', label: 'Mới nhất', icon: RefreshCw },&#10;    { key: 'trending', label: 'Thịnh hành', icon: TrendingUp },&#10;    { key: 'top-liked', label: 'Yêu thích', icon: Heart }&#10;  ];&#10;&#10;  if (isLoading &amp;&amp; posts.length === 0) {&#10;    return (&#10;        &lt;main className=&quot;flex justify-center items-center min-h-[16rem]&quot;&gt;&#10;          &lt;LoadingSpinner size=&quot;lg&quot; /&gt;&#10;        &lt;/main&gt;&#10;    );&#10;  }&#10;&#10;  return (&#10;      &lt;main className={`space-y-6 ${className}`}&gt;&#10;        {/* Header */}&#10;        &lt;header className=&quot;bg-white rounded-xl shadow-md border border-gray-200 overflow-hidden&quot;&gt;&#10;          {/* Hero top banner */}&#10;          &lt;div className=&quot;bg-gradient-to-r from-indigo-600 to-purple-700 px-6 py-5 flex flex-col sm:flex-row sm:justify-between sm:items-center gap-3 sm:gap-0&quot;&gt;&#10;            &lt;div&gt;&#10;              &lt;h1 className=&quot;text-white text-2xl font-extrabold tracking-tight&quot;&gt;&#10;                Bảng tin CTU Connect&#10;              &lt;/h1&gt;&#10;              &lt;p className=&quot;mt-1 text-indigo-200 text-sm max-w-md&quot;&gt;&#10;                Khám phá, chia sẻ những điều thú vị với cộng đồng CTU&#10;              &lt;/p&gt;&#10;            &lt;/div&gt;&#10;&#10;              &lt;Button&#10;                  onClick={() =&gt; setShowCreatePost((v) =&gt; !v)}&#10;                  aria-expanded={showCreatePost}&#10;                  aria-controls=&quot;create-post-form&quot;&#10;                  variant=&quot;especially&quot;&#10;                  size=&quot;sm&quot;&#10;              &gt;&#10;                &lt;Plus className={`w-5 h-5 ${showCreatePost ? 'rotate-45' : ''}`} /&gt;&#10;                &lt;span&gt;{showCreatePost ? 'Hủy bài viết' : 'Tạo bài viết'}&lt;/span&gt;&#10;              &lt;/Button&gt;&#10;            &lt;/div&gt;&#10;&#10;&#10;          {/* Tabs + Control */}&#10;          &lt;div className=&quot;px-6 py-4 border-t border-gray-100 flex flex-col md:flex-row md:items-center md:justify-between gap-4&quot;&gt;&#10;            {/* Tabs */}&#10;            &lt;nav aria-label=&quot;Bộ lọc bài viết&quot; className=&quot;flex flex-wrap gap-3&quot;&gt;&#10;              {tabs.map(({ key, label, icon: Icon }) =&gt; {&#10;                const isActive = activeTab === key;&#10;                return (&#10;                    &lt;button&#10;                        key={key}&#10;                        type=&quot;button&quot;&#10;                        aria-current={isActive ? 'page' : undefined}&#10;                        onClick={() =&gt; handleTabChange(key as any)}&#10;                        className={`flex items-center gap-2 px-4 py-2 rounded-lg font-semibold text-sm transition-all duration-200&#10;                    ${&#10;                            isActive&#10;                                ? 'bg-indigo-100 text-indigo-700 shadow-sm border border-indigo-300'&#10;                                : 'text-gray-600 hover:bg-gray-50 hover:text-indigo-600 border border-transparent'&#10;                        }&#10;                  `}&#10;                        title={label}&#10;                    &gt;&#10;                      &lt;Icon&#10;                          className={`w-5 h-5 transition-transform ${&#10;                              isActive ? 'text-indigo-600' : 'text-gray-400 group-hover:text-indigo-600'&#10;                          }`}&#10;                          aria-hidden=&quot;true&quot;&#10;                      /&gt;&#10;                      &lt;span&gt;{label}&lt;/span&gt;&#10;                    &lt;/button&gt;&#10;                );&#10;              })}&#10;            &lt;/nav&gt;&#10;&#10;            {/* Filter info + Refresh */}&#10;            &lt;div className=&quot;flex flex-wrap gap-3 items-center&quot;&gt;&#10;              {(search || category || authorId) &amp;&amp; (&#10;                  &lt;div className=&quot;flex items-center gap-2 bg-indigo-50 text-indigo-700 px-3 py-1 rounded-lg text-xs&quot;&gt;&#10;                    &lt;Filter className=&quot;w-4 h-4&quot; /&gt;&#10;                    &lt;span&gt;&#10;                  Đang lọc:&#10;                      {search &amp;&amp; ` &quot;${search}&quot;`}&#10;                      {category &amp;&amp; ` ${category}`}&#10;                      {authorId &amp;&amp; ` ${authorName ?? authorId}`}&#10;                &lt;/span&gt;&#10;                  &lt;/div&gt;&#10;              )}&#10;&#10;              &lt;Button&#10;                  variant=&quot;outline&quot;&#10;                  size=&quot;sm&quot;&#10;                  onClick={handleRefresh}&#10;                  disabled={isLoading || isLoadingMore}&#10;                  aria-label=&quot;Làm mới danh sách bài viết&quot;&#10;                  className=&quot;flex items-center gap-2&quot;&#10;              &gt;&#10;                &lt;RefreshCw&#10;                    className={`w-4 h-4 transition-transform ${isLoading ? 'animate-spin' : 'hover:rotate-180'}`}&#10;                    aria-hidden=&quot;true&quot;&#10;                /&gt;&#10;                &lt;span className=&quot;hidden sm:inline&quot;&gt;Làm mới&lt;/span&gt;&#10;              &lt;/Button&gt;&#10;            &lt;/div&gt;&#10;          &lt;/div&gt;&#10;        &lt;/header&gt;&#10;&#10;        {/* Form tạo bài viết */}&#10;        {showCreatePost &amp;&amp; (&#10;            &lt;section&#10;                id=&quot;create-post-form&quot;&#10;                aria-label=&quot;Tạo bài viết mới&quot;&#10;                className=&quot;animate-slide-up&quot;&#10;            &gt;&#10;              &lt;CreatePost onPostCreated={handlePostCreated} onCancel={() =&gt; setShowCreatePost(false)} /&gt;&#10;            &lt;/section&gt;&#10;        )}&#10;&#10;        {/* Error */}&#10;        {error &amp;&amp; &lt;ErrorAlert message={error} onClose={() =&gt; setError(null)} /&gt;}&#10;&#10;        {/* Enhanced Post List - Full Width */}&#10;        &lt;section&#10;            aria-live=&quot;polite&quot;&#10;            aria-busy={isLoading}&#10;            className=&quot;space-y-6&quot;&#10;            aria-label=&quot;Danh sách bài viết&quot;&#10;        &gt;&#10;          {!isLoading &amp;&amp; posts.length === 0 ? (&#10;              &lt;div className=&quot;text-center py-16&quot;&gt;&#10;                &lt;div className=&quot;w-24 h-24 bg-gray-100 rounded-full flex items-center justify-center mx-auto mb-6&quot;&gt;&#10;                  &lt;MessageCircle className=&quot;w-12 h-12 text-gray-400&quot; /&gt;&#10;                &lt;/div&gt;&#10;                &lt;p className=&quot;text-gray-500 text-xl vietnamese-text font-medium&quot;&gt;Không có bài viết nào&lt;/p&gt;&#10;                &lt;p className=&quot;text-gray-400 text-sm vietnamese-text mt-2&quot;&gt;&#10;                  {activeTab === 'latest' &amp;&amp; 'Hãy tạo bài viết đầu tiên của bạn!'}&#10;                  {activeTab === 'trending' &amp;&amp; 'Chưa có bài viết thịnh hành nào.'}&#10;                  {activeTab === 'top-liked' &amp;&amp; 'Chưa có bài viết được yêu thích nào.'}&#10;                &lt;/p&gt;&#10;              &lt;/div&gt;&#10;          ) : (&#10;              posts.map((post) =&gt; (&#10;                  &lt;PostCard&#10;                    key={post.id}&#10;                    post={post}&#10;                    onPostUpdate={handlePostUpdate}&#10;                    onPostDelete={handlePostDelete}&#10;                    className=&quot;w-full&quot;&#10;                  /&gt;&#10;              ))&#10;          )}&#10;        &lt;/section&gt;&#10;&#10;        {/* Load More */}&#10;        {hasMore &amp;&amp; posts.length &gt; 0 &amp;&amp; (&#10;            &lt;div className=&quot;flex justify-center pt-4&quot;&gt;&#10;              &lt;Button&#10;                  variant=&quot;outline&quot;&#10;                  onClick={handleLoadMore}&#10;                  disabled={isLoadingMore || isLoading}&#10;                  loading={isLoadingMore}&#10;                  aria-label=&quot;Xem thêm bài viết&quot;&#10;              &gt;&#10;                {isLoadingMore ? 'Đang tải...' : 'Xem thêm bài viết'}&#10;              &lt;/Button&gt;&#10;            &lt;/div&gt;&#10;        )}&#10;&#10;        {/* Loading Spinner */}&#10;        {isLoadingMore &amp;&amp; (&#10;            &lt;div className=&quot;flex justify-center py-4&quot; aria-hidden=&quot;true&quot;&gt;&#10;              &lt;LoadingSpinner /&gt;&#10;            &lt;/div&gt;&#10;        )}&#10;      &lt;/main&gt;&#10;  );&#10;};&#10;" />
              <option name="updatedContent" value="'use client';&#10;&#10;import React, { useState, useEffect, useCallback } from 'react';&#10;import { Post, PaginatedResponse } from '@/types';&#10;import { postService } from '@/services/postService';&#10;import { PostCard } from './PostCard';&#10;import { CreatePost } from './CreatePost';&#10;import { LoadingSpinner } from '@/components/ui/LoadingSpinner';&#10;import { ErrorAlert } from '@/components/ui/ErrorAlert';&#10;import { Button } from '@/components/ui/Button';&#10;import { RefreshCw, Plus, TrendingUp, Heart, Filter, MessageCircle } from 'lucide-react';&#10;&#10;interface PostFeedProps {&#10;  authorId?: string;&#10;  authorName?: string;&#10;  category?: string;&#10;  search?: string;&#10;  className?: string;&#10;}&#10;&#10;export const PostFeed: React.FC&lt;PostFeedProps&gt; = ({&#10;                                                    authorId,&#10;                                                    authorName,&#10;                                                    category,&#10;                                                    search,&#10;                                                    className = ''&#10;                                                  }) =&gt; {&#10;  const [posts, setPosts] = useState&lt;Post[]&gt;([]);&#10;  const [isLoading, setIsLoading] = useState(true);&#10;  const [isLoadingMore, setIsLoadingMore] = useState(false);&#10;  const [error, setError] = useState&lt;string | null&gt;(null);&#10;  const [hasMore, setHasMore] = useState(true);&#10;  const [currentPage, setCurrentPage] = useState(0);&#10;  const [showCreatePost, setShowCreatePost] = useState(false);&#10;  const [activeTab, setActiveTab] = useState&lt;'latest' | 'trending' | 'top-liked'&gt;('latest');&#10;&#10;  const loadPosts = useCallback(&#10;      async (page = 0, append = false) =&gt; {&#10;        try {&#10;          if (!append) {&#10;            setIsLoading(true);&#10;            setError(null);&#10;          } else {&#10;            setIsLoadingMore(true);&#10;          }&#10;&#10;          let response: PaginatedResponse&lt;Post&gt;;&#10;&#10;          if (activeTab === 'trending') {&#10;            const trendingPosts = await postService.getTopViewedPosts();&#10;            response = {&#10;              content: trendingPosts,&#10;              totalElements: trendingPosts.length,&#10;              totalPages: 1,&#10;              size: trendingPosts.length,&#10;              number: 0,&#10;              first: true,&#10;              last: true,&#10;            };&#10;          } else if (activeTab === 'top-liked') {&#10;            const topLikedPosts = await postService.getTopLikedPosts();&#10;            response = {&#10;              content: topLikedPosts,&#10;              totalElements: topLikedPosts.length,&#10;              totalPages: 1,&#10;              size: topLikedPosts.length,&#10;              number: 0,&#10;              first: true,&#10;              last: true,&#10;            };&#10;          } else {&#10;            response = await postService.getPosts(&#10;                page,&#10;                10,&#10;                'createdAt',&#10;                'desc',&#10;                authorId,&#10;                category,&#10;                search&#10;            );&#10;          }&#10;&#10;          if (append) {&#10;            setPosts((prev) =&gt; [...prev, ...response.content]);&#10;          } else {&#10;            setPosts(response.content);&#10;          }&#10;&#10;          setHasMore(!response.last &amp;&amp; response.content.length &gt; 0);&#10;          setCurrentPage(response.number);&#10;        } catch (err: any) {&#10;          setError(err.response?.data?.message || 'Failed to load posts');&#10;        } finally {&#10;          setIsLoading(false);&#10;          setIsLoadingMore(false);&#10;        }&#10;      },&#10;      [activeTab, authorId, category, search]&#10;  );&#10;&#10;  useEffect(() =&gt; {&#10;    loadPosts(0, false);&#10;  }, [loadPosts]);&#10;&#10;  const handleLoadMore = () =&gt; {&#10;    if (hasMore &amp;&amp; !isLoadingMore) {&#10;      loadPosts(currentPage + 1, true);&#10;    }&#10;  };&#10;&#10;  const handleRefresh = () =&gt; {&#10;    setCurrentPage(0);&#10;    loadPosts(0, false);&#10;  };&#10;&#10;  const handleTabChange = (tab: 'latest' | 'trending' | 'top-liked') =&gt; {&#10;    if (tab !== activeTab) {&#10;      setActiveTab(tab);&#10;      setCurrentPage(0);&#10;      setPosts([]);&#10;    }&#10;  };&#10;&#10;  const handlePostCreated = (newPost: Post) =&gt; {&#10;    setPosts((prev) =&gt; [newPost, ...prev]);&#10;    setShowCreatePost(false);&#10;  };&#10;&#10;  const handlePostUpdate = (updatedPost: Post) =&gt; {&#10;    setPosts((prev) =&gt; prev.map((p) =&gt; (p.id === updatedPost.id ? updatedPost : p)));&#10;  };&#10;&#10;  const handlePostDelete = (postId: string) =&gt; {&#10;    setPosts((prev) =&gt; prev.filter((p) =&gt; p.id !== postId));&#10;  };&#10;&#10;  const tabs = [&#10;    { key: 'latest', label: 'Mới nhất', icon: RefreshCw },&#10;    { key: 'trending', label: 'Thịnh hành', icon: TrendingUp },&#10;    { key: 'top-liked', label: 'Yêu thích', icon: Heart }&#10;  ];&#10;&#10;  if (isLoading &amp;&amp; posts.length === 0) {&#10;    return (&#10;        &lt;main className=&quot;flex justify-center items-center min-h-[16rem]&quot;&gt;&#10;          &lt;LoadingSpinner size=&quot;lg&quot; /&gt;&#10;        &lt;/main&gt;&#10;    );&#10;  }&#10;&#10;  return (&#10;      &lt;main className={`space-y-6 ${className}`}&gt;&#10;        {/* Header */}&#10;        &lt;header className=&quot;bg-white rounded-xl shadow-md border border-gray-200 overflow-hidden&quot;&gt;&#10;          {/* Hero top banner */}&#10;          &lt;div className=&quot;bg-gradient-to-r from-indigo-600 to-purple-700 px-6 py-5 flex flex-col sm:flex-row sm:justify-between sm:items-center gap-3 sm:gap-0&quot;&gt;&#10;            &lt;div&gt;&#10;              &lt;h1 className=&quot;text-white text-2xl font-extrabold tracking-tight&quot;&gt;&#10;                Bảng tin CTU Connect&#10;              &lt;/h1&gt;&#10;              &lt;p className=&quot;mt-1 text-indigo-200 text-sm max-w-md&quot;&gt;&#10;                Khám phá, chia sẻ những điều thú vị với cộng đồng CTU&#10;              &lt;/p&gt;&#10;            &lt;/div&gt;&#10;&#10;              &lt;Button&#10;                  onClick={() =&gt; setShowCreatePost((v) =&gt; !v)}&#10;                  aria-expanded={showCreatePost}&#10;                  aria-controls=&quot;create-post-form&quot;&#10;                  variant=&quot;especially&quot;&#10;                  size=&quot;sm&quot;&#10;              &gt;&#10;                &lt;Plus className={`w-5 h-5 ${showCreatePost ? 'rotate-45' : ''}`} /&gt;&#10;                &lt;span&gt;{showCreatePost ? 'Hủy bài viết' : 'Tạo bài viết'}&lt;/span&gt;&#10;              &lt;/Button&gt;&#10;            &lt;/div&gt;&#10;&#10;&#10;          {/* Tabs + Control */}&#10;          &lt;div className=&quot;px-6 py-4 border-t border-gray-100 flex flex-col md:flex-row md:items-center md:justify-between gap-4&quot;&gt;&#10;            {/* Tabs */}&#10;            &lt;nav aria-label=&quot;Bộ lọc bài viết&quot; className=&quot;flex flex-wrap gap-3&quot;&gt;&#10;              {tabs.map(({ key, label, icon: Icon }) =&gt; {&#10;                const isActive = activeTab === key;&#10;                return (&#10;                    &lt;button&#10;                        key={key}&#10;                        type=&quot;button&quot;&#10;                        aria-current={isActive ? 'page' : undefined}&#10;                        onClick={() =&gt; handleTabChange(key as any)}&#10;                        className={`flex items-center gap-2 px-4 py-2 rounded-lg font-semibold text-sm transition-all duration-200&#10;                    ${&#10;                            isActive&#10;                                ? 'bg-indigo-100 text-indigo-700 shadow-sm border border-indigo-300'&#10;                                : 'text-gray-600 hover:bg-gray-50 hover:text-indigo-600 border border-transparent'&#10;                        }&#10;                  `}&#10;                        title={label}&#10;                    &gt;&#10;                      &lt;Icon&#10;                          className={`w-5 h-5 transition-transform ${&#10;                              isActive ? 'text-indigo-600' : 'text-gray-400 group-hover:text-indigo-600'&#10;                          }`}&#10;                          aria-hidden=&quot;true&quot;&#10;                      /&gt;&#10;                      &lt;span&gt;{label}&lt;/span&gt;&#10;                    &lt;/button&gt;&#10;                );&#10;              })}&#10;            &lt;/nav&gt;&#10;&#10;            {/* Filter info + Refresh */}&#10;            &lt;div className=&quot;flex flex-wrap gap-3 items-center&quot;&gt;&#10;              {(search || category || authorId) &amp;&amp; (&#10;                  &lt;div className=&quot;flex items-center gap-2 bg-indigo-50 text-indigo-700 px-3 py-1 rounded-lg text-xs&quot;&gt;&#10;                    &lt;Filter className=&quot;w-4 h-4&quot; /&gt;&#10;                    &lt;span&gt;&#10;                  Đang lọc:&#10;                      {search &amp;&amp; ` &quot;${search}&quot;`}&#10;                      {category &amp;&amp; ` ${category}`}&#10;                      {authorId &amp;&amp; ` ${authorName ?? authorId}`}&#10;                &lt;/span&gt;&#10;                  &lt;/div&gt;&#10;              )}&#10;&#10;              &lt;Button&#10;                  variant=&quot;outline&quot;&#10;                  size=&quot;sm&quot;&#10;                  onClick={handleRefresh}&#10;                  disabled={isLoading || isLoadingMore}&#10;                  aria-label=&quot;Làm mới danh sách bài viết&quot;&#10;                  className=&quot;flex items-center gap-2&quot;&#10;              &gt;&#10;                &lt;RefreshCw&#10;                    className={`w-4 h-4 transition-transform ${isLoading ? 'animate-spin' : 'hover:rotate-180'}`}&#10;                    aria-hidden=&quot;true&quot;&#10;                /&gt;&#10;                &lt;span className=&quot;hidden sm:inline&quot;&gt;Làm mới&lt;/span&gt;&#10;              &lt;/Button&gt;&#10;            &lt;/div&gt;&#10;          &lt;/div&gt;&#10;        &lt;/header&gt;&#10;&#10;        {/* Form tạo bài viết */}&#10;        {showCreatePost &amp;&amp; (&#10;            &lt;section&#10;                id=&quot;create-post-form&quot;&#10;                aria-label=&quot;Tạo bài viết mới&quot;&#10;                className=&quot;animate-slide-up&quot;&#10;            &gt;&#10;              &lt;CreatePost onPostCreated={handlePostCreated} onCancel={() =&gt; setShowCreatePost(false)} /&gt;&#10;            &lt;/section&gt;&#10;        )}&#10;&#10;        {/* Error */}&#10;        {error &amp;&amp; &lt;ErrorAlert message={error} onClose={() =&gt; setError(null)} /&gt;}&#10;&#10;        {/* Enhanced Post List - Full Width */}&#10;        &lt;section&#10;            aria-live=&quot;polite&quot;&#10;            aria-busy={isLoading}&#10;            className=&quot;space-y-6&quot;&#10;            aria-label=&quot;Danh sách bài viết&quot;&#10;        &gt;&#10;          {!isLoading &amp;&amp; posts.length === 0 ? (&#10;              &lt;div className=&quot;text-center py-16&quot;&gt;&#10;                &lt;div className=&quot;w-24 h-24 bg-gray-100 rounded-full flex items-center justify-center mx-auto mb-6&quot;&gt;&#10;                  &lt;MessageCircle className=&quot;w-12 h-12 text-gray-400&quot; /&gt;&#10;                &lt;/div&gt;&#10;                &lt;p className=&quot;text-gray-500 text-xl vietnamese-text font-medium&quot;&gt;Không có bài viết nào&lt;/p&gt;&#10;                &lt;p className=&quot;text-gray-400 text-sm vietnamese-text mt-2&quot;&gt;&#10;                  {activeTab === 'latest' &amp;&amp; 'Hãy tạo bài viết đầu tiên của bạn!'}&#10;                  {activeTab === 'trending' &amp;&amp; 'Chưa có bài viết thịnh hành nào.'}&#10;                  {activeTab === 'top-liked' &amp;&amp; 'Chưa có bài viết được yêu thích nào.'}&#10;                &lt;/p&gt;&#10;              &lt;/div&gt;&#10;          ) : (&#10;              posts.map((post) =&gt; (&#10;                  &lt;PostCard&#10;                    key={post.id}&#10;                    post={post}&#10;                    onPostUpdate={handlePostUpdate}&#10;                    onPostDelete={handlePostDelete}&#10;                    className=&quot;w-full&quot;&#10;                  /&gt;&#10;              ))&#10;          )}&#10;        &lt;/section&gt;&#10;&#10;        {/* Load More */}&#10;        {hasMore &amp;&amp; posts.length &gt; 0 &amp;&amp; (&#10;            &lt;div className=&quot;flex justify-center pt-4&quot;&gt;&#10;              &lt;Button&#10;                  variant=&quot;outline&quot;&#10;                  onClick={handleLoadMore}&#10;                  disabled={isLoadingMore || isLoading}&#10;                  loading={isLoadingMore}&#10;                  aria-label=&quot;Xem thêm bài viết&quot;&#10;              &gt;&#10;                {isLoadingMore ? 'Đang tải...' : 'Xem thêm bài viết'}&#10;              &lt;/Button&gt;&#10;            &lt;/div&gt;&#10;        )}&#10;&#10;        {/* Loading Spinner */}&#10;        {isLoadingMore &amp;&amp; (&#10;            &lt;div className=&quot;flex justify-center py-4&quot; aria-hidden=&quot;true&quot;&gt;&#10;              &lt;LoadingSpinner /&gt;&#10;            &lt;/div&gt;&#10;        )}&#10;      &lt;/main&gt;&#10;  );&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/client-frontend/src/lib/locales/vi.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/client-frontend/src/lib/locales/vi.ts" />
              <option name="updatedContent" value="// Vietnamese localization constants&#10;export const VI_LOCALE = {&#10;  // Common actions&#10;  actions: {&#10;    save: 'Lưu',&#10;    cancel: 'Hủy',&#10;    delete: 'Xóa',&#10;    edit: 'Chỉnh sửa',&#10;    submit: 'Gửi',&#10;    confirm: 'Xác nhận',&#10;    back: 'Quay lại',&#10;    next: 'Tiếp theo',&#10;    loading: 'Đang tải...',&#10;    retry: 'Thử lại',&#10;    close: 'Đóng',&#10;    open: 'Mở',&#10;    view: 'Xem',&#10;    share: 'Chia sẻ',&#10;    copy: 'Sao chép',&#10;    download: 'Tải xuống',&#10;    upload: 'Tải lên',&#10;    search: 'Tìm kiếm',&#10;    filter: 'Lọc',&#10;    sort: 'Sắp xếp',&#10;    refresh: 'Làm mới'&#10;  },&#10;&#10;  // Authentication&#10;  auth: {&#10;    login: 'Đăng nhập',&#10;    logout: 'Đăng xuất',&#10;    register: 'Đăng ký',&#10;    forgotPassword: 'Quên mật khẩu',&#10;    resetPassword: 'Đặt lại mật khẩu',&#10;    changePassword: 'Đổi mật khẩu',&#10;    verifyEmail: 'Xác thực email',&#10;    resendVerification: 'Gửi lại mã xác thực'&#10;  },&#10;&#10;  // Posts&#10;  posts: {&#10;    createPost: 'Tạo bài viết',&#10;    editPost: 'Chỉnh sửa bài viết',&#10;    deletePost: 'Xóa bài viết',&#10;    sharePost: 'Chia sẻ bài viết',&#10;    likePost: 'Thích bài viết',&#10;    unlikePost: 'Bỏ thích',&#10;    bookmarkPost: 'Lưu bài viết',&#10;    removeBookmark: 'Bỏ lưu',&#10;    commentPost: 'Bình luận',&#10;    viewComments: 'Xem bình luận',&#10;    hideComments: 'Ẩn bình luận',&#10;    writeComment: 'Viết bình luận...',&#10;    replyComment: 'Trả lời',&#10;    postTitle: 'Tiêu đề bài viết',&#10;    postContent: 'Nội dung bài viết',&#10;    addMedia: 'Thêm ảnh/video',&#10;    addTag: 'Thêm thẻ',&#10;    selectCategory: 'Chọn danh mục',&#10;    noPostsFound: 'Không tìm thấy bài viết nào',&#10;    loadMorePosts: 'Tải thêm bài viết'&#10;  },&#10;&#10;  // User profile&#10;  profile: {&#10;    profile: 'Hồ sơ',&#10;    editProfile: 'Chỉnh sửa hồ sơ',&#10;    viewProfile: 'Xem hồ sơ',&#10;    fullName: 'Họ và tên',&#10;    email: 'Email',&#10;    username: 'Tên đăng nhập',&#10;    bio: 'Giới thiệu',&#10;    avatar: 'Ảnh đại diện',&#10;    coverPhoto: 'Ảnh bìa',&#10;    birthday: 'Ngày sinh',&#10;    gender: 'Giới tính',&#10;    faculty: 'Khoa',&#10;    major: 'Ngành học',&#10;    studentId: 'Mã số sinh viên',&#10;    academicYear: 'Niên khóa',&#10;    phone: 'Số điện thoại',&#10;    address: 'Địa chỉ'&#10;  },&#10;&#10;  // Messages and notifications&#10;  messages: {&#10;    success: {&#10;      loginSuccess: 'Đăng nhập thành công',&#10;      logoutSuccess: 'Đăng xuất thành công',&#10;      registrationSuccess: 'Đăng ký thành công',&#10;      profileUpdated: 'Cập nhật hồ sơ thành công',&#10;      postCreated: 'Tạo bài viết thành công',&#10;      postUpdated: 'Cập nhật bài viết thành công',&#10;      postDeleted: 'Xóa bài viết thành công',&#10;      commentAdded: 'Thêm bình luận thành công',&#10;      passwordChanged: 'Đổi mật khẩu thành công',&#10;      emailVerified: 'Xác thực email thành công'&#10;    },&#10;    error: {&#10;      genericError: 'Đã xảy ra lỗi. Vui lòng thử lại.',&#10;      networkError: 'Lỗi kết nối mạng. Vui lòng kiểm tra kết nối internet.',&#10;      unauthorized: 'Bạn không có quyền truy cập.',&#10;      forbidden: 'Truy cập bị từ chối.',&#10;      notFound: 'Không tìm thấy tài nguyên.',&#10;      serverError: 'Lỗi máy chủ. Vui lòng thử lại sau.',&#10;      validationError: 'Dữ liệu không hợp lệ.',&#10;      loginFailed: 'Đăng nhập thất bại',&#10;      registrationFailed: 'Đăng ký thất bại',&#10;      uploadFailed: 'Tải file thất bại',&#10;      securityError: 'Xác thực bảo mật thất bại. Vui lòng thử lại.'&#10;    },&#10;    validation: {&#10;      required: 'Trường này là bắt buộc',&#10;      invalidEmail: 'Email không hợp lệ',&#10;      invalidPassword: 'Mật khẩu không hợp lệ',&#10;      passwordMismatch: 'Mật khẩu xác nhận không khớp',&#10;      minLength: 'Tối thiểu {min} ký tự',&#10;      maxLength: 'Tối đa {max} ký tự',&#10;      invalidFormat: 'Định dạng không hợp lệ'&#10;    }&#10;  },&#10;&#10;  // Time formatting&#10;  time: {&#10;    now: 'Vừa xong',&#10;    minutesAgo: '{count} phút trước',&#10;    hoursAgo: '{count} giờ trước',&#10;    daysAgo: '{count} ngày trước',&#10;    weeksAgo: '{count} tuần trước',&#10;    monthsAgo: '{count} tháng trước',&#10;    yearsAgo: '{count} năm trước'&#10;  },&#10;&#10;  // File upload&#10;  upload: {&#10;    selectFiles: 'Chọn tệp',&#10;    dragAndDrop: 'Kéo thả tệp vào đây',&#10;    maxFileSize: 'Kích thước tệp tối đa: {size}MB',&#10;    supportedFormats: 'Định dạng hỗ trợ: {formats}',&#10;    uploadProgress: 'Đang tải lên... {progress}%',&#10;    uploadComplete: 'Tải lên hoàn tất',&#10;    uploadFailed: 'Tải lên thất bại'&#10;  },&#10;&#10;  // Search and filters&#10;  search: {&#10;    searchPlaceholder: 'Tìm kiếm...',&#10;    noResults: 'Không tìm thấy kết quả',&#10;    searchResults: 'Kết quả tìm kiếm',&#10;    filters: 'Bộ lọc',&#10;    sortBy: 'Sắp xếp theo',&#10;    sortNewest: 'Mới nhất',&#10;    sortOldest: 'Cũ nhất',&#10;    sortMostLiked: 'Nhiều lượt thích nhất',&#10;    sortMostViewed: 'Nhiều lượt xem nhất'&#10;  },&#10;&#10;  // Categories&#10;  categories: {&#10;    academic: 'Học tập',&#10;    social: 'Sinh hoạt',&#10;    announcement: 'Thông báo',&#10;    career: 'Nghề nghiệp',&#10;    technology: 'Công nghệ',&#10;    sports: 'Thể thao',&#10;    entertainment: 'Giải trí',&#10;    other: 'Khác'&#10;  }&#10;} as const;&#10;&#10;export type LocaleKey = keyof typeof VI_LOCALE;&#10;export type LocaleValue = typeof VI_LOCALE[LocaleKey];" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/client-frontend/src/shared/services/post.service.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/client-frontend/src/shared/services/post.service.ts" />
              <option name="originalContent" value="import { apiClient } from '@/shared/config/api-client';&#10;import { API_ENDPOINTS } from '@/shared/constants';&#10;import { createApiUrl } from '@/shared/utils';&#10;import {&#10;  Post,&#10;  Comment,&#10;  CreatePostRequest,&#10;  UpdatePostRequest,&#10;  CreateCommentRequest,&#10;  UpdateCommentRequest,&#10;  PaginatedResponse,&#10;  ApiResponse,&#10;  PostVisibility,&#10;} from '@/shared/types';&#10;&#10;/**&#10; * Post Service&#10; * Handles all post-related API calls&#10; * Handles all post-related API calls&#10; */&#10;export class PostService {&#10;   * Create new post&#10;   * Create new post&#10;    const formData = new FormData();&#10;    formData.append('content', postData.content);&#10;&#10;    if (postData.visibility) {&#10;      formData.append('visibility', postData.visibility);&#10;    }&#10;    formData.append('content', postData.content);&#10;    if (postData.tags) {&#10;      postData.tags.forEach(tag =&gt; formData.append('tags', tag));&#10;    }&#10;&#10;    if (postData.images) {&#10;      postData.images.forEach(image =&gt; formData.append('images', image));&#10;    }&#10;&#10;    return apiClient.post&lt;Post&gt;(API_ENDPOINTS.POSTS.BASE, formData, {&#10;      headers: {&#10;        'Content-Type': 'multipart/form-data',&#10;      },&#10;    });&#10;      postData.tags.forEach(tag =&gt; formData.append('tags', tag));&#10;    }&#10;&#10;    if (postData.images) {&#10;      postData.images.forEach(image =&gt; formData.append('images', image));&#10;    }&#10;&#10;    return apiClient.post&lt;Post&gt;(API_ENDPOINTS.POSTS.BASE, formData, {&#10;      headers: {&#10;        'Content-Type': 'multipart/form-data',&#10;      },&#10;    });&#10;  }&#10;&#10;  /**&#10;   * Get posts feed&#10;   */&#10;  async getPosts(page = 0, size = 10): Promise&lt;PaginatedResponse&lt;Post&gt;&gt; {&#10;    const url = createApiUrl(API_ENDPOINTS.POSTS.BASE, undefined, { page, size });&#10;    return apiClient.get&lt;PaginatedResponse&lt;Post&gt;&gt;(url);&#10;  }&#10;&#10;  /**&#10;   * Get single post by ID&#10;   */&#10;  async getPost(postId: string): Promise&lt;Post&gt; {&#10;    const url = createApiUrl(API_ENDPOINTS.POSTS.BASE + '/:id', { id: postId });&#10;    return apiClient.get&lt;Post&gt;(url);&#10;  }&#10;&#10;  /**&#10;   * Get posts by user&#10;   */&#10;  async getUserPosts(&#10;    userId: string,&#10;    page = 0,&#10;    size = 10&#10;  ): Promise&lt;PaginatedResponse&lt;Post&gt;&gt; {&#10;    const url = createApiUrl(&#10;      API_ENDPOINTS.POSTS.BY_USER,&#10;      { id: userId },&#10;      { page, size }&#10;    );&#10;    return apiClient.get&lt;PaginatedResponse&lt;Post&gt;&gt;(url);&#10;  }&#10;&#10;  /**&#10;   * Update post&#10;   */&#10;  async updatePost(postId: string, updateData: UpdatePostRequest): Promise&lt;Post&gt; {&#10;    const url = createApiUrl(API_ENDPOINTS.POSTS.BASE + '/:id', { id: postId });&#10;    return apiClient.put&lt;Post&gt;(url, updateData);&#10;  }&#10;&#10;  /**&#10;   * Delete post&#10;   */&#10;  async deletePost(postId: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#10;    const url = createApiUrl(API_ENDPOINTS.POSTS.BASE + '/:id', { id: postId });&#10;    return apiClient.delete&lt;ApiResponse&lt;null&gt;&gt;(url);&#10;  }&#10;&#10;  /**&#10;   * Like post&#10;   */&#10;  async likePost(postId: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#10;    const url = createApiUrl(API_ENDPOINTS.POSTS.LIKE, { id: postId });&#10;    return apiClient.post&lt;ApiResponse&lt;null&gt;&gt;(url);&#10;  }&#10;&#10;  /**&#10;   * Unlike post&#10;   */&#10;  async unlikePost(postId: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#10;    const url = createApiUrl(API_ENDPOINTS.POSTS.LIKE, { id: postId });&#10;    return apiClient.delete&lt;ApiResponse&lt;null&gt;&gt;(url);&#10;  }&#10;&#10;  /**&#10;   * Get post comments&#10;   */&#10;  async getComments(&#10;    postId: string,&#10;    page = 0,&#10;    size = 10&#10;  ): Promise&lt;PaginatedResponse&lt;Comment&gt;&gt; {&#10;    const url = createApiUrl(&#10;      API_ENDPOINTS.POSTS.COMMENTS,&#10;      { id: postId },&#10;      { page, size }&#10;    );&#10;    return apiClient.get&lt;PaginatedResponse&lt;Comment&gt;&gt;(url);&#10;  }&#10;&#10;  /**&#10;   * Create comment&#10;   */&#10;  async createComment(commentData: CreateCommentRequest): Promise&lt;Comment&gt; {&#10;    const url = createApiUrl(API_ENDPOINTS.POSTS.COMMENTS, { id: commentData.postId });&#10;    return apiClient.post&lt;Comment&gt;(url, {&#10;      content: commentData.content,&#10;      parentId: commentData.parentId,&#10;    });&#10;  }&#10;&#10;  /**&#10;   * Update comment&#10;   */&#10;  async updateComment(&#10;    commentId: string,&#10;    updateData: UpdateCommentRequest&#10;  ): Promise&lt;Comment&gt; {&#10;    const url = createApiUrl('/comments/:id', { id: commentId });&#10;    return apiClient.put&lt;Comment&gt;(url, updateData);&#10;  }&#10;&#10;  /**&#10;   * Delete comment&#10;   */&#10;  async deleteComment(commentId: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#10;    const url = createApiUrl('/comments/:id', { id: commentId });&#10;    return apiClient.delete&lt;ApiResponse&lt;null&gt;&gt;(url);&#10;  }&#10;&#10;  /**&#10;   * Like comment&#10;   */&#10;  async likeComment(commentId: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#10;    const url = createApiUrl(API_ENDPOINTS.POSTS.COMMENT_LIKE, { id: commentId });&#10;    return apiClient.post&lt;ApiResponse&lt;null&gt;&gt;(url);&#10;  }&#10;&#10;  /**&#10;   * Unlike comment&#10;   */&#10;  async unlikeComment(commentId: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#10;    const url = createApiUrl(API_ENDPOINTS.POSTS.COMMENT_LIKE, { id: commentId });&#10;    return apiClient.delete&lt;ApiResponse&lt;null&gt;&gt;(url);&#10;  }&#10;&#10;  /**&#10;   * Share post&#10;   */&#10;  async sharePost(postId: string, content?: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#10;    const url = createApiUrl('/posts/:id/share', { id: postId });&#10;    return apiClient.post&lt;ApiResponse&lt;null&gt;&gt;(url, { content });&#10;  }&#10;&#10;  /**&#10;   * Bookmark post&#10;   */&#10;  async bookmarkPost(postId: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#10;    const url = createApiUrl('/posts/:id/bookmark', { id: postId });&#10;    return apiClient.post&lt;ApiResponse&lt;null&gt;&gt;(url);&#10;  }&#10;&#10;  /**&#10;   * Remove bookmark&#10;   */&#10;  async removeBookmark(postId: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#10;    const url = createApiUrl('/posts/:id/bookmark', { id: postId });&#10;    return apiClient.delete&lt;ApiResponse&lt;null&gt;&gt;(url);&#10;  }&#10;}&#10;&#10;// Export singleton instance&#10;export const postService = new PostService();&#10;" />
              <option name="updatedContent" value="import { apiClient } from '@/shared/config/api-client';&#13;&#10;import { API_ENDPOINTS } from '@/shared/constants';&#13;&#10;import { createApiUrl } from '@/shared/utils';&#13;&#10;import {&#13;&#10;  Post,&#13;&#10;  Comment,&#13;&#10;  CreatePostRequest,&#13;&#10;  UpdatePostRequest,&#13;&#10;  CreateCommentRequest,&#13;&#10;  UpdateCommentRequest,&#13;&#10;  PaginatedResponse,&#13;&#10;  ApiResponse,&#13;&#10;  PostVisibility,&#13;&#10;} from '@/shared/types';&#13;&#10;&#13;&#10;/**&#13;&#10; * Post Service - Updated to sync with backend APIs&#13;&#10; */&#13;&#10;export class PostService {&#13;&#10;  /**&#13;&#10;   * Create new post - Updated to match EnhancedPostController&#13;&#10;   */&#13;&#10;  async createPost(postData: CreatePostRequest): Promise&lt;Post&gt; {&#13;&#10;    // Use JSON instead of FormData to match EnhancedPostController&#13;&#10;    return apiClient.post&lt;Post&gt;(API_ENDPOINTS.POSTS.BASE, postData);&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Get personalized feed - Updated to match backend&#13;&#10;   */&#13;&#10;  async getPersonalizedFeed(page = 0, size = 10): Promise&lt;Post[]&gt; {&#13;&#10;    const url = createApiUrl(API_ENDPOINTS.POSTS.FEED, undefined, { page, size });&#13;&#10;    return apiClient.get&lt;Post[]&gt;(url);&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Get posts feed&#13;&#10;   */&#13;&#10;  async getPosts(page = 0, size = 10): Promise&lt;PaginatedResponse&lt;Post&gt;&gt; {&#13;&#10;    const url = createApiUrl(API_ENDPOINTS.POSTS.BASE, undefined, { page, size });&#13;&#10;    return apiClient.get&lt;PaginatedResponse&lt;Post&gt;&gt;(url);&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Get single post by ID&#13;&#10;   */&#13;&#10;  async getPost(postId: string): Promise&lt;Post&gt; {&#13;&#10;    const url = createApiUrl(API_ENDPOINTS.POSTS.BASE + '/:id', { id: postId });&#13;&#10;    return apiClient.get&lt;Post&gt;(url);&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Get posts by user&#13;&#10;   */&#13;&#10;  async getUserPosts(&#13;&#10;    userId: string,&#13;&#10;    page = 0,&#13;&#10;    size = 10&#13;&#10;  ): Promise&lt;PaginatedResponse&lt;Post&gt;&gt; {&#13;&#10;    const url = createApiUrl(&#13;&#10;      API_ENDPOINTS.POSTS.BY_USER,&#13;&#10;      { id: userId },&#13;&#10;      { page, size }&#13;&#10;    );&#13;&#10;    return apiClient.get&lt;PaginatedResponse&lt;Post&gt;&gt;(url);&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Update post&#13;&#10;   */&#13;&#10;  async updatePost(postId: string, updateData: UpdatePostRequest): Promise&lt;Post&gt; {&#13;&#10;    const url = createApiUrl(API_ENDPOINTS.POSTS.BASE + '/:id', { id: postId });&#13;&#10;    return apiClient.put&lt;Post&gt;(url, updateData);&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Delete post&#13;&#10;   */&#13;&#10;  async deletePost(postId: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#13;&#10;    const url = createApiUrl(API_ENDPOINTS.POSTS.BASE + '/:id', { id: postId });&#13;&#10;    return apiClient.delete&lt;ApiResponse&lt;null&gt;&gt;(url);&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Like post&#13;&#10;   */&#13;&#10;  async likePost(postId: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#13;&#10;    const url = createApiUrl(API_ENDPOINTS.POSTS.LIKE, { id: postId });&#13;&#10;    return apiClient.post&lt;ApiResponse&lt;null&gt;&gt;(url);&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Unlike post&#13;&#10;   */&#13;&#10;  async unlikePost(postId: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#13;&#10;    const url = createApiUrl(API_ENDPOINTS.POSTS.LIKE, { id: postId });&#13;&#10;    return apiClient.delete&lt;ApiResponse&lt;null&gt;&gt;(url);&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Get post comments&#13;&#10;   */&#13;&#10;  async getComments(&#13;&#10;    postId: string,&#13;&#10;    page = 0,&#13;&#10;    size = 10&#13;&#10;  ): Promise&lt;PaginatedResponse&lt;Comment&gt;&gt; {&#13;&#10;    const url = createApiUrl(&#13;&#10;      API_ENDPOINTS.POSTS.COMMENTS,&#13;&#10;      { id: postId },&#13;&#10;      { page, size }&#13;&#10;    );&#13;&#10;    return apiClient.get&lt;PaginatedResponse&lt;Comment&gt;&gt;(url);&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Create comment&#13;&#10;   */&#13;&#10;  async createComment(commentData: CreateCommentRequest): Promise&lt;Comment&gt; {&#13;&#10;    const url = createApiUrl(API_ENDPOINTS.POSTS.COMMENTS, { id: commentData.postId });&#13;&#10;    return apiClient.post&lt;Comment&gt;(url, {&#13;&#10;      content: commentData.content,&#13;&#10;      parentId: commentData.parentId,&#13;&#10;    });&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Update comment&#13;&#10;   */&#13;&#10;  async updateComment(&#13;&#10;    commentId: string,&#13;&#10;    updateData: UpdateCommentRequest&#13;&#10;  ): Promise&lt;Comment&gt; {&#13;&#10;    const url = createApiUrl('/comments/:id', { id: commentId });&#13;&#10;    return apiClient.put&lt;Comment&gt;(url, updateData);&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Delete comment&#13;&#10;   */&#13;&#10;  async deleteComment(commentId: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#13;&#10;    const url = createApiUrl('/comments/:id', { id: commentId });&#13;&#10;    return apiClient.delete&lt;ApiResponse&lt;null&gt;&gt;(url);&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Like comment&#13;&#10;   */&#13;&#10;  async likeComment(commentId: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#13;&#10;    const url = createApiUrl(API_ENDPOINTS.POSTS.COMMENT_LIKE, { id: commentId });&#13;&#10;    return apiClient.post&lt;ApiResponse&lt;null&gt;&gt;(url);&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Unlike comment&#13;&#10;   */&#13;&#10;  async unlikeComment(commentId: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#13;&#10;    const url = createApiUrl(API_ENDPOINTS.POSTS.COMMENT_LIKE, { id: commentId });&#13;&#10;    return apiClient.delete&lt;ApiResponse&lt;null&gt;&gt;(url);&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Share post&#13;&#10;   */&#13;&#10;  async sharePost(postId: string, content?: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#13;&#10;    const url = createApiUrl('/posts/:id/share', { id: postId });&#13;&#10;    return apiClient.post&lt;ApiResponse&lt;null&gt;&gt;(url, { content });&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Bookmark post&#13;&#10;   */&#13;&#10;  async bookmarkPost(postId: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#13;&#10;    const url = createApiUrl('/posts/:id/bookmark', { id: postId });&#13;&#10;    return apiClient.post&lt;ApiResponse&lt;null&gt;&gt;(url);&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Remove bookmark&#13;&#10;   */&#13;&#10;  async removeBookmark(postId: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#13;&#10;    const url = createApiUrl('/posts/:id/bookmark', { id: postId });&#13;&#10;    return apiClient.delete&lt;ApiResponse&lt;null&gt;&gt;(url);&#13;&#10;  }&#13;&#10;}&#13;&#10;&#13;&#10;// Export singleton instance&#13;&#10;export const postService = new PostService();" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/client-frontend/src/utils/localization.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/client-frontend/src/utils/localization.ts" />
              <option name="updatedContent" value="import { VI_LOCALE } from '@/lib/locales/vi';&#10;&#10;/**&#10; * Get localized text with parameter substitution&#10; * @param key - The key path to the localized text (e.g., 'actions.save', 'messages.error.loginFailed')&#10; * @param params - Parameters to substitute in the text&#10; * @returns Localized text string&#10; */&#10;export function t(key: string, params?: Record&lt;string, string | number&gt;): string {&#10;  const keys = key.split('.');&#10;  let value: any = VI_LOCALE;&#10;&#10;  for (const k of keys) {&#10;    if (value &amp;&amp; typeof value === 'object' &amp;&amp; k in value) {&#10;      value = value[k];&#10;    } else {&#10;      console.warn(`Translation key not found: ${key}`);&#10;      return key;&#10;    }&#10;  }&#10;&#10;  if (typeof value !== 'string') {&#10;    console.warn(`Translation value is not a string: ${key}`);&#10;    return key;&#10;  }&#10;&#10;  // Replace parameters in the text&#10;  if (params) {&#10;    return value.replace(/\{(\w+)\}/g, (match, paramKey) =&gt; {&#10;      return params[paramKey]?.toString() || match;&#10;    });&#10;  }&#10;&#10;  return value;&#10;}&#10;&#10;/**&#10; * Format time relative to now in Vietnamese&#10; * @param date - The date to format&#10; * @returns Formatted time string in Vietnamese&#10; */&#10;export function formatTimeAgo(date: Date | string): string {&#10;  const now = new Date();&#10;  const targetDate = new Date(date);&#10;  const diffInSeconds = Math.floor((now.getTime() - targetDate.getTime()) / 1000);&#10;&#10;  if (diffInSeconds &lt; 60) {&#10;    return t('time.now');&#10;  } else if (diffInSeconds &lt; 3600) {&#10;    const minutes = Math.floor(diffInSeconds / 60);&#10;    return t('time.minutesAgo', { count: minutes.toString() });&#10;  } else if (diffInSeconds &lt; 86400) {&#10;    const hours = Math.floor(diffInSeconds / 3600);&#10;    return t('time.hoursAgo', { count: hours.toString() });&#10;  } else if (diffInSeconds &lt; 604800) {&#10;    const days = Math.floor(diffInSeconds / 86400);&#10;    return t('time.daysAgo', { count: days.toString() });&#10;  } else if (diffInSeconds &lt; 2592000) {&#10;    const weeks = Math.floor(diffInSeconds / 604800);&#10;    return t('time.weeksAgo', { count: weeks.toString() });&#10;  } else if (diffInSeconds &lt; 31536000) {&#10;    const months = Math.floor(diffInSeconds / 2592000);&#10;    return t('time.monthsAgo', { count: months.toString() });&#10;  } else {&#10;    const years = Math.floor(diffInSeconds / 31536000);&#10;    return t('time.yearsAgo', { count: years.toString() });&#10;  }&#10;}&#10;&#10;/**&#10; * Format file size in Vietnamese&#10; * @param bytes - File size in bytes&#10; * @returns Formatted file size string&#10; */&#10;export function formatFileSize(bytes: number): string {&#10;  if (bytes === 0) return '0 Bytes';&#10;&#10;  const k = 1024;&#10;  const sizes = ['Bytes', 'KB', 'MB', 'GB'];&#10;  const i = Math.floor(Math.log(bytes) / Math.log(k));&#10;&#10;  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];&#10;}&#10;&#10;/**&#10; * Get category name in Vietnamese&#10; * @param categoryKey - Category key&#10; * @returns Vietnamese category name&#10; */&#10;export function getCategoryName(categoryKey: string): string {&#10;  return t(`categories.${categoryKey}`) || categoryKey;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/PostServiceApplication.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/PostServiceApplication.java" />
              <option name="originalContent" value="package com.ctuconnect;&#10;&#10;import org.springframework.boot.SpringApplication;&#10;import org.springframework.boot.autoconfigure.SpringBootApplication;&#10;import org.springframework.cloud.client.discovery.EnableDiscoveryClient;&#10;import org.springframework.cloud.openfeign.EnableFeignClients;&#10;import org.springframework.kafka.annotation.EnableKafka;&#10;&#10;@SpringBootApplication&#10;@EnableDiscoveryClient&#10;@EnableFeignClients&#10;@EnableKafka&#10;public class PostServiceApplication {&#10;&#10;    public static void main(String[] args) {&#10;        SpringApplication.run(PostServiceApplication.class, args);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.ctuconnect;&#13;&#10;&#13;&#10;import org.springframework.boot.SpringApplication;&#13;&#10;import org.springframework.boot.autoconfigure.SpringBootApplication;&#13;&#10;import org.springframework.cloud.client.discovery.EnableDiscoveryClient;&#13;&#10;import org.springframework.cloud.openfeign.EnableFeignClients;&#13;&#10;import org.springframework.kafka.annotation.EnableKafka;&#13;&#10;import org.springframework.data.mongodb.config.EnableMongoAuditing;&#13;&#10;&#13;&#10;@SpringBootApplication&#13;&#10;@EnableDiscoveryClient&#13;&#10;@EnableFeignClients&#13;&#10;@EnableKafka&#13;&#10;@EnableMongoAuditing // Enable MongoDB auditing for @CreatedDate and @LastModifiedDate&#13;&#10;public class PostServiceApplication {&#13;&#10;&#13;&#10;    public static void main(String[] args) {&#13;&#10;        SpringApplication.run(PostServiceApplication.class, args);&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/client/MediaServiceClient.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/client/MediaServiceClient.java" />
              <option name="originalContent" value="package com.ctuconnect.client;&#10;&#10;import lombok.Data;&#10;import org.springframework.cloud.openfeign.FeignClient;&#10;import org.springframework.http.MediaType;&#10;import org.springframework.web.bind.annotation.*;&#10;import org.springframework.web.multipart.MultipartFile;&#10;&#10;&#10;@FeignClient(name = &quot;media-service&quot;, url = &quot;${media-service.url:http://localhost:8080}&quot;)&#10;public interface MediaServiceClient {&#10;&#10;    @PostMapping(value = &quot;/api/media/upload&quot;, consumes = MediaType.MULTIPART_FORM_DATA_VALUE)&#10;    MediaUploadResponse uploadFile(@RequestPart(&quot;file&quot;) MultipartFile file,&#10;                                  @RequestParam(&quot;type&quot;) String type);&#10;&#10;    @DeleteMapping(&quot;/api/media/{id}&quot;)&#10;    void deleteFile(@PathVariable(&quot;id&quot;) String fileId);&#10;&#10;    @GetMapping(&quot;/api/media/{id}&quot;)&#10;    MediaResponse getFileInfo(@PathVariable(&quot;id&quot;) String fileId);&#10;&#10;    // Response DTOs for media service&#10;    class MediaUploadResponse {&#10;        private String id;&#10;        private String fileName;&#10;        private String fileUrl;&#10;        private String fileType;&#10;        private long fileSize;&#10;&#10;        // Getters and Setters&#10;        public String getId() {&#10;            return id;&#10;        }&#10;&#10;        public void setId(String id) {&#10;            this.id = id;&#10;        }&#10;&#10;        public String getFileName() {&#10;            return fileName;&#10;        }&#10;&#10;        public void setFileName(String fileName) {&#10;            this.fileName = fileName;&#10;        }&#10;&#10;        public String getFileUrl() {&#10;            return fileUrl;&#10;        }&#10;&#10;        public void setFileUrl(String fileUrl) {&#10;            this.fileUrl = fileUrl;&#10;        }&#10;&#10;        public String getFileType() {&#10;            return fileType;&#10;        }&#10;&#10;        public void setFileType(String fileType) {&#10;            this.fileType = fileType;&#10;        }&#10;&#10;        public long getFileSize() {&#10;            return fileSize;&#10;        }&#10;&#10;        public void setFileSize(long fileSize) {&#10;            this.fileSize = fileSize;&#10;        }&#10;    }&#10;&#10;    @Data&#10;    class MediaResponse {&#10;        private String id;&#10;        private String fileName;&#10;        private String fileUrl;&#10;        private String fileType;&#10;        private long fileSize;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.ctuconnect.client;&#13;&#10;&#13;&#10;import lombok.Data;&#13;&#10;import org.springframework.cloud.openfeign.FeignClient;&#13;&#10;import org.springframework.http.MediaType;&#13;&#10;import org.springframework.web.bind.annotation.*;&#13;&#10;import org.springframework.web.multipart.MultipartFile;&#13;&#10;import com.ctuconnect.config.FeignConfig;&#13;&#10;&#13;&#10;@FeignClient(&#13;&#10;    name = &quot;media-service&quot;, &#13;&#10;    url = &quot;${media-service.url}&quot;, &#13;&#10;    configuration = FeignConfig.class&#13;&#10;)&#13;&#10;public interface MediaServiceClient {&#13;&#10;&#13;&#10;    @PostMapping(value = &quot;/api/media/upload&quot;, consumes = MediaType.MULTIPART_FORM_DATA_VALUE)&#13;&#10;    MediaUploadResponse uploadFile(@RequestPart(&quot;file&quot;) MultipartFile file,&#13;&#10;                                  @RequestParam(&quot;type&quot;) String type);&#13;&#10;&#13;&#10;    @DeleteMapping(&quot;/api/media/{id}&quot;)&#13;&#10;    void deleteFile(@PathVariable(&quot;id&quot;) String fileId);&#13;&#10;&#13;&#10;    @GetMapping(&quot;/api/media/{id}&quot;)&#13;&#10;    MediaResponse getFileInfo(@PathVariable(&quot;id&quot;) String fileId);&#13;&#10;&#13;&#10;    // Response DTOs for media service&#13;&#10;    class MediaUploadResponse {&#13;&#10;        private String id;&#13;&#10;        private String fileName;&#13;&#10;        private String fileUrl;&#13;&#10;        private String fileType;&#13;&#10;        private long fileSize;&#13;&#10;&#13;&#10;        // Getters and Setters&#13;&#10;        public String getId() {&#13;&#10;            return id;&#13;&#10;        }&#13;&#10;&#13;&#10;        public void setId(String id) {&#13;&#10;            this.id = id;&#13;&#10;        }&#13;&#10;&#13;&#10;        public String getFileName() {&#13;&#10;            return fileName;&#13;&#10;        }&#13;&#10;&#13;&#10;        public void setFileName(String fileName) {&#13;&#10;            this.fileName = fileName;&#13;&#10;        }&#13;&#10;&#13;&#10;        public String getFileUrl() {&#13;&#10;            return fileUrl;&#13;&#10;        }&#13;&#10;&#13;&#10;        public void setFileUrl(String fileUrl) {&#13;&#10;            this.fileUrl = fileUrl;&#13;&#10;        }&#13;&#10;&#13;&#10;        public String getFileType() {&#13;&#10;            return fileType;&#13;&#10;        }&#13;&#10;&#13;&#10;        public void setFileType(String fileType) {&#13;&#10;            this.fileType = fileType;&#13;&#10;        }&#13;&#10;&#13;&#10;        public long getFileSize() {&#13;&#10;            return fileSize;&#13;&#10;        }&#13;&#10;&#13;&#10;        public void setFileSize(long fileSize) {&#13;&#10;            this.fileSize = fileSize;&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    @Data&#13;&#10;    class MediaResponse {&#13;&#10;        private String id;&#13;&#10;        private String fileName;&#13;&#10;        private String fileUrl;&#13;&#10;        private String fileType;&#13;&#10;        private long fileSize;&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/client/UserServiceClientFallback.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/client/UserServiceClientFallback.java" />
              <option name="updatedContent" value="package com.ctuconnect.client;&#10;&#10;import com.ctuconnect.dto.AuthorInfo;&#10;import lombok.extern.slf4j.Slf4j;&#10;import org.springframework.stereotype.Component;&#10;&#10;import java.util.HashSet;&#10;import java.util.Set;&#10;&#10;/**&#10; * Fallback implementation for UserServiceClient when user-service is unavailable&#10; * Provides default values to prevent service failures&#10; */&#10;@Component&#10;@Slf4j&#10;public class UserServiceClientFallback implements UserServiceClient {&#10;&#10;    @Override&#10;    public AuthorInfo getAuthorInfo(String authorId) {&#10;        log.warn(&quot;User service unavailable, returning fallback author info for user: {}&quot;, authorId);&#10;        return AuthorInfo.builder()&#10;                .userId(authorId)&#10;                .username(&quot;Unknown User&quot;)&#10;                .fullName(&quot;Unknown User&quot;)&#10;                .avatarUrl(null)&#10;                .isVerified(false)&#10;                .build();&#10;    }&#10;&#10;    @Override&#10;    public Set&lt;String&gt; getFriendIds(String userId) {&#10;        log.warn(&quot;User service unavailable, returning empty friend list for user: {}&quot;, userId);&#10;        return new HashSet&lt;&gt;();&#10;    }&#10;&#10;    @Override&#10;    public Set&lt;String&gt; getCloseInteractionIds(String userId) {&#10;        log.warn(&quot;User service unavailable, returning empty close interactions for user: {}&quot;, userId);&#10;        return new HashSet&lt;&gt;();&#10;    }&#10;&#10;    @Override&#10;    public Set&lt;String&gt; getSameFacultyUserIds(String userId) {&#10;        log.warn(&quot;User service unavailable, returning empty same faculty users for user: {}&quot;, userId);&#10;        return new HashSet&lt;&gt;();&#10;    }&#10;&#10;    @Override&#10;    public Set&lt;String&gt; getSameMajorUserIds(String userId) {&#10;        log.warn(&quot;User service unavailable, returning empty same major users for user: {}&quot;, userId);&#10;        return new HashSet&lt;&gt;();&#10;    }&#10;&#10;    @Override&#10;    public Set&lt;String&gt; getUserInterestTags(String userId) {&#10;        log.warn(&quot;User service unavailable, returning empty interest tags for user: {}&quot;, userId);&#10;        return new HashSet&lt;&gt;();&#10;    }&#10;&#10;    @Override&#10;    public Set&lt;String&gt; getUserPreferredCategories(String userId) {&#10;        log.warn(&quot;User service unavailable, returning empty preferred categories for user: {}&quot;, userId);&#10;        return new HashSet&lt;&gt;();&#10;    }&#10;&#10;    @Override&#10;    public String getUserFacultyId(String userId) {&#10;        log.warn(&quot;User service unavailable, returning null faculty ID for user: {}&quot;, userId);&#10;        return null;&#10;    }&#10;&#10;    @Override&#10;    public String getUserMajorId(String userId) {&#10;        log.warn(&quot;User service unavailable, returning null major ID for user: {}&quot;, userId);&#10;        return null;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/config/CacheConfig.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/config/CacheConfig.java" />
              <option name="updatedContent" value="package com.ctuconnect.config;&#10;&#10;import org.springframework.beans.factory.annotation.Value;&#10;import org.springframework.context.annotation.Bean;&#10;import org.springframework.context.annotation.Configuration;&#10;import org.springframework.data.redis.connection.RedisConnectionFactory;&#10;import org.springframework.data.redis.connection.lettuce.LettuceConnectionFactory;&#10;import org.springframework.data.redis.core.RedisTemplate;&#10;import org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer;&#10;import org.springframework.data.redis.serializer.StringRedisSerializer;&#10;&#10;@Configuration&#10;public class CacheConfig {&#10;&#10;    @Value(&quot;${spring.data.redis.host:localhost}&quot;)&#10;    private String redisHost;&#10;&#10;    @Value(&quot;${spring.data.redis.port:6379}&quot;)&#10;    private int redisPort;&#10;&#10;    @Bean&#10;    public RedisConnectionFactory redisConnectionFactory() {&#10;        return new LettuceConnectionFactory(redisHost, redisPort);&#10;    }&#10;&#10;    @Bean&#10;    public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory connectionFactory) {&#10;        RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;();&#10;        template.setConnectionFactory(connectionFactory);&#10;        &#10;        // Use String serializer for keys&#10;        template.setKeySerializer(new StringRedisSerializer());&#10;        template.setHashKeySerializer(new StringRedisSerializer());&#10;        &#10;        // Use JSON serializer for values&#10;        template.setValueSerializer(new GenericJackson2JsonRedisSerializer());&#10;        template.setHashValueSerializer(new GenericJackson2JsonRedisSerializer());&#10;        &#10;        template.afterPropertiesSet();&#10;        return template;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/config/FeignConfig.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/config/FeignConfig.java" />
              <option name="updatedContent" value="package com.ctuconnect.config;&#10;&#10;import feign.Logger;&#10;import feign.Request;&#10;import feign.Retryer;&#10;import feign.codec.ErrorDecoder;&#10;import org.springframework.context.annotation.Bean;&#10;import org.springframework.context.annotation.Configuration;&#10;&#10;import java.util.concurrent.TimeUnit;&#10;&#10;/**&#10; * Feign client configuration for better error handling and retry mechanism&#10; */&#10;@Configuration&#10;public class FeignConfig {&#10;&#10;    @Bean&#10;    Logger.Level feignLoggerLevel() {&#10;        return Logger.Level.BASIC;&#10;    }&#10;&#10;    @Bean&#10;    public Request.Options requestOptions() {&#10;        return new Request.Options(&#10;                10, TimeUnit.SECONDS, // connect timeout&#10;                60, TimeUnit.SECONDS, // read timeout&#10;                true // follow redirects&#10;        );&#10;    }&#10;&#10;    @Bean&#10;    public Retryer retryer() {&#10;        return new Retryer.Default(&#10;                1000, // initial interval&#10;                3000, // max interval&#10;                3     // max attempts&#10;        );&#10;    }&#10;&#10;    @Bean&#10;    public ErrorDecoder errorDecoder() {&#10;        return new CustomFeignErrorDecoder();&#10;    }&#10;&#10;    /**&#10;     * Custom error decoder to handle service communication errors gracefully&#10;     */&#10;    public static class CustomFeignErrorDecoder implements ErrorDecoder {&#10;        &#10;        @Override&#10;        public Exception decode(String methodKey, feign.Response response) {&#10;            switch (response.status()) {&#10;                case 400:&#10;                    return new IllegalArgumentException(&quot;Bad Request: &quot; + methodKey);&#10;                case 404:&#10;                    return new RuntimeException(&quot;Service not found: &quot; + methodKey);&#10;                case 500:&#10;                    return new RuntimeException(&quot;Internal Server Error in &quot; + methodKey);&#10;                case 503:&#10;                    return new RuntimeException(&quot;Service Unavailable: &quot; + methodKey);&#10;                default:&#10;                    return new RuntimeException(&quot;Unknown error occurred in &quot; + methodKey + &quot;: &quot; + response.status());&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/config/HealthCheckConfig.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/config/HealthCheckConfig.java" />
              <option name="updatedContent" value="package com.ctuconnect.config;&#10;&#10;import org.springframework.boot.actuator.health.Health;&#10;import org.springframework.boot.actuator.health.HealthIndicator;&#10;import org.springframework.context.annotation.Bean;&#10;import org.springframework.context.annotation.Configuration;&#10;import org.springframework.data.redis.connection.RedisConnectionFactory;&#10;import org.springframework.data.mongodb.core.MongoTemplate;&#10;&#10;@Configuration&#10;public class HealthCheckConfig {&#10;    &#10;    @Bean&#10;    public HealthIndicator redisHealthIndicator(RedisConnectionFactory redisConnectionFactory) {&#10;        return () -&gt; {&#10;            try {&#10;                redisConnectionFactory.getConnection().ping();&#10;                return Health.up()&#10;                    .withDetail(&quot;redis&quot;, &quot;Available&quot;)&#10;                    .build();&#10;            } catch (Exception e) {&#10;                return Health.down()&#10;                    .withDetail(&quot;redis&quot;, &quot;Unavailable&quot;)&#10;                    .withDetail(&quot;error&quot;, e.getMessage())&#10;                    .build();&#10;            }&#10;        };&#10;    }&#10;    &#10;    @Bean&#10;    public HealthIndicator mongoHealthIndicator(MongoTemplate mongoTemplate) {&#10;        return () -&gt; {&#10;            try {&#10;                mongoTemplate.getCollection(&quot;health_check&quot;).countDocuments();&#10;                return Health.up()&#10;                    .withDetail(&quot;mongodb&quot;, &quot;Available&quot;)&#10;                    .build();&#10;            } catch (Exception e) {&#10;                return Health.down()&#10;                    .withDetail(&quot;mongodb&quot;, &quot;Unavailable&quot;)&#10;                    .withDetail(&quot;error&quot;, e.getMessage())&#10;                    .build();&#10;            }&#10;        };&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/config/WebConfig.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/config/WebConfig.java" />
              <option name="updatedContent" value="package com.ctuconnect.config;&#10;&#10;import com.ctuconnect.security.AuthenticationInterceptor;&#10;import lombok.RequiredArgsConstructor;&#10;import org.springframework.context.annotation.Configuration;&#10;import org.springframework.web.servlet.config.annotation.InterceptorRegistry;&#10;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;&#10;&#10;/**&#10; * Web configuration to register security interceptors&#10; */&#10;@Configuration&#10;@RequiredArgsConstructor&#10;public class WebConfig implements WebMvcConfigurer {&#10;&#10;    private final AuthenticationInterceptor authenticationInterceptor;&#10;&#10;    @Override&#10;    public void addInterceptors(InterceptorRegistry registry) {&#10;        registry.addInterceptor(authenticationInterceptor)&#10;                .addPathPatterns(&quot;/api/**&quot;) // Apply to all API endpoints&#10;                .excludePathPatterns(&#10;                        &quot;/api/posts/health&quot;,&#10;                        &quot;/api/posts/actuator/**&quot;,&#10;                        &quot;/api/posts/swagger-ui/**&quot;,&#10;                        &quot;/api/posts/v3/api-docs/**&quot;&#10;                );&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/config/WebSocketConfig.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/config/WebSocketConfig.java" />
              <option name="updatedContent" value="package com.ctuconnect.config;&#10;&#10;import org.springframework.context.annotation.Configuration;&#10;import org.springframework.messaging.simp.config.MessageBrokerRegistry;&#10;import org.springframework.web.socket.config.annotation.EnableWebSocketMessageBroker;&#10;import org.springframework.web.socket.config.annotation.StompEndpointRegistry;&#10;import org.springframework.web.socket.config.annotation.WebSocketMessageBrokerConfigurer;&#10;&#10;@Configuration&#10;@EnableWebSocketMessageBroker&#10;public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {&#10;&#10;    @Override&#10;    public void configureMessageBroker(MessageBrokerRegistry config) {&#10;        // Enable simple message broker for in-memory message handling&#10;        config.enableSimpleBroker(&quot;/topic&quot;, &quot;/queue&quot;);&#10;        config.setApplicationDestinationPrefixes(&quot;/app&quot;);&#10;        config.setUserDestinationPrefix(&quot;/user&quot;);&#10;    }&#10;&#10;    @Override&#10;    public void registerStompEndpoints(StompEndpointRegistry registry) {&#10;        // Register STOMP endpoints for WebSocket connections&#10;        registry.addEndpoint(&quot;/ws&quot;)&#10;                .setAllowedOriginPatterns(&quot;*&quot;)&#10;                .withSockJS();&#10;        &#10;        registry.addEndpoint(&quot;/ws-notifications&quot;)&#10;                .setAllowedOriginPatterns(&quot;*&quot;)&#10;                .withSockJS();&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/controller/EnhancedPostController.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/controller/EnhancedPostController.java" />
              <option name="updatedContent" value="// This file has been merged into PostController.java&#10;// Delete this file to avoid conflicts" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/repository/CommentRepository.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/repository/CommentRepository.java" />
              <option name="originalContent" value="package com.ctuconnect.repository;&#10;&#10;import org.springframework.data.domain.Page;&#10;import org.springframework.data.domain.Pageable;&#10;import org.springframework.data.mongodb.repository.MongoRepository;&#10;import org.springframework.data.mongodb.repository.Query;&#10;import org.springframework.stereotype.Repository;&#10;import com.ctuconnect.entity.CommentEntity;&#10;&#10;import java.util.List;&#10;&#10;@Repository&#10;public interface CommentRepository extends MongoRepository&lt;CommentEntity, String&gt; {&#10;&#10;    Page&lt;CommentEntity&gt; findByPostId(String postId, Pageable pageable);&#10;&#10;    List&lt;CommentEntity&gt; findByPostIdAndParentCommentIdIsNull(String postId);&#10;&#10;    List&lt;CommentEntity&gt; findByParentCommentId(String parentCommentId);&#10;&#10;    long countByPostId(String postId);&#10;&#10;    // Fix: Use MongoDB query for nested author object&#10;    @Query(value = &quot;{ 'author.id': ?0 }&quot;, count = true)&#10;    long countByAuthor_Id(String authorId);&#10;&#10;    void deleteByPostId(String postId);&#10;&#10;    // Additional useful queries for nested author structure&#10;    @Query(&quot;{ 'author.id': ?0 }&quot;)&#10;    Page&lt;CommentEntity&gt; findByAuthor_Id(String authorId, Pageable pageable);&#10;&#10;    // Add method that AdminController is calling (without underscore)&#10;    @Query(value = &quot;{ 'author.id': ?0 }&quot;, count = true)&#10;    long countByAuthorId(String authorId);&#10;}&#10;" />
              <option name="updatedContent" value="package com.ctuconnect.repository;&#13;&#10;&#13;&#10;import org.springframework.data.domain.Page;&#13;&#10;import org.springframework.data.domain.Pageable;&#13;&#10;import org.springframework.data.mongodb.repository.MongoRepository;&#13;&#10;import org.springframework.data.mongodb.repository.Query;&#13;&#10;import org.springframework.stereotype.Repository;&#13;&#10;import com.ctuconnect.entity.CommentEntity;&#13;&#10;&#13;&#10;import java.util.List;&#13;&#10;&#13;&#10;@Repository&#13;&#10;public interface CommentRepository extends MongoRepository&lt;CommentEntity, String&gt; {&#13;&#10;&#13;&#10;    Page&lt;CommentEntity&gt; findByPostId(String postId, Pageable pageable);&#13;&#10;&#13;&#10;    List&lt;CommentEntity&gt; findByPostIdAndParentCommentIdIsNull(String postId);&#13;&#10;&#13;&#10;    List&lt;CommentEntity&gt; findByParentCommentId(String parentCommentId);&#13;&#10;&#13;&#10;    long countByPostId(String postId);&#13;&#10;&#13;&#10;    // Fix: Use MongoDB query for nested author object&#13;&#10;    @Query(value = &quot;{ 'author.id': ?0 }&quot;, count = true)&#13;&#10;    long countByAuthor_Id(String authorId);&#13;&#10;&#13;&#10;    void deleteByPostId(String postId);&#13;&#10;&#13;&#10;    // Additional useful queries for nested author structure&#13;&#10;    @Query(&quot;{ 'author.id': ?0 }&quot;)&#13;&#10;    Page&lt;CommentEntity&gt; findByAuthor_Id(String authorId, Pageable pageable);&#13;&#10;&#13;&#10;    // Add method that AdminController is calling (without underscore)&#13;&#10;    @Query(value = &quot;{ 'author.id': ?0 }&quot;, count = true)&#13;&#10;    long countByAuthorId(String authorId);&#13;&#10;&#13;&#10;    // Method for user profile synchronization - find all comments by author ID&#13;&#10;    @Query(&quot;{ 'author.id': ?0 }&quot;)&#13;&#10;    List&lt;CommentEntity&gt; findByAuthor_Id(String authorId);&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/service/UserServiceClient.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/service/UserServiceClient.java" />
              <option name="updatedContent" value="package com.ctuconnect.service;&#10;&#10;import org.springframework.cloud.openfeign.FeignClient;&#10;import org.springframework.web.bind.annotation.GetMapping;&#10;import org.springframework.web.bind.annotation.PathVariable;&#10;&#10;import java.util.Set;&#10;&#10;@FeignClient(name = &quot;user-service&quot;, url = &quot;${user-service.url:http://user-service:8081}&quot;)&#10;public interface UserServiceClient {&#10;    &#10;    @GetMapping(&quot;/api/users/{userId}/friends/ids&quot;)&#10;    Set&lt;String&gt; getFriendIds(@PathVariable String userId);&#10;    &#10;    @GetMapping(&quot;/api/users/{userId}/close-interactions&quot;)&#10;    Set&lt;String&gt; getCloseInteractionIds(@PathVariable String userId);&#10;    &#10;    @GetMapping(&quot;/api/users/{userId}/same-faculty&quot;)&#10;    Set&lt;String&gt; getSameFacultyUserIds(@PathVariable String userId);&#10;    &#10;    @GetMapping(&quot;/api/users/{userId}/same-major&quot;)&#10;    Set&lt;String&gt; getSameMajorUserIds(@PathVariable String userId);&#10;    &#10;    @GetMapping(&quot;/api/users/{userId}/interest-tags&quot;)&#10;    Set&lt;String&gt; getUserInterestTags(@PathVariable String userId);&#10;    &#10;    @GetMapping(&quot;/api/users/{userId}/preferred-categories&quot;)&#10;    Set&lt;String&gt; getUserPreferredCategories(@PathVariable String userId);&#10;    &#10;    @GetMapping(&quot;/api/users/{userId}/faculty-id&quot;)&#10;    String getUserFacultyId(@PathVariable String userId);&#10;    &#10;    @GetMapping(&quot;/api/users/{userId}/major-id&quot;)&#10;    String getUserMajorId(@PathVariable String userId);&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/post-service/src/main/resources/application-docker.properties">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/post-service/src/main/resources/application-docker.properties" />
              <option name="originalContent" value="# Docker-specific configuration for post-service&#10;spring.application.name=post-service&#10;server.port=8085&#10;&#10;# MongoDB Configuration - Docker service name&#10;spring.data.mongodb.database=post_db&#10;spring.data.mongodb.host=post_db&#10;spring.data.mongodb.port=27017&#10;&#10;# Redis Configuration - Docker service name&#10;spring.data.redis.host=redis&#10;spring.data.redis.port=6379&#10;spring.data.redis.timeout=60000ms&#10;spring.data.redis.lettuce.pool.max-active=8&#10;spring.data.redis.lettuce.pool.max-idle=8&#10;spring.data.redis.lettuce.pool.min-idle=0&#10;&#10;# Kafka Configuration - Docker service name&#10;spring.kafka.bootstrap-servers=kafka:9092&#10;spring.kafka.producer.key-serializer=org.apache.kafka.common.serialization.StringSerializer&#10;spring.kafka.producer.value-serializer=org.springframework.kafka.support.serializer.JsonSerializer&#10;&#10;spring.kafka.consumer.group-id=post-service-group&#10;spring.kafka.consumer.key-deserializer=org.apache.kafka.common.serialization.StringDeserializer&#10;spring.kafka.consumer.value-deserializer=org.springframework.kafka.support.serializer.JsonDeserializer&#10;spring.kafka.consumer.properties.spring.json.trusted.packages=*&#10;spring.kafka.consumer.auto-offset-reset=earliest&#10;spring.kafka.consumer.enable-auto-commit=true&#10;&#10;# Eureka Configuration - Docker service name&#10;eureka.client.service-url.defaultZone=http://eureka-server:8761/eureka/&#10;eureka.instance.prefer-ip-address=true&#10;eureka.instance.instance-id=${spring.application.name}:${server.port}&#10;&#10;# Media Service Configuration - Docker service name&#10;media-service.url=http://media-service:8084&#10;&#10;# File Upload Configuration&#10;spring.servlet.multipart.max-file-size=10MB&#10;spring.servlet.multipart.max-request-size=50MB&#10;&#10;# Actuator Configuration&#10;management.endpoints.web.exposure.include=health,info,metrics&#10;management.endpoint.health.show-details=always&#10;&#10;# Logging Configuration&#10;logging.level.com.ctuconnect=DEBUG&#10;logging.level.org.springframework.kafka=INFO&#10;logging.level.org.springframework.data.mongodb=INFO&#10;" />
              <option name="updatedContent" value="# Docker-specific configuration for post-service&#13;&#10;spring.application.name=post-service&#13;&#10;server.port=8085&#13;&#10;&#13;&#10;# MongoDB Configuration - Docker service name&#13;&#10;spring.data.mongodb.database=post_db&#13;&#10;spring.data.mongodb.host=post_db&#13;&#10;spring.data.mongodb.port=27017&#13;&#10;&#13;&#10;# Redis Configuration - Docker service name&#13;&#10;spring.data.redis.host=redis&#13;&#10;spring.data.redis.port=6379&#13;&#10;spring.data.redis.timeout=60000ms&#13;&#10;spring.data.redis.lettuce.pool.max-active=8&#13;&#10;spring.data.redis.lettuce.pool.min-idle=0&#13;&#10;&#13;&#10;# Kafka Configuration - Docker service name&#13;&#10;spring.kafka.bootstrap-servers=kafka:9092&#13;&#10;spring.kafka.producer.key-serializer=org.apache.kafka.common.serialization.StringSerializer&#13;&#10;spring.kafka.producer.value-serializer=org.springframework.kafka.support.serializer.JsonSerializer&#13;&#10;&#13;&#10;spring.kafka.consumer.group-id=post-service-group&#13;&#10;spring.kafka.consumer.key-deserializer=org.apache.kafka.common.serialization.StringDeserializer&#13;&#10;spring.kafka.consumer.value-deserializer=org.springframework.kafka.support.serializer.JsonDeserializer&#13;&#10;spring.kafka.consumer.properties.spring.json.trusted.packages=*&#13;&#10;spring.kafka.consumer.auto-offset-reset=earliest&#13;&#10;spring.kafka.consumer.enable-auto-commit=true&#13;&#10;&#13;&#10;# Eureka Configuration - Docker service name&#13;&#10;eureka.client.service-url.defaultZone=http://eureka-server:8761/eureka/&#13;&#10;eureka.instance.prefer-ip-address=true&#13;&#10;eureka.instance.instance-id=${spring.application.name}:${server.port}&#13;&#10;&#13;&#10;# User Service Configuration - Docker service name&#13;&#10;user-service.url=http://user-service:8081&#13;&#10;&#13;&#10;# Media Service Configuration - Docker service name&#13;&#10;media-service.url=http://media-service:8084&#13;&#10;&#13;&#10;# Feign Configuration&#13;&#10;feign.client.config.default.connect-timeout=10000&#13;&#10;feign.client.config.default.read-timeout=10000&#13;&#10;feign.client.config.default.logger-level=basic&#13;&#10;&#13;&#10;# File Upload Configuration&#13;&#10;spring.servlet.multipart.max-file-size=10MB&#13;&#10;spring.servlet.multipart.max-request-size=50MB&#13;&#10;&#13;&#10;# Actuator Configuration&#13;&#10;management.endpoints.web.exposure.include=health,info,metrics&#13;&#10;management.endpoint.health.show-details=always&#13;&#10;&#13;&#10;# Logging Configuration&#13;&#10;logging.level.com.ctuconnect=DEBUG&#13;&#10;logging.level.org.springframework.kafka=INFO&#13;&#10;logging.level.org.springframework.data.mongodb=INFO" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/post-service/src/main/resources/application.properties">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/post-service/src/main/resources/application.properties" />
              <option name="originalContent" value="spring.application.name=post-service&#10;server.port=8085&#10;&#10;# MongoDB Configuration&#10;spring.data.mongodb.database=post_db&#10;spring.data.mongodb.host=localhost&#10;spring.data.mongodb.port=27018&#10;&#10;# Kafka Configuration&#10;spring.kafka.bootstrap-servers=localhost:9092&#10;spring.kafka.producer.key-serializer=org.apache.kafka.common.serialization.StringSerializer&#10;spring.kafka.producer.value-serializer=org.springframework.kafka.support.serializer.JsonSerializer&#10;&#10;# Kafka Consumer Configuration - Fix missing group-id error&#10;spring.kafka.consumer.group-id=post-service-group&#10;spring.kafka.consumer.key-deserializer=org.apache.kafka.common.serialization.StringDeserializer&#10;spring.kafka.consumer.value-deserializer=org.springframework.kafka.support.serializer.JsonDeserializer&#10;spring.kafka.consumer.properties.spring.json.trusted.packages=*&#10;spring.kafka.consumer.auto-offset-reset=earliest&#10;spring.kafka.consumer.enable-auto-commit=true&#10;&#10;# Eureka Configuration&#10;eureka.client.service-url.defaultZone=http://localhost:8761/eureka/&#10;eureka.instance.prefer-ip-address=true&#10;eureka.instance.instance-id=${spring.application.name}:${server.port}&#10;&#10;# Redis Configuration - Fix for Docker container networking&#10;spring.data.redis.host=redis&#10;spring.data.redis.port=6379&#10;spring.data.redis.timeout=60000ms&#10;spring.data.redis.lettuce.pool.max-active=8&#10;spring.data.redis.lettuce.pool.max-idle=8&#10;spring.data.redis.lettuce.pool.min-idle=0&#10;&#10;# Media Service Configuration&#10;media-service.url=http://localhost:8084&#10;&#10;# File Upload Configuration&#10;spring.servlet.multipart.max-file-size=10MB&#10;spring.servlet.multipart.max-request-size=50MB&#10;&#10;# Actuator Configuration&#10;management.endpoints.web.exposure.include=health,info,metrics&#10;management.endpoint.health.show-details=always&#10;&#10;# Logging Configuration&#10;logging.level.vn.ctu.edu.postservice=DEBUG&#10;logging.level.org.springframework.kafka=INFO&#10;logging.level.org.springframework.data.mongodb=INFO&#10;" />
              <option name="updatedContent" value="spring.application.name=post-service&#10;server.port=8085&#10;&#10;# MongoDB Configuration&#10;spring.data.mongodb.database=post_db&#10;spring.data.mongodb.host=localhost&#10;spring.data.mongodb.port=27018&#10;&#10;# Kafka Configuration&#10;spring.kafka.bootstrap-servers=localhost:9092&#10;spring.kafka.producer.key-serializer=org.apache.kafka.common.serialization.StringSerializer&#10;spring.kafka.producer.value-serializer=org.springframework.kafka.support.serializer.JsonSerializer&#10;&#10;# Kafka Consumer Configuration - Fix missing group-id error&#10;spring.kafka.consumer.group-id=post-service-group&#10;spring.kafka.consumer.key-deserializer=org.apache.kafka.common.serialization.StringDeserializer&#10;spring.kafka.consumer.value-deserializer=org.springframework.kafka.support.serializer.JsonDeserializer&#10;spring.kafka.consumer.properties.spring.json.trusted.packages=*&#10;spring.kafka.consumer.auto-offset-reset=earliest&#10;spring.kafka.consumer.enable-auto-commit=true&#10;&#10;# Eureka Configuration&#10;eureka.client.service-url.defaultZone=http://localhost:8761/eureka/&#10;eureka.instance.prefer-ip-address=true&#10;eureka.instance.instance-id=${spring.application.name}:${server.port}&#10;&#10;# Redis Configuration - Fix for Docker container networking&#10;spring.data.redis.host=redis&#10;spring.data.redis.port=6379&#10;spring.data.redis.timeout=60000ms&#10;spring.data.redis.lettuce.pool.max-active=8&#10;spring.data.redis.lettuce.pool.max-idle=8&#10;spring.data.redis.lettuce.pool.min-idle=0&#10;&#10;# User Service Configuration&#10;user-service.url=http://localhost:8081&#10;&#10;# Media Service Configuration&#10;media-service.url=http://localhost:8084&#10;&#10;# Feign Configuration&#10;feign.client.config.default.connect-timeout=5000&#10;feign.client.config.default.read-timeout=5000&#10;feign.client.config.default.logger-level=basic&#10;&#10;# File Upload Configuration&#10;spring.servlet.multipart.max-file-size=10MB&#10;spring.servlet.multipart.max-request-size=50MB&#10;&#10;# Actuator Configuration&#10;management.endpoints.web.exposure.include=health,info,metrics&#10;management.endpoint.health.show-details=always&#10;&#10;# Logging Configuration&#10;logging.level.vn.ctu.edu.postservice=DEBUG&#10;logging.level.org.springframework.kafka=INFO&#10;logging.level.org.springframework.data.mongodb=INFO" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/user-service/src/main/java/com/ctuconnect/controller/UserSyncController.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/user-service/src/main/java/com/ctuconnect/controller/UserSyncController.java" />
              <option name="originalContent" value="package com.ctuconnect.controller;&#10;&#10;import com.ctuconnect.dto.AuthorDTO;&#10;import com.ctuconnect.dto.UserDTO;&#10;import com.ctuconnect.security.annotation.RequireAuth;&#10;import com.ctuconnect.service.UserSyncService;&#10;import com.ctuconnect.service.UserService;&#10;import org.springframework.beans.factory.annotation.Autowired;&#10;import org.springframework.http.ResponseEntity;&#10;import org.springframework.web.bind.annotation.*;&#10;&#10;import java.util.Set;&#10;&#10;/**&#10; * Controller để xử lý đồng bộ dữ liệu giữa auth-db và user-db&#10; * Các endpoint này được gọi từ auth-service hoặc các microservices khác&#10; */&#10;@RestController&#10;@RequestMapping(&quot;/api/users/sync&quot;)&#10;public class UserSyncController {&#10;&#10;    @Autowired&#10;    private UserSyncService userSyncService;&#10;&#10;    @Autowired&#10;    private UserService userService;&#10;&#10;    /**&#10;     * Tạo user profile trong user-db khi user được tạo ở auth-db&#10;     * Endpoint này được gọi từ auth-service&#10;     */&#10;    @PostMapping(&quot;/create&quot;)&#10;    @RequireAuth(roles = {&quot;SYSTEM&quot;, &quot;ADMIN&quot;}) // Chỉ system hoặc admin mới có thể gọi&#10;    public ResponseEntity&lt;UserDTO&gt; syncUserFromAuth(&#10;            @RequestParam String userId,&#10;            @RequestParam String email,&#10;            @RequestParam String role) {&#10;        UserDTO userDTO = userSyncService.syncUserFromAuth(userId, email, role);&#10;        return ResponseEntity.ok(userDTO);&#10;    }&#10;&#10;    /**&#10;     * Cập nhật thông tin user khi có thay đổi từ auth-db&#10;     */&#10;    @PutMapping(&quot;/update&quot;)&#10;    @RequireAuth(roles = {&quot;SYSTEM&quot;, &quot;ADMIN&quot;})&#10;    public ResponseEntity&lt;UserDTO&gt; updateUserFromAuth(&#10;            @RequestParam String userId,&#10;            @RequestParam String email,&#10;            @RequestParam String role) {&#10;        UserDTO userDTO = userSyncService.updateUserFromAuth(userId, email, role);&#10;        return ResponseEntity.ok(userDTO);&#10;    }&#10;&#10;    /**&#10;     * Xóa user khỏi user-db khi user bị xóa ở auth-db&#10;     */&#10;    @DeleteMapping(&quot;/delete&quot;)&#10;    @RequireAuth(roles = {&quot;SYSTEM&quot;, &quot;ADMIN&quot;})&#10;    public ResponseEntity&lt;String&gt; deleteUserFromAuth(@RequestParam String userId) {&#10;        userSyncService.deleteUserFromAuth(userId);&#10;        return ResponseEntity.ok(&quot;User deleted from user database successfully&quot;);&#10;    }&#10;&#10;    /**&#10;     * Kiểm tra tính nhất quán dữ liệu giữa auth-db và user-db&#10;     */&#10;    @GetMapping(&quot;/check&quot;)&#10;    @RequireAuth(roles = {&quot;SYSTEM&quot;, &quot;ADMIN&quot;})&#10;    public ResponseEntity&lt;Boolean&gt; checkUserSync(&#10;            @RequestParam String userId,&#10;            @RequestParam String email,&#10;            @RequestParam String role) {&#10;        boolean isSynced = userSyncService.isUserSynced(userId, email, role);&#10;        return ResponseEntity.ok(isSynced);&#10;    }&#10;&#10;    /**&#10;     * Lấy thông tin tác giả cho post-service&#10;     * Endpoint này được gọi từ post-service để lấy author info&#10;     */&#10;    @GetMapping(&quot;/authors/{id}&quot;)&#10;    public ResponseEntity&lt;AuthorDTO&gt; getAuthorInfo(@PathVariable(&quot;id&quot;) String authorId) {&#10;        AuthorDTO authorInfo = userSyncService.getAuthorInfo(authorId);&#10;        return ResponseEntity.ok(authorInfo);&#10;    }&#10;&#10;    /**&#10;     * Lấy danh sách ID bạn bè của user&#10;     * Endpoint này được gọi từ post-service cho news feed algorithm&#10;     */&#10;    @GetMapping(&quot;/{userId}/friends/ids&quot;)&#10;    public ResponseEntity&lt;Set&lt;String&gt;&gt; getFriendIds(@PathVariable(&quot;userId&quot;) String userId) {&#10;        Set&lt;String&gt; friendIds = userService.getFriendIds(userId);&#10;        return ResponseEntity.ok(friendIds);&#10;    }&#10;&#10;    /**&#10;     * Lấy danh sách user có tương tác gần với user&#10;     * Endpoint này được gọi từ post-service cho news feed algorithm&#10;     */&#10;    @GetMapping(&quot;/{userId}/close-interactions&quot;)&#10;    public ResponseEntity&lt;Set&lt;String&gt;&gt; getCloseInteractionIds(@PathVariable(&quot;userId&quot;) String userId) {&#10;        Set&lt;String&gt; closeInteractionIds = userService.getCloseInteractionIds(userId);&#10;        return ResponseEntity.ok(closeInteractionIds);&#10;    }&#10;&#10;    /**&#10;     * Lấy danh sách user cùng khoa&#10;     * Endpoint này được gọi từ post-service cho news feed algorithm&#10;     */&#10;    @GetMapping(&quot;/{userId}/same-faculty&quot;)&#10;    public ResponseEntity&lt;Set&lt;String&gt;&gt; getSameFacultyUserIds(@PathVariable(&quot;userId&quot;) String userId) {&#10;        Set&lt;String&gt; sameFacultyIds = userService.getSameFacultyUserIds(userId);&#10;        return ResponseEntity.ok(sameFacultyIds);&#10;    }&#10;&#10;    /**&#10;     * Lấy danh sách user cùng ngành&#10;     * Endpoint này được gọi từ post-service cho news feed algorithm&#10;     */&#10;    @GetMapping(&quot;/{userId}/same-major&quot;)&#10;    public ResponseEntity&lt;Set&lt;String&gt;&gt; getSameMajorUserIds(@PathVariable(&quot;userId&quot;) String userId) {&#10;        Set&lt;String&gt; sameMajorIds = userService.getSameMajorUserIds(userId);&#10;        return ResponseEntity.ok(sameMajorIds);&#10;    }&#10;&#10;    /**&#10;     * Lấy danh sách interest tags của user&#10;     * Endpoint này được gọi từ post-service cho content recommendation&#10;     */&#10;    @GetMapping(&quot;/{userId}/interest-tags&quot;)&#10;    public ResponseEntity&lt;Set&lt;String&gt;&gt; getUserInterestTags(@PathVariable(&quot;userId&quot;) String userId) {&#10;        Set&lt;String&gt; interestTags = userService.getUserInterestTags(userId);&#10;        return ResponseEntity.ok(interestTags);&#10;    }&#10;&#10;    /**&#10;     * Lấy danh sách preferred categories của user&#10;     * Endpoint này được gọi từ post-service cho content filtering&#10;     */&#10;    @GetMapping(&quot;/{userId}/preferred-categories&quot;)&#10;    public ResponseEntity&lt;Set&lt;String&gt;&gt; getUserPreferredCategories(@PathVariable(&quot;userId&quot;) String userId) {&#10;        Set&lt;String&gt; preferredCategories = userService.getUserPreferredCategories(userId);&#10;        return ResponseEntity.ok(preferredCategories);&#10;    }&#10;&#10;    /**&#10;     * Lấy faculty ID của user&#10;     * Endpoint này được gọi từ post-service cho group filtering&#10;     */&#10;    @GetMapping(&quot;/{userId}/faculty-id&quot;)&#10;    public ResponseEntity&lt;String&gt; getUserFacultyId(@PathVariable(&quot;userId&quot;) String userId) {&#10;        String facultyId = userService.getUserFacultyId(userId);&#10;        return ResponseEntity.ok(facultyId);&#10;    }&#10;&#10;    /**&#10;     * Lấy major ID của user&#10;     * Endpoint này được gọi từ post-service cho group filtering&#10;     */&#10;    @GetMapping(&quot;/{userId}/major-id&quot;)&#10;    public ResponseEntity&lt;String&gt; getUserMajorId(@PathVariable(&quot;userId&quot;) String userId) {&#10;        String majorId = userService.getUserMajorId(userId);&#10;        return ResponseEntity.ok(majorId);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.ctuconnect.controller;&#10;&#10;import com.ctuconnect.dto.AuthorDTO;&#10;import com.ctuconnect.dto.UserDTO;&#10;import com.ctuconnect.security.annotation.RequireAuth;&#10;import com.ctuconnect.service.UserSyncService;&#10;import com.ctuconnect.service.UserService;&#10;import org.springframework.beans.factory.annotation.Autowired;&#10;import org.springframework.http.ResponseEntity;&#10;import org.springframework.web.bind.annotation.*;&#10;&#10;import java.util.Set;&#10;&#10;/**&#10; * Controller để xử lý đồng bộ dữ liệu giữa auth-db và user-db&#10; * Các endpoint này được gọi từ auth-service hoặc các microservices khác&#10; */&#10;@RestController&#10;@RequestMapping(&quot;/api/users/sync&quot;)&#10;public class UserSyncController {&#10;&#10;    @Autowired&#10;    private UserSyncService userSyncService;&#10;&#10;    @Autowired&#10;    private UserService userService;&#10;&#10;    /**&#10;     * Tạo user profile trong user-db khi user được tạo ở auth-db&#10;     * Endpoint này được gọi từ auth-service&#10;     */&#10;    @PostMapping(&quot;/create&quot;)&#10;    @RequireAuth(roles = {&quot;SYSTEM&quot;, &quot;ADMIN&quot;}) // Chỉ system hoặc admin mới có thể gọi&#10;    public ResponseEntity&lt;UserDTO&gt; syncUserFromAuth(&#10;            @RequestParam String userId,&#10;            @RequestParam String email,&#10;            @RequestParam String role) {&#10;        UserDTO userDTO = userSyncService.syncUserFromAuth(userId, email, role);&#10;        return ResponseEntity.ok(userDTO);&#10;    }&#10;&#10;    /**&#10;     * Cập nhật thông tin user khi có thay đổi từ auth-db&#10;     */&#10;    @PutMapping(&quot;/update&quot;)&#10;    @RequireAuth(roles = {&quot;SYSTEM&quot;, &quot;ADMIN&quot;})&#10;    public ResponseEntity&lt;UserDTO&gt; updateUserFromAuth(&#10;            @RequestParam String userId,&#10;            @RequestParam String email,&#10;            @RequestParam String role) {&#10;        UserDTO userDTO = userSyncService.updateUserFromAuth(userId, email, role);&#10;        return ResponseEntity.ok(userDTO);&#10;    }&#10;&#10;    /**&#10;     * Xóa user khỏi user-db khi user bị xóa ở auth-db&#10;     */&#10;    @DeleteMapping(&quot;/delete&quot;)&#10;    @RequireAuth(roles = {&quot;SYSTEM&quot;, &quot;ADMIN&quot;})&#10;    public ResponseEntity&lt;String&gt; deleteUserFromAuth(@RequestParam String userId) {&#10;        userSyncService.deleteUserFromAuth(userId);&#10;        return ResponseEntity.ok(&quot;User deleted from user database successfully&quot;);&#10;    }&#10;&#10;    /**&#10;     * Kiểm tra tính nhất quán dữ liệu giữa auth-db và user-db&#10;     */&#10;    @GetMapping(&quot;/check&quot;)&#10;    @RequireAuth(roles = {&quot;SYSTEM&quot;, &quot;ADMIN&quot;})&#10;    public ResponseEntity&lt;Boolean&gt; checkUserSync(&#10;            @RequestParam String userId,&#10;            @RequestParam String email,&#10;            @RequestParam String role) {&#10;        boolean isSynced = userSyncService.isUserSynced(userId, email, role);&#10;        return ResponseEntity.ok(isSynced);&#10;    }&#10;&#10;    /**&#10;     * Lấy thông tin tác giả cho post-service&#10;     * Endpoint này được gọi từ post-service để lấy author info&#10;     * Không yêu cầu authentication vì đây là internal service call&#10;     */&#10;    @GetMapping(&quot;/authors/{id}&quot;)&#10;    public ResponseEntity&lt;AuthorDTO&gt; getAuthorInfo(@PathVariable(&quot;id&quot;) String authorId) {&#10;        AuthorDTO authorInfo = userSyncService.getAuthorInfo(authorId);&#10;        return ResponseEntity.ok(authorInfo);&#10;    }&#10;&#10;    /**&#10;     * Lấy danh sách ID bạn bè của user&#10;     * Endpoint này được gọi từ post-service cho news feed algorithm&#10;     * Không yêu cầu authentication vì đây là internal service call&#10;     */&#10;    @GetMapping(&quot;/{userId}/friends/ids&quot;)&#10;    public ResponseEntity&lt;Set&lt;String&gt;&gt; getFriendIds(@PathVariable(&quot;userId&quot;) String userId) {&#10;        Set&lt;String&gt; friendIds = userService.getFriendIds(userId);&#10;        return ResponseEntity.ok(friendIds);&#10;    }&#10;&#10;    /**&#10;     * Lấy danh sách user có tương tác gần với user&#10;     * Endpoint này được gọi từ post-service cho news feed algorithm&#10;     */&#10;    @GetMapping(&quot;/{userId}/close-interactions&quot;)&#10;    public ResponseEntity&lt;Set&lt;String&gt;&gt; getCloseInteractionIds(@PathVariable(&quot;userId&quot;) String userId) {&#10;        Set&lt;String&gt; closeInteractionIds = userService.getCloseInteractionIds(userId);&#10;        return ResponseEntity.ok(closeInteractionIds);&#10;    }&#10;&#10;    /**&#10;     * Lấy danh sách user cùng khoa&#10;     * Endpoint này được gọi từ post-service cho news feed algorithm&#10;     */&#10;    @GetMapping(&quot;/{userId}/same-faculty&quot;)&#10;    public ResponseEntity&lt;Set&lt;String&gt;&gt; getSameFacultyUserIds(@PathVariable(&quot;userId&quot;) String userId) {&#10;        Set&lt;String&gt; sameFacultyIds = userService.getSameFacultyUserIds(userId);&#10;        return ResponseEntity.ok(sameFacultyIds);&#10;    }&#10;&#10;    /**&#10;     * Lấy danh sách user cùng ngành&#10;     * Endpoint này được gọi từ post-service cho news feed algorithm&#10;     */&#10;    @GetMapping(&quot;/{userId}/same-major&quot;)&#10;    public ResponseEntity&lt;Set&lt;String&gt;&gt; getSameMajorUserIds(@PathVariable(&quot;userId&quot;) String userId) {&#10;        Set&lt;String&gt; sameMajorIds = userService.getSameMajorUserIds(userId);&#10;        return ResponseEntity.ok(sameMajorIds);&#10;    }&#10;&#10;    /**&#10;     * Lấy danh sách interest tags của user&#10;     * Endpoint này được gọi từ post-service cho content recommendation&#10;     */&#10;    @GetMapping(&quot;/{userId}/interest-tags&quot;)&#10;    public ResponseEntity&lt;Set&lt;String&gt;&gt; getUserInterestTags(@PathVariable(&quot;userId&quot;) String userId) {&#10;        Set&lt;String&gt; interestTags = userService.getUserInterestTags(userId);&#10;        return ResponseEntity.ok(interestTags);&#10;    }&#10;&#10;    /**&#10;     * Lấy danh sách preferred categories của user&#10;     * Endpoint này được gọi từ post-service cho content filtering&#10;     */&#10;    @GetMapping(&quot;/{userId}/preferred-categories&quot;)&#10;    public ResponseEntity&lt;Set&lt;String&gt;&gt; getUserPreferredCategories(@PathVariable(&quot;userId&quot;) String userId) {&#10;        Set&lt;String&gt; preferredCategories = userService.getUserPreferredCategories(userId);&#10;        return ResponseEntity.ok(preferredCategories);&#10;    }&#10;&#10;    /**&#10;     * Lấy faculty ID của user&#10;     * Endpoint này được gọi từ post-service cho group filtering&#10;     */&#10;    @GetMapping(&quot;/{userId}/faculty-id&quot;)&#10;    public ResponseEntity&lt;String&gt; getUserFacultyId(@PathVariable(&quot;userId&quot;) String userId) {&#10;        String facultyId = userService.getUserFacultyId(userId);&#10;        return ResponseEntity.ok(facultyId);&#10;    }&#10;&#10;    /**&#10;     * Lấy major ID của user&#10;     * Endpoint này được gọi từ post-service cho group filtering&#10;     */&#10;    @GetMapping(&quot;/{userId}/major-id&quot;)&#10;    public ResponseEntity&lt;String&gt; getUserMajorId(@PathVariable(&quot;userId&quot;) String userId) {&#10;        String majorId = userService.getUserMajorId(userId);&#10;        return ResponseEntity.ok(majorId);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/user-service/src/main/java/com/ctuconnect/dto/ActivityDTO.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/user-service/src/main/java/com/ctuconnect/dto/ActivityDTO.java" />
              <option name="originalContent" value="package com.ctuconnect.dto;&#10;&#10;import lombok.AllArgsConstructor;&#10;import lombok.Builder;&#10;import lombok.Data;&#10;import lombok.NoArgsConstructor;&#10;&#10;import java.time.LocalDateTime;&#10;&#10;@Data&#10;@Builder&#10;@NoArgsConstructor&#10;@AllArgsConstructor&#10;public class ActivityDTO {&#10;    private String id;&#10;    private String userId;&#10;    private String activityType; // POST_CREATED, POST_LIKED, COMMENT_ADDED, etc.&#10;    private String targetType; // POST, COMMENT, USER&#10;    private String targetId;&#10;    private String actorName;&#10;    private String actorAvatarUrl;&#10;&#10;    // For activity feed display&#10;    private String displayText;&#10;    private String actionUrl;&#10;    private boolean isRead;&#10;&#10;    public enum ActivityType {&#10;        POST_CREATED,&#10;        POST_LIKED,&#10;        POST_SHARED,&#10;        COMMENT_ADDED,&#10;        FRIEND_REQUEST_SENT,&#10;        FRIEND_REQUEST_ACCEPTED,&#10;        PROFILE_UPDATED&#10;    }&#10;&#10;    public enum TargetType {&#10;        POST,&#10;        COMMENT,&#10;        USER,&#10;        PROFILE&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.ctuconnect.dto;&#10;&#10;import lombok.AllArgsConstructor;&#10;import lombok.Builder;&#10;import lombok.Data;&#10;import lombok.NoArgsConstructor;&#10;&#10;import java.time.LocalDateTime;&#10;&#10;@Data&#10;@Builder&#10;@NoArgsConstructor&#10;@AllArgsConstructor&#10;public class ActivityDTO {&#10;    private String id;&#10;    private String userId;&#10;    private String activityType; // POST_CREATED, POST_LIKED, COMMENT_ADDED, etc.&#10;    private String targetType; // POST, COMMENT, USER&#10;    private String targetId;&#10;    private String entityType; // Add missing entityType field&#10;    private String entityId; // Add missing entityId field&#10;    private String description;&#10;    private LocalDateTime timestamp;&#10;    private String actorName;&#10;    private String actorAvatarUrl;&#10;&#10;    // For activity feed display&#10;    private String displayText;&#10;    private String actionUrl;&#10;    private boolean isRead;&#10;&#10;    public enum ActivityType {&#10;        POST_CREATED,&#10;        POST_LIKED,&#10;        POST_SHARED,&#10;        COMMENT_ADDED,&#10;        FRIEND_REQUEST_SENT,&#10;        FRIEND_REQUEST_ACCEPTED,&#10;        PROFILE_UPDATED&#10;    }&#10;&#10;    public enum TargetType {&#10;        POST,&#10;        COMMENT,&#10;        USER,&#10;        PROFILE&#10;    }&#10;&#10;    public enum EntityType {&#10;        POST,&#10;        COMMENT,&#10;        USER,&#10;        PROFILE&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/user-service/src/main/java/com/ctuconnect/dto/FriendSuggestionDTO.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/user-service/src/main/java/com/ctuconnect/dto/FriendSuggestionDTO.java" />
              <option name="updatedContent" value="package com.ctuconnect.dto;&#10;&#10;import lombok.AllArgsConstructor;&#10;import lombok.Builder;&#10;import lombok.Data;&#10;import lombok.NoArgsConstructor;&#10;&#10;@Data&#10;@AllArgsConstructor&#10;@NoArgsConstructor&#10;@Builder&#10;public class FriendSuggestionDTO {&#10;    private String userId;&#10;    private String username;&#10;    private String fullName;&#10;    private String avatarUrl;&#10;    private String bio;&#10;    &#10;    // Suggestion metadata&#10;    private int mutualFriendsCount;&#10;    private String suggestionReason;&#10;    private double relevanceScore;&#10;    private SuggestionType suggestionType;&#10;    &#10;    // Academic context&#10;    private String facultyName;&#10;    private String majorName;&#10;    private String batchYear;&#10;    &#10;    // Social context&#10;    private boolean sameCollege;&#10;    private boolean sameFaculty;&#10;    private boolean sameMajor;&#10;    private boolean sameBatch;&#10;    &#10;    public enum SuggestionType {&#10;        MUTUAL_FRIENDS,&#10;        ACADEMIC_CONNECTION,&#10;        FRIENDS_OF_FRIENDS,&#10;        PROFILE_VIEWER,&#10;        SIMILAR_INTERESTS,&#10;        LOCATION_BASED,&#10;        ACTIVITY_BASED&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/user-service/src/main/java/com/ctuconnect/event/UserEventPublisher.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/user-service/src/main/java/com/ctuconnect/event/UserEventPublisher.java" />
              <option name="updatedContent" value="package com.ctuconnect.event;&#10;&#10;import org.springframework.beans.factory.annotation.Autowired;&#10;import org.springframework.kafka.core.KafkaTemplate;&#10;import org.springframework.stereotype.Service;&#10;import com.fasterxml.jackson.databind.ObjectMapper;&#10;import lombok.extern.slf4j.Slf4j;&#10;&#10;import java.util.HashMap;&#10;import java.util.Map;&#10;&#10;/**&#10; * Service to publish user profile update events to Kafka&#10; * This notifies other services (like post-service) when user profiles are updated&#10; */&#10;@Service&#10;@Slf4j&#10;public class UserEventPublisher {&#10;&#10;    @Autowired&#10;    private KafkaTemplate&lt;String, String&gt; kafkaTemplate;&#10;&#10;    @Autowired&#10;    private ObjectMapper objectMapper;&#10;&#10;    private static final String USER_PROFILE_UPDATED_TOPIC = &quot;user-profile-updated&quot;;&#10;&#10;    /**&#10;     * Publish user profile update event&#10;     */&#10;    public void publishUserProfileUpdateEvent(String userId, String fullName, String email, String avatarUrl, String role) {&#10;        try {&#10;            Map&lt;String, Object&gt; eventData = new HashMap&lt;&gt;();&#10;            eventData.put(&quot;userId&quot;, userId);&#10;            eventData.put(&quot;fullName&quot;, fullName);&#10;            eventData.put(&quot;email&quot;, email);&#10;            eventData.put(&quot;avatarUrl&quot;, avatarUrl);&#10;            eventData.put(&quot;role&quot;, role);&#10;            eventData.put(&quot;eventType&quot;, &quot;USER_PROFILE_UPDATED&quot;);&#10;            eventData.put(&quot;timestamp&quot;, System.currentTimeMillis());&#10;&#10;            String eventMessage = objectMapper.writeValueAsString(eventData);&#10;            &#10;            kafkaTemplate.send(USER_PROFILE_UPDATED_TOPIC, userId, eventMessage);&#10;            log.info(&quot;Published user profile update event for user: {}&quot;, userId);&#10;            &#10;        } catch (Exception e) {&#10;            log.error(&quot;Failed to publish user profile update event for user {}: {}&quot;, userId, e.getMessage(), e);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Publish user profile update event with user entity data&#10;     */&#10;    public void publishUserProfileUpdateEvent(String userId, Map&lt;String, Object&gt; userData) {&#10;        try {&#10;            Map&lt;String, Object&gt; eventData = new HashMap&lt;&gt;();&#10;            eventData.put(&quot;userId&quot;, userId);&#10;            eventData.put(&quot;userData&quot;, userData);&#10;            eventData.put(&quot;eventType&quot;, &quot;USER_PROFILE_UPDATED&quot;);&#10;            eventData.put(&quot;timestamp&quot;, System.currentTimeMillis());&#10;&#10;            String eventMessage = objectMapper.writeValueAsString(eventData);&#10;            &#10;            kafkaTemplate.send(USER_PROFILE_UPDATED_TOPIC, userId, eventMessage);&#10;            log.info(&quot;Published user profile update event for user: {}&quot;, userId);&#10;            &#10;        } catch (Exception e) {&#10;            log.error(&quot;Failed to publish user profile update event for user {}: {}&quot;, userId, e.getMessage(), e);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>