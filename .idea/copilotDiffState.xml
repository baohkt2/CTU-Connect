<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/.env.example">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/.env.example" />
              <option name="updatedContent" value="# CTU Connect Environment Variables&#10;# Copy this file to .env and update values as needed&#10;&#10;# Eureka Server&#10;EUREKA_PORT=8761&#10;&#10;# API Gateway&#10;API_GATEWAY_PORT=8090&#10;&#10;# Auth Service&#10;AUTH_SERVICE_PORT=8080&#10;&#10;# User Service  &#10;USER_SERVICE_PORT=8081&#10;&#10;# Media Service&#10;MEDIA_SERVICE_PORT=8084&#10;&#10;# Database Configuration&#10;POSTGRES_USER=postgres&#10;POSTGRES_PASSWORD=password&#10;AUTH_DB_PORT=5432&#10;&#10;# Redis Configuration&#10;REDIS_PORT=6379&#10;&#10;# Recommendation Service&#10;RECOMMENDATION_SECRET_KEY=recommendation-secret-key-change-in-production&#10;&#10;# Email Configuration (for Auth Service)&#10;MAIL_HOST=smtp.gmail.com&#10;MAIL_PORT=587&#10;MAIL_USERNAME=your_email@gmail.com&#10;MAIL_PASSWORD=your_app_password&#10;&#10;# Cloudinary Configuration (for Media Service)&#10;CLOUDINARY_CLOUD_NAME=your_cloudinary_cloud_name&#10;CLOUDINARY_API_KEY=your_cloudinary_api_key&#10;CLOUDINARY_API_SECRET=your_cloudinary_api_secret" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/ARCHITECTURE_OPTIMIZATION.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ARCHITECTURE_OPTIMIZATION.md" />
              <option name="originalContent" value="# CTU-Connect Architecture Optimization Plan&#10;## Based on Facebook's Social Network Model&#10;&#10;### Current Architecture Analysis&#10;- ✅ Microservices architecture with proper service separation&#10;- ✅ Event-driven communication via Kafka&#10;- ✅ Multiple database technologies (PostgreSQL, MongoDB, Neo4j, Redis)&#10;- ✅ API Gateway for centralized routing&#10;- ✅ Service discovery with Eureka&#10;&#10;### Key Optimizations Required&#10;- Implement eventual consistency patterns&#10;#### 1. Data Consistency &amp; Flow Optimization&#10;- Implement eventual consistency patterns&#10;- Add distributed transaction management&#10;- Optimize cross-service data synchronization&#10;" />
              <option name="updatedContent" value="# CTU-Connect Architecture Optimization Plan&#10;## Based on Facebook's Social Network Model&#10;&#10;### Current Architecture Analysis&#10;- ✅ Microservices architecture with proper service separation&#10;- ✅ Event-driven communication via Kafka&#10;- ✅ Multiple database technologies (PostgreSQL, MongoDB, Neo4j, Redis)&#10;- ✅ API Gateway for centralized routing&#10;- ✅ Service discovery with Eureka&#10;&#10;## COMPLETED OPTIMIZATIONS&#10;&#10;### 1. Enhanced Data Models (Facebook-like)&#10;&#10;#### Enhanced PostEntity&#10;- **Audience Targeting**: Similar to Facebook's privacy controls with granular audience settings&#10;- **Engagement Metrics**: Real-time engagement scoring for feed ranking algorithms&#10;- **Post Types**: Support for TEXT, IMAGE, VIDEO, LINK, POLL, EVENT, SHARED&#10;- **Location Support**: Geographic tagging capabilities&#10;- **Scheduled Posts**: Ability to schedule posts for future publishing&#10;- **Edit History**: Track post modifications with timestamps&#10;&#10;#### Advanced Social Graph (Neo4j)&#10;- **Friend Suggestions**: Multi-signal algorithm using mutual friends, academic connections, profile viewers&#10;- **Relationship Types**: FRIENDS_WITH, FRIEND_REQUEST_SENT, VIEWED_PROFILE, BLOCKED&#10;- **Academic Context**: Faculty, major, and batch-based connections&#10;- **Interaction History**: Track user interactions for personalization&#10;&#10;### 2. Facebook-like News Feed Algorithm&#10;&#10;#### NewsFeedService Implementation&#10;- **Personalized Ranking**: Multi-factor scoring system&#10;  - Friend relationship weight (1.0)&#10;  - Engagement score weight (0.8)&#10;  - Recency weight (0.6)&#10;  - Content relevance weight (0.7)&#10;- **Cache Strategy**: 30-minute feed cache with intelligent invalidation&#10;- **Over-fetching**: Retrieve 3x posts for optimal ranking&#10;- **Diversity Control**: Prevent feed domination by single authors&#10;&#10;#### Feed Types&#10;- **Personalized Feed**: User-specific content based on social graph&#10;- **Trending Posts**: Engagement-based trending algorithm&#10;- **User Timeline**: Profile-specific post timeline with privacy filtering&#10;&#10;### 3. Real-time Notification System&#10;&#10;#### NotificationService Features&#10;- **Real-time WebSocket**: Instant notifications via SimpMessagingTemplate&#10;- **Event-driven**: Kafka integration for scalable notification processing&#10;- **Notification Types**: POST_LIKED, COMMENTED, SHARED, FRIEND_REQUEST, etc.&#10;- **Bulk Notifications**: Efficient handling of viral content notifications&#10;- **Unread Counters**: Redis-cached unread notification counts&#10;&#10;### 4. Data Consistency Management&#10;&#10;#### DataConsistencyService&#10;- **Eventual Consistency**: Cross-service data synchronization&#10;- **Cache Invalidation**: Smart cache invalidation on data changes&#10;- **Compensation Logic**: Failure handling and retry mechanisms&#10;- **Event Sourcing**: Kafka-based event propagation&#10;&#10;### 5. Advanced Caching Strategy&#10;&#10;#### Multi-level Caching&#10;- **Redis Caching**: &#10;  - User data (24 hours TTL)&#10;  - Posts (6 hours TTL)&#10;  - Friend suggestions (6 hours TTL)&#10;  - News feed (30 minutes TTL)&#10;- **Application-level**: In-memory caching for frequently accessed data&#10;- **Database-level**: Optimized queries and indexing&#10;&#10;### 6. Social Graph Optimization&#10;&#10;#### SocialGraphService Features&#10;- **Friend Suggestions Algorithm**:&#10;  - Mutual friends (highest priority)&#10;  - Academic connections (faculty/major/batch)&#10;  - Friends of friends&#10;  - Profile viewers&#10;  - Similar interests&#10;- **Relevance Scoring**: Multi-factor relevance calculation&#10;- **Cache Management**: 6-hour TTL with smart invalidation&#10;&#10;### 7. Performance Enhancements&#10;&#10;#### Database Optimizations&#10;- **MongoDB**: Compound indexes for posts, engagement-based sorting&#10;- **Neo4j**: Optimized Cypher queries for relationship traversal&#10;- **PostgreSQL**: Proper indexing for auth and media services&#10;- **Redis**: Strategic caching and session management&#10;&#10;#### API Optimizations&#10;- **Pagination**: Consistent pagination across all endpoints&#10;- **Bulk Operations**: Efficient batch processing for notifications&#10;- **Async Processing**: CompletableFuture for non-blocking operations&#10;&#10;### 8. Enhanced Security &amp; Privacy&#10;&#10;#### Privacy Controls&#10;- **Audience Settings**: PUBLIC, FRIENDS, CUSTOM, ONLY_ME&#10;- **Academic Targeting**: Faculty/major/batch-specific visibility&#10;- **Block Lists**: User blocking functionality&#10;- **Profile Privacy**: Granular profile visibility controls&#10;&#10;### 9. Real-time Features&#10;&#10;#### WebSocket Integration&#10;- **Live Notifications**: Real-time notification delivery&#10;- **Activity Status**: User online/offline status tracking&#10;- **Real-time Comments**: Live comment updates on posts&#10;&#10;### 10. Monitoring &amp; Health Checks&#10;&#10;#### System Monitoring&#10;- **Health Indicators**: Redis, MongoDB, Neo4j health checks&#10;- **Performance Metrics**: Engagement rates, cache hit ratios&#10;- **Error Tracking**: Comprehensive logging and error handling&#10;&#10;## IMPLEMENTATION SUMMARY&#10;&#10;### New Services Created&#10;1. **NewsFeedService** - Facebook-like feed generation&#10;2. **NotificationService** - Real-time notification system&#10;3. **SocialGraphService** - Advanced friend suggestions&#10;4. **DataConsistencyService** - Cross-service data synchronization&#10;&#10;### Enhanced Controllers&#10;1. **EnhancedPostController** - Advanced post management&#10;2. **EnhancedUserController** - Social graph operations&#10;&#10;### Data Models Enhanced&#10;- **PostEntity** - Facebook-like post features&#10;- **NotificationEntity** - Rich notification system&#10;- **FriendSuggestionDTO** - Comprehensive suggestion data&#10;&#10;### Configuration Added&#10;- **CacheConfig** - Multi-level caching strategy&#10;- **HealthCheckConfig** - System health monitoring&#10;&#10;## FACEBOOK-INSPIRED FEATURES IMPLEMENTED&#10;&#10;### Content &amp; Engagement&#10;✅ **News Feed Algorithm** - Personalized content ranking&#10;✅ **Post Types** - Text, image, video, link, poll support&#10;✅ **Reactions System** - Like, love, laugh, etc.&#10;✅ **Comments &amp; Replies** - Threaded comment system&#10;✅ **Share Functionality** - Post sharing with attribution&#10;✅ **Trending Posts** - Viral content discovery&#10;&#10;### Social Features&#10;✅ **Friend Suggestions** - Multi-signal recommendation engine&#10;✅ **Mutual Friends** - Connection discovery&#10;✅ **Academic Networks** - University-specific connections&#10;✅ **People You May Know** - Profile viewer suggestions&#10;✅ **Friend Requests** - Connection management&#10;&#10;### Privacy &amp; Security&#10;✅ **Audience Controls** - Granular post visibility&#10;✅ **Academic Targeting** - Faculty/major-based sharing&#10;✅ **Block/Unblock** - User blocking system&#10;✅ **Profile Privacy** - Customizable profile visibility&#10;&#10;### Real-time Features&#10;✅ **Live Notifications** - Instant activity updates  &#10;✅ **Real-time Comments** - Live comment updates&#10;✅ **Activity Status** - Online presence tracking&#10;✅ **WebSocket Integration** - Real-time communication&#10;&#10;### Performance &amp; Scale&#10;✅ **Multi-level Caching** - Redis + application caching&#10;✅ **Event-driven Architecture** - Kafka message streaming&#10;✅ **Database Optimization** - Proper indexing and queries&#10;✅ **Load Balancing Ready** - Horizontal scaling support&#10;&#10;## DEPLOYMENT RECOMMENDATIONS&#10;&#10;### 1. Database Scaling&#10;- **MongoDB Sharding** for post data&#10;- **Neo4j Clustering** for social graph&#10;- **Redis Clustering** for caching layer&#10;&#10;### 2. Performance Monitoring&#10;- Implement APM tools (New Relic, DataDog)&#10;- Set up alerts for cache hit ratios&#10;- Monitor database query performance&#10;&#10;### 3. Content Delivery&#10;- Integrate CDN for media files&#10;- Implement image/video optimization&#10;- Add progressive loading for feeds&#10;&#10;### 4. Security Enhancements&#10;- Rate limiting on API endpoints&#10;- Content moderation system&#10;- Spam detection algorithms&#10;&#10;This comprehensive optimization transforms your CTU-Connect platform into a robust, scalable social network with Facebook-like capabilities while maintaining the academic focus of your original vision." />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/chat-service/pom.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/chat-service/pom.xml" />
              <option name="originalContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&#10;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&#10;&#9;xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;&#10;&#9;&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;&#10;&#9;&lt;parent&gt;&#10;&#9;&#9;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;&#9;&#9;&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;&#10;&#9;&#9;&lt;version&gt;3.2.0&lt;/version&gt;&#10;&#9;&#9;&lt;relativePath/&gt;&#10;&#9;&lt;/parent&gt;&#10;&#9;&lt;groupId&gt;vn.ctu.edu&lt;/groupId&gt;&#10;&#9;&lt;artifactId&gt;chat-service&lt;/artifactId&gt;&#10;&#9;&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;&#10;&#9;&lt;name&gt;chat-service&lt;/name&gt;&#10;&#9;&lt;description&gt;Chat Service for CTU Connect&lt;/description&gt;&#10;&#9;&lt;properties&gt;&#10;&#9;&#9;&lt;java.version&gt;17&lt;/java.version&gt;&#10;&#9;&#9;&lt;spring-cloud.version&gt;2023.0.0&lt;/spring-cloud.version&gt;&#10;&#9;&lt;/properties&gt;&#10;&#9;&lt;dependencies&gt;&#10;&#9;&#9;&lt;!-- Spring Boot Starters --&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;spring-boot-starter-websocket&lt;/artifactId&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;spring-boot-starter-data-mongodb&lt;/artifactId&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#10;&#9;&#9;&lt;!-- Spring Cloud --&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#10;&#9;&#9;&lt;!-- Kafka for event streaming --&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;org.springframework.kafka&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;spring-kafka&lt;/artifactId&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#10;&#9;&#9;&lt;!-- JSON Processing --&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;com.fasterxml.jackson.datatype&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;jackson-datatype-jsr310&lt;/artifactId&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#10;&#9;&#9;&lt;!-- JWT --&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;jjwt-api&lt;/artifactId&gt;&#10;&#9;&#9;&#9;&lt;version&gt;0.11.5&lt;/version&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;jjwt-impl&lt;/artifactId&gt;&#10;&#9;&#9;&#9;&lt;version&gt;0.11.5&lt;/version&gt;&#10;&#9;&#9;&#9;&lt;scope&gt;runtime&lt;/scope&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;jjwt-jackson&lt;/artifactId&gt;&#10;&#9;&#9;&#9;&lt;version&gt;0.11.5&lt;/version&gt;&#10;&#9;&#9;&#9;&lt;scope&gt;runtime&lt;/scope&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#10;&#9;&#9;&lt;!-- Utilities --&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;org.apache.commons&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;commons-lang3&lt;/artifactId&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;org.projectlombok&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;lombok&lt;/artifactId&gt;&#10;&#9;&#9;&#9;&lt;optional&gt;true&lt;/optional&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#10;&#9;&#9;&lt;!-- Testing --&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;&#10;&#9;&#9;&#9;&lt;scope&gt;test&lt;/scope&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;org.springframework.kafka&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;spring-kafka-test&lt;/artifactId&gt;&#10;&#9;&#9;&#9;&lt;scope&gt;test&lt;/scope&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;de.flapdoodle.embed&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;de.flapdoodle.embed.mongo&lt;/artifactId&gt;&#10;&#10;&#9;&lt;dependencyManagement&gt;&#10;&#9;&#9;&lt;dependencies&gt;&#10;&#9;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&#9;&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;&#10;&#9;&#9;&#9;&#9;&lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;&#10;&#9;&#9;&#9;&#9;&lt;version&gt;${spring-cloud.version}&lt;/version&gt;&#10;&#9;&#9;&#9;&#9;&lt;type&gt;pom&lt;/type&gt;&#10;&#9;&#9;&#9;&#9;&lt;scope&gt;import&lt;/scope&gt;&#10;&#9;&#9;&#9;&lt;/dependency&gt;&#10;&#9;&#9;&lt;/dependencies&gt;&#10;&#9;&lt;/dependencyManagement&gt;&#10;&#10;&#9;&lt;build&gt;&#10;&#9;&#9;&lt;plugins&gt;&#10;&#9;&#9;&#9;&lt;plugin&gt;&#10;&#9;&#9;&#9;&#9;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;&#9;&#9;&#9;&#9;&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;&#10;&#9;&#9;&#9;&#9;&lt;configuration&gt;&#10;&#9;&#9;&#9;&#9;&#9;&lt;excludes&gt;&#10;&#9;&#9;&#9;&#9;&#9;&#9;&lt;exclude&gt;&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&lt;groupId&gt;org.projectlombok&lt;/groupId&gt;&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&lt;artifactId&gt;lombok&lt;/artifactId&gt;&#10;&#9;&#9;&#9;&#9;&#9;&#9;&lt;/exclude&gt;&#10;&#9;&#9;&#9;&#9;&#9;&lt;/excludes&gt;&#10;&#9;&#9;&#9;&#9;&lt;/configuration&gt;&#10;&#9;&#9;&#9;&lt;/plugin&gt;&#10;&#9;&#9;&lt;/plugins&gt;&#10;&#9;&lt;/build&gt;&#10;&lt;/project&gt;&#10;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&#10;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&#10;&#9;xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;&#10;&#9;&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;&#10;&#9;&lt;parent&gt;&#10;&#9;&#9;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;&#9;&#9;&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;&#10;&#9;&#9;&lt;version&gt;3.2.0&lt;/version&gt;&#10;&#9;&#9;&lt;relativePath/&gt;&#10;&#9;&lt;/parent&gt;&#10;&#9;&lt;groupId&gt;vn.ctu.edu&lt;/groupId&gt;&#10;&#9;&lt;artifactId&gt;chat-service&lt;/artifactId&gt;&#10;&#9;&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;&#10;&#9;&lt;name&gt;chat-service&lt;/name&gt;&#10;&#9;&lt;description&gt;Chat Service for CTU Connect&lt;/description&gt;&#10;&#9;&lt;properties&gt;&#10;&#9;&#9;&lt;java.version&gt;17&lt;/java.version&gt;&#10;&#9;&#9;&lt;spring-cloud.version&gt;2023.0.0&lt;/spring-cloud.version&gt;&#10;&#9;&lt;/properties&gt;&#10;&#9;&lt;dependencies&gt;&#10;&#9;&#9;&lt;!-- Spring Boot Starters --&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;spring-boot-starter-websocket&lt;/artifactId&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;spring-boot-starter-data-mongodb&lt;/artifactId&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#10;&#9;&#9;&lt;!-- Spring Cloud --&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#10;&#9;&#9;&lt;!-- Kafka for event streaming --&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;org.springframework.kafka&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;spring-kafka&lt;/artifactId&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#10;&#9;&#9;&lt;!-- JSON Processing --&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;com.fasterxml.jackson.datatype&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;jackson-datatype-jsr310&lt;/artifactId&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#10;&#9;&#9;&lt;!-- JWT --&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;jjwt-api&lt;/artifactId&gt;&#10;&#9;&#9;&#9;&lt;version&gt;0.11.5&lt;/version&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;jjwt-impl&lt;/artifactId&gt;&#10;&#9;&#9;&#9;&lt;version&gt;0.11.5&lt;/version&gt;&#10;&#9;&#9;&#9;&lt;scope&gt;runtime&lt;/scope&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;jjwt-jackson&lt;/artifactId&gt;&#10;&#9;&#9;&#9;&lt;version&gt;0.11.5&lt;/version&gt;&#10;&#9;&#9;&#9;&lt;scope&gt;runtime&lt;/scope&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#10;&#9;&#9;&lt;!-- Utilities --&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;org.apache.commons&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;commons-lang3&lt;/artifactId&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;org.projectlombok&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;lombok&lt;/artifactId&gt;&#10;&#9;&#9;&#9;&lt;optional&gt;true&lt;/optional&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#10;&#9;&#9;&lt;!-- Testing --&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;&#10;&#9;&#9;&#9;&lt;scope&gt;test&lt;/scope&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;org.springframework.kafka&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;spring-kafka-test&lt;/artifactId&gt;&#10;&#9;&#9;&#9;&lt;scope&gt;test&lt;/scope&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;de.flapdoodle.embed&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;de.flapdoodle.embed.mongo&lt;/artifactId&gt;&#10;&#9;&#9;&#9;&lt;version&gt;4.9.2&lt;/version&gt;&#10;&#9;&#9;&#9;&lt;scope&gt;test&lt;/scope&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#9;&lt;/dependencies&gt;&#10;&#10;&#9;&lt;dependencyManagement&gt;&#10;&#9;&#9;&lt;dependencies&gt;&#10;&#9;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&#9;&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;&#10;&#9;&#9;&#9;&#9;&lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;&#10;&#9;&#9;&#9;&#9;&lt;version&gt;${spring-cloud.version}&lt;/version&gt;&#10;&#9;&#9;&#9;&#9;&lt;type&gt;pom&lt;/type&gt;&#10;&#9;&#9;&#9;&#9;&lt;scope&gt;import&lt;/scope&gt;&#10;&#9;&#9;&#9;&lt;/dependency&gt;&#10;&#9;&#9;&lt;/dependencies&gt;&#10;&#9;&lt;/dependencyManagement&gt;&#10;&#10;&#9;&lt;build&gt;&#10;&#9;&#9;&lt;plugins&gt;&#10;&#9;&#9;&#9;&lt;plugin&gt;&#10;&#9;&#9;&#9;&#9;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;&#9;&#9;&#9;&#9;&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;&#10;&#9;&#9;&#9;&#9;&lt;configuration&gt;&#10;&#9;&#9;&#9;&#9;&#9;&lt;excludes&gt;&#10;&#9;&#9;&#9;&#9;&#9;&#9;&lt;exclude&gt;&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&lt;groupId&gt;org.projectlombok&lt;/groupId&gt;&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&lt;artifactId&gt;lombok&lt;/artifactId&gt;&#10;&#9;&#9;&#9;&#9;&#9;&#9;&lt;/exclude&gt;&#10;&#9;&#9;&#9;&#9;&#9;&lt;/excludes&gt;&#10;&#9;&#9;&#9;&#9;&lt;/configuration&gt;&#10;&#9;&#9;&#9;&lt;/plugin&gt;&#10;&#9;&#9;&lt;/plugins&gt;&#10;&#9;&lt;/build&gt;&#10;&lt;/project&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/chat-service/src/main/java/com/ctuconnect/ChatServiceApplication.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/chat-service/src/main/java/com/ctuconnect/ChatServiceApplication.java" />
              <option name="originalContent" value="package com.ctuconnect;&#10;&#10;import org.springframework.boot.SpringApplication;&#10;import org.springframework.boot.autoconfigure.SpringBootApplication;&#10;import org.springframework.cloud.netflix.eureka.EnableEurekaClient;&#10;import org.springframework.cloud.openfeign.EnableFeignClients;&#10;import org.springframework.kafka.annotation.EnableKafka;&#10;import org.springframework.scheduling.annotation.EnableAsync;&#10;import org.springframework.scheduling.annotation.EnableScheduling;&#10;&#10;@SpringBootApplication&#10;@EnableEurekaClient&#10;@EnableFeignClients&#10;@EnableKafka&#10;@EnableAsync&#10;@EnableScheduling&#10;public class ChatServiceApplication {&#10;&#10;    public static void main(String[] args) {&#10;        SpringApplication.run(ChatServiceApplication.class, args);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.ctuconnect;&#10;&#10;import org.springframework.boot.SpringApplication;&#10;import org.springframework.boot.autoconfigure.SpringBootApplication;&#10;import org.springframework.cloud.client.discovery.EnableDiscoveryClient;&#10;import org.springframework.cloud.openfeign.EnableFeignClients;&#10;import org.springframework.kafka.annotation.EnableKafka;&#10;import org.springframework.scheduling.annotation.EnableAsync;&#10;import org.springframework.scheduling.annotation.EnableScheduling;&#10;&#10;@SpringBootApplication&#10;@EnableDiscoveryClient&#10;@EnableFeignClients&#10;@EnableKafka&#10;@EnableAsync&#10;@EnableScheduling&#10;public class ChatServiceApplication {&#10;&#10;    public static void main(String[] args) {&#10;        SpringApplication.run(ChatServiceApplication.class, args);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/chat-service/src/main/java/com/ctuconnect/config/SecurityConfig.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/chat-service/src/main/java/com/ctuconnect/config/SecurityConfig.java" />
              <option name="originalContent" value="                .authorizeHttpRequests(auth -&gt; auth&#10;" />
              <option name="updatedContent" value="package com.ctuconnect.config;&#13;&#10;&#13;&#10;import org.springframework.beans.factory.annotation.Value;&#13;&#10;import org.springframework.context.annotation.Bean;&#13;&#10;import org.springframework.context.annotation.Configuration;&#13;&#10;import org.springframework.security.config.annotation.web.builders.HttpSecurity;&#13;&#10;import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;&#13;&#10;import org.springframework.security.config.http.SessionCreationPolicy;&#13;&#10;import org.springframework.security.web.SecurityFilterChain;&#13;&#10;import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;&#13;&#10;import org.springframework.web.cors.CorsConfiguration;&#13;&#10;import org.springframework.web.cors.CorsConfigurationSource;&#13;&#10;import org.springframework.web.cors.UrlBasedCorsConfigurationSource;&#13;&#10;&#13;&#10;import java.util.Arrays;&#13;&#10;&#13;&#10;/**&#13;&#10; * Enhanced Security Configuration for Chat Service&#13;&#10; * Integrates with API Gateway authentication while supporting WebSocket connections&#13;&#10; */&#13;&#10;@Configuration&#13;&#10;public class SecurityConfig {&#13;&#10;&#13;&#10;    @Value(&quot;${app.cors.allowed-origins:http://localhost:3000}&quot;)&#13;&#10;    private String[] allowedOrigins;&#13;&#10;&#13;&#10;    @Bean&#13;&#10;    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {&#13;&#10;        http&#13;&#10;                .csrf(AbstractHttpConfigurer::disable)&#13;&#10;                .cors(cors -&gt; cors.configurationSource(corsConfigurationSource()))&#13;&#10;                .sessionManagement(session -&gt; session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))&#13;&#10;                .authorizeHttpRequests(auth -&gt; auth&#13;&#10;                        // Health check endpoints&#13;&#10;                        .requestMatchers(&quot;/actuator/**&quot;, &quot;/health/**&quot;).permitAll()&#13;&#10;                        &#13;&#10;                        // WebSocket connection endpoints (will be authenticated via socket handshake)&#13;&#10;                        .requestMatchers(&quot;/ws/**&quot;, &quot;/chat-websocket/**&quot;).permitAll()&#13;&#10;                        &#13;&#10;                        // Internal service communication endpoints (from API Gateway)&#13;&#10;                        .requestMatchers(&quot;/internal/**&quot;).hasAuthority(&quot;INTERNAL_SERVICE&quot;)&#13;&#10;                        &#13;&#10;                        // All chat API endpoints require authentication&#13;&#10;                        .requestMatchers(&quot;/api/**&quot;).authenticated()&#13;&#10;                        &#13;&#10;                        // Any other request requires authentication&#13;&#10;                        .anyRequest().authenticated()&#13;&#10;                )&#13;&#10;                // Add JWT token filter for API Gateway integration&#13;&#10;                .addFilterBefore(jwtAuthenticationFilter(), UsernamePasswordAuthenticationFilter.class)&#13;&#10;                &#13;&#10;                // Handle authentication exceptions&#13;&#10;                .exceptionHandling(exceptions -&gt; exceptions&#13;&#10;                        .authenticationEntryPoint((request, response, authException) -&gt; {&#13;&#10;                            response.setStatus(401);&#13;&#10;                            response.setContentType(&quot;application/json&quot;);&#13;&#10;                            response.getWriter().write(&quot;{\&quot;error\&quot;:\&quot;Unauthorized\&quot;,\&quot;message\&quot;:\&quot;Authentication required\&quot;}&quot;);&#13;&#10;                        })&#13;&#10;                        .accessDeniedHandler((request, response, accessDeniedException) -&gt; {&#13;&#10;                            response.setStatus(403);&#13;&#10;                            response.setContentType(&quot;application/json&quot;);&#13;&#10;                            response.getWriter().write(&quot;{\&quot;error\&quot;:\&quot;Access Denied\&quot;,\&quot;message\&quot;:\&quot;Insufficient permissions\&quot;}&quot;);&#13;&#10;                        })&#13;&#10;                );&#13;&#10;&#13;&#10;        return http.build();&#13;&#10;    }&#13;&#10;&#13;&#10;    @Bean&#13;&#10;    public CorsConfigurationSource corsConfigurationSource() {&#13;&#10;        CorsConfiguration configuration = new CorsConfiguration();&#13;&#10;        configuration.setAllowedOriginPatterns(Arrays.asList(allowedOrigins));&#13;&#10;        configuration.setAllowedMethods(Arrays.asList(&quot;GET&quot;, &quot;POST&quot;, &quot;PUT&quot;, &quot;DELETE&quot;, &quot;OPTIONS&quot;));&#13;&#10;        configuration.setAllowedHeaders(Arrays.asList(&quot;*&quot;));&#13;&#10;        configuration.setAllowCredentials(true);&#13;&#10;        configuration.setMaxAge(3600L);&#13;&#10;        &#13;&#10;        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();&#13;&#10;        source.registerCorsConfiguration(&quot;/**&quot;, configuration);&#13;&#10;        return source;&#13;&#10;    }&#13;&#10;&#13;&#10;    @Bean&#13;&#10;    public JwtAuthenticationFilter jwtAuthenticationFilter() {&#13;&#10;        return new JwtAuthenticationFilter();&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/chat-service/src/main/java/com/ctuconnect/security/JwtAuthenticationFilter.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/chat-service/src/main/java/com/ctuconnect/security/JwtAuthenticationFilter.java" />
              <option name="updatedContent" value="package com.ctuconnect.security;&#10;&#10;import jakarta.servlet.FilterChain;&#10;import jakarta.servlet.ServletException;&#10;import jakarta.servlet.http.HttpServletRequest;&#10;import jakarta.servlet.http.HttpServletResponse;&#10;import org.springframework.beans.factory.annotation.Value;&#10;import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;&#10;import org.springframework.security.core.authority.SimpleGrantedAuthority;&#10;import org.springframework.security.core.context.SecurityContextHolder;&#10;import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;&#10;import org.springframework.stereotype.Component;&#10;import org.springframework.web.filter.OncePerRequestFilter;&#10;import io.jsonwebtoken.Claims;&#10;import io.jsonwebtoken.Jwts;&#10;import io.jsonwebtoken.security.Keys;&#10;&#10;import javax.crypto.SecretKey;&#10;import java.io.IOException;&#10;import java.util.Collections;&#10;import java.util.List;&#10;&#10;/**&#10; * JWT Authentication Filter for Chat Service&#10; * Validates tokens passed from API Gateway and sets Spring Security context&#10; */&#10;@Component&#10;public class JwtAuthenticationFilter extends OncePerRequestFilter {&#10;&#10;    @Value(&quot;${app.jwt.secret:ctu-connect-chat-service-secret-key-2024}&quot;)&#10;    private String jwtSecret;&#10;&#10;    @Override&#10;    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, &#10;                                  FilterChain filterChain) throws ServletException, IOException {&#10;        &#10;        try {&#10;            String token = getTokenFromRequest(request);&#10;            &#10;            if (token != null &amp;&amp; validateToken(token)) {&#10;                String userId = getUserIdFromToken(token);&#10;                String userRole = getUserRoleFromToken(token);&#10;                &#10;                // Create authorities based on role&#10;                List&lt;SimpleGrantedAuthority&gt; authorities = Collections.singletonList(&#10;                    new SimpleGrantedAuthority(&quot;ROLE_&quot; + userRole)&#10;                );&#10;                &#10;                // Create authentication token&#10;                UsernamePasswordAuthenticationToken authentication = &#10;                    new UsernamePasswordAuthenticationToken(userId, null, authorities);&#10;                authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));&#10;                &#10;                // Set the authentication in SecurityContext&#10;                SecurityContextHolder.getContext().setAuthentication(authentication);&#10;            }&#10;        } catch (Exception e) {&#10;            logger.error(&quot;Cannot set user authentication: &quot; + e.getMessage());&#10;        }&#10;        &#10;        filterChain.doFilter(request, response);&#10;    }&#10;&#10;    /**&#10;     * Extract JWT token from request headers&#10;     */&#10;    private String getTokenFromRequest(HttpServletRequest request) {&#10;        // First check Authorization header&#10;        String bearerToken = request.getHeader(&quot;Authorization&quot;);&#10;        if (bearerToken != null &amp;&amp; bearerToken.startsWith(&quot;Bearer &quot;)) {&#10;            return bearerToken.substring(7);&#10;        }&#10;        &#10;        // Check X-User-Id header for internal service calls&#10;        String userId = request.getHeader(&quot;X-User-Id&quot;);&#10;        if (userId != null) {&#10;            // For internal calls from API Gateway, create a simple token&#10;            return generateInternalToken(userId);&#10;        }&#10;        &#10;        return null;&#10;    }&#10;&#10;    /**&#10;     * Validate JWT token&#10;     */&#10;    private boolean validateToken(String token) {&#10;        try {&#10;            SecretKey key = Keys.hmacShaKeyFor(jwtSecret.getBytes());&#10;            Jwts.parserBuilder()&#10;                .setSigningKey(key)&#10;                .build()&#10;                .parseClaimsJws(token);&#10;            return true;&#10;        } catch (Exception e) {&#10;            logger.error(&quot;JWT validation error: &quot; + e.getMessage());&#10;            return false;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Extract user ID from JWT token&#10;     */&#10;    private String getUserIdFromToken(String token) {&#10;        SecretKey key = Keys.hmacShaKeyFor(jwtSecret.getBytes());&#10;        Claims claims = Jwts.parserBuilder()&#10;            .setSigningKey(key)&#10;            .build()&#10;            .parseClaimsJws(token)&#10;            .getBody();&#10;        &#10;        return claims.getSubject();&#10;    }&#10;&#10;    /**&#10;     * Extract user role from JWT token&#10;     */&#10;    private String getUserRoleFromToken(String token) {&#10;        try {&#10;            SecretKey key = Keys.hmacShaKeyFor(jwtSecret.getBytes());&#10;            Claims claims = Jwts.parserBuilder()&#10;                .setSigningKey(key)&#10;                .build()&#10;                .parseClaimsJws(token)&#10;                .getBody();&#10;            &#10;            return claims.get(&quot;role&quot;, String.class);&#10;        } catch (Exception e) {&#10;            return &quot;USER&quot;; // Default role&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Generate internal token for service-to-service communication&#10;     */&#10;    private String generateInternalToken(String userId) {&#10;        try {&#10;            SecretKey key = Keys.hmacShaKeyFor(jwtSecret.getBytes());&#10;            return Jwts.builder()&#10;                .setSubject(userId)&#10;                .claim(&quot;role&quot;, &quot;USER&quot;)&#10;                .claim(&quot;internal&quot;, true)&#10;                .signWith(key)&#10;                .compact();&#10;        } catch (Exception e) {&#10;            logger.error(&quot;Error generating internal token: &quot; + e.getMessage());&#10;            return null;&#10;        }&#10;    }&#10;&#10;    @Override&#10;    protected boolean shouldNotFilter(HttpServletRequest request) throws ServletException {&#10;        String path = request.getRequestURI();&#10;        &#10;        // Skip filter for public endpoints&#10;        return path.startsWith(&quot;/actuator&quot;) || &#10;               path.startsWith(&quot;/health&quot;) ||&#10;               path.startsWith(&quot;/ws&quot;) ||&#10;               path.startsWith(&quot;/chat-websocket&quot;);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/chat-service/src/main/java/vn/ctu/edu/chatservice/ChatServiceApplication.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/chat-service/src/main/java/vn/ctu/edu/chatservice/ChatServiceApplication.java" />
              <option name="updatedContent" value="package vn.ctu.edu.chatservice;&#10;&#10;import org.springframework.boot.SpringApplication;&#10;import org.springframework.boot.autoconfigure.SpringBootApplication;&#10;import org.springframework.cloud.netflix.eureka.EnableEurekaClient;&#10;import org.springframework.cloud.openfeign.EnableFeignClients;&#10;import org.springframework.kafka.annotation.EnableKafka;&#10;import org.springframework.scheduling.annotation.EnableAsync;&#10;import org.springframework.scheduling.annotation.EnableScheduling;&#10;&#10;@SpringBootApplication&#10;@EnableEurekaClient&#10;@EnableFeignClients&#10;@EnableKafka&#10;@EnableAsync&#10;@EnableScheduling&#10;public class ChatServiceApplication {&#10;&#10;    public static void main(String[] args) {&#10;        SpringApplication.run(ChatServiceApplication.class, args);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/chat-service/src/main/java/vn/ctu/edu/chatservice/config/AppConfig.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/chat-service/src/main/java/vn/ctu/edu/chatservice/config/AppConfig.java" />
              <option name="updatedContent" value="package vn.ctu.edu.chatservice.config;&#10;&#10;import org.springframework.context.annotation.Bean;&#10;import org.springframework.context.annotation.Configuration;&#10;import org.springframework.data.redis.connection.RedisConnectionFactory;&#10;import org.springframework.data.redis.core.RedisTemplate;&#10;import org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer;&#10;import org.springframework.data.redis.serializer.StringRedisSerializer;&#10;import org.springframework.web.client.RestTemplate;&#10;&#10;@Configuration&#10;public class AppConfig {&#10;    &#10;    @Bean&#10;    public RestTemplate restTemplate() {&#10;        return new RestTemplate();&#10;    }&#10;    &#10;    @Bean&#10;    public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory connectionFactory) {&#10;        RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;();&#10;        template.setConnectionFactory(connectionFactory);&#10;        &#10;        // Use String serializer for keys&#10;        template.setKeySerializer(new StringRedisSerializer());&#10;        template.setHashKeySerializer(new StringRedisSerializer());&#10;        &#10;        // Use JSON serializer for values&#10;        template.setValueSerializer(new GenericJackson2JsonRedisSerializer());&#10;        template.setHashValueSerializer(new GenericJackson2JsonRedisSerializer());&#10;        &#10;        template.afterPropertiesSet();&#10;        return template;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/chat-service/src/main/java/vn/ctu/edu/chatservice/config/SecurityConfig.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/chat-service/src/main/java/vn/ctu/edu/chatservice/config/SecurityConfig.java" />
              <option name="updatedContent" value="package vn.ctu.edu.chatservice.config;&#10;&#10;import org.springframework.context.annotation.Bean;&#10;import org.springframework.context.annotation.Configuration;&#10;import org.springframework.security.config.annotation.web.builders.HttpSecurity;&#10;import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;&#10;import org.springframework.security.config.http.SessionCreationPolicy;&#10;import org.springframework.security.web.SecurityFilterChain;&#10;import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;&#10;import org.springframework.web.cors.CorsConfiguration;&#10;import org.springframework.web.cors.CorsConfigurationSource;&#10;import org.springframework.web.cors.UrlBasedCorsConfigurationSource;&#10;&#10;import java.util.Arrays;&#10;&#10;@Configuration&#10;@EnableWebSecurity&#10;public class SecurityConfig {&#10;    &#10;    @Bean&#10;    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {&#10;        http.cors().and().csrf().disable()&#10;            .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)&#10;            .and()&#10;            .authorizeHttpRequests(authz -&gt; authz&#10;                .requestMatchers(&quot;/ws/chat/**&quot;).permitAll()&#10;                .requestMatchers(&quot;/actuator/**&quot;).permitAll()&#10;                .anyRequest().authenticated()&#10;            );&#10;            // TODO: Add JWT filter&#10;            // .addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class);&#10;        &#10;        return http.build();&#10;    }&#10;    &#10;    @Bean&#10;    public CorsConfigurationSource corsConfigurationSource() {&#10;        CorsConfiguration configuration = new CorsConfiguration();&#10;        configuration.setAllowedOriginPatterns(Arrays.asList(&quot;http://localhost:3000&quot;, &quot;http://localhost:3001&quot;));&#10;        configuration.setAllowedMethods(Arrays.asList(&quot;GET&quot;, &quot;POST&quot;, &quot;PUT&quot;, &quot;DELETE&quot;, &quot;OPTIONS&quot;));&#10;        configuration.setAllowedHeaders(Arrays.asList(&quot;*&quot;));&#10;        configuration.setAllowCredentials(true);&#10;        &#10;        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();&#10;        source.registerCorsConfiguration(&quot;/**&quot;, configuration);&#10;        return source;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/chat-service/src/main/java/vn/ctu/edu/chatservice/config/WebSocketConfig.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/chat-service/src/main/java/vn/ctu/edu/chatservice/config/WebSocketConfig.java" />
              <option name="updatedContent" value="package vn.ctu.edu.chatservice.config;&#10;&#10;import lombok.RequiredArgsConstructor;&#10;import org.springframework.context.annotation.Configuration;&#10;import org.springframework.messaging.Message;&#10;import org.springframework.messaging.MessageChannel;&#10;import org.springframework.messaging.simp.config.ChannelRegistration;&#10;import org.springframework.messaging.simp.config.MessageBrokerRegistry;&#10;import org.springframework.messaging.simp.stomp.StompCommand;&#10;import org.springframework.messaging.simp.stomp.StompHeaderAccessor;&#10;import org.springframework.messaging.support.ChannelInterceptor;&#10;import org.springframework.messaging.support.MessageHeaderAccessor;&#10;import org.springframework.web.socket.config.annotation.EnableWebSocketMessageBroker;&#10;import org.springframework.web.socket.config.annotation.StompEndpointRegistry;&#10;import org.springframework.web.socket.config.annotation.WebSocketMessageBrokerConfigurer;&#10;import vn.ctu.edu.chatservice.service.UserPresenceService;&#10;&#10;@Configuration&#10;@EnableWebSocketMessageBroker&#10;@RequiredArgsConstructor&#10;public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {&#10;    &#10;    private final UserPresenceService userPresenceService;&#10;    &#10;    @Override&#10;    public void configureMessageBroker(MessageBrokerRegistry config) {&#10;        // Enable simple broker for sending messages to clients&#10;        config.enableSimpleBroker(&quot;/topic&quot;, &quot;/queue&quot;);&#10;        &#10;        // Prefix for messages that are bound for methods annotated with @MessageMapping&#10;        config.setApplicationDestinationPrefixes(&quot;/app&quot;);&#10;        &#10;        // Prefix for user-specific destinations&#10;        config.setUserDestinationPrefix(&quot;/user&quot;);&#10;    }&#10;    &#10;    @Override&#10;    public void registerStompEndpoints(StompEndpointRegistry registry) {&#10;        // Register STOMP endpoint&#10;        registry.addEndpoint(&quot;/ws/chat&quot;)&#10;                .setAllowedOriginPatterns(&quot;http://localhost:3000&quot;, &quot;http://localhost:3001&quot;)&#10;                .withSockJS();&#10;    }&#10;    &#10;    @Override&#10;    public void configureClientInboundChannel(ChannelRegistration registration) {&#10;        registration.interceptors(new ChannelInterceptor() {&#10;            @Override&#10;            public Message&lt;?&gt; preSend(Message&lt;?&gt; message, MessageChannel channel) {&#10;                StompHeaderAccessor accessor = MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class);&#10;                &#10;                if (StompCommand.CONNECT.equals(accessor.getCommand())) {&#10;                    // Extract user ID from headers&#10;                    String userId = accessor.getFirstNativeHeader(&quot;userId&quot;);&#10;                    String sessionId = accessor.getSessionId();&#10;                    &#10;                    if (userId != null &amp;&amp; sessionId != null) {&#10;                        accessor.setUser(() -&gt; userId);&#10;                        userPresenceService.setUserOnline(userId, sessionId);&#10;                    }&#10;                } else if (StompCommand.DISCONNECT.equals(accessor.getCommand())) {&#10;                    String userId = accessor.getUser() != null ? accessor.getUser().getName() : null;&#10;                    if (userId != null) {&#10;                        userPresenceService.setUserOffline(userId);&#10;                    }&#10;                }&#10;                &#10;                return message;&#10;            }&#10;        });&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/chat-service/src/main/java/vn/ctu/edu/chatservice/controller/ConversationController.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/chat-service/src/main/java/vn/ctu/edu/chatservice/controller/ConversationController.java" />
              <option name="updatedContent" value="package vn.ctu.edu.chatservice.controller;&#10;&#10;import lombok.RequiredArgsConstructor;&#10;import org.springframework.data.domain.Page;&#10;import org.springframework.http.ResponseEntity;&#10;import org.springframework.messaging.handler.annotation.MessageMapping;&#10;import org.springframework.messaging.handler.annotation.Payload;&#10;import org.springframework.security.core.Authentication;&#10;import org.springframework.web.bind.annotation.*;&#10;import vn.ctu.edu.chatservice.dto.request.*;&#10;import vn.ctu.edu.chatservice.dto.response.*;&#10;import vn.ctu.edu.chatservice.service.ConversationService;&#10;import vn.ctu.edu.chatservice.service.UserPresenceService;&#10;&#10;import jakarta.validation.Valid;&#10;import java.util.List;&#10;&#10;@RestController&#10;@RequestMapping(&quot;/api/conversations&quot;)&#10;@RequiredArgsConstructor&#10;public class ConversationController {&#10;    &#10;    private final ConversationService conversationService;&#10;    private final UserPresenceService userPresenceService;&#10;    &#10;    @PostMapping&#10;    public ResponseEntity&lt;ConversationResponse&gt; createConversation(&#10;            @Valid @RequestBody CreateConversationRequest request,&#10;            Authentication authentication) {&#10;        &#10;        String userId = authentication.getName();&#10;        ConversationResponse response = conversationService.createConversation(request, userId);&#10;        return ResponseEntity.ok(response);&#10;    }&#10;    &#10;    @GetMapping&#10;    public ResponseEntity&lt;Page&lt;ConversationResponse&gt;&gt; getUserConversations(&#10;            @RequestParam(defaultValue = &quot;0&quot;) int page,&#10;            @RequestParam(defaultValue = &quot;20&quot;) int size,&#10;            Authentication authentication) {&#10;        &#10;        String userId = authentication.getName();&#10;        Page&lt;ConversationResponse&gt; conversations = conversationService.getUserConversations(userId, page, size);&#10;        return ResponseEntity.ok(conversations);&#10;    }&#10;    &#10;    @GetMapping(&quot;/{conversationId}&quot;)&#10;    public ResponseEntity&lt;ConversationResponse&gt; getConversation(&#10;            @PathVariable String conversationId,&#10;            Authentication authentication) {&#10;        &#10;        String userId = authentication.getName();&#10;        ConversationResponse response = conversationService.getConversationById(conversationId, userId);&#10;        return ResponseEntity.ok(response);&#10;    }&#10;    &#10;    @PutMapping(&quot;/{conversationId}&quot;)&#10;    public ResponseEntity&lt;ConversationResponse&gt; updateConversation(&#10;            @PathVariable String conversationId,&#10;            @Valid @RequestBody UpdateConversationRequest request,&#10;            Authentication authentication) {&#10;        &#10;        String userId = authentication.getName();&#10;        ConversationResponse response = conversationService.updateConversation(conversationId, request, userId);&#10;        return ResponseEntity.ok(response);&#10;    }&#10;    &#10;    @PostMapping(&quot;/{conversationId}/participants&quot;)&#10;    public ResponseEntity&lt;Void&gt; addParticipant(&#10;            @PathVariable String conversationId,&#10;            @RequestParam String participantId,&#10;            Authentication authentication) {&#10;        &#10;        String userId = authentication.getName();&#10;        conversationService.addParticipant(conversationId, participantId, userId);&#10;        return ResponseEntity.ok().build();&#10;    }&#10;    &#10;    @DeleteMapping(&quot;/{conversationId}/participants/{participantId}&quot;)&#10;    public ResponseEntity&lt;Void&gt; removeParticipant(&#10;            @PathVariable String conversationId,&#10;            @PathVariable String participantId,&#10;            Authentication authentication) {&#10;        &#10;        String userId = authentication.getName();&#10;        conversationService.removeParticipant(conversationId, participantId, userId);&#10;        return ResponseEntity.ok().build();&#10;    }&#10;    &#10;    @GetMapping(&quot;/search&quot;)&#10;    public ResponseEntity&lt;List&lt;ConversationResponse&gt;&gt; searchConversations(&#10;            @RequestParam String query,&#10;            Authentication authentication) {&#10;        &#10;        String userId = authentication.getName();&#10;        List&lt;ConversationResponse&gt; results = conversationService.searchConversations(userId, query);&#10;        return ResponseEntity.ok(results);&#10;    }&#10;    &#10;    @DeleteMapping(&quot;/{conversationId}&quot;)&#10;    public ResponseEntity&lt;Void&gt; deleteConversation(&#10;            @PathVariable String conversationId,&#10;            Authentication authentication) {&#10;        &#10;        String userId = authentication.getName();&#10;        conversationService.deleteConversation(conversationId, userId);&#10;        return ResponseEntity.noContent().build();&#10;    }&#10;    &#10;    // WebSocket message mappings for real-time features&#10;    @MessageMapping(&quot;/conversation/{conversationId}/typing&quot;)&#10;    public void handleTyping(@Payload TypingRequest request, Authentication authentication) {&#10;        String userId = authentication.getName();&#10;        userPresenceService.setTypingStatus(userId, request.getConversationId(), request.isTyping());&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/chat-service/src/main/java/vn/ctu/edu/chatservice/controller/MessageController.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/chat-service/src/main/java/vn/ctu/edu/chatservice/controller/MessageController.java" />
              <option name="updatedContent" value="package vn.ctu.edu.chatservice.controller;&#10;&#10;import lombok.RequiredArgsConstructor;&#10;import org.springframework.http.ResponseEntity;&#10;import org.springframework.messaging.handler.annotation.MessageMapping;&#10;import org.springframework.messaging.handler.annotation.Payload;&#10;import org.springframework.security.core.Authentication;&#10;import org.springframework.web.bind.annotation.*;&#10;import vn.ctu.edu.chatservice.dto.request.AddReactionRequest;&#10;import vn.ctu.edu.chatservice.dto.request.SendMessageRequest;&#10;import vn.ctu.edu.chatservice.dto.response.ChatPageResponse;&#10;import vn.ctu.edu.chatservice.dto.response.MessageResponse;&#10;import vn.ctu.edu.chatservice.service.MessageService;&#10;&#10;import jakarta.validation.Valid;&#10;import java.util.List;&#10;&#10;@RestController&#10;@RequestMapping(&quot;/api/messages&quot;)&#10;@RequiredArgsConstructor&#10;public class MessageController {&#10;    &#10;    private final MessageService messageService;&#10;    &#10;    @PostMapping&#10;    public ResponseEntity&lt;MessageResponse&gt; sendMessage(&#10;            @Valid @RequestBody SendMessageRequest request,&#10;            Authentication authentication) {&#10;        &#10;        String userId = authentication.getName();&#10;        MessageResponse response = messageService.sendMessage(request, userId);&#10;        return ResponseEntity.ok(response);&#10;    }&#10;    &#10;    @GetMapping(&quot;/conversation/{conversationId}&quot;)&#10;    public ResponseEntity&lt;ChatPageResponse&lt;MessageResponse&gt;&gt; getMessages(&#10;            @PathVariable String conversationId,&#10;            @RequestParam(defaultValue = &quot;0&quot;) int page,&#10;            @RequestParam(defaultValue = &quot;50&quot;) int size,&#10;            Authentication authentication) {&#10;        &#10;        String userId = authentication.getName();&#10;        ChatPageResponse&lt;MessageResponse&gt; messages = messageService.getMessages(conversationId, userId, page, size);&#10;        return ResponseEntity.ok(messages);&#10;    }&#10;    &#10;    @PutMapping(&quot;/{messageId}&quot;)&#10;    public ResponseEntity&lt;MessageResponse&gt; editMessage(&#10;            @PathVariable String messageId,&#10;            @RequestParam String content,&#10;            Authentication authentication) {&#10;        &#10;        String userId = authentication.getName();&#10;        MessageResponse response = messageService.editMessage(messageId, content, userId);&#10;        return ResponseEntity.ok(response);&#10;    }&#10;    &#10;    @DeleteMapping(&quot;/{messageId}&quot;)&#10;    public ResponseEntity&lt;Void&gt; deleteMessage(&#10;            @PathVariable String messageId,&#10;            Authentication authentication) {&#10;        &#10;        String userId = authentication.getName();&#10;        messageService.deleteMessage(messageId, userId);&#10;        return ResponseEntity.noContent().build();&#10;    }&#10;    &#10;    @PostMapping(&quot;/reactions&quot;)&#10;    public ResponseEntity&lt;MessageResponse&gt; addReaction(&#10;            @Valid @RequestBody AddReactionRequest request,&#10;            Authentication authentication) {&#10;        &#10;        String userId = authentication.getName();&#10;        MessageResponse response = messageService.addReaction(request, userId);&#10;        return ResponseEntity.ok(response);&#10;    }&#10;    &#10;    @DeleteMapping(&quot;/{messageId}/reactions&quot;)&#10;    public ResponseEntity&lt;Void&gt; removeReaction(&#10;            @PathVariable String messageId,&#10;            Authentication authentication) {&#10;        &#10;        String userId = authentication.getName();&#10;        messageService.removeReaction(messageId, userId);&#10;        return ResponseEntity.noContent().build();&#10;    }&#10;    &#10;    @GetMapping(&quot;/conversation/{conversationId}/search&quot;)&#10;    public ResponseEntity&lt;List&lt;MessageResponse&gt;&gt; searchMessages(&#10;            @PathVariable String conversationId,&#10;            @RequestParam String query,&#10;            Authentication authentication) {&#10;        &#10;        String userId = authentication.getName();&#10;        List&lt;MessageResponse&gt; results = messageService.searchMessages(conversationId, query, userId);&#10;        return ResponseEntity.ok(results);&#10;    }&#10;    &#10;    @GetMapping(&quot;/conversation/{conversationId}/unread-count&quot;)&#10;    public ResponseEntity&lt;Long&gt; getUnreadCount(&#10;            @PathVariable String conversationId,&#10;            Authentication authentication) {&#10;        &#10;        String userId = authentication.getName();&#10;        long count = messageService.getUnreadCount(conversationId, userId);&#10;        return ResponseEntity.ok(count);&#10;    }&#10;    &#10;    @PostMapping(&quot;/conversation/{conversationId}/mark-read&quot;)&#10;    public ResponseEntity&lt;Void&gt; markAsRead(&#10;            @PathVariable String conversationId,&#10;            Authentication authentication) {&#10;        &#10;        String userId = authentication.getName();&#10;        messageService.markMessagesAsRead(conversationId, userId);&#10;        return ResponseEntity.ok().build();&#10;    }&#10;    &#10;    // WebSocket message mappings for real-time messaging&#10;    @MessageMapping(&quot;/message.send&quot;)&#10;    public void sendMessageViaWebSocket(@Payload SendMessageRequest request, Authentication authentication) {&#10;        String userId = authentication.getName();&#10;        messageService.sendMessage(request, userId);&#10;    }&#10;    &#10;    @MessageMapping(&quot;/message.reaction&quot;)&#10;    public void addReactionViaWebSocket(@Payload AddReactionRequest request, Authentication authentication) {&#10;        String userId = authentication.getName();&#10;        messageService.addReaction(request, userId);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/chat-service/src/main/java/vn/ctu/edu/chatservice/controller/UserPresenceController.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/chat-service/src/main/java/vn/ctu/edu/chatservice/controller/UserPresenceController.java" />
              <option name="updatedContent" value="package vn.ctu.edu.chatservice.controller;&#10;&#10;import lombok.RequiredArgsConstructor;&#10;import org.springframework.http.ResponseEntity;&#10;import org.springframework.security.core.Authentication;&#10;import org.springframework.web.bind.annotation.*;&#10;import vn.ctu.edu.chatservice.dto.response.UserPresenceResponse;&#10;import vn.ctu.edu.chatservice.service.UserPresenceService;&#10;&#10;import java.util.List;&#10;&#10;@RestController&#10;@RequestMapping(&quot;/api/presence&quot;)&#10;@RequiredArgsConstructor&#10;public class UserPresenceController {&#10;    &#10;    private final UserPresenceService userPresenceService;&#10;    &#10;    @GetMapping(&quot;/{userId}&quot;)&#10;    public ResponseEntity&lt;UserPresenceResponse&gt; getUserPresence(@PathVariable String userId) {&#10;        UserPresenceResponse presence = userPresenceService.getUserPresence(userId);&#10;        return ResponseEntity.ok(presence);&#10;    }&#10;    &#10;    @GetMapping(&quot;/users&quot;)&#10;    public ResponseEntity&lt;List&lt;UserPresenceResponse&gt;&gt; getMultipleUserPresence(&#10;            @RequestParam List&lt;String&gt; userIds) {&#10;        List&lt;UserPresenceResponse&gt; presences = userPresenceService.getMultipleUserPresence(userIds);&#10;        return ResponseEntity.ok(presences);&#10;    }&#10;    &#10;    @GetMapping(&quot;/online&quot;)&#10;    public ResponseEntity&lt;List&lt;UserPresenceResponse&gt;&gt; getOnlineUsers() {&#10;        List&lt;UserPresenceResponse&gt; onlineUsers = userPresenceService.getOnlineUsers();&#10;        return ResponseEntity.ok(onlineUsers);&#10;    }&#10;    &#10;    @PostMapping(&quot;/away&quot;)&#10;    public ResponseEntity&lt;Void&gt; setAway(Authentication authentication) {&#10;        String userId = authentication.getName();&#10;        userPresenceService.setUserAway(userId);&#10;        return ResponseEntity.ok().build();&#10;    }&#10;    &#10;    @GetMapping(&quot;/conversation/{conversationId}/typing&quot;)&#10;    public ResponseEntity&lt;List&lt;String&gt;&gt; getTypingUsers(@PathVariable String conversationId) {&#10;        List&lt;String&gt; typingUsers = userPresenceService.getTypingUsers(conversationId);&#10;        return ResponseEntity.ok(typingUsers);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/chat-service/src/main/java/vn/ctu/edu/chatservice/dto/request/ChatRequests.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/chat-service/src/main/java/vn/ctu/edu/chatservice/dto/request/ChatRequests.java" />
              <option name="updatedContent" value="package vn.ctu.edu.chatservice.dto.request;&#10;&#10;import lombok.AllArgsConstructor;&#10;import lombok.Data;&#10;import lombok.NoArgsConstructor;&#10;import vn.ctu.edu.chatservice.model.Conversation;&#10;&#10;import jakarta.validation.constraints.NotBlank;&#10;import jakarta.validation.constraints.NotEmpty;&#10;import jakarta.validation.constraints.Size;&#10;import java.util.List;&#10;&#10;@Data&#10;@NoArgsConstructor&#10;@AllArgsConstructor&#10;public class CreateConversationRequest {&#10;    @Size(max = 100, message = &quot;Tên nhóm không được vượt quá 100 ký tự&quot;)&#10;    private String name;&#10;    &#10;    @NotEmpty(message = &quot;Danh sách thành viên không được trống&quot;)&#10;    private List&lt;String&gt; participantIds;&#10;    &#10;    private Conversation.ConversationType type = Conversation.ConversationType.DIRECT;&#10;    &#10;    private String description;&#10;    &#10;    private String avatarUrl;&#10;}&#10;&#10;@Data&#10;@NoArgsConstructor&#10;@AllArgsConstructor&#10;class SendMessageRequest {&#10;    @NotBlank(message = &quot;ID conversation không được trống&quot;)&#10;    private String conversationId;&#10;    &#10;    @NotBlank(message = &quot;Nội dung tin nhắn không được trống&quot;)&#10;    @Size(max = 2000, message = &quot;Tin nhắn không được vượt quá 2000 ký tự&quot;)&#10;    private String content;&#10;    &#10;    private String replyToMessageId;&#10;}&#10;&#10;@Data&#10;@NoArgsConstructor&#10;@AllArgsConstructor&#10;class AddReactionRequest {&#10;    @NotBlank(message = &quot;ID tin nhắn không được trống&quot;)&#10;    private String messageId;&#10;    &#10;    @NotBlank(message = &quot;Emoji không được trống&quot;)&#10;    private String emoji;&#10;}&#10;&#10;@Data&#10;@NoArgsConstructor&#10;@AllArgsConstructor&#10;class UpdateConversationRequest {&#10;    private String name;&#10;    private String description;&#10;    private String avatarUrl;&#10;    private List&lt;String&gt; participantIds;&#10;}&#10;&#10;@Data&#10;@NoArgsConstructor&#10;@AllArgsConstructor&#10;class TypingRequest {&#10;    @NotBlank(message = &quot;ID conversation không được trống&quot;)&#10;    private String conversationId;&#10;    &#10;    private boolean isTyping;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/chat-service/src/main/java/vn/ctu/edu/chatservice/dto/response/ChatResponses.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/chat-service/src/main/java/vn/ctu/edu/chatservice/dto/response/ChatResponses.java" />
              <option name="updatedContent" value="package vn.ctu.edu.chatservice.dto.response;&#10;&#10;import lombok.AllArgsConstructor;&#10;import lombok.Data;&#10;import lombok.NoArgsConstructor;&#10;import vn.ctu.edu.chatservice.model.*;&#10;&#10;import java.time.LocalDateTime;&#10;import java.util.List;&#10;&#10;@Data&#10;@NoArgsConstructor&#10;@AllArgsConstructor&#10;public class ConversationResponse {&#10;    private String id;&#10;    private String name;&#10;    private Conversation.ConversationType type;&#10;    private List&lt;ParticipantInfo&gt; participants;&#10;    private MessageResponse lastMessage;&#10;    private LocalDateTime lastMessageAt;&#10;    private int unreadCount;&#10;    private String avatarUrl;&#10;    private LocalDateTime createdAt;&#10;    private LocalDateTime updatedAt;&#10;}&#10;&#10;@Data&#10;@NoArgsConstructor&#10;@AllArgsConstructor&#10;class ParticipantInfo {&#10;    private String userId;&#10;    private String userName;&#10;    private String userAvatar;&#10;    private UserPresence.PresenceStatus presenceStatus;&#10;    private LocalDateTime lastSeenAt;&#10;    private boolean isAdmin;&#10;}&#10;&#10;@Data&#10;@NoArgsConstructor&#10;@AllArgsConstructor&#10;class MessageResponse {&#10;    private String id;&#10;    private String conversationId;&#10;    private String senderId;&#10;    private String senderName;&#10;    private String senderAvatar;&#10;    private Message.MessageType type;&#10;    private String content;&#10;    private MessageAttachmentResponse attachment;&#10;    private String replyToMessageId;&#10;    private MessageResponse replyToMessage;&#10;    private List&lt;MessageReactionResponse&gt; reactions;&#10;    private Message.MessageStatus status;&#10;    private List&lt;String&gt; readByUserIds;&#10;    private LocalDateTime createdAt;&#10;    private LocalDateTime updatedAt;&#10;    private LocalDateTime editedAt;&#10;    private boolean isEdited;&#10;    private boolean isDeleted;&#10;}&#10;&#10;@Data&#10;@NoArgsConstructor&#10;@AllArgsConstructor&#10;class MessageAttachmentResponse {&#10;    private String fileName;&#10;    private String fileUrl;&#10;    private String fileType;&#10;    private Long fileSize;&#10;    private String thumbnailUrl;&#10;}&#10;&#10;@Data&#10;@NoArgsConstructor&#10;@AllArgsConstructor&#10;class MessageReactionResponse {&#10;    private String userId;&#10;    private String userName;&#10;    private String emoji;&#10;    private LocalDateTime createdAt;&#10;}&#10;&#10;@Data&#10;@NoArgsConstructor&#10;@AllArgsConstructor&#10;class UserPresenceResponse {&#10;    private String userId;&#10;    private String userName;&#10;    private String userAvatar;&#10;    private UserPresence.PresenceStatus status;&#10;    private String currentActivity;&#10;    private LocalDateTime lastSeenAt;&#10;}&#10;&#10;@Data&#10;@NoArgsConstructor&#10;@AllArgsConstructor&#10;class ChatPageResponse&lt;T&gt; {&#10;    private List&lt;T&gt; content;&#10;    private int page;&#10;    private int size;&#10;    private long totalElements;&#10;    private int totalPages;&#10;    private boolean hasNext;&#10;    private boolean hasPrevious;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/chat-service/src/main/java/vn/ctu/edu/chatservice/exception/ChatException.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/chat-service/src/main/java/vn/ctu/edu/chatservice/exception/ChatException.java" />
              <option name="updatedContent" value="package vn.ctu.edu.chatservice.exception;&#10;&#10;public class ChatException extends RuntimeException {&#10;    public ChatException(String message) {&#10;        super(message);&#10;    }&#10;    &#10;    public ChatException(String message, Throwable cause) {&#10;        super(message, cause);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/chat-service/src/main/java/vn/ctu/edu/chatservice/model/Conversation.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/chat-service/src/main/java/vn/ctu/edu/chatservice/model/Conversation.java" />
              <option name="updatedContent" value="package vn.ctu.edu.chatservice.model;&#10;&#10;import lombok.AllArgsConstructor;&#10;import lombok.Data;&#10;import lombok.NoArgsConstructor;&#10;import org.springframework.data.annotation.Id;&#10;import org.springframework.data.mongodb.core.mapping.Document;&#10;import org.springframework.data.mongodb.core.index.Indexed;&#10;&#10;import java.time.LocalDateTime;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;&#10;@Data&#10;@NoArgsConstructor&#10;@AllArgsConstructor&#10;@Document(collection = &quot;conversations&quot;)&#10;public class Conversation {&#10;    @Id&#10;    private String id;&#10;    &#10;    @Indexed&#10;    private String name; // Tên nhóm chat (null nếu là chat 1-1)&#10;    &#10;    @Indexed&#10;    private ConversationType type; // DIRECT, GROUP&#10;    &#10;    private List&lt;String&gt; participantIds = new ArrayList&lt;&gt;(); // Danh sách user IDs&#10;    &#10;    private String lastMessageId; // ID tin nhắn cuối cùng&#10;    &#10;    private LocalDateTime lastMessageAt; // Thời gian tin nhắn cuối&#10;    &#10;    private String createdBy; // Người tạo conversation&#10;    &#10;    private LocalDateTime createdAt;&#10;    &#10;    private LocalDateTime updatedAt;&#10;    &#10;    // Metadata cho group chat&#10;    private ConversationMetadata metadata;&#10;    &#10;    // Settings&#10;    private ConversationSettings settings;&#10;    &#10;    public enum ConversationType {&#10;        DIRECT, // Chat 1-1&#10;        GROUP   // Chat nhóm&#10;    }&#10;}&#10;&#10;@Data&#10;@NoArgsConstructor&#10;@AllArgsConstructor&#10;class ConversationMetadata {&#10;    private String description; // Mô tả nhóm&#10;    private String avatarUrl;   // Avatar nhóm&#10;    private List&lt;String&gt; adminIds = new ArrayList&lt;&gt;(); // Danh sách admin&#10;}&#10;&#10;@Data&#10;@NoArgsConstructor&#10;@AllArgsConstructor&#10;class ConversationSettings {&#10;    private boolean allowMembersToAddOthers = true;&#10;    private boolean allowMembersToChangeInfo = false;&#10;    private boolean muteNotifications = false;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/chat-service/src/main/java/vn/ctu/edu/chatservice/model/Message.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/chat-service/src/main/java/vn/ctu/edu/chatservice/model/Message.java" />
              <option name="updatedContent" value="package vn.ctu.edu.chatservice.model;&#10;&#10;import lombok.AllArgsConstructor;&#10;import lombok.Data;&#10;import lombok.NoArgsConstructor;&#10;import org.springframework.data.annotation.Id;&#10;import org.springframework.data.mongodb.core.mapping.Document;&#10;import org.springframework.data.mongodb.core.index.Indexed;&#10;&#10;import java.time.LocalDateTime;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;&#10;@Data&#10;@NoArgsConstructor&#10;@AllArgsConstructor&#10;@Document(collection = &quot;messages&quot;)&#10;public class Message {&#10;    @Id&#10;    private String id;&#10;    &#10;    @Indexed&#10;    private String conversationId; // ID của conversation&#10;    &#10;    @Indexed&#10;    private String senderId; // ID người gửi&#10;    &#10;    private String senderName; // Tên người gửi (cache)&#10;    &#10;    private String senderAvatar; // Avatar người gửi (cache)&#10;    &#10;    private MessageType type; // TEXT, IMAGE, FILE, SYSTEM&#10;    &#10;    private String content; // Nội dung tin nhắn&#10;    &#10;    private MessageAttachment attachment; // File đính kèm&#10;    &#10;    private String replyToMessageId; // ID tin nhắn được reply&#10;    &#10;    private List&lt;MessageReaction&gt; reactions = new ArrayList&lt;&gt;(); // Reactions&#10;    &#10;    private MessageStatus status; // SENT, DELIVERED, READ&#10;    &#10;    private List&lt;String&gt; readByUserIds = new ArrayList&lt;&gt;(); // Danh sách user đã đọc&#10;    &#10;    private LocalDateTime createdAt;&#10;    &#10;    private LocalDateTime updatedAt;&#10;    &#10;    private LocalDateTime editedAt;&#10;    &#10;    private boolean isEdited = false;&#10;    &#10;    private boolean isDeleted = false;&#10;    &#10;    public enum MessageType {&#10;        TEXT,&#10;        IMAGE,&#10;        FILE,&#10;        SYSTEM // Tin nhắn hệ thống (join, leave, etc.)&#10;    }&#10;    &#10;    public enum MessageStatus {&#10;        SENT,&#10;        DELIVERED,&#10;        READ&#10;    }&#10;}&#10;&#10;@Data&#10;@NoArgsConstructor&#10;@AllArgsConstructor&#10;class MessageAttachment {&#10;    private String fileName;&#10;    private String fileUrl;&#10;    private String fileType; // image/jpeg, application/pdf, etc.&#10;    private Long fileSize;&#10;    private String thumbnailUrl; // Cho images/videos&#10;}&#10;&#10;@Data&#10;@NoArgsConstructor&#10;@AllArgsConstructor&#10;class MessageReaction {&#10;    private String userId;&#10;    private String userName;&#10;    private String emoji; // , ❤️, , , , &#10;    private LocalDateTime createdAt;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/chat-service/src/main/java/vn/ctu/edu/chatservice/model/UserPresence.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/chat-service/src/main/java/vn/ctu/edu/chatservice/model/UserPresence.java" />
              <option name="updatedContent" value="package vn.ctu.edu.chatservice.model;&#10;&#10;import lombok.AllArgsConstructor;&#10;import lombok.Data;&#10;import lombok.NoArgsConstructor;&#10;import org.springframework.data.annotation.Id;&#10;import org.springframework.data.mongodb.core.mapping.Document;&#10;import org.springframework.data.mongodb.core.index.Indexed;&#10;&#10;import java.time.LocalDateTime;&#10;&#10;@Data&#10;@NoArgsConstructor&#10;@AllArgsConstructor&#10;@Document(collection = &quot;user_presence&quot;)&#10;public class UserPresence {&#10;    @Id&#10;    private String id;&#10;    &#10;    @Indexed(unique = true)&#10;    private String userId;&#10;    &#10;    private String userName;&#10;    &#10;    private String userAvatar;&#10;    &#10;    private PresenceStatus status; // ONLINE, OFFLINE, AWAY&#10;    &#10;    private String currentActivity; // &quot;typing in conversation_id&quot; hoặc null&#10;    &#10;    private LocalDateTime lastSeenAt;&#10;    &#10;    private LocalDateTime updatedAt;&#10;    &#10;    private String sessionId; // WebSocket session ID&#10;    &#10;    public enum PresenceStatus {&#10;        ONLINE,&#10;        OFFLINE,&#10;        AWAY&#10;    }&#10;}&#10;&#10;@Data&#10;@NoArgsConstructor&#10;@AllArgsConstructor&#10;class TypingIndicator {&#10;    private String userId;&#10;    private String userName;&#10;    private String conversationId;&#10;    private LocalDateTime startedAt;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/chat-service/src/main/java/vn/ctu/edu/chatservice/repository/ConversationRepository.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/chat-service/src/main/java/vn/ctu/edu/chatservice/repository/ConversationRepository.java" />
              <option name="updatedContent" value="package vn.ctu.edu.chatservice.repository;&#10;&#10;import org.springframework.data.domain.Page;&#10;import org.springframework.data.domain.Pageable;&#10;import org.springframework.data.mongodb.repository.MongoRepository;&#10;import org.springframework.data.mongodb.repository.Query;&#10;import org.springframework.stereotype.Repository;&#10;import vn.ctu.edu.chatservice.model.Conversation;&#10;&#10;import java.time.LocalDateTime;&#10;import java.util.List;&#10;import java.util.Optional;&#10;&#10;@Repository&#10;public interface ConversationRepository extends MongoRepository&lt;Conversation, String&gt; {&#10;    &#10;    // Tìm conversations mà user tham gia&#10;    @Query(&quot;{'participantIds': ?0}&quot;)&#10;    Page&lt;Conversation&gt; findByParticipantIdsContaining(String userId, Pageable pageable);&#10;    &#10;    // Tìm conversation trực tiếp giữa 2 users&#10;    @Query(&quot;{'type': 'DIRECT', 'participantIds': {$all: [?0, ?1], $size: 2}}&quot;)&#10;    Optional&lt;Conversation&gt; findDirectConversationBetweenUsers(String userId1, String userId2);&#10;    &#10;    // Tìm conversations theo tên (search)&#10;    @Query(&quot;{'participantIds': ?0, 'name': {$regex: ?1, $options: 'i'}}&quot;)&#10;    List&lt;Conversation&gt; findByParticipantIdsContainingAndNameContainingIgnoreCase(String userId, String name);&#10;    &#10;    // Tìm conversations được cập nhật gần đây&#10;    @Query(&quot;{'participantIds': ?0, 'lastMessageAt': {$gte: ?1}}&quot;)&#10;    List&lt;Conversation&gt; findRecentConversations(String userId, LocalDateTime since);&#10;    &#10;    // Đếm số conversations chưa đọc của user&#10;    @Query(value = &quot;{'participantIds': ?0}&quot;, count = true)&#10;    long countByParticipantIdsContaining(String userId);&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/chat-service/src/main/java/vn/ctu/edu/chatservice/repository/MessageRepository.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/chat-service/src/main/java/vn/ctu/edu/chatservice/repository/MessageRepository.java" />
              <option name="updatedContent" value="package vn.ctu.edu.chatservice.repository;&#10;&#10;import org.springframework.data.domain.Page;&#10;import org.springframework.data.domain.Pageable;&#10;import org.springframework.data.mongodb.repository.MongoRepository;&#10;import org.springframework.data.mongodb.repository.Query;&#10;import org.springframework.stereotype.Repository;&#10;import vn.ctu.edu.chatservice.model.Message;&#10;&#10;import java.time.LocalDateTime;&#10;import java.util.List;&#10;import java.util.Optional;&#10;&#10;@Repository&#10;public interface MessageRepository extends MongoRepository&lt;Message, String&gt; {&#10;    &#10;    // Lấy messages trong conversation với pagination&#10;    Page&lt;Message&gt; findByConversationIdAndIsDeletedFalseOrderByCreatedAtDesc(String conversationId, Pageable pageable);&#10;    &#10;    // Lấy tin nhắn mới nhất của conversation&#10;    Optional&lt;Message&gt; findFirstByConversationIdAndIsDeletedFalseOrderByCreatedAtDesc(String conversationId);&#10;    &#10;    // Tìm kiếm messages theo nội dung&#10;    @Query(&quot;{'conversationId': ?0, 'content': {$regex: ?1, $options: 'i'}, 'isDeleted': false}&quot;)&#10;    List&lt;Message&gt; searchMessagesInConversation(String conversationId, String searchText);&#10;    &#10;    // Đếm messages chưa đọc trong conversation&#10;    @Query(value = &quot;{'conversationId': ?0, 'senderId': {$ne: ?1}, 'readByUserIds': {$nin: [?1]}, 'isDeleted': false}&quot;, count = true)&#10;    long countUnreadMessages(String conversationId, String userId);&#10;    &#10;    // Lấy messages sau một thời điểm cụ thể (real-time sync)&#10;    List&lt;Message&gt; findByConversationIdAndCreatedAtAfterAndIsDeletedFalseOrderByCreatedAtAsc(&#10;        String conversationId, LocalDateTime after);&#10;    &#10;    // Lấy messages được gửi bởi user cụ thể&#10;    List&lt;Message&gt; findBySenderIdAndConversationIdAndIsDeletedFalseOrderByCreatedAtDesc(&#10;        String senderId, String conversationId);&#10;    &#10;    // Lấy messages có attachments&#10;    @Query(&quot;{'conversationId': ?0, 'attachment': {$ne: null}, 'isDeleted': false}&quot;)&#10;    List&lt;Message&gt; findMessagesWithAttachments(String conversationId);&#10;    &#10;    // Xóa tất cả messages trong conversation&#10;    void deleteByConversationId(String conversationId);&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/chat-service/src/main/java/vn/ctu/edu/chatservice/repository/UserPresenceRepository.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/chat-service/src/main/java/vn/ctu/edu/chatservice/repository/UserPresenceRepository.java" />
              <option name="updatedContent" value="package vn.ctu.edu.chatservice.repository;&#10;&#10;import org.springframework.data.mongodb.repository.MongoRepository;&#10;import org.springframework.data.mongodb.repository.Query;&#10;import org.springframework.stereotype.Repository;&#10;import vn.ctu.edu.chatservice.model.UserPresence;&#10;&#10;import java.time.LocalDateTime;&#10;import java.util.List;&#10;import java.util.Optional;&#10;&#10;@Repository&#10;public interface UserPresenceRepository extends MongoRepository&lt;UserPresence, String&gt; {&#10;    &#10;    // Tìm presence theo userId&#10;    Optional&lt;UserPresence&gt; findByUserId(String userId);&#10;    &#10;    // Tìm presence theo sessionId&#10;    Optional&lt;UserPresence&gt; findBySessionId(String sessionId);&#10;    &#10;    // Lấy danh sách users online&#10;    List&lt;UserPresence&gt; findByStatus(UserPresence.PresenceStatus status);&#10;    &#10;    // Lấy presence của nhiều users&#10;    List&lt;UserPresence&gt; findByUserIdIn(List&lt;String&gt; userIds);&#10;    &#10;    // Tìm users đang typing trong conversation&#10;    @Query(&quot;{'currentActivity': {$regex: '^typing in ?0', $options: 'i'}}&quot;)&#10;    List&lt;UserPresence&gt; findUsersTypingInConversation(String conversationId);&#10;    &#10;    // Lấy users online gần đây&#10;    List&lt;UserPresence&gt; findByLastSeenAtAfterOrderByLastSeenAtDesc(LocalDateTime since);&#10;    &#10;    // Xóa presence của user khi disconnect&#10;    void deleteByUserId(String userId);&#10;    &#10;    // Xóa presence cũ (cleanup job)&#10;    void deleteByLastSeenAtBefore(LocalDateTime before);&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/chat-service/src/main/java/vn/ctu/edu/chatservice/service/ConversationService.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/chat-service/src/main/java/vn/ctu/edu/chatservice/service/ConversationService.java" />
              <option name="updatedContent" value="package vn.ctu.edu.chatservice.service;&#10;&#10;import lombok.RequiredArgsConstructor;&#10;import lombok.extern.slf4j.Slf4j;&#10;import org.springframework.data.domain.Page;&#10;import org.springframework.data.domain.PageRequest;&#10;import org.springframework.data.domain.Pageable;&#10;import org.springframework.data.domain.Sort;&#10;import org.springframework.stereotype.Service;&#10;import vn.ctu.edu.chatservice.dto.request.CreateConversationRequest;&#10;import vn.ctu.edu.chatservice.dto.request.UpdateConversationRequest;&#10;import vn.ctu.edu.chatservice.dto.response.ConversationResponse;&#10;import vn.ctu.edu.chatservice.dto.response.ParticipantInfo;&#10;import vn.ctu.edu.chatservice.exception.ChatException;&#10;import vn.ctu.edu.chatservice.model.Conversation;&#10;import vn.ctu.edu.chatservice.repository.ConversationRepository;&#10;import vn.ctu.edu.chatservice.repository.MessageRepository;&#10;&#10;import java.time.LocalDateTime;&#10;import java.util.List;&#10;import java.util.Optional;&#10;import java.util.stream.Collectors;&#10;&#10;@Service&#10;@RequiredArgsConstructor&#10;@Slf4j&#10;public class ConversationService {&#10;    &#10;    private final ConversationRepository conversationRepository;&#10;    private final MessageRepository messageRepository;&#10;    private final UserPresenceService userPresenceService;&#10;    private final UserService userService;&#10;    &#10;    public ConversationResponse createConversation(CreateConversationRequest request, String createdBy) {&#10;        log.info(&quot;Creating conversation with type: {} by user: {}&quot;, request.getType(), createdBy);&#10;        &#10;        // Validate participants&#10;        if (request.getParticipantIds().isEmpty()) {&#10;            throw new ChatException(&quot;Danh sách thành viên không được trống&quot;);&#10;        }&#10;        &#10;        // Kiểm tra nếu là chat trực tiếp giữa 2 người đã tồn tại&#10;        if (request.getType() == Conversation.ConversationType.DIRECT &amp;&amp; &#10;            request.getParticipantIds().size() == 1) {&#10;            &#10;            String otherUserId = request.getParticipantIds().get(0);&#10;            Optional&lt;Conversation&gt; existingConversation = &#10;                conversationRepository.findDirectConversationBetweenUsers(createdBy, otherUserId);&#10;            &#10;            if (existingConversation.isPresent()) {&#10;                return convertToResponse(existingConversation.get());&#10;            }&#10;        }&#10;        &#10;        // Tạo conversation mới&#10;        Conversation conversation = new Conversation();&#10;        conversation.setName(request.getName());&#10;        conversation.setType(request.getType());&#10;        &#10;        // Thêm creator vào danh sách participants&#10;        List&lt;String&gt; participants = request.getParticipantIds();&#10;        if (!participants.contains(createdBy)) {&#10;            participants.add(createdBy);&#10;        }&#10;        conversation.setParticipantIds(participants);&#10;        &#10;        conversation.setCreatedBy(createdBy);&#10;        conversation.setCreatedAt(LocalDateTime.now());&#10;        conversation.setUpdatedAt(LocalDateTime.now());&#10;        &#10;        // Metadata cho group chat&#10;        if (request.getType() == Conversation.ConversationType.GROUP) {&#10;            ConversationMetadata metadata = new ConversationMetadata();&#10;            metadata.setDescription(request.getDescription());&#10;            metadata.setAvatarUrl(request.getAvatarUrl());&#10;            metadata.getAdminIds().add(createdBy); // Creator là admin&#10;            conversation.setMetadata(metadata);&#10;        }&#10;        &#10;        Conversation saved = conversationRepository.save(conversation);&#10;        log.info(&quot;Created conversation: {} with {} participants&quot;, saved.getId(), participants.size());&#10;        &#10;        return convertToResponse(saved);&#10;    }&#10;    &#10;    public Page&lt;ConversationResponse&gt; getUserConversations(String userId, int page, int size) {&#10;        Pageable pageable = PageRequest.of(page, size, Sort.by(&quot;lastMessageAt&quot;).descending());&#10;        Page&lt;Conversation&gt; conversations = conversationRepository.findByParticipantIdsContaining(userId, pageable);&#10;        &#10;        return conversations.map(this::convertToResponse);&#10;    }&#10;    &#10;    public ConversationResponse getConversationById(String conversationId, String userId) {&#10;        Conversation conversation = conversationRepository.findById(conversationId)&#10;            .orElseThrow(() -&gt; new ChatException(&quot;Không tìm thấy cuộc trò chuyện&quot;));&#10;        &#10;        // Kiểm tra quyền truy cập&#10;        if (!conversation.getParticipantIds().contains(userId)) {&#10;            throw new ChatException(&quot;Bạn không có quyền truy cập cuộc trò chuyện này&quot;);&#10;        }&#10;        &#10;        return convertToResponse(conversation);&#10;    }&#10;    &#10;    public ConversationResponse updateConversation(String conversationId, UpdateConversationRequest request, String userId) {&#10;        Conversation conversation = conversationRepository.findById(conversationId)&#10;            .orElseThrow(() -&gt; new ChatException(&quot;Không tìm thấy cuộc trò chuyện&quot;));&#10;        &#10;        // Kiểm tra quyền sửa đổi&#10;        if (!canModifyConversation(conversation, userId)) {&#10;            throw new ChatException(&quot;Bạn không có quyền sửa đổi cuộc trò chuyện này&quot;);&#10;        }&#10;        &#10;        // Cập nhật thông tin&#10;        if (request.getName() != null) {&#10;            conversation.setName(request.getName());&#10;        }&#10;        &#10;        if (conversation.getMetadata() != null) {&#10;            if (request.getDescription() != null) {&#10;                conversation.getMetadata().setDescription(request.getDescription());&#10;            }&#10;            if (request.getAvatarUrl() != null) {&#10;                conversation.getMetadata().setAvatarUrl(request.getAvatarUrl());&#10;            }&#10;        }&#10;        &#10;        if (request.getParticipantIds() != null) {&#10;            conversation.setParticipantIds(request.getParticipantIds());&#10;        }&#10;        &#10;        conversation.setUpdatedAt(LocalDateTime.now());&#10;        &#10;        Conversation updated = conversationRepository.save(conversation);&#10;        return convertToResponse(updated);&#10;    }&#10;    &#10;    public void addParticipant(String conversationId, String participantId, String addedBy) {&#10;        Conversation conversation = conversationRepository.findById(conversationId)&#10;            .orElseThrow(() -&gt; new ChatException(&quot;Không tìm thấy cuộc trò chuyện&quot;));&#10;        &#10;        if (!canAddMembers(conversation, addedBy)) {&#10;            throw new ChatException(&quot;Bạn không có quyền thêm thành viên&quot;);&#10;        }&#10;        &#10;        if (!conversation.getParticipantIds().contains(participantId)) {&#10;            conversation.getParticipantIds().add(participantId);&#10;            conversation.setUpdatedAt(LocalDateTime.now());&#10;            conversationRepository.save(conversation);&#10;            &#10;            log.info(&quot;Added participant {} to conversation {} by {}&quot;, participantId, conversationId, addedBy);&#10;        }&#10;    }&#10;    &#10;    public void removeParticipant(String conversationId, String participantId, String removedBy) {&#10;        Conversation conversation = conversationRepository.findById(conversationId)&#10;            .orElseThrow(() -&gt; new ChatException(&quot;Không tìm thấy cuộc trò chuyện&quot;));&#10;        &#10;        // Chỉ admin hoặc chính user đó mới có thể remove&#10;        if (!canRemoveMembers(conversation, removedBy) &amp;&amp; !participantId.equals(removedBy)) {&#10;            throw new ChatException(&quot;Bạn không có quyền xóa thành viên&quot;);&#10;        }&#10;        &#10;        conversation.getParticipantIds().remove(participantId);&#10;        conversation.setUpdatedAt(LocalDateTime.now());&#10;        conversationRepository.save(conversation);&#10;        &#10;        log.info(&quot;Removed participant {} from conversation {} by {}&quot;, participantId, conversationId, removedBy);&#10;    }&#10;    &#10;    public List&lt;ConversationResponse&gt; searchConversations(String userId, String query) {&#10;        List&lt;Conversation&gt; conversations = conversationRepository&#10;            .findByParticipantIdsContainingAndNameContainingIgnoreCase(userId, query);&#10;        &#10;        return conversations.stream()&#10;            .map(this::convertToResponse)&#10;            .collect(Collectors.toList());&#10;    }&#10;    &#10;    public void deleteConversation(String conversationId, String userId) {&#10;        Conversation conversation = conversationRepository.findById(conversationId)&#10;            .orElseThrow(() -&gt; new ChatException(&quot;Không tìm thấy cuộc trò chuyện&quot;));&#10;        &#10;        // Chỉ creator hoặc admin mới có thể xóa&#10;        if (!canDeleteConversation(conversation, userId)) {&#10;            throw new ChatException(&quot;Bạn không có quyền xóa cuộc trò chuyện này&quot;);&#10;        }&#10;        &#10;        // Xóa tất cả messages trong conversation&#10;        messageRepository.deleteByConversationId(conversationId);&#10;        &#10;        // Xóa conversation&#10;        conversationRepository.deleteById(conversationId);&#10;        &#10;        log.info(&quot;Deleted conversation {} by user {}&quot;, conversationId, userId);&#10;    }&#10;    &#10;    private ConversationResponse convertToResponse(Conversation conversation) {&#10;        ConversationResponse response = new ConversationResponse();&#10;        response.setId(conversation.getId());&#10;        response.setName(conversation.getName());&#10;        response.setType(conversation.getType());&#10;        response.setCreatedAt(conversation.getCreatedAt());&#10;        response.setUpdatedAt(conversation.getUpdatedAt());&#10;        response.setLastMessageAt(conversation.getLastMessageAt());&#10;        &#10;        // Lấy thông tin participants&#10;        List&lt;ParticipantInfo&gt; participants = conversation.getParticipantIds().stream()&#10;            .map(this::getParticipantInfo)&#10;            .collect(Collectors.toList());&#10;        response.setParticipants(participants);&#10;        &#10;        // Avatar cho group chat&#10;        if (conversation.getMetadata() != null) {&#10;            response.setAvatarUrl(conversation.getMetadata().getAvatarUrl());&#10;        }&#10;        &#10;        // Đếm unread messages (sẽ implement sau)&#10;        response.setUnreadCount(0);&#10;        &#10;        return response;&#10;    }&#10;    &#10;    private ParticipantInfo getParticipantInfo(String userId) {&#10;        // Tích hợp với UserService để lấy thông tin user&#10;        // và UserPresenceService để lấy trạng thái online&#10;        ParticipantInfo info = new ParticipantInfo();&#10;        info.setUserId(userId);&#10;        // TODO: Implement user info retrieval&#10;        return info;&#10;    }&#10;    &#10;    private boolean canModifyConversation(Conversation conversation, String userId) {&#10;        if (conversation.getType() == Conversation.ConversationType.DIRECT) {&#10;            return conversation.getParticipantIds().contains(userId);&#10;        }&#10;        &#10;        // Group chat: chỉ admin mới được sửa&#10;        return conversation.getMetadata() != null &amp;&amp; &#10;               conversation.getMetadata().getAdminIds().contains(userId);&#10;    }&#10;    &#10;    private boolean canAddMembers(Conversation conversation, String userId) {&#10;        if (conversation.getSettings() != null &amp;&amp; &#10;            !conversation.getSettings().isAllowMembersToAddOthers()) {&#10;            return conversation.getMetadata() != null &amp;&amp; &#10;                   conversation.getMetadata().getAdminIds().contains(userId);&#10;        }&#10;        return conversation.getParticipantIds().contains(userId);&#10;    }&#10;    &#10;    private boolean canRemoveMembers(Conversation conversation, String userId) {&#10;        return conversation.getMetadata() != null &amp;&amp; &#10;               conversation.getMetadata().getAdminIds().contains(userId);&#10;    }&#10;    &#10;    private boolean canDeleteConversation(Conversation conversation, String userId) {&#10;        return conversation.getCreatedBy().equals(userId) ||&#10;               (conversation.getMetadata() != null &amp;&amp; &#10;                conversation.getMetadata().getAdminIds().contains(userId));&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/chat-service/src/main/java/vn/ctu/edu/chatservice/service/MessageService.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/chat-service/src/main/java/vn/ctu/edu/chatservice/service/MessageService.java" />
              <option name="updatedContent" value="package vn.ctu.edu.chatservice.service;&#10;&#10;import lombok.RequiredArgsConstructor;&#10;import lombok.extern.slf4j.Slf4j;&#10;import org.springframework.data.domain.Page;&#10;import org.springframework.data.domain.PageRequest;&#10;import org.springframework.data.domain.Pageable;&#10;import org.springframework.data.domain.Sort;&#10;import org.springframework.stereotype.Service;&#10;import vn.ctu.edu.chatservice.dto.request.AddReactionRequest;&#10;import vn.ctu.edu.chatservice.dto.request.SendMessageRequest;&#10;import vn.ctu.edu.chatservice.dto.response.MessageResponse;&#10;import vn.ctu.edu.chatservice.dto.response.ChatPageResponse;&#10;import vn.ctu.edu.chatservice.exception.ChatException;&#10;import vn.ctu.edu.chatservice.model.*;&#10;import vn.ctu.edu.chatservice.repository.ConversationRepository;&#10;import vn.ctu.edu.chatservice.repository.MessageRepository;&#10;&#10;import java.time.LocalDateTime;&#10;import java.util.List;&#10;import java.util.Optional;&#10;import java.util.stream.Collectors;&#10;&#10;@Service&#10;@RequiredArgsConstructor&#10;@Slf4j&#10;public class MessageService {&#10;    &#10;    private final MessageRepository messageRepository;&#10;    private final ConversationRepository conversationRepository;&#10;    private final WebSocketService webSocketService;&#10;    private final NotificationService notificationService;&#10;    &#10;    public MessageResponse sendMessage(SendMessageRequest request, String senderId) {&#10;        log.info(&quot;Sending message from user: {} to conversation: {}&quot;, senderId, request.getConversationId());&#10;        &#10;        // Kiểm tra conversation tồn tại và user có quyền gửi tin nhắn&#10;        Conversation conversation = conversationRepository.findById(request.getConversationId())&#10;            .orElseThrow(() -&gt; new ChatException(&quot;Không tìm thấy cuộc trò chuyện&quot;));&#10;        &#10;        if (!conversation.getParticipantIds().contains(senderId)) {&#10;            throw new ChatException(&quot;Bạn không có quyền gửi tin nhắn trong cuộc trò chuyện này&quot;);&#10;        }&#10;        &#10;        // Tạo message mới&#10;        Message message = new Message();&#10;        message.setConversationId(request.getConversationId());&#10;        message.setSenderId(senderId);&#10;        message.setType(Message.MessageType.TEXT);&#10;        message.setContent(request.getContent());&#10;        message.setReplyToMessageId(request.getReplyToMessageId());&#10;        message.setStatus(Message.MessageStatus.SENT);&#10;        message.setCreatedAt(LocalDateTime.now());&#10;        message.setUpdatedAt(LocalDateTime.now());&#10;        &#10;        // Lấy thông tin sender (cache)&#10;        // TODO: Tích hợp với UserService&#10;        message.setSenderName(&quot;User &quot; + senderId);&#10;        message.setSenderAvatar(&quot;&quot;);&#10;        &#10;        // Lưu message&#10;        Message savedMessage = messageRepository.save(message);&#10;        &#10;        // Cập nhật last message của conversation&#10;        conversation.setLastMessageId(savedMessage.getId());&#10;        conversation.setLastMessageAt(savedMessage.getCreatedAt());&#10;        conversation.setUpdatedAt(LocalDateTime.now());&#10;        conversationRepository.save(conversation);&#10;        &#10;        // Chuyển đổi thành response&#10;        MessageResponse response = convertToResponse(savedMessage);&#10;        &#10;        // Gửi real-time notification qua WebSocket&#10;        webSocketService.sendMessageToConversation(request.getConversationId(), response);&#10;        &#10;        // Gửi push notification&#10;        notificationService.sendMessageNotification(conversation, savedMessage);&#10;        &#10;        log.info(&quot;Message sent successfully: {}&quot;, savedMessage.getId());&#10;        return response;&#10;    }&#10;    &#10;    public ChatPageResponse&lt;MessageResponse&gt; getMessages(String conversationId, String userId, int page, int size) {&#10;        // Kiểm tra quyền truy cập&#10;        Conversation conversation = conversationRepository.findById(conversationId)&#10;            .orElseThrow(() -&gt; new ChatException(&quot;Không tìm thấy cuộc trò chuyện&quot;));&#10;        &#10;        if (!conversation.getParticipantIds().contains(userId)) {&#10;            throw new ChatException(&quot;Bạn không có quyền truy cập cuộc trò chuyện này&quot;);&#10;        }&#10;        &#10;        // Lấy messages với pagination (sắp xếp theo thời gian giảm dần)&#10;        Pageable pageable = PageRequest.of(page, size, Sort.by(&quot;createdAt&quot;).descending());&#10;        Page&lt;Message&gt; messages = messageRepository.findByConversationIdAndIsDeletedFalseOrderByCreatedAtDesc(&#10;            conversationId, pageable);&#10;        &#10;        // Chuyển đổi thành response&#10;        List&lt;MessageResponse&gt; messageResponses = messages.getContent().stream()&#10;            .map(this::convertToResponse)&#10;            .collect(Collectors.toList());&#10;        &#10;        // Đánh dấu messages là đã đọc&#10;        markMessagesAsRead(conversationId, userId);&#10;        &#10;        return new ChatPageResponse&lt;&gt;(&#10;            messageResponses,&#10;            messages.getNumber(),&#10;            messages.getSize(),&#10;            messages.getTotalElements(),&#10;            messages.getTotalPages(),&#10;            messages.hasNext(),&#10;            messages.hasPrevious()&#10;        );&#10;    }&#10;    &#10;    public MessageResponse editMessage(String messageId, String newContent, String userId) {&#10;        Message message = messageRepository.findById(messageId)&#10;            .orElseThrow(() -&gt; new ChatException(&quot;Không tìm thấy tin nhắn&quot;));&#10;        &#10;        // Chỉ người gửi mới có thể sửa tin nhắn&#10;        if (!message.getSenderId().equals(userId)) {&#10;            throw new ChatException(&quot;Bạn không có quyền sửa tin nhắn này&quot;);&#10;        }&#10;        &#10;        // Không thể sửa tin nhắn quá cũ (15 phút)&#10;        if (message.getCreatedAt().isBefore(LocalDateTime.now().minusMinutes(15))) {&#10;            throw new ChatException(&quot;Không thể sửa tin nhắn sau 15 phút&quot;);&#10;        }&#10;        &#10;        message.setContent(newContent);&#10;        message.setIsEdited(true);&#10;        message.setEditedAt(LocalDateTime.now());&#10;        message.setUpdatedAt(LocalDateTime.now());&#10;        &#10;        Message updated = messageRepository.save(message);&#10;        MessageResponse response = convertToResponse(updated);&#10;        &#10;        // Gửi cập nhật real-time&#10;        webSocketService.sendMessageUpdateToConversation(message.getConversationId(), response);&#10;        &#10;        return response;&#10;    }&#10;    &#10;    public void deleteMessage(String messageId, String userId) {&#10;        Message message = messageRepository.findById(messageId)&#10;            .orElseThrow(() -&gt; new ChatException(&quot;Không tìm thấy tin nhắn&quot;));&#10;        &#10;        // Chỉ người gửi mới có thể xóa tin nhắn&#10;        if (!message.getSenderId().equals(userId)) {&#10;            throw new ChatException(&quot;Bạn không có quyền xóa tin nhắn này&quot;);&#10;        }&#10;        &#10;        message.setIsDeleted(true);&#10;        message.setContent(&quot;Tin nhắn đã được xóa&quot;);&#10;        message.setUpdatedAt(LocalDateTime.now());&#10;        &#10;        messageRepository.save(message);&#10;        &#10;        // Gửi cập nhật real-time&#10;        webSocketService.sendMessageDeleteToConversation(message.getConversationId(), messageId);&#10;        &#10;        log.info(&quot;Message {} deleted by user {}&quot;, messageId, userId);&#10;    }&#10;    &#10;    public MessageResponse addReaction(AddReactionRequest request, String userId) {&#10;        Message message = messageRepository.findById(request.getMessageId())&#10;            .orElseThrow(() -&gt; new ChatException(&quot;Không tìm thấy tin nhắn&quot;));&#10;        &#10;        // Kiểm tra user có quyền react không&#10;        Conversation conversation = conversationRepository.findById(message.getConversationId())&#10;            .orElseThrow(() -&gt; new ChatException(&quot;Không tìm thấy cuộc trò chuyện&quot;));&#10;        &#10;        if (!conversation.getParticipantIds().contains(userId)) {&#10;            throw new ChatException(&quot;Bạn không có quyền react tin nhắn này&quot;);&#10;        }&#10;        &#10;        // Kiểm tra xem user đã react chưa&#10;        Optional&lt;MessageReaction&gt; existingReaction = message.getReactions().stream()&#10;            .filter(r -&gt; r.getUserId().equals(userId))&#10;            .findFirst();&#10;        &#10;        if (existingReaction.isPresent()) {&#10;            // Update existing reaction&#10;            existingReaction.get().setEmoji(request.getEmoji());&#10;            existingReaction.get().setCreatedAt(LocalDateTime.now());&#10;        } else {&#10;            // Add new reaction&#10;            MessageReaction reaction = new MessageReaction();&#10;            reaction.setUserId(userId);&#10;            reaction.setUserName(&quot;User &quot; + userId); // TODO: Get from UserService&#10;            reaction.setEmoji(request.getEmoji());&#10;            reaction.setCreatedAt(LocalDateTime.now());&#10;            message.getReactions().add(reaction);&#10;        }&#10;        &#10;        message.setUpdatedAt(LocalDateTime.now());&#10;        Message updated = messageRepository.save(message);&#10;        &#10;        MessageResponse response = convertToResponse(updated);&#10;        &#10;        // Gửi cập nhật real-time&#10;        webSocketService.sendReactionUpdateToConversation(message.getConversationId(), response);&#10;        &#10;        return response;&#10;    }&#10;    &#10;    public void removeReaction(String messageId, String userId) {&#10;        Message message = messageRepository.findById(messageId)&#10;            .orElseThrow(() -&gt; new ChatException(&quot;Không tìm thấy tin nhắn&quot;));&#10;        &#10;        message.getReactions().removeIf(r -&gt; r.getUserId().equals(userId));&#10;        message.setUpdatedAt(LocalDateTime.now());&#10;        &#10;        Message updated = messageRepository.save(message);&#10;        MessageResponse response = convertToResponse(updated);&#10;        &#10;        // Gửi cập nhật real-time&#10;        webSocketService.sendReactionUpdateToConversation(message.getConversationId(), response);&#10;    }&#10;    &#10;    public List&lt;MessageResponse&gt; searchMessages(String conversationId, String query, String userId) {&#10;        // Kiểm tra quyền truy cập&#10;        Conversation conversation = conversationRepository.findById(conversationId)&#10;            .orElseThrow(() -&gt; new ChatException(&quot;Không tìm thấy cuộc trò chuyện&quot;));&#10;        &#10;        if (!conversation.getParticipantIds().contains(userId)) {&#10;            throw new ChatException(&quot;Bạn không có quyền tìm kiếm trong cuộc trò chuyện này&quot;);&#10;        }&#10;        &#10;        List&lt;Message&gt; messages = messageRepository.searchMessagesInConversation(conversationId, query);&#10;        &#10;        return messages.stream()&#10;            .map(this::convertToResponse)&#10;            .collect(Collectors.toList());&#10;    }&#10;    &#10;    public long getUnreadCount(String conversationId, String userId) {&#10;        return messageRepository.countUnreadMessages(conversationId, userId);&#10;    }&#10;    &#10;    public void markMessagesAsRead(String conversationId, String userId) {&#10;        // Lấy tất cả messages chưa đọc trong conversation&#10;        List&lt;Message&gt; unreadMessages = messageRepository.findByConversationIdAndIsDeletedFalseOrderByCreatedAtDesc(&#10;            conversationId, PageRequest.of(0, 100)).getContent().stream()&#10;            .filter(m -&gt; !m.getReadByUserIds().contains(userId) &amp;&amp; !m.getSenderId().equals(userId))&#10;            .collect(Collectors.toList());&#10;        &#10;        // Đánh dấu là đã đọc&#10;        for (Message message : unreadMessages) {&#10;            if (!message.getReadByUserIds().contains(userId)) {&#10;                message.getReadByUserIds().add(userId);&#10;                message.setStatus(Message.MessageStatus.READ);&#10;                message.setUpdatedAt(LocalDateTime.now());&#10;            }&#10;        }&#10;        &#10;        if (!unreadMessages.isEmpty()) {&#10;            messageRepository.saveAll(unreadMessages);&#10;            &#10;            // Gửi read receipt real-time&#10;            webSocketService.sendReadReceiptToConversation(conversationId, userId);&#10;        }&#10;    }&#10;    &#10;    private MessageResponse convertToResponse(Message message) {&#10;        MessageResponse response = new MessageResponse();&#10;        response.setId(message.getId());&#10;        response.setConversationId(message.getConversationId());&#10;        response.setSenderId(message.getSenderId());&#10;        response.setSenderName(message.getSenderName());&#10;        response.setSenderAvatar(message.getSenderAvatar());&#10;        response.setType(message.getType());&#10;        response.setContent(message.getContent());&#10;        response.setReplyToMessageId(message.getReplyToMessageId());&#10;        response.setStatus(message.getStatus());&#10;        response.setReadByUserIds(message.getReadByUserIds());&#10;        response.setCreatedAt(message.getCreatedAt());&#10;        response.setUpdatedAt(message.getUpdatedAt());&#10;        response.setEditedAt(message.getEditedAt());&#10;        response.setEdited(message.isEdited());&#10;        response.setDeleted(message.isDeleted());&#10;        &#10;        // Convert reactions&#10;        if (message.getReactions() != null) {&#10;            response.setReactions(&#10;                message.getReactions().stream()&#10;                    .map(r -&gt; new MessageReactionResponse(r.getUserId(), r.getUserName(), r.getEmoji(), r.getCreatedAt()))&#10;                    .collect(Collectors.toList())&#10;            );&#10;        }&#10;        &#10;        // Convert attachment if exists&#10;        if (message.getAttachment() != null) {&#10;            MessageAttachmentResponse attachment = new MessageAttachmentResponse();&#10;            attachment.setFileName(message.getAttachment().getFileName());&#10;            attachment.setFileUrl(message.getAttachment().getFileUrl());&#10;            attachment.setFileType(message.getAttachment().getFileType());&#10;            attachment.setFileSize(message.getAttachment().getFileSize());&#10;            attachment.setThumbnailUrl(message.getAttachment().getThumbnailUrl());&#10;            response.setAttachment(attachment);&#10;        }&#10;        &#10;        // Load reply message if exists&#10;        if (message.getReplyToMessageId() != null) {&#10;            messageRepository.findById(message.getReplyToMessageId())&#10;                .ifPresent(replyMessage -&gt; response.setReplyToMessage(convertToResponse(replyMessage)));&#10;        }&#10;        &#10;        return response;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/chat-service/src/main/java/vn/ctu/edu/chatservice/service/NotificationService.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/chat-service/src/main/java/vn/ctu/edu/chatservice/service/NotificationService.java" />
              <option name="updatedContent" value="package vn.ctu.edu.chatservice.service;&#10;&#10;import lombok.RequiredArgsConstructor;&#10;import lombok.extern.slf4j.Slf4j;&#10;import org.springframework.kafka.core.KafkaTemplate;&#10;import org.springframework.stereotype.Service;&#10;import vn.ctu.edu.chatservice.model.Conversation;&#10;import vn.ctu.edu.chatservice.model.Message;&#10;&#10;import java.util.HashMap;&#10;import java.util.Map;&#10;&#10;@Service&#10;@RequiredArgsConstructor&#10;@Slf4j&#10;public class NotificationService {&#10;    &#10;    private final KafkaTemplate&lt;String, Object&gt; kafkaTemplate;&#10;    private final WebSocketService webSocketService;&#10;    &#10;    private static final String NOTIFICATION_TOPIC = &quot;chat_notifications&quot;;&#10;    &#10;    public void sendMessageNotification(Conversation conversation, Message message) {&#10;        // Tạo notification event&#10;        Map&lt;String, Object&gt; notificationEvent = new HashMap&lt;&gt;();&#10;        notificationEvent.put(&quot;type&quot;, &quot;NEW_MESSAGE&quot;);&#10;        notificationEvent.put(&quot;conversationId&quot;, conversation.getId());&#10;        notificationEvent.put(&quot;messageId&quot;, message.getId());&#10;        notificationEvent.put(&quot;senderId&quot;, message.getSenderId());&#10;        notificationEvent.put(&quot;senderName&quot;, message.getSenderName());&#10;        notificationEvent.put(&quot;content&quot;, message.getContent());&#10;        notificationEvent.put(&quot;conversationName&quot;, conversation.getName());&#10;        notificationEvent.put(&quot;conversationType&quot;, conversation.getType().toString());&#10;        &#10;        // Gửi notification cho từng participant (trừ sender)&#10;        conversation.getParticipantIds().stream()&#10;            .filter(participantId -&gt; !participantId.equals(message.getSenderId()))&#10;            .forEach(participantId -&gt; {&#10;                notificationEvent.put(&quot;recipientId&quot;, participantId);&#10;                &#10;                // Gửi qua Kafka để notification service xử lý&#10;                kafkaTemplate.send(NOTIFICATION_TOPIC, participantId, notificationEvent);&#10;                &#10;                // Gửi real-time notification qua WebSocket&#10;                webSocketService.sendNotificationToUser(participantId, notificationEvent);&#10;                &#10;                log.debug(&quot;Sent message notification to user: {}&quot;, participantId);&#10;            });&#10;    }&#10;    &#10;    public void sendConversationUpdateNotification(Conversation conversation, String updateType, String updatedBy) {&#10;        Map&lt;String, Object&gt; notificationEvent = new HashMap&lt;&gt;();&#10;        notificationEvent.put(&quot;type&quot;, &quot;CONVERSATION_UPDATE&quot;);&#10;        notificationEvent.put(&quot;conversationId&quot;, conversation.getId());&#10;        notificationEvent.put(&quot;updateType&quot;, updateType); // MEMBER_ADDED, MEMBER_REMOVED, INFO_UPDATED&#10;        notificationEvent.put(&quot;updatedBy&quot;, updatedBy);&#10;        notificationEvent.put(&quot;conversationName&quot;, conversation.getName());&#10;        &#10;        // Gửi cho tất cả participants&#10;        conversation.getParticipantIds().forEach(participantId -&gt; {&#10;            notificationEvent.put(&quot;recipientId&quot;, participantId);&#10;            kafkaTemplate.send(NOTIFICATION_TOPIC, participantId, notificationEvent);&#10;            webSocketService.sendNotificationToUser(participantId, notificationEvent);&#10;        });&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/chat-service/src/main/java/vn/ctu/edu/chatservice/service/UserPresenceService.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/chat-service/src/main/java/vn/ctu/edu/chatservice/service/UserPresenceService.java" />
              <option name="updatedContent" value="package vn.ctu.edu.chatservice.service;&#10;&#10;import lombok.RequiredArgsConstructor;&#10;import lombok.extern.slf4j.Slf4j;&#10;import org.springframework.data.redis.core.RedisTemplate;&#10;import org.springframework.stereotype.Service;&#10;import vn.ctu.edu.chatservice.dto.response.UserPresenceResponse;&#10;import vn.ctu.edu.chatservice.model.UserPresence;&#10;import vn.ctu.edu.chatservice.repository.UserPresenceRepository;&#10;&#10;import java.time.LocalDateTime;&#10;import java.util.List;&#10;import java.util.Optional;&#10;import java.util.concurrent.TimeUnit;&#10;import java.util.stream.Collectors;&#10;&#10;@Service&#10;@RequiredArgsConstructor&#10;@Slf4j&#10;public class UserPresenceService {&#10;    &#10;    private final UserPresenceRepository userPresenceRepository;&#10;    private final RedisTemplate&lt;String, Object&gt; redisTemplate;&#10;    private final WebSocketService webSocketService;&#10;    &#10;    private static final String PRESENCE_CACHE_PREFIX = &quot;presence:&quot;;&#10;    private static final String TYPING_CACHE_PREFIX = &quot;typing:&quot;;&#10;    &#10;    public void setUserOnline(String userId, String sessionId) {&#10;        log.info(&quot;Setting user {} online with session {}&quot;, userId, sessionId);&#10;        &#10;        UserPresence presence = userPresenceRepository.findByUserId(userId)&#10;            .orElse(new UserPresence());&#10;        &#10;        presence.setUserId(userId);&#10;        presence.setStatus(UserPresence.PresenceStatus.ONLINE);&#10;        presence.setSessionId(sessionId);&#10;        presence.setLastSeenAt(LocalDateTime.now());&#10;        presence.setUpdatedAt(LocalDateTime.now());&#10;        &#10;        // TODO: Lấy thông tin user từ UserService&#10;        presence.setUserName(&quot;User &quot; + userId);&#10;        presence.setUserAvatar(&quot;&quot;);&#10;        &#10;        userPresenceRepository.save(presence);&#10;        &#10;        // Cache trong Redis&#10;        cacheUserPresence(presence);&#10;        &#10;        // Broadcast presence update&#10;        webSocketService.broadcastPresenceUpdate(convertToResponse(presence));&#10;    }&#10;    &#10;    public void setUserOffline(String userId) {&#10;        log.info(&quot;Setting user {} offline&quot;, userId);&#10;        &#10;        Optional&lt;UserPresence&gt; existingPresence = userPresenceRepository.findByUserId(userId);&#10;        if (existingPresence.isPresent()) {&#10;            UserPresence presence = existingPresence.get();&#10;            presence.setStatus(UserPresence.PresenceStatus.OFFLINE);&#10;            presence.setLastSeenAt(LocalDateTime.now());&#10;            presence.setUpdatedAt(LocalDateTime.now());&#10;            presence.setCurrentActivity(null);&#10;            presence.setSessionId(null);&#10;            &#10;            userPresenceRepository.save(presence);&#10;            &#10;            // Cache trong Redis&#10;            cacheUserPresence(presence);&#10;            &#10;            // Clear typing status&#10;            clearTypingStatus(userId);&#10;            &#10;            // Broadcast presence update&#10;            webSocketService.broadcastPresenceUpdate(convertToResponse(presence));&#10;        }&#10;    }&#10;    &#10;    public void setUserAway(String userId) {&#10;        Optional&lt;UserPresence&gt; existingPresence = userPresenceRepository.findByUserId(userId);&#10;        if (existingPresence.isPresent()) {&#10;            UserPresence presence = existingPresence.get();&#10;            presence.setStatus(UserPresence.PresenceStatus.AWAY);&#10;            presence.setUpdatedAt(LocalDateTime.now());&#10;            &#10;            userPresenceRepository.save(presence);&#10;            cacheUserPresence(presence);&#10;            &#10;            webSocketService.broadcastPresenceUpdate(convertToResponse(presence));&#10;        }&#10;    }&#10;    &#10;    public void setTypingStatus(String userId, String conversationId, boolean isTyping) {&#10;        String typingKey = TYPING_CACHE_PREFIX + conversationId + &quot;:&quot; + userId;&#10;        &#10;        if (isTyping) {&#10;            // Set typing với TTL 10 giây&#10;            redisTemplate.opsForValue().set(typingKey, userId, 10, TimeUnit.SECONDS);&#10;            &#10;            // Update presence activity&#10;            Optional&lt;UserPresence&gt; presence = userPresenceRepository.findByUserId(userId);&#10;            if (presence.isPresent()) {&#10;                presence.get().setCurrentActivity(&quot;typing in &quot; + conversationId);&#10;                presence.get().setUpdatedAt(LocalDateTime.now());&#10;                userPresenceRepository.save(presence.get());&#10;            }&#10;            &#10;            log.debug(&quot;User {} started typing in conversation {}&quot;, userId, conversationId);&#10;        } else {&#10;            // Remove typing status&#10;            redisTemplate.delete(typingKey);&#10;            &#10;            // Clear presence activity&#10;            Optional&lt;UserPresence&gt; presence = userPresenceRepository.findByUserId(userId);&#10;            if (presence.isPresent()) {&#10;                presence.get().setCurrentActivity(null);&#10;                presence.get().setUpdatedAt(LocalDateTime.now());&#10;                userPresenceRepository.save(presence.get());&#10;            }&#10;            &#10;            log.debug(&quot;User {} stopped typing in conversation {}&quot;, userId, conversationId);&#10;        }&#10;        &#10;        // Broadcast typing status&#10;        webSocketService.broadcastTypingStatus(conversationId, userId, isTyping);&#10;    }&#10;    &#10;    public List&lt;String&gt; getTypingUsers(String conversationId) {&#10;        String pattern = TYPING_CACHE_PREFIX + conversationId + &quot;:*&quot;;&#10;        return redisTemplate.keys(pattern).stream()&#10;            .map(key -&gt; (String) redisTemplate.opsForValue().get(key))&#10;            .collect(Collectors.toList());&#10;    }&#10;    &#10;    public UserPresenceResponse getUserPresence(String userId) {&#10;        // Thử cache trước&#10;        UserPresence cached = getCachedUserPresence(userId);&#10;        if (cached != null) {&#10;            return convertToResponse(cached);&#10;        }&#10;        &#10;        // Nếu không có cache, query database&#10;        Optional&lt;UserPresence&gt; presence = userPresenceRepository.findByUserId(userId);&#10;        if (presence.isPresent()) {&#10;            cacheUserPresence(presence.get());&#10;            return convertToResponse(presence.get());&#10;        }&#10;        &#10;        // Nếu không tìm thấy, tạo presence mặc định&#10;        return createDefaultPresence(userId);&#10;    }&#10;    &#10;    public List&lt;UserPresenceResponse&gt; getMultipleUserPresence(List&lt;String&gt; userIds) {&#10;        return userIds.stream()&#10;            .map(this::getUserPresence)&#10;            .collect(Collectors.toList());&#10;    }&#10;    &#10;    public List&lt;UserPresenceResponse&gt; getOnlineUsers() {&#10;        List&lt;UserPresence&gt; onlineUsers = userPresenceRepository.findByStatus(UserPresence.PresenceStatus.ONLINE);&#10;        return onlineUsers.stream()&#10;            .map(this::convertToResponse)&#10;            .collect(Collectors.toList());&#10;    }&#10;    &#10;    public void cleanupStalePresence() {&#10;        // Cleanup presence cũ hơn 1 giờ&#10;        LocalDateTime oneHourAgo = LocalDateTime.now().minusHours(1);&#10;        userPresenceRepository.deleteByLastSeenAtBefore(oneHourAgo);&#10;        &#10;        log.info(&quot;Cleaned up stale presence records&quot;);&#10;    }&#10;    &#10;    private void cacheUserPresence(UserPresence presence) {&#10;        String cacheKey = PRESENCE_CACHE_PREFIX + presence.getUserId();&#10;        redisTemplate.opsForValue().set(cacheKey, presence, 5, TimeUnit.MINUTES);&#10;    }&#10;    &#10;    private UserPresence getCachedUserPresence(String userId) {&#10;        String cacheKey = PRESENCE_CACHE_PREFIX + userId;&#10;        return (UserPresence) redisTemplate.opsForValue().get(cacheKey);&#10;    }&#10;    &#10;    private void clearTypingStatus(String userId) {&#10;        String pattern = TYPING_CACHE_PREFIX + &quot;*:&quot; + userId;&#10;        redisTemplate.keys(pattern).forEach(redisTemplate::delete);&#10;    }&#10;    &#10;    private UserPresenceResponse createDefaultPresence(String userId) {&#10;        UserPresenceResponse response = new UserPresenceResponse();&#10;        response.setUserId(userId);&#10;        response.setUserName(&quot;User &quot; + userId);&#10;        response.setUserAvatar(&quot;&quot;);&#10;        response.setStatus(UserPresence.PresenceStatus.OFFLINE);&#10;        response.setLastSeenAt(LocalDateTime.now());&#10;        return response;&#10;    }&#10;    &#10;    private UserPresenceResponse convertToResponse(UserPresence presence) {&#10;        UserPresenceResponse response = new UserPresenceResponse();&#10;        response.setUserId(presence.getUserId());&#10;        response.setUserName(presence.getUserName());&#10;        response.setUserAvatar(presence.getUserAvatar());&#10;        response.setStatus(presence.getStatus());&#10;        response.setCurrentActivity(presence.getCurrentActivity());&#10;        response.setLastSeenAt(presence.getLastSeenAt());&#10;        return response;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/chat-service/src/main/java/vn/ctu/edu/chatservice/service/UserService.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/chat-service/src/main/java/vn/ctu/edu/chatservice/service/UserService.java" />
              <option name="updatedContent" value="package vn.ctu.edu.chatservice.service;&#10;&#10;import lombok.extern.slf4j.Slf4j;&#10;import org.springframework.beans.factory.annotation.Value;&#10;import org.springframework.stereotype.Service;&#10;import org.springframework.web.client.RestTemplate;&#10;&#10;import java.util.Map;&#10;&#10;@Service&#10;@Slf4j&#10;public class UserService {&#10;    &#10;    private final RestTemplate restTemplate;&#10;    private final String userServiceUrl;&#10;    &#10;    public UserService(RestTemplate restTemplate, &#10;                      @Value(&quot;${user.service.url:http://user-service:8081}&quot;) String userServiceUrl) {&#10;        this.restTemplate = restTemplate;&#10;        this.userServiceUrl = userServiceUrl;&#10;    }&#10;    &#10;    public Map&lt;String, Object&gt; getUserInfo(String userId) {&#10;        try {&#10;            String url = userServiceUrl + &quot;/api/users/&quot; + userId;&#10;            return restTemplate.getForObject(url, Map.class);&#10;        } catch (Exception e) {&#10;            log.error(&quot;Failed to get user info for userId: {}&quot;, userId, e);&#10;            return createDefaultUserInfo(userId);&#10;        }&#10;    }&#10;    &#10;    private Map&lt;String, Object&gt; createDefaultUserInfo(String userId) {&#10;        return Map.of(&#10;            &quot;id&quot;, userId,&#10;            &quot;name&quot;, &quot;User &quot; + userId,&#10;            &quot;avatar&quot;, &quot;&quot;&#10;        );&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/chat-service/src/main/java/vn/ctu/edu/chatservice/service/WebSocketService.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/chat-service/src/main/java/vn/ctu/edu/chatservice/service/WebSocketService.java" />
              <option name="updatedContent" value="package vn.ctu.edu.chatservice.service;&#10;&#10;import lombok.RequiredArgsConstructor;&#10;import lombok.extern.slf4j.Slf4j;&#10;import org.springframework.messaging.simp.SimpMessagingTemplate;&#10;import org.springframework.stereotype.Service;&#10;import vn.ctu.edu.chatservice.dto.response.MessageResponse;&#10;import vn.ctu.edu.chatservice.dto.response.UserPresenceResponse;&#10;&#10;@Service&#10;@RequiredArgsConstructor&#10;@Slf4j&#10;public class WebSocketService {&#10;    &#10;    private final SimpMessagingTemplate messagingTemplate;&#10;    &#10;    // Send message to all users in a conversation&#10;    public void sendMessageToConversation(String conversationId, MessageResponse message) {&#10;        String destination = &quot;/topic/conversation/&quot; + conversationId + &quot;/messages&quot;;&#10;        messagingTemplate.convertAndSend(destination, message);&#10;        log.debug(&quot;Sent message to conversation {}: {}&quot;, conversationId, message.getId());&#10;    }&#10;    &#10;    // Send message update (edit) to conversation&#10;    public void sendMessageUpdateToConversation(String conversationId, MessageResponse message) {&#10;        String destination = &quot;/topic/conversation/&quot; + conversationId + &quot;/messages/update&quot;;&#10;        messagingTemplate.convertAndSend(destination, message);&#10;        log.debug(&quot;Sent message update to conversation {}: {}&quot;, conversationId, message.getId());&#10;    }&#10;    &#10;    // Send message delete notification&#10;    public void sendMessageDeleteToConversation(String conversationId, String messageId) {&#10;        String destination = &quot;/topic/conversation/&quot; + conversationId + &quot;/messages/delete&quot;;&#10;        messagingTemplate.convertAndSend(destination, messageId);&#10;        log.debug(&quot;Sent message delete to conversation {}: {}&quot;, conversationId, messageId);&#10;    }&#10;    &#10;    // Send reaction update&#10;    public void sendReactionUpdateToConversation(String conversationId, MessageResponse message) {&#10;        String destination = &quot;/topic/conversation/&quot; + conversationId + &quot;/reactions&quot;;&#10;        messagingTemplate.convertAndSend(destination, message);&#10;        log.debug(&quot;Sent reaction update to conversation {}: {}&quot;, conversationId, message.getId());&#10;    }&#10;    &#10;    // Send typing status&#10;    public void broadcastTypingStatus(String conversationId, String userId, boolean isTyping) {&#10;        String destination = &quot;/topic/conversation/&quot; + conversationId + &quot;/typing&quot;;&#10;        TypingEvent event = new TypingEvent(userId, isTyping);&#10;        messagingTemplate.convertAndSend(destination, event);&#10;        log.debug(&quot;Broadcasted typing status for user {} in conversation {}: {}&quot;, userId, conversationId, isTyping);&#10;    }&#10;    &#10;    // Send read receipt&#10;    public void sendReadReceiptToConversation(String conversationId, String userId) {&#10;        String destination = &quot;/topic/conversation/&quot; + conversationId + &quot;/read&quot;;&#10;        ReadReceiptEvent event = new ReadReceiptEvent(userId);&#10;        messagingTemplate.convertAndSend(destination, event);&#10;        log.debug(&quot;Sent read receipt for user {} in conversation {}&quot;, userId, conversationId);&#10;    }&#10;    &#10;    // Broadcast user presence update&#10;    public void broadcastPresenceUpdate(UserPresenceResponse presence) {&#10;        String destination = &quot;/topic/presence&quot;;&#10;        messagingTemplate.convertAndSend(destination, presence);&#10;        log.debug(&quot;Broadcasted presence update for user {}: {}&quot;, presence.getUserId(), presence.getStatus());&#10;    }&#10;    &#10;    // Send notification to specific user&#10;    public void sendNotificationToUser(String userId, Object notification) {&#10;        String destination = &quot;/queue/user/&quot; + userId + &quot;/notifications&quot;;&#10;        messagingTemplate.convertAndSend(destination, notification);&#10;        log.debug(&quot;Sent notification to user {}&quot;, userId);&#10;    }&#10;    &#10;    // Send conversation update (new conversation, member added/removed)&#10;    public void sendConversationUpdate(String conversationId, Object update) {&#10;        String destination = &quot;/topic/conversation/&quot; + conversationId + &quot;/updates&quot;;&#10;        messagingTemplate.convertAndSend(destination, update);&#10;        log.debug(&quot;Sent conversation update to {}&quot;, conversationId);&#10;    }&#10;    &#10;    // Event classes&#10;    public static class TypingEvent {&#10;        private String userId;&#10;        private boolean isTyping;&#10;        &#10;        public TypingEvent(String userId, boolean isTyping) {&#10;            this.userId = userId;&#10;            this.isTyping = isTyping;&#10;        }&#10;        &#10;        // Getters and setters&#10;        public String getUserId() { return userId; }&#10;        public void setUserId(String userId) { this.userId = userId; }&#10;        public boolean isTyping() { return isTyping; }&#10;        public void setTyping(boolean typing) { isTyping = typing; }&#10;    }&#10;    &#10;    public static class ReadReceiptEvent {&#10;        private String userId;&#10;        &#10;        public ReadReceiptEvent(String userId) {&#10;            this.userId = userId;&#10;        }&#10;        &#10;        // Getters and setters&#10;        public String getUserId() { return userId; }&#10;        public void setUserId(String userId) { this.userId = userId; }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/client-frontend/.env.local">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/client-frontend/.env.local" />
              <option name="originalContent" value="# API Configuration&#10;NEXT_PUBLIC_API_URL=http://localhost:8090/api&#10;&#10;# App Configuration&#10;NEXT_PUBLIC_APP_NAME=CTU_Connect&#10;NEXT_PUBLIC_APP_VERSION=1.0.0&#10;&#10;# Socket Configuration (for real-time features)&#10;NEXT_PUBLIC_SOCKET_URL=ws://localhost:8090/ws&#10;&#10;# File Upload Configuration&#10;NEXT_PUBLIC_MAX_FILE_SIZE=10485760&#10;&#10;# Development&#10;NODE_ENV=development&#10;&#10;# Optional: CSRF Token if needed&#10;# NEXT_PUBLIC_CSRF_TOKEN_HEADER=X-CSRF-TOKEN&#10;" />
              <option name="updatedContent" value="# API Configuration&#13;&#10;NEXT_PUBLIC_API_URL=http://localhost:8090/api&#13;&#10;&#13;&#10;# Chat Service Configuration&#13;&#10;NEXT_PUBLIC_CHAT_SERVICE_URL=http://localhost:8084&#13;&#10;&#13;&#10;# reCAPTCHA Configuration&#13;&#10;NEXT_PUBLIC_RECAPTCHA_SITE_KEY=6Lc3hoIrAAAAAH2Eo0ab9wqpOEBQR41WuQJgalw2&#13;&#10;&#13;&#10;# App Configuration&#13;&#10;NEXT_PUBLIC_APP_NAME=CTU_Connect&#13;&#10;NEXT_PUBLIC_APP_VERSION=1.0.0&#13;&#10;&#13;&#10;# Socket Configuration (for real-time features)&#13;&#10;NEXT_PUBLIC_SOCKET_URL=ws://localhost:8090/ws&#13;&#10;NEXT_PUBLIC_CHAT_WEBSOCKET_URL=ws://localhost:8084/ws&#13;&#10;&#13;&#10;# File Upload Configuration&#13;&#10;NEXT_PUBLIC_MAX_FILE_SIZE=10485760&#13;&#10;NEXT_PUBLIC_ALLOWED_FILE_TYPES=image/jpeg,image/png,image/gif,image/webp&#13;&#10;&#13;&#10;# Development&#13;&#10;NODE_ENV=development&#13;&#10;&#13;&#10;# Optional: CSRF Token if needed&#13;&#10;# NEXT_PUBLIC_CSRF_TOKEN_HEADER=X-CSRF-TOKEN" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/client-frontend/src/app/friends/page.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/client-frontend/src/app/friends/page.tsx" />
              <option name="originalContent" value="'use client';&#10;&#10;import { FriendsDashboard } from '@/features/users/components/friends';&#10;&#10;&#10;export default function FriendsPage() {&#10;  return (&#10;&#10;      &lt;div className=&quot;min-h-screen bg-gray-50&quot;&gt;&#10;        &lt;FriendsDashboard /&gt;&#10;      &lt;/div&gt;&#10;&#10;  );&#10;}&#10;" />
              <option name="updatedContent" value="'use client';&#10;&#10;import { FriendsList } from '@/features/users/components/friends/FriendsList';&#10;import { FriendRequests } from '@/features/users/components/friends/FriendRequests';&#10;import { FriendSuggestions } from '@/features/users/components/friends/FriendSuggestions';&#10;import { useState } from 'react';&#10;&#10;type FriendsTab = 'friends' | 'requests' | 'suggestions';&#10;&#10;export default function FriendsPage() {&#10;  const [activeTab, setActiveTab] = useState&lt;FriendsTab&gt;('friends');&#10;&#10;  const tabs = [&#10;    { id: 'friends' as const, label: 'My Friends', icon: '' },&#10;    { id: 'requests' as const, label: 'Friend Requests', icon: '' },&#10;    { id: 'suggestions' as const, label: 'Suggestions', icon: '' }&#10;  ];&#10;&#10;  return (&#10;    &lt;div className=&quot;min-h-screen bg-gray-50&quot;&gt;&#10;      &lt;div className=&quot;max-w-6xl mx-auto p-6&quot;&gt;&#10;        {/* Header */}&#10;        &lt;div className=&quot;mb-6&quot;&gt;&#10;          &lt;h1 className=&quot;text-2xl font-bold text-gray-900 mb-2&quot;&gt;Friends&lt;/h1&gt;&#10;          &lt;p className=&quot;text-gray-600&quot;&gt;Manage your friends and discover new connections&lt;/p&gt;&#10;        &lt;/div&gt;&#10;&#10;        {/* Tab Navigation */}&#10;        &lt;div className=&quot;flex space-x-1 bg-gray-100 p-1 rounded-lg mb-6&quot;&gt;&#10;          {tabs.map((tab) =&gt; (&#10;            &lt;button&#10;              key={tab.id}&#10;              onClick={() =&gt; setActiveTab(tab.id)}&#10;              className={`flex-1 flex items-center justify-center space-x-2 py-3 px-4 rounded-md text-sm font-medium transition-colors ${&#10;                activeTab === tab.id&#10;                  ? 'bg-white text-blue-600 shadow-sm'&#10;                  : 'text-gray-500 hover:text-gray-700 hover:bg-gray-50'&#10;              }`}&#10;            &gt;&#10;              &lt;span&gt;{tab.icon}&lt;/span&gt;&#10;              &lt;span&gt;{tab.label}&lt;/span&gt;&#10;            &lt;/button&gt;&#10;          ))}&#10;        &lt;/div&gt;&#10;&#10;        {/* Tab Content */}&#10;        &lt;div className=&quot;bg-white rounded-lg border shadow-sm p-6&quot;&gt;&#10;          {activeTab === 'friends' &amp;&amp; &lt;FriendsList /&gt;}&#10;          {activeTab === 'requests' &amp;&amp; &lt;FriendRequests /&gt;}&#10;          {activeTab === 'suggestions' &amp;&amp; &lt;FriendSuggestions /&gt;}&#10;        &lt;/div&gt;&#10;      &lt;/div&gt;&#10;    &lt;/div&gt;&#10;  );&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/client-frontend/src/app/messages/page.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/client-frontend/src/app/messages/page.tsx" />
              <option name="originalContent" value="'use client';&#10;&#10;import React from 'react';&#10;import { useAuth } from '@/contexts/AuthContext';&#10;import Card from '@/components/ui/Card';&#10;import Card from '@/components/ui/Card';&#10;import { useEffect } from 'react';&#10;&#10;export default function MessagesPage() {&#10;  const { user, loading } = useAuth();&#10;  const router = useRouter();&#10;&#10;  useEffect(() =&gt; {&#10;      router.push('/login');&#10;    }&#10;  }, [user, loading, router]);&#10;&#10;  if (loading) {&#10;    return (&#10;      &lt;div className=&quot;min-h-screen flex items-center justify-center&quot;&gt;&#10;        &lt;div className=&quot;animate-spin rounded-full h-8 w-8 border-b-2 border-indigo-600&quot;&gt;&lt;/div&gt;&#10;      &lt;/div&gt;&#10;    );&#10;  }&#10;&#10;  if (!user) {&#10;    return null;&#10;  }&#10;&#10;  return (&#10;    &lt;Layout&gt;&#10;      &lt;div className=&quot;max-w-6xl mx-auto&quot;&gt;&#10;        &lt;Card className=&quot;min-h-[600px]&quot;&gt;&#10;          &lt;div className=&quot;text-center py-16&quot;&gt;&#10;      &lt;div className=&quot;max-w-6xl mx-auto&quot;&gt;&#10;        &lt;Card className=&quot;min-h-[600px]&quot;&gt;&#10;          &lt;div className=&quot;text-center py-16&quot;&gt;&#10;            &lt;h1 className=&quot;text-2xl font-bold text-gray-900 mb-4&quot;&gt;Tin nhắn&lt;/h1&gt;&#10;            &lt;p className=&quot;text-gray-600 mb-8&quot;&gt;Tính năng chat sẽ sớm được phát triển&lt;/p&gt;&#10;            &lt;div className=&quot;bg-gray-50 rounded-lg p-8&quot;&gt;&#10;              &lt;p className=&quot;text-sm text-gray-500&quot;&gt;&#10;                Chức năng nhắn tin đang được phát triển và sẽ có sẵn trong phiên bản tiếp theo.&#10;              &lt;/p&gt;&#10;            &lt;/div&gt;&#10;          &lt;/div&gt;&#10;        &lt;/Card&gt;&#10;        &lt;/Card&gt;&#10;      &lt;/div&gt;&#10;    &lt;/Layout&gt;&#10;  );&#10;}&#10;" />
              <option name="updatedContent" value="'use client';&#10;&#10;import React, { useState } from 'react';&#10;import { useAuth } from '@/contexts/AuthContext';&#10;import { ChatProvider } from '@/contexts/ChatContext';&#10;import Layout from '@/components/layout/Layout';&#10;import ChatWindow from '@/components/chat/ChatWindow';&#10;import { useRouter } from 'next/navigation';&#10;import { useEffect } from 'react';&#10;&#10;export default function MessagesPage() {&#10;  const { user, loading } = useAuth();&#10;  const router = useRouter();&#10;  const [isChatOpen, setIsChatOpen] = useState(true);&#10;&#10;  useEffect(() =&gt; {&#10;    if (!loading &amp;&amp; !user) {&#10;      router.push('/login');&#10;    }&#10;  }, [user, loading, router]);&#10;&#10;  if (loading) {&#10;    return (&#10;      &lt;div className=&quot;min-h-screen flex items-center justify-center&quot;&gt;&#10;        &lt;div className=&quot;animate-spin rounded-full h-8 w-8 border-b-2 border-indigo-600&quot;&gt;&lt;/div&gt;&#10;      &lt;/div&gt;&#10;    );&#10;  }&#10;&#10;  if (!user) {&#10;    return null;&#10;  }&#10;&#10;  return (&#10;    &lt;Layout&gt;&#10;      &lt;div className=&quot;h-[calc(100vh-8rem)] max-w-7xl mx-auto&quot;&gt;&#10;        &lt;ChatProvider&gt;&#10;          &lt;ChatWindow &#10;            isOpen={isChatOpen}&#10;            onClose={() =&gt; setIsChatOpen(false)}&#10;            currentUserId={user.id}&#10;          /&gt;&#10;        &lt;/ChatProvider&gt;&#10;      &lt;/div&gt;&#10;    &lt;/Layout&gt;&#10;  );&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/client-frontend/src/app/profile/[userId]/page.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/client-frontend/src/app/profile/[userId]/page.tsx" />
              <option name="originalContent" value="'use client';&#10;&#10;import React from 'react';&#10;import { useParams } from 'next/navigation';&#10;import { useAuth } from '@/contexts/AuthContext';&#10;import Layout from '@/components/layout/Layout';&#10;import UserProfile from '@/components/user/UserProfile';&#10;import { useRouter } from 'next/navigation';&#10;import { useEffect } from 'react';&#10;&#10;export default function ProfilePage() {&#10;  const { user, loading } = useAuth();&#10;  const router = useRouter();&#10;  const params = useParams();&#10;  const userId = params.userId as string;&#10;&#10;  useEffect(() =&gt; {&#10;    if (!loading &amp;&amp; !user) {&#10;      router.push('/login');&#10;  }, [user, loading, router]);&#10;  }, [user, loading, router]);&#10;" />
              <option name="updatedContent" value="'use client';&#10;&#10;import React from 'react';&#10;import { useParams } from 'next/navigation';&#10;import { useAuth } from '@/contexts/AuthContext';&#10;import Layout from '@/components/layout/Layout';&#10;import UserProfile from '@/components/user/UserProfile';&#10;import { useRouter } from 'next/navigation';&#10;import { useEffect } from 'react';&#10;&#10;export default function OtherUserProfilePage() {&#10;  const { user, loading } = useAuth();&#10;  const router = useRouter();&#10;  const params = useParams();&#10;  const userId = params.userId as string;&#10;&#10;  useEffect(() =&gt; {&#10;    if (!loading &amp;&amp; !user) {&#10;      router.push('/login');&#10;      return;&#10;    }&#10;&#10;    // If the userId matches current user's ID, redirect to /profile/me&#10;    if (user &amp;&amp; user.id === userId) {&#10;      router.push('/profile/me');&#10;      return;&#10;    }&#10;  }, [user, loading, router, userId]);&#10;&#10;  if (loading) {&#10;    return (&#10;      &lt;div className=&quot;min-h-screen flex items-center justify-center bg-gray-50&quot;&gt;&#10;        &lt;div className=&quot;text-center&quot;&gt;&#10;          &lt;div className=&quot;animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600 mx-auto mb-4&quot;&gt;&lt;/div&gt;&#10;          &lt;p className=&quot;text-gray-600 vietnamese-text&quot;&gt;Đang tải trang cá nhân...&lt;/p&gt;&#10;        &lt;/div&gt;&#10;      &lt;/div&gt;&#10;    );&#10;  }&#10;&#10;  if (!user) {&#10;    return null;&#10;  }&#10;&#10;  // Don't render if this is current user's profile (will be redirected)&#10;  if (user.id === userId) {&#10;    return null;&#10;  }&#10;&#10;  return (&#10;    &lt;Layout&gt;&#10;      &lt;div className=&quot;min-h-screen bg-gray-50&quot;&gt;&#10;        &lt;UserProfile userId={userId} /&gt;&#10;      &lt;/div&gt;&#10;    &lt;/Layout&gt;&#10;  );&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/client-frontend/src/app/profile/me/page.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/client-frontend/src/app/profile/me/page.tsx" />
              <option name="updatedContent" value="'use client';&#10;&#10;import React from 'react';&#10;import { useAuth } from '@/contexts/AuthContext';&#10;import Layout from '@/components/layout/Layout';&#10;import UserProfile from '@/components/user/UserProfile';&#10;import { useRouter } from 'next/navigation';&#10;import { useEffect } from 'react';&#10;&#10;export default function MyProfilePage() {&#10;  const { user, loading } = useAuth();&#10;  const router = useRouter();&#10;&#10;  useEffect(() =&gt; {&#10;    if (!loading &amp;&amp; !user) {&#10;      router.push('/login');&#10;    }&#10;  }, [user, loading, router]);&#10;&#10;  if (loading) {&#10;    return (&#10;      &lt;div className=&quot;min-h-screen flex items-center justify-center bg-gray-50&quot;&gt;&#10;        &lt;div className=&quot;text-center&quot;&gt;&#10;          &lt;div className=&quot;animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600 mx-auto mb-4&quot;&gt;&lt;/div&gt;&#10;          &lt;p className=&quot;text-gray-600 vietnamese-text&quot;&gt;Đang tải trang cá nhân của bạn...&lt;/p&gt;&#10;        &lt;/div&gt;&#10;      &lt;/div&gt;&#10;    );&#10;  }&#10;&#10;  if (!user) {&#10;    return null;&#10;  }&#10;&#10;  return (&#10;    &lt;Layout&gt;&#10;      &lt;div className=&quot;min-h-screen bg-gray-50&quot;&gt;&#10;        &lt;UserProfile userId={user.id} /&gt;&#10;      &lt;/div&gt;&#10;    &lt;/Layout&gt;&#10;  );&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/client-frontend/src/app/profile/update/page.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/client-frontend/src/app/profile/update/page.tsx" />
              <option name="originalContent" value="'use client';&#10;&#10;import { useEffect, useState } from 'react';&#10;import { useAuth } from '@/contexts/AuthContext';&#10;import { userService } from '@/services/userService';&#10;import { User } from '@/types';&#10;import StudentProfileForm from '@/components/profile/StudentProfileForm';&#10;import LecturerProfileForm from '@/components/profile/LecturerProfileForm';&#10;import LoadingSpinner from '@/components/ui/LoadingSpinner';&#10;import {useRouter} from &quot;next/navigation&quot;;&#10;        &lt;div className=&quot;bg-white rounded-lg shadow-lg p-8&quot;&gt;&#10;          &lt;div className=&quot;text-center mb-8&quot;&gt;&#10;            &lt;h1 className=&quot;text-3xl font-bold text-gray-900 mb-2&quot;&gt;&#10;        &lt;/div&gt;&#10;      &lt;/div&gt;&#10;      &lt;/div&gt;&#10;    &lt;/div&gt;&#10;  );&#10;}&#10;      &lt;div className=&quot;min-h-screen flex items-center justify-center&quot;&gt;&#10;        &lt;LoadingSpinner /&gt;&#10;      &lt;/div&gt;&#10;" />
              <option name="updatedContent" value="'use client';&#13;&#10;&#13;&#10;import { useEffect, useState } from 'react';&#13;&#10;import { useAuth } from '@/contexts/AuthContext';&#13;&#10;import { userService } from '@/services/userService';&#13;&#10;import { User } from '@/types';&#13;&#10;import StudentProfileForm from '@/components/profile/StudentProfileForm';&#13;&#10;import LecturerProfileForm from '@/components/profile/LecturerProfileForm';&#13;&#10;import LoadingSpinner from '@/components/ui/LoadingSpinner';&#13;&#10;import Layout from '@/components/layout/Layout';&#13;&#10;import { useRouter } from &quot;next/navigation&quot;;&#13;&#10;import { ArrowLeft, User as UserIcon } from 'lucide-react';&#13;&#10;import { Button } from '@/components/ui/Button';&#13;&#10;&#13;&#10;export default function UpdateProfilePage() {&#13;&#10;  const { user } = useAuth();&#13;&#10;  const router = useRouter();&#13;&#10;  const [currentUser, setCurrentUser] = useState&lt;User | null&gt;(null);&#13;&#10;  const [loading, setLoading] = useState(true);&#13;&#10;  const [error, setError] = useState&lt;string | null&gt;(null);&#13;&#10;&#13;&#10;  useEffect(() =&gt; {&#13;&#10;    if (!user) {&#13;&#10;      router.push('/login');&#13;&#10;      return;&#13;&#10;    }&#13;&#10;&#13;&#10;    const fetchUserProfile = async () =&gt; {&#13;&#10;      try {&#13;&#10;        const profile = await userService.getMyProfile();&#13;&#10;        setCurrentUser(profile);&#13;&#10;        console.log('Current user profile:', profile);&#13;&#10;      } catch (err) {&#13;&#10;        console.error('Error fetching user profile:', err);&#13;&#10;        setError('Không thể tải thông tin người dùng');&#13;&#10;      } finally {&#13;&#10;        setLoading(false);&#13;&#10;      }&#13;&#10;    };&#13;&#10;&#13;&#10;    fetchUserProfile();&#13;&#10;  }, [user, router]);&#13;&#10;&#13;&#10;  const handleBackToProfile = () =&gt; {&#13;&#10;    router.push('/profile/me');&#13;&#10;  };&#13;&#10;&#13;&#10;  if (loading) {&#13;&#10;    return (&#13;&#10;      &lt;Layout&gt;&#13;&#10;        &lt;div className=&quot;min-h-screen flex items-center justify-center bg-gray-50&quot;&gt;&#13;&#10;          &lt;div className=&quot;text-center&quot;&gt;&#13;&#10;            &lt;LoadingSpinner size=&quot;lg&quot; /&gt;&#13;&#10;            &lt;p className=&quot;text-gray-600 mt-4 vietnamese-text&quot;&gt;Đang tải thông tin cá nhân...&lt;/p&gt;&#13;&#10;          &lt;/div&gt;&#13;&#10;        &lt;/div&gt;&#13;&#10;      &lt;/Layout&gt;&#13;&#10;    );&#13;&#10;  }&#13;&#10;&#13;&#10;  if (error) {&#13;&#10;    return (&#13;&#10;      &lt;Layout&gt;&#13;&#10;        &lt;div className=&quot;min-h-screen flex items-center justify-center bg-gray-50&quot;&gt;&#13;&#10;          &lt;div className=&quot;text-center bg-white rounded-lg shadow-sm p-8 max-w-md&quot;&gt;&#13;&#10;            &lt;div className=&quot;text-red-500 mb-4&quot;&gt;&#13;&#10;              &lt;UserIcon className=&quot;h-16 w-16 mx-auto&quot; /&gt;&#13;&#10;            &lt;/div&gt;&#13;&#10;            &lt;h2 className=&quot;text-2xl font-bold text-red-600 mb-4 vietnamese-text&quot;&gt;Lỗi&lt;/h2&gt;&#13;&#10;            &lt;p className=&quot;text-gray-600 mb-6 vietnamese-text&quot;&gt;{error}&lt;/p&gt;&#13;&#10;            &lt;Button onClick={() =&gt; window.location.reload()} className=&quot;mr-3&quot;&gt;&#13;&#10;              Thử lại&#13;&#10;            &lt;/Button&gt;&#13;&#10;            &lt;Button variant=&quot;outline&quot; onClick={() =&gt; router.push('/profile/me')}&gt;&#13;&#10;              Quay lại&#13;&#10;            &lt;/Button&gt;&#13;&#10;          &lt;/div&gt;&#13;&#10;        &lt;/div&gt;&#13;&#10;      &lt;/Layout&gt;&#13;&#10;    );&#13;&#10;  }&#13;&#10;&#13;&#10;  if (!currentUser) {&#13;&#10;    return (&#13;&#10;      &lt;Layout&gt;&#13;&#10;        &lt;div className=&quot;min-h-screen flex items-center justify-center bg-gray-50&quot;&gt;&#13;&#10;          &lt;div className=&quot;text-center bg-white rounded-lg shadow-sm p-8 max-w-md&quot;&gt;&#13;&#10;            &lt;div className=&quot;text-gray-400 mb-4&quot;&gt;&#13;&#10;              &lt;UserIcon className=&quot;h-16 w-16 mx-auto&quot; /&gt;&#13;&#10;            &lt;/div&gt;&#13;&#10;            &lt;h2 className=&quot;text-2xl font-bold text-gray-800 mb-4 vietnamese-text&quot;&gt;&#13;&#10;              Không tìm thấy thông tin người dùng&#13;&#10;            &lt;/h2&gt;&#13;&#10;            &lt;Button onClick={() =&gt; router.push('/profile/me')}&gt;&#13;&#10;              Quay lại trang cá nhân&#13;&#10;            &lt;/Button&gt;&#13;&#10;          &lt;/div&gt;&#13;&#10;        &lt;/div&gt;&#13;&#10;      &lt;/Layout&gt;&#13;&#10;    );&#13;&#10;  }&#13;&#10;&#13;&#10;  return (&#13;&#10;    &lt;Layout&gt;&#13;&#10;      &lt;div className=&quot;min-h-screen bg-gray-50 py-8&quot;&gt;&#13;&#10;        &lt;div className=&quot;max-w-4xl mx-auto px-4 sm:px-6 lg:px-8&quot;&gt;&#13;&#10;          {/* Header with Back Button */}&#13;&#10;          &lt;div className=&quot;mb-6&quot;&gt;&#13;&#10;            &lt;Button&#13;&#10;              variant=&quot;outline&quot;&#13;&#10;              onClick={handleBackToProfile}&#13;&#10;              className=&quot;flex items-center space-x-2 mb-4&quot;&#13;&#10;            &gt;&#13;&#10;              &lt;ArrowLeft className=&quot;h-4 w-4&quot; /&gt;&#13;&#10;              &lt;span className=&quot;vietnamese-text&quot;&gt;Quay lại trang cá nhân&lt;/span&gt;&#13;&#10;            &lt;/Button&gt;&#13;&#10;          &lt;/div&gt;&#13;&#10;&#13;&#10;          &lt;div className=&quot;bg-white rounded-lg shadow-lg p-8&quot;&gt;&#13;&#10;            &lt;div className=&quot;text-center mb-8&quot;&gt;&#13;&#10;              &lt;div className=&quot;mb-4&quot;&gt;&#13;&#10;                {currentUser.avatarUrl ? (&#13;&#10;                  &lt;img&#13;&#10;                    src={currentUser.avatarUrl}&#13;&#10;                    alt=&quot;Avatar&quot;&#13;&#10;                    className=&quot;w-20 h-20 rounded-full mx-auto object-cover border-4 border-white shadow-lg&quot;&#13;&#10;                  /&gt;&#13;&#10;                ) : (&#13;&#10;                  &lt;div className=&quot;w-20 h-20 bg-gradient-to-br from-blue-400 to-purple-600 rounded-full mx-auto flex items-center justify-center text-white text-2xl font-bold shadow-lg&quot;&gt;&#13;&#10;                    {(currentUser.fullName || currentUser.name || 'U').charAt(0).toUpperCase()}&#13;&#10;                  &lt;/div&gt;&#13;&#10;                )}&#13;&#10;              &lt;/div&gt;&#13;&#10;              &#13;&#10;              &lt;h1 className=&quot;text-3xl font-bold text-gray-900 mb-2 vietnamese-text&quot;&gt;&#13;&#10;                Cập nhật thông tin cá nhân&#13;&#10;              &lt;/h1&gt;&#13;&#10;              &lt;p className=&quot;text-gray-600 vietnamese-text&quot;&gt;&#13;&#10;                Vui lòng hoàn thiện thông tin để sử dụng đầy đủ các tính năng của hệ thống&#13;&#10;              &lt;/p&gt;&#13;&#10;              &#13;&#10;              {/* Role Badge */}&#13;&#10;              &lt;div className=&quot;mt-4&quot;&gt;&#13;&#10;                &lt;span className={`inline-flex px-3 py-1 rounded-full text-sm font-medium ${&#13;&#10;                  currentUser.role === 'LECTURER' &#13;&#10;                    ? 'bg-blue-100 text-blue-700' &#13;&#10;                    : 'bg-green-100 text-green-700'&#13;&#10;                }`}&gt;&#13;&#10;                  {currentUser.role === 'LECTURER' ? 'Giảng viên' : 'Sinh viên'}&#13;&#10;                &lt;/span&gt;&#13;&#10;              &lt;/div&gt;&#13;&#10;            &lt;/div&gt;&#13;&#10;&#13;&#10;            {currentUser.role === 'STUDENT' &amp;&amp; (&#13;&#10;              &lt;StudentProfileForm user={currentUser} /&gt;&#13;&#10;            )}&#13;&#10;&#13;&#10;            {currentUser.role === 'LECTURER' &amp;&amp; (&#13;&#10;              &lt;LecturerProfileForm user={currentUser} /&gt;&#13;&#10;            )}&#13;&#10;&#13;&#10;            {!['STUDENT', 'LECTURER'].includes(currentUser.role) &amp;&amp; (&#13;&#10;              &lt;div className=&quot;text-center py-8&quot;&gt;&#13;&#10;                &lt;div className=&quot;text-gray-400 mb-4&quot;&gt;&#13;&#10;                  &lt;UserIcon className=&quot;h-12 w-12 mx-auto&quot; /&gt;&#13;&#10;                &lt;/div&gt;&#13;&#10;                &lt;p className=&quot;text-gray-600 vietnamese-text&quot;&gt;&#13;&#10;                  Vai trò người dùng không hợp lệ để cập nhật thông tin cá nhân.&#13;&#10;                &lt;/p&gt;&#13;&#10;                &lt;Button &#13;&#10;                  variant=&quot;outline&quot; &#13;&#10;                  onClick={() =&gt; router.push('/profile/me')} &#13;&#10;                  className=&quot;mt-4&quot;&#13;&#10;                &gt;&#13;&#10;                  Quay lại trang cá nhân&#13;&#10;                &lt;/Button&gt;&#13;&#10;              &lt;/div&gt;&#13;&#10;            )}&#13;&#10;          &lt;/div&gt;&#13;&#10;        &lt;/div&gt;&#13;&#10;      &lt;/div&gt;&#13;&#10;    &lt;/Layout&gt;&#13;&#10;  );&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/client-frontend/src/components/chat/NewConversationModal.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/client-frontend/src/components/chat/NewConversationModal.tsx" />
              <option name="updatedContent" value="import React, { useState } from 'react';&#10;import { XMarkIcon } from '@heroicons/react/24/outline';&#10;&#10;interface NewConversationModalProps {&#10;  isOpen: boolean;&#10;  onClose: () =&gt; void;&#10;  currentUserId: string;&#10;}&#10;&#10;const NewConversationModal: React.FC&lt;NewConversationModalProps&gt; = ({&#10;  isOpen,&#10;  onClose,&#10;  currentUserId&#10;}) =&gt; {&#10;  const [searchQuery, setSearchQuery] = useState('');&#10;  const [selectedUsers, setSelectedUsers] = useState&lt;string[]&gt;([]);&#10;  const [conversationName, setConversationName] = useState('');&#10;&#10;  if (!isOpen) return null;&#10;&#10;  const handleCreateConversation = () =&gt; {&#10;    // TODO: Implement conversation creation&#10;    console.log('Creating conversation:', {&#10;      name: conversationName,&#10;      participants: selectedUsers,&#10;      createdBy: currentUserId&#10;    });&#10;    onClose();&#10;  };&#10;&#10;  return (&#10;    &lt;div className=&quot;fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50&quot;&gt;&#10;      &lt;div className=&quot;bg-white rounded-lg p-6 w-full max-w-md mx-4&quot;&gt;&#10;        &lt;div className=&quot;flex items-center justify-between mb-4&quot;&gt;&#10;          &lt;h2 className=&quot;text-lg font-semibold&quot;&gt;New Conversation&lt;/h2&gt;&#10;          &lt;button&#10;            onClick={onClose}&#10;            className=&quot;text-gray-400 hover:text-gray-600&quot;&#10;          &gt;&#10;            &lt;XMarkIcon className=&quot;h-6 w-6&quot; /&gt;&#10;          &lt;/button&gt;&#10;        &lt;/div&gt;&#10;&#10;        &lt;div className=&quot;space-y-4&quot;&gt;&#10;          &lt;div&gt;&#10;            &lt;label className=&quot;block text-sm font-medium text-gray-700 mb-1&quot;&gt;&#10;              Conversation Name (optional)&#10;            &lt;/label&gt;&#10;            &lt;input&#10;              type=&quot;text&quot;&#10;              value={conversationName}&#10;              onChange={(e) =&gt; setConversationName(e.target.value)}&#10;              placeholder=&quot;Enter conversation name&quot;&#10;              className=&quot;w-full px-3 py-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-indigo-500 focus:border-transparent&quot;&#10;            /&gt;&#10;          &lt;/div&gt;&#10;&#10;          &lt;div&gt;&#10;            &lt;label className=&quot;block text-sm font-medium text-gray-700 mb-1&quot;&gt;&#10;              Search Users&#10;            &lt;/label&gt;&#10;            &lt;input&#10;              type=&quot;text&quot;&#10;              value={searchQuery}&#10;              onChange={(e) =&gt; setSearchQuery(e.target.value)}&#10;              placeholder=&quot;Search for users to add&quot;&#10;              className=&quot;w-full px-3 py-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-indigo-500 focus:border-transparent&quot;&#10;            /&gt;&#10;          &lt;/div&gt;&#10;&#10;          {/* TODO: Add user search results */}&#10;          &lt;div className=&quot;text-sm text-gray-500&quot;&gt;&#10;            User search functionality will be implemented here&#10;          &lt;/div&gt;&#10;        &lt;/div&gt;&#10;&#10;        &lt;div className=&quot;flex justify-end space-x-3 mt-6&quot;&gt;&#10;          &lt;button&#10;            onClick={onClose}&#10;            className=&quot;px-4 py-2 text-sm font-medium text-gray-700 bg-gray-100 hover:bg-gray-200 rounded-md&quot;&#10;          &gt;&#10;            Cancel&#10;          &lt;/button&gt;&#10;          &lt;button&#10;            onClick={handleCreateConversation}&#10;            disabled={selectedUsers.length === 0}&#10;            className=&quot;px-4 py-2 text-sm font-medium text-white bg-indigo-600 hover:bg-indigo-700 disabled:opacity-50 disabled:cursor-not-allowed rounded-md&quot;&#10;          &gt;&#10;            Create&#10;          &lt;/button&gt;&#10;        &lt;/div&gt;&#10;      &lt;/div&gt;&#10;    &lt;/div&gt;&#10;  );&#10;};&#10;&#10;export default NewConversationModal;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/client-frontend/src/components/chat/UserPresenceBar.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/client-frontend/src/components/chat/UserPresenceBar.tsx" />
              <option name="updatedContent" value="import React from 'react';&#10;import { useChat } from '@/contexts/ChatContext';&#10;&#10;const UserPresenceBar: React.FC = () =&gt; {&#10;  const { onlineUsers } = useChat();&#10;&#10;  if (onlineUsers.size === 0) {&#10;    return null;&#10;  }&#10;&#10;  return (&#10;    &lt;div className=&quot;p-3 bg-gray-50 border-t border-gray-200&quot;&gt;&#10;      &lt;div className=&quot;flex items-center space-x-2&quot;&gt;&#10;        &lt;div className=&quot;flex items-center space-x-1&quot;&gt;&#10;          &lt;div className=&quot;w-2 h-2 bg-green-400 rounded-full&quot;&gt;&lt;/div&gt;&#10;          &lt;span className=&quot;text-sm text-gray-600&quot;&gt;&#10;            {onlineUsers.size} online&#10;          &lt;/span&gt;&#10;        &lt;/div&gt;&#10;      &lt;/div&gt;&#10;    &lt;/div&gt;&#10;  );&#10;};&#10;&#10;export default UserPresenceBar;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/client-frontend/src/components/post/PostEditModal.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/client-frontend/src/components/post/PostEditModal.tsx" />
              <option name="updatedContent" value="'use client';&#10;&#10;import React, { useState } from 'react';&#10;import { Modal } from '@/components/ui/Modal';&#10;import { Button } from '@/components/ui/Button';&#10;import { Textarea } from '@/components/ui/Textarea';&#10;import { Input } from '@/components/ui/Input';&#10;import { LoadingSpinner } from '@/components/ui/LoadingSpinner';&#10;import { UpdatePostRequest } from '@/types';&#10;import { X, Image, Video, Hash } from 'lucide-react';&#10;&#10;interface PostEditModalProps {&#10;  isOpen: boolean;&#10;  onClose: () =&gt; void;&#10;  post: any;&#10;  onSave: (updatedPost: UpdatePostRequest) =&gt; Promise&lt;void&gt;;&#10;}&#10;&#10;export const PostEditModal: React.FC&lt;PostEditModalProps&gt; = ({&#10;  isOpen,&#10;  onClose,&#10;  post,&#10;  onSave&#10;}) =&gt; {&#10;  const [title, setTitle] = useState(post.title || '');&#10;  const [content, setContent] = useState(post.content || '');&#10;  const [category, setCategory] = useState(post.category || '');&#10;  const [tags, setTags] = useState&lt;string[]&gt;(post.tags || []);&#10;  const [tagInput, setTagInput] = useState('');&#10;  const [visibility, setVisibility] = useState(post.visibility || post.privacy || 'PUBLIC');&#10;  const [isSaving, setIsSaving] = useState(false);&#10;&#10;  const handleAddTag = () =&gt; {&#10;    if (tagInput.trim() &amp;&amp; !tags.includes(tagInput.trim())) {&#10;      setTags(prev =&gt; [...prev, tagInput.trim()]);&#10;      setTagInput('');&#10;    }&#10;  };&#10;&#10;  const handleRemoveTag = (tagToRemove: string) =&gt; {&#10;    setTags(prev =&gt; prev.filter(tag =&gt; tag !== tagToRemove));&#10;  };&#10;&#10;  const handleKeyPress = (e: React.KeyboardEvent) =&gt; {&#10;    if (e.key === 'Enter' &amp;&amp; tagInput.trim()) {&#10;      e.preventDefault();&#10;      handleAddTag();&#10;    }&#10;  };&#10;&#10;  const handleSave = async () =&gt; {&#10;    if (!content.trim()) return;&#10;&#10;    setIsSaving(true);&#10;    try {&#10;      const updatedPost: UpdatePostRequest = {&#10;        title: title.trim() || undefined,&#10;        content: content.trim(),&#10;        category: category.trim() || undefined,&#10;        tags: tags.length &gt; 0 ? tags : undefined,&#10;        visibility: visibility as 'PUBLIC' | 'FRIENDS' | 'PRIVATE'&#10;      };&#10;&#10;      await onSave(updatedPost);&#10;      onClose();&#10;    } catch (error) {&#10;      console.error('Error saving post:', error);&#10;    } finally {&#10;      setIsSaving(false);&#10;    }&#10;  };&#10;&#10;  const handleClose = () =&gt; {&#10;    if (!isSaving) {&#10;      onClose();&#10;    }&#10;  };&#10;&#10;  return (&#10;    &lt;Modal &#10;      isOpen={isOpen} &#10;      onClose={handleClose}&#10;      title=&quot;Chỉnh sửa bài viết&quot;&#10;      size=&quot;lg&quot;&#10;    &gt;&#10;      &lt;div className=&quot;space-y-6&quot;&gt;&#10;        {/* Title */}&#10;        &lt;div&gt;&#10;          &lt;label className=&quot;block text-sm font-medium text-gray-700 mb-2 vietnamese-text&quot;&gt;&#10;            Tiêu đề (tùy chọn)&#10;          &lt;/label&gt;&#10;          &lt;Input&#10;            type=&quot;text&quot;&#10;            value={title}&#10;            onChange={(e) =&gt; setTitle(e.target.value)}&#10;            placeholder=&quot;Nhập tiêu đề bài viết...&quot;&#10;            className=&quot;vietnamese-text&quot;&#10;            disabled={isSaving}&#10;          /&gt;&#10;        &lt;/div&gt;&#10;&#10;        {/* Content */}&#10;        &lt;div&gt;&#10;          &lt;label className=&quot;block text-sm font-medium text-gray-700 mb-2 vietnamese-text&quot;&gt;&#10;            Nội dung &lt;span className=&quot;text-red-500&quot;&gt;*&lt;/span&gt;&#10;          &lt;/label&gt;&#10;          &lt;Textarea&#10;            value={content}&#10;            onChange={(e) =&gt; setContent(e.target.value)}&#10;            placeholder=&quot;Bạn đang nghĩ gì?&quot;&#10;            className=&quot;min-h-[120px] vietnamese-text&quot;&#10;            disabled={isSaving}&#10;          /&gt;&#10;        &lt;/div&gt;&#10;&#10;        {/* Category */}&#10;        &lt;div&gt;&#10;          &lt;label className=&quot;block text-sm font-medium text-gray-700 mb-2 vietnamese-text&quot;&gt;&#10;            Danh mục&#10;          &lt;/label&gt;&#10;          &lt;select&#10;            value={category}&#10;            onChange={(e) =&gt; setCategory(e.target.value)}&#10;            className=&quot;w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 vietnamese-text&quot;&#10;            disabled={isSaving}&#10;          &gt;&#10;            &lt;option value=&quot;&quot;&gt;Chọn danh mục&lt;/option&gt;&#10;            &lt;option value=&quot;Tin tức&quot;&gt;Tin tức&lt;/option&gt;&#10;            &lt;option value=&quot;Học tập&quot;&gt;Học tập&lt;/option&gt;&#10;            &lt;option value=&quot;Giải trí&quot;&gt;Giải trí&lt;/option&gt;&#10;            &lt;option value=&quot;Thể thao&quot;&gt;Thể thao&lt;/option&gt;&#10;            &lt;option value=&quot;Công nghệ&quot;&gt;Công nghệ&lt;/option&gt;&#10;            &lt;option value=&quot;Du lịch&quot;&gt;Du lịch&lt;/option&gt;&#10;            &lt;option value=&quot;Khác&quot;&gt;Khác&lt;/option&gt;&#10;          &lt;/select&gt;&#10;        &lt;/div&gt;&#10;&#10;        {/* Tags */}&#10;        &lt;div&gt;&#10;          &lt;label className=&quot;block text-sm font-medium text-gray-700 mb-2 vietnamese-text&quot;&gt;&#10;            Thẻ hashtag&#10;          &lt;/label&gt;&#10;          &lt;div className=&quot;flex flex-wrap gap-2 mb-2&quot;&gt;&#10;            {tags.map((tag, index) =&gt; (&#10;              &lt;span&#10;                key={index}&#10;                className=&quot;inline-flex items-center bg-blue-100 text-blue-800 text-sm px-2 py-1 rounded-full&quot;&#10;              &gt;&#10;                &lt;Hash className=&quot;h-3 w-3 mr-1&quot; /&gt;&#10;                {tag}&#10;                &lt;button&#10;                  type=&quot;button&quot;&#10;                  onClick={() =&gt; handleRemoveTag(tag)}&#10;                  className=&quot;ml-1 hover:text-blue-600&quot;&#10;                  disabled={isSaving}&#10;                &gt;&#10;                  &lt;X className=&quot;h-3 w-3&quot; /&gt;&#10;                &lt;/button&gt;&#10;              &lt;/span&gt;&#10;            ))}&#10;          &lt;/div&gt;&#10;          &lt;div className=&quot;flex space-x-2&quot;&gt;&#10;            &lt;Input&#10;              type=&quot;text&quot;&#10;              value={tagInput}&#10;              onChange={(e) =&gt; setTagInput(e.target.value)}&#10;              onKeyPress={handleKeyPress}&#10;              placeholder=&quot;Thêm thẻ hashtag...&quot;&#10;              className=&quot;flex-1 vietnamese-text&quot;&#10;              disabled={isSaving}&#10;            /&gt;&#10;            &lt;Button&#10;              type=&quot;button&quot;&#10;              onClick={handleAddTag}&#10;              disabled={!tagInput.trim() || isSaving}&#10;              variant=&quot;outline&quot;&#10;              size=&quot;sm&quot;&#10;            &gt;&#10;              Thêm&#10;            &lt;/Button&gt;&#10;          &lt;/div&gt;&#10;        &lt;/div&gt;&#10;&#10;        {/* Visibility */}&#10;        &lt;div&gt;&#10;          &lt;label className=&quot;block text-sm font-medium text-gray-700 mb-2 vietnamese-text&quot;&gt;&#10;            Quyền riêng tư&#10;          &lt;/label&gt;&#10;          &lt;select&#10;            value={visibility}&#10;            onChange={(e) =&gt; setVisibility(e.target.value)}&#10;            className=&quot;w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 vietnamese-text&quot;&#10;            disabled={isSaving}&#10;          &gt;&#10;            &lt;option value=&quot;PUBLIC&quot;&gt;Công khai&lt;/option&gt;&#10;            &lt;option value=&quot;FRIENDS&quot;&gt;Bạn bè&lt;/option&gt;&#10;            &lt;option value=&quot;PRIVATE&quot;&gt;Riêng tư&lt;/option&gt;&#10;          &lt;/select&gt;&#10;        &lt;/div&gt;&#10;&#10;        {/* Media Preview (if exists) */}&#10;        {(post.images?.length &gt; 0 || post.videos?.length &gt; 0) &amp;&amp; (&#10;          &lt;div&gt;&#10;            &lt;label className=&quot;block text-sm font-medium text-gray-700 mb-2 vietnamese-text&quot;&gt;&#10;              Media hiện tại&#10;            &lt;/label&gt;&#10;            &lt;div className=&quot;bg-gray-50 rounded-lg p-4&quot;&gt;&#10;              &lt;div className=&quot;flex items-center space-x-4 text-sm text-gray-600&quot;&gt;&#10;                {post.images?.length &gt; 0 &amp;&amp; (&#10;                  &lt;div className=&quot;flex items-center space-x-1&quot;&gt;&#10;                    &lt;Image className=&quot;h-4 w-4&quot; /&gt;&#10;                    &lt;span&gt;{post.images.length} ảnh&lt;/span&gt;&#10;                  &lt;/div&gt;&#10;                )}&#10;                {post.videos?.length &gt; 0 &amp;&amp; (&#10;                  &lt;div className=&quot;flex items-center space-x-1&quot;&gt;&#10;                    &lt;Video className=&quot;h-4 w-4&quot; /&gt;&#10;                    &lt;span&gt;{post.videos.length} video&lt;/span&gt;&#10;                  &lt;/div&gt;&#10;                )}&#10;              &lt;/div&gt;&#10;              &lt;p className=&quot;text-xs text-gray-500 mt-2 vietnamese-text&quot;&gt;&#10;                Lưu ý: Không thể chỉnh sửa media trong phiên bản hiện tại&#10;              &lt;/p&gt;&#10;            &lt;/div&gt;&#10;          &lt;/div&gt;&#10;        )}&#10;&#10;        {/* Action Buttons */}&#10;        &lt;div className=&quot;flex justify-end space-x-3 pt-4 border-t&quot;&gt;&#10;          &lt;Button&#10;            variant=&quot;outline&quot;&#10;            onClick={handleClose}&#10;            disabled={isSaving}&#10;          &gt;&#10;            Hủy&#10;          &lt;/Button&gt;&#10;          &lt;Button&#10;            onClick={handleSave}&#10;            disabled={!content.trim() || isSaving}&#10;            className=&quot;flex items-center space-x-2&quot;&#10;          &gt;&#10;            {isSaving ? (&#10;              &lt;&gt;&#10;                &lt;LoadingSpinner size=&quot;sm&quot; /&gt;&#10;                &lt;span&gt;Đang lưu...&lt;/span&gt;&#10;              &lt;/&gt;&#10;            ) : (&#10;              &lt;span&gt;Lưu thay đổi&lt;/span&gt;&#10;            )}&#10;          &lt;/Button&gt;&#10;        &lt;/div&gt;&#10;      &lt;/div&gt;&#10;    &lt;/Modal&gt;&#10;  );&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/client-frontend/src/components/post/PostMenu.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/client-frontend/src/components/post/PostMenu.tsx" />
              <option name="updatedContent" value="'use client';&#10;&#10;import React, { useState } from 'react';&#10;import { &#10;  MoreHorizontal, &#10;  Edit3, &#10;  Trash2, &#10;  Flag, &#10;  EyeOff, &#10;  UserX,&#10;  Copy,&#10;  Bookmark,&#10;  Share&#10;} from 'lucide-react';&#10;import { useAuth } from '@/contexts/AuthContext';&#10;&#10;interface PostMenuProps {&#10;  post: any;&#10;  onEdit?: () =&gt; void;&#10;  onDelete?: () =&gt; void;&#10;  onReport?: () =&gt; void;&#10;  onHide?: () =&gt; void;&#10;  onBlock?: () =&gt; void;&#10;  onBookmark?: () =&gt; void;&#10;  onShare?: () =&gt; void;&#10;  onCopyLink?: () =&gt; void;&#10;  className?: string;&#10;}&#10;&#10;export const PostMenu: React.FC&lt;PostMenuProps&gt; = ({&#10;  post,&#10;  onEdit,&#10;  onDelete,&#10;  onReport,&#10;  onHide,&#10;  onBlock,&#10;  onBookmark,&#10;  onShare,&#10;  onCopyLink,&#10;  className = ''&#10;}) =&gt; {&#10;  const { user } = useAuth();&#10;  const [isOpen, setIsOpen] = useState(false);&#10;  const isOwnPost = user?.id === post.authorId || user?.id === post.author?.id;&#10;&#10;  const handleAction = (action: () =&gt; void) =&gt; {&#10;    action();&#10;    setIsOpen(false);&#10;  };&#10;&#10;  const menuItems = [&#10;    // Own post actions&#10;    ...(isOwnPost ? [&#10;      {&#10;        icon: &lt;Edit3 className=&quot;h-4 w-4&quot; /&gt;,&#10;        label: 'Chỉnh sửa bài viết',&#10;        action: onEdit,&#10;        className: 'text-gray-700 hover:bg-gray-50'&#10;      },&#10;      {&#10;        icon: &lt;Trash2 className=&quot;h-4 w-4 text-red-500&quot; /&gt;,&#10;        label: 'Xóa bài viết',&#10;        action: onDelete,&#10;        className: 'text-red-600 hover:bg-red-50'&#10;      }&#10;    ] : []),&#10;    &#10;    // Common actions&#10;    {&#10;      icon: &lt;Bookmark className=&quot;h-4 w-4&quot; /&gt;,&#10;      label: 'Lưu bài viết',&#10;      action: onBookmark,&#10;      className: 'text-gray-700 hover:bg-gray-50'&#10;    },&#10;    {&#10;      icon: &lt;Share className=&quot;h-4 w-4&quot; /&gt;,&#10;      label: 'Chia sẻ',&#10;      action: onShare,&#10;      className: 'text-gray-700 hover:bg-gray-50'&#10;    },&#10;    {&#10;      icon: &lt;Copy className=&quot;h-4 w-4&quot; /&gt;,&#10;      label: 'Sao chép liên kết',&#10;      action: onCopyLink,&#10;      className: 'text-gray-700 hover:bg-gray-50'&#10;    },&#10;    &#10;    // Other user's post actions&#10;    ...(!isOwnPost ? [&#10;      {&#10;        icon: &lt;Flag className=&quot;h-4 w-4 text-red-500&quot; /&gt;,&#10;        label: 'Báo cáo bài viết',&#10;        action: onReport,&#10;        className: 'text-red-600 hover:bg-red-50'&#10;      },&#10;      {&#10;        icon: &lt;EyeOff className=&quot;h-4 w-4&quot; /&gt;,&#10;        label: 'Ẩn bài viết',&#10;        action: onHide,&#10;        className: 'text-gray-700 hover:bg-gray-50'&#10;      },&#10;      {&#10;        icon: &lt;UserX className=&quot;h-4 w-4 text-red-500&quot; /&gt;,&#10;        label: `Chặn bài viết từ ${post.author?.fullName || post.author?.name || post.authorName}`,&#10;        action: onBlock,&#10;        className: 'text-red-600 hover:bg-red-50'&#10;      }&#10;    ] : [])&#10;  ].filter(item =&gt; item.action); // Only include items with actions&#10;&#10;  return (&#10;    &lt;div className={`relative ${className}`}&gt;&#10;      &lt;button&#10;        onClick={() =&gt; setIsOpen(!isOpen)}&#10;        className=&quot;p-2 hover:bg-gray-100 rounded-full transition-colors&quot;&#10;        aria-label=&quot;Tùy chọn bài viết&quot;&#10;      &gt;&#10;        &lt;MoreHorizontal className=&quot;h-4 w-4 text-gray-500&quot; /&gt;&#10;      &lt;/button&gt;&#10;&#10;      {isOpen &amp;&amp; (&#10;        &lt;&gt;&#10;          {/* Backdrop */}&#10;          &lt;div &#10;            className=&quot;fixed inset-0 z-40&quot; &#10;            onClick={() =&gt; setIsOpen(false)}&#10;          /&gt;&#10;          &#10;          {/* Menu */}&#10;          &lt;div className=&quot;absolute right-0 top-full mt-1 bg-white rounded-lg shadow-lg border border-gray-200 py-2 z-50 min-w-[220px]&quot;&gt;&#10;            {menuItems.map((item, index) =&gt; (&#10;              &lt;button&#10;                key={index}&#10;                onClick={() =&gt; handleAction(item.action!)}&#10;                className={`&#10;                  flex items-center space-x-3 w-full px-4 py-2 text-sm transition-colors vietnamese-text&#10;                  ${item.className}&#10;                `}&#10;              &gt;&#10;                {item.icon}&#10;                &lt;span&gt;{item.label}&lt;/span&gt;&#10;              &lt;/button&gt;&#10;            ))}&#10;            &#10;            {menuItems.length === 0 &amp;&amp; (&#10;              &lt;div className=&quot;px-4 py-2 text-sm text-gray-500 vietnamese-text&quot;&gt;&#10;                Không có tùy chọn nào&#10;              &lt;/div&gt;&#10;            )}&#10;          &lt;/div&gt;&#10;        &lt;/&gt;&#10;      )}&#10;    &lt;/div&gt;&#10;  );&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/client-frontend/src/components/profile/ProfileHeader.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/client-frontend/src/components/profile/ProfileHeader.tsx" />
              <option name="updatedContent" value="'use client';&#10;&#10;import React, { useState } from 'react';&#10;import { User } from '@/types';&#10;import { Camera, MapPin, Calendar, Briefcase, GraduationCap, Edit3, UserPlus, MessageCircle, MoreHorizontal } from 'lucide-react';&#10;import { Button } from '@/components/ui/Button';&#10;import { formatTimeAgo } from '@/utils/localization';&#10;&#10;interface ProfileHeaderProps {&#10;  user: User;&#10;  isOwnProfile: boolean;&#10;  isFollowing?: boolean;&#10;  onFollow?: () =&gt; void;&#10;  onMessage?: () =&gt; void;&#10;  onEditProfile?: () =&gt; void;&#10;  onEditCover?: () =&gt; void;&#10;  onEditAvatar?: () =&gt; void;&#10;}&#10;&#10;export const ProfileHeader: React.FC&lt;ProfileHeaderProps&gt; = ({&#10;  user,&#10;  isOwnProfile,&#10;  isFollowing = false,&#10;  onFollow,&#10;  onMessage,&#10;  onEditProfile,&#10;  onEditCover,&#10;  onEditAvatar&#10;}) =&gt; {&#10;  const [showFullBio, setShowFullBio] = useState(false);&#10;&#10;  const getRoleDisplay = (role: string) =&gt; {&#10;    switch (role) {&#10;      case 'STUDENT': return 'Sinh viên';&#10;      case 'LECTURER': return 'Giảng viên';&#10;      case 'ADMIN': return 'Quản trị viên';&#10;      default: return 'Người dùng';&#10;    }&#10;  };&#10;&#10;  return (&#10;    &lt;div className=&quot;bg-white rounded-lg shadow-sm overflow-hidden&quot;&gt;&#10;      {/* Cover Photo */}&#10;      &lt;div className=&quot;relative h-80 bg-gradient-to-r from-blue-500 to-purple-600&quot;&gt;&#10;        {user.backgroundUrl ? (&#10;          &lt;img&#10;            src={user.backgroundUrl}&#10;            alt=&quot;Ảnh bìa&quot;&#10;            className=&quot;w-full h-full object-cover&quot;&#10;          /&gt;&#10;        ) : (&#10;          &lt;div className=&quot;w-full h-full bg-gradient-to-r from-blue-500 via-purple-500 to-pink-500&quot; /&gt;&#10;        )}&#10;        &#10;        {/* Cover Photo Edit Button */}&#10;        {isOwnProfile &amp;&amp; (&#10;          &lt;button&#10;            onClick={onEditCover}&#10;            className=&quot;absolute bottom-4 right-4 bg-white bg-opacity-90 hover:bg-opacity-100 rounded-lg px-3 py-2 text-gray-700 font-medium transition-all duration-200 flex items-center space-x-2&quot;&#10;          &gt;&#10;            &lt;Camera className=&quot;h-4 w-4&quot; /&gt;&#10;            &lt;span className=&quot;text-sm&quot;&gt;Chỉnh sửa ảnh bìa&lt;/span&gt;&#10;          &lt;/button&gt;&#10;        )}&#10;      &lt;/div&gt;&#10;&#10;      {/* Profile Info Section */}&#10;      &lt;div className=&quot;px-6 pb-6&quot;&gt;&#10;        &lt;div className=&quot;flex flex-col lg:flex-row lg:items-end lg:justify-between -mt-20 relative&quot;&gt;&#10;          {/* Avatar and Basic Info */}&#10;          &lt;div className=&quot;flex flex-col sm:flex-row sm:items-end sm:space-x-5&quot;&gt;&#10;            {/* Avatar */}&#10;            &lt;div className=&quot;relative&quot;&gt;&#10;              &lt;div className=&quot;w-40 h-40 rounded-full border-4 border-white shadow-xl overflow-hidden bg-gray-200&quot;&gt;&#10;                {user.avatarUrl ? (&#10;                  &lt;img&#10;                    src={user.avatarUrl}&#10;                    alt={user.fullName || user.name || 'Avatar'}&#10;                    className=&quot;w-full h-full object-cover&quot;&#10;                  /&gt;&#10;                ) : (&#10;                  &lt;div className=&quot;w-full h-full bg-gradient-to-br from-blue-400 to-purple-600 flex items-center justify-center text-white text-4xl font-bold&quot;&gt;&#10;                    {(user.fullName || user.name || 'U').charAt(0).toUpperCase()}&#10;                  &lt;/div&gt;&#10;                )}&#10;              &lt;/div&gt;&#10;              &#10;              {/* Avatar Edit Button */}&#10;              {isOwnProfile &amp;&amp; (&#10;                &lt;button&#10;                  onClick={onEditAvatar}&#10;                  className=&quot;absolute bottom-2 right-2 bg-gray-100 hover:bg-gray-200 rounded-full p-2 shadow-lg transition-colors&quot;&#10;                &gt;&#10;                  &lt;Camera className=&quot;h-4 w-4 text-gray-600&quot; /&gt;&#10;                &lt;/button&gt;&#10;              )}&#10;            &lt;/div&gt;&#10;&#10;            {/* Name and Title */}&#10;            &lt;div className=&quot;mt-4 sm:mt-0 flex-1&quot;&gt;&#10;              &lt;div className=&quot;flex items-center space-x-2&quot;&gt;&#10;                &lt;h1 className=&quot;text-3xl font-bold text-gray-900 vietnamese-text&quot;&gt;&#10;                  {user.fullName || user.name || 'Người dùng'}&#10;                &lt;/h1&gt;&#10;                {user.isVerified &amp;&amp; (&#10;                  &lt;div className=&quot;w-6 h-6 bg-blue-500 rounded-full flex items-center justify-center&quot;&gt;&#10;                    &lt;svg className=&quot;w-4 h-4 text-white&quot; fill=&quot;currentColor&quot; viewBox=&quot;0 0 20 20&quot;&gt;&#10;                      &lt;path fillRule=&quot;evenodd&quot; d=&quot;M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z&quot; clipRule=&quot;evenodd&quot; /&gt;&#10;                    &lt;/svg&gt;&#10;                  &lt;/div&gt;&#10;                )}&#10;              &lt;/div&gt;&#10;              &#10;              &lt;div className=&quot;flex items-center space-x-2 mt-1&quot;&gt;&#10;                &lt;span className={`px-3 py-1 rounded-full text-sm font-medium ${&#10;                  user.role === 'LECTURER' &#10;                    ? 'bg-blue-100 text-blue-700' &#10;                    : 'bg-green-100 text-green-700'&#10;                }`}&gt;&#10;                  {getRoleDisplay(user.role)}&#10;                &lt;/span&gt;&#10;                {user.isOnline &amp;&amp; (&#10;                  &lt;span className=&quot;flex items-center text-sm text-gray-500&quot;&gt;&#10;                    &lt;div className=&quot;w-2 h-2 bg-green-500 rounded-full mr-1&quot;&gt;&lt;/div&gt;&#10;                    Đang hoạt động&#10;                  &lt;/span&gt;&#10;                )}&#10;              &lt;/div&gt;&#10;&#10;              {/* Quick Info */}&#10;              &lt;div className=&quot;flex flex-wrap items-center mt-3 text-sm text-gray-600 space-x-4&quot;&gt;&#10;                {user.role === 'STUDENT' &amp;&amp; user.major &amp;&amp; (&#10;                  &lt;div className=&quot;flex items-center space-x-1&quot;&gt;&#10;                    &lt;GraduationCap className=&quot;h-4 w-4&quot; /&gt;&#10;                    &lt;span&gt;{user.major.name}&lt;/span&gt;&#10;                  &lt;/div&gt;&#10;                )}&#10;                &#10;                {user.role === 'LECTURER' &amp;&amp; user.faculty &amp;&amp; (&#10;                  &lt;div className=&quot;flex items-center space-x-1&quot;&gt;&#10;                    &lt;Briefcase className=&quot;h-4 w-4&quot; /&gt;&#10;                    &lt;span&gt;{user.faculty.name}&lt;/span&gt;&#10;                  &lt;/div&gt;&#10;                )}&#10;                &#10;                {user.createdAt &amp;&amp; (&#10;                  &lt;div className=&quot;flex items-center space-x-1&quot;&gt;&#10;                    &lt;Calendar className=&quot;h-4 w-4&quot; /&gt;&#10;                    &lt;span&gt;Tham gia {formatTimeAgo(user.createdAt)}&lt;/span&gt;&#10;                  &lt;/div&gt;&#10;                )}&#10;              &lt;/div&gt;&#10;            &lt;/div&gt;&#10;          &lt;/div&gt;&#10;&#10;          {/* Action Buttons */}&#10;          &lt;div className=&quot;flex items-center space-x-3 mt-4 lg:mt-0&quot;&gt;&#10;            {isOwnProfile ? (&#10;              &lt;&gt;&#10;                &lt;Button&#10;                  onClick={onEditProfile}&#10;                  variant=&quot;outline&quot;&#10;                  className=&quot;flex items-center space-x-2&quot;&#10;                &gt;&#10;                  &lt;Edit3 className=&quot;h-4 w-4&quot; /&gt;&#10;                  &lt;span&gt;Chỉnh sửa trang cá nhân&lt;/span&gt;&#10;                &lt;/Button&gt;&#10;              &lt;/&gt;&#10;            ) : (&#10;              &lt;&gt;&#10;                &lt;Button&#10;                  onClick={onFollow}&#10;                  variant={isFollowing ? &quot;outline&quot; : &quot;primary&quot;}&#10;                  className=&quot;flex items-center space-x-2&quot;&#10;                &gt;&#10;                  &lt;UserPlus className=&quot;h-4 w-4&quot; /&gt;&#10;                  &lt;span&gt;{isFollowing ? 'Đang theo dõi' : 'Theo dõi'}&lt;/span&gt;&#10;                &lt;/Button&gt;&#10;                &#10;                &lt;Button&#10;                  onClick={onMessage}&#10;                  variant=&quot;outline&quot;&#10;                  className=&quot;flex items-center space-x-2&quot;&#10;                &gt;&#10;                  &lt;MessageCircle className=&quot;h-4 w-4&quot; /&gt;&#10;                  &lt;span&gt;Nhắn tin&lt;/span&gt;&#10;                &lt;/Button&gt;&#10;                &#10;                &lt;button className=&quot;p-2 hover:bg-gray-100 rounded-lg transition-colors&quot;&gt;&#10;                  &lt;MoreHorizontal className=&quot;h-5 w-5 text-gray-600&quot; /&gt;&#10;                &lt;/button&gt;&#10;              &lt;/&gt;&#10;            )}&#10;          &lt;/div&gt;&#10;        &lt;/div&gt;&#10;&#10;        {/* Bio Section */}&#10;        {user.bio &amp;&amp; (&#10;          &lt;div className=&quot;mt-6 bg-gray-50 rounded-lg p-4&quot;&gt;&#10;            &lt;h3 className=&quot;font-semibold text-gray-900 mb-2&quot;&gt;Giới thiệu&lt;/h3&gt;&#10;            &lt;p className=&quot;text-gray-700 vietnamese-text leading-relaxed&quot;&gt;&#10;              {showFullBio || user.bio.length &lt;= 200 &#10;                ? user.bio &#10;                : `${user.bio.substring(0, 200)}...`&#10;              }&#10;            &lt;/p&gt;&#10;            {user.bio.length &gt; 200 &amp;&amp; (&#10;              &lt;button&#10;                onClick={() =&gt; setShowFullBio(!showFullBio)}&#10;                className=&quot;text-blue-600 hover:text-blue-700 font-medium mt-2&quot;&#10;              &gt;&#10;                {showFullBio ? 'Thu gọn' : 'Xem thêm'}&#10;              &lt;/button&gt;&#10;            )}&#10;          &lt;/div&gt;&#10;        )}&#10;      &lt;/div&gt;&#10;    &lt;/div&gt;&#10;  );&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/client-frontend/src/components/profile/ProfilePhotoModal.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/client-frontend/src/components/profile/ProfilePhotoModal.tsx" />
              <option name="updatedContent" value="'use client';&#10;&#10;import React, { useState } from 'react';&#10;import { User } from '@/types';&#10;import { Camera, X, Upload, Loader2 } from 'lucide-react';&#10;import { Button } from '@/components/ui/Button';&#10;import { Modal } from '@/components/ui/Modal';&#10;&#10;interface ProfilePhotoModalProps {&#10;  isOpen: boolean;&#10;  onClose: () =&gt; void;&#10;  user: User;&#10;  type: 'avatar' | 'cover';&#10;  onPhotoUpdate: (photoUrl: string) =&gt; void;&#10;}&#10;&#10;export const ProfilePhotoModal: React.FC&lt;ProfilePhotoModalProps&gt; = ({&#10;  isOpen,&#10;  onClose,&#10;  user,&#10;  type,&#10;  onPhotoUpdate&#10;}) =&gt; {&#10;  const [selectedFile, setSelectedFile] = useState&lt;File | null&gt;(null);&#10;  const [previewUrl, setPreviewUrl] = useState&lt;string | null&gt;(null);&#10;  const [isUploading, setIsUploading] = useState(false);&#10;&#10;  const handleFileSelect = (event: React.ChangeEvent&lt;HTMLInputElement&gt;) =&gt; {&#10;    const file = event.target.files?.[0];&#10;    if (file) {&#10;      setSelectedFile(file);&#10;      const url = URL.createObjectURL(file);&#10;      setPreviewUrl(url);&#10;    }&#10;  };&#10;&#10;  const handleUpload = async () =&gt; {&#10;    if (!selectedFile) return;&#10;&#10;    setIsUploading(true);&#10;    try {&#10;      // TODO: Implement actual upload logic&#10;      // const uploadResult = await mediaService.uploadImage(selectedFile);&#10;      // onPhotoUpdate(uploadResult.url);&#10;      &#10;      // Mock upload for now&#10;      setTimeout(() =&gt; {&#10;        onPhotoUpdate(previewUrl || '');&#10;        setIsUploading(false);&#10;        onClose();&#10;        resetModal();&#10;      }, 2000);&#10;    } catch (error) {&#10;      console.error('Error uploading photo:', error);&#10;      setIsUploading(false);&#10;    }&#10;  };&#10;&#10;  const resetModal = () =&gt; {&#10;    setSelectedFile(null);&#10;    if (previewUrl) {&#10;      URL.revokeObjectURL(previewUrl);&#10;    }&#10;    setPreviewUrl(null);&#10;  };&#10;&#10;  const handleClose = () =&gt; {&#10;    if (!isUploading) {&#10;      resetModal();&#10;      onClose();&#10;    }&#10;  };&#10;&#10;  const title = type === 'avatar' ? 'Cập nhật ảnh đại diện' : 'Cập nhật ảnh bìa';&#10;  const aspectRatio = type === 'avatar' ? 'aspect-square' : 'aspect-[3/1]';&#10;&#10;  return (&#10;    &lt;Modal isOpen={isOpen} onClose={handleClose} title={title}&gt;&#10;      &lt;div className=&quot;space-y-6&quot;&gt;&#10;        {/* Current Photo */}&#10;        &lt;div className=&quot;text-center&quot;&gt;&#10;          &lt;h3 className=&quot;text-sm font-medium text-gray-900 mb-3 vietnamese-text&quot;&gt;&#10;            {type === 'avatar' ? 'Ảnh đại diện hiện tại' : 'Ảnh bìa hiện tại'}&#10;          &lt;/h3&gt;&#10;          &lt;div className={`mx-auto bg-gray-200 rounded-lg overflow-hidden ${&#10;            type === 'avatar' ? 'w-32 h-32 rounded-full' : 'w-full h-40'&#10;          }`}&gt;&#10;            {(type === 'avatar' ? user.avatarUrl : user.backgroundUrl) ? (&#10;              &lt;img&#10;                src={type === 'avatar' ? user.avatarUrl! : user.backgroundUrl!}&#10;                alt={title}&#10;                className=&quot;w-full h-full object-cover&quot;&#10;              /&gt;&#10;            ) : (&#10;              &lt;div className=&quot;w-full h-full bg-gradient-to-br from-blue-400 to-purple-600 flex items-center justify-center text-white text-2xl font-bold&quot;&gt;&#10;                {type === 'avatar' ? (user.fullName || user.name || 'U').charAt(0).toUpperCase() : ''}&#10;              &lt;/div&gt;&#10;            )}&#10;          &lt;/div&gt;&#10;        &lt;/div&gt;&#10;&#10;        {/* Preview New Photo */}&#10;        {previewUrl &amp;&amp; (&#10;          &lt;div className=&quot;text-center&quot;&gt;&#10;            &lt;h3 className=&quot;text-sm font-medium text-gray-900 mb-3 vietnamese-text&quot;&gt;&#10;              Xem trước&#10;            &lt;/h3&gt;&#10;            &lt;div className={`mx-auto bg-gray-200 rounded-lg overflow-hidden ${&#10;              type === 'avatar' ? 'w-32 h-32 rounded-full' : 'w-full h-40'&#10;            }`}&gt;&#10;              &lt;img&#10;                src={previewUrl}&#10;                alt=&quot;Preview&quot;&#10;                className=&quot;w-full h-full object-cover&quot;&#10;              /&gt;&#10;            &lt;/div&gt;&#10;          &lt;/div&gt;&#10;        )}&#10;&#10;        {/* File Upload */}&#10;        &lt;div className=&quot;border-2 border-dashed border-gray-300 rounded-lg p-6 text-center hover:border-gray-400 transition-colors&quot;&gt;&#10;          &lt;input&#10;            type=&quot;file&quot;&#10;            accept=&quot;image/*&quot;&#10;            onChange={handleFileSelect}&#10;            className=&quot;hidden&quot;&#10;            id=&quot;photo-upload&quot;&#10;            disabled={isUploading}&#10;          /&gt;&#10;          &lt;label htmlFor=&quot;photo-upload&quot; className=&quot;cursor-pointer&quot;&gt;&#10;            &lt;Upload className=&quot;h-12 w-12 text-gray-400 mx-auto mb-4&quot; /&gt;&#10;            &lt;p className=&quot;text-sm text-gray-600 vietnamese-text&quot;&gt;&#10;              Nhấp để chọn ảnh hoặc kéo thả ảnh vào đây&#10;            &lt;/p&gt;&#10;            &lt;p className=&quot;text-xs text-gray-500 mt-1 vietnamese-text&quot;&gt;&#10;              Định dạng: JPG, PNG (Tối đa 10MB)&#10;            &lt;/p&gt;&#10;          &lt;/label&gt;&#10;        &lt;/div&gt;&#10;&#10;        {/* Action Buttons */}&#10;        &lt;div className=&quot;flex justify-end space-x-3&quot;&gt;&#10;          &lt;Button&#10;            variant=&quot;outline&quot;&#10;            onClick={handleClose}&#10;            disabled={isUploading}&#10;          &gt;&#10;            Hủy&#10;          &lt;/Button&gt;&#10;          &lt;Button&#10;            onClick={handleUpload}&#10;            disabled={!selectedFile || isUploading}&#10;            className=&quot;flex items-center space-x-2&quot;&#10;          &gt;&#10;            {isUploading ? (&#10;              &lt;&gt;&#10;                &lt;Loader2 className=&quot;h-4 w-4 animate-spin&quot; /&gt;&#10;                &lt;span&gt;Đang tải lên...&lt;/span&gt;&#10;              &lt;/&gt;&#10;            ) : (&#10;              &lt;&gt;&#10;                &lt;Camera className=&quot;h-4 w-4&quot; /&gt;&#10;                &lt;span&gt;Cập nhật ảnh&lt;/span&gt;&#10;              &lt;/&gt;&#10;            )}&#10;          &lt;/Button&gt;&#10;        &lt;/div&gt;&#10;      &lt;/div&gt;&#10;    &lt;/Modal&gt;&#10;  );&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/client-frontend/src/components/profile/ProfilePostFeed.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/client-frontend/src/components/profile/ProfilePostFeed.tsx" />
              <option name="originalContent" value="'use client';&#10;&#10;import React, { useState, useEffect, useCallback } from 'react';&#10;import { Post, PaginatedResponse } from '@/types';&#10;import { postService } from '@/services/postService';&#10;import { PostCard } from '@/components/post/PostCard';&#10;import { LoadingSpinner } from '@/components/ui/LoadingSpinner';&#10;import { ErrorAlert } from '@/components/ui/ErrorAlert';&#10;import { Button } from '@/components/ui/Button';&#10;import { RefreshCw, FileText, Image, Video, Clock } from 'lucide-react';&#10;import { useAuth } from '@/contexts/AuthContext';&#10;&#10;interface ProfilePostFeedProps {&#10;  userId: string;&#10;  userName?: string;&#10;  isOwnProfile?: boolean;&#10;  className?: string;&#10;}&#10;&#10;export const ProfilePostFeed: React.FC&lt;ProfilePostFeedProps&gt; = ({&#10;  userId,&#10;  userName,&#10;  isOwnProfile = false,&#10;  className = ''&#10;}) =&gt; {&#10;  const [posts, setPosts] = useState&lt;Post[]&gt;([]);&#10;  const [isLoading, setIsLoading] = useState(true);&#10;  const [isLoadingMore, setIsLoadingMore] = useState(false);&#10;  const [error, setError] = useState&lt;string | null&gt;(null);&#10;  const [hasMore, setHasMore] = useState(true);&#10;  const [currentPage, setCurrentPage] = useState(0);&#10;  const [totalPosts, setTotalPosts] = useState(0);&#10;  const [activeFilter, setActiveFilter] = useState&lt;'all' | 'text' | 'image' | 'video'&gt;('all');&#10;  const {user} = useAuth();&#10;  const loadUserPosts = useCallback(async (page = 0, append = false, filter = 'all') =&gt; {&#10;    try {&#10;      if (!append) {&#10;        setIsLoading(true);&#10;        setError(null);&#10;      } else {&#10;        setIsLoadingMore(true);&#10;      }&#10;      let response;&#10;      // TODO: Replace with actual API call to get user posts&#10;      if (userId !== user?.id) {&#10;        response = await postService.getUserPosts(userId, page, 10, filter);&#10;&#10;      }&#10;      }&#10;&#10;        const mockResponse: PaginatedResponse&lt;Post&gt; = response;&#10;      // Mock data for now - replace with actual API call&#10;      /*const mockResponse: PaginatedResponse&lt;Post&gt; = {&#10;        content: [],&#10;        totalElements: 0,&#10;        totalPages: 0,&#10;        size: 10,&#10;        number: page,&#10;        first: page === 0,&#10;        last: true&#10;      };*/&#10;        setPosts(mockResponse.content);&#10;        setPosts(prev =&gt; [...prev, ...mockResponse.content]);&#10;      setHasMore(!mockResponse.last);&#10;      setCurrentPage(mockResponse.number);&#10;&#10;    } catch (err: any) {&#10;        setPosts(prev =&gt; [...prev, ...mockResponse.content]);&#10;      setHasMore(!mockResponse.last);&#10;      setCurrentPage(mockResponse.number);&#10;    loadUserPosts(0, false, activeFilter);&#10;        setPosts(mockResponse.content);&#10;&#10;  const handleLoadMore = () =&gt; {&#10;    if (hasMore &amp;&amp; !isLoadingMore) {&#10;  }, [userId]);&#10;    }&#10;  };&#10;&#10;  const handleRefresh = () =&gt; {&#10;      setTotalPosts(mockResponse.totalElements);&#10;      setHasMore(!mockResponse.last);&#10;      setCurrentPage(mockResponse.number);&#10;  }, [userId]);&#10;    setActiveFilter(filter);&#10;    setCurrentPage(0);&#10;  };&#10;&#10;  const handlePostUpdate = (updatedPost: Post) =&gt; {&#10;    setPosts(prev =&gt; prev.map(post =&gt;&#10;      post.id === updatedPost.id ? updatedPost : post&#10;  }, [userId]);&#10;  };&#10;&#10;  const handlePostDelete = (postId: string) =&gt; {&#10;    setPosts(prev =&gt; prev.filter(post =&gt; post.id !== postId));&#10;    setTotalPosts(prev =&gt; prev - 1);&#10;  };&#10;&#10;  const getFilterIcon = (filter: string) =&gt; {&#10;    switch (filter) {&#10;      case 'text': return &lt;FileText className=&quot;h-4 w-4&quot; /&gt;;&#10;      case 'image': return &lt;Image className=&quot;h-4 w-4&quot; /&gt;;&#10;      case 'video': return &lt;Video className=&quot;h-4 w-4&quot; /&gt;;&#10;      default: return &lt;Clock className=&quot;h-4 w-4&quot; /&gt;;&#10;    }&#10;  };&#10;&#10;  const getFilterLabel = (filter: string) =&gt; {&#10;    switch (filter) {&#10;      case 'text': return 'Văn bản';&#10;      case 'image': return 'Hình ảnh';&#10;      case 'video': return 'Video';&#10;      default: return 'Tất cả';&#10;    }&#10;  };&#10;&#10;  if (isLoading) {&#10;    return (&#10;      &lt;div className={`space-y-6 ${className}`}&gt;&#10;        &lt;div className=&quot;flex justify-center py-12&quot;&gt;&#10;          &lt;div className=&quot;text-center&quot;&gt;&#10;            &lt;LoadingSpinner size=&quot;lg&quot; /&gt;&#10;            &lt;p className=&quot;text-gray-600 mt-4 vietnamese-text&quot;&gt;&#10;              Đang tải bài viết...&#10;            &lt;/p&gt;&#10;          &lt;/div&gt;&#10;        &lt;/div&gt;&#10;      &lt;/div&gt;&#10;    );&#10;  }&#10;&#10;  if (error) {&#10;    return (&#10;      &lt;div className={`space-y-6 ${className}`}&gt;&#10;        &lt;ErrorAlert&#10;          message={error}&#10;          onRetry={handleRefresh}&#10;        /&gt;&#10;      &lt;/div&gt;&#10;    );&#10;  }&#10;&#10;  return (&#10;    &lt;div className={`space-y-6 ${className}`}&gt;&#10;      {/* Header with Stats and Filters */}&#10;      &lt;div className=&quot;bg-white rounded-lg shadow-sm p-6&quot;&gt;&#10;        &lt;div className=&quot;flex flex-col sm:flex-row sm:items-center sm:justify-between gap-4&quot;&gt;&#10;          {/* Post Count */}&#10;          &lt;div&gt;&#10;            &lt;h2 className=&quot;text-xl font-bold text-gray-900 vietnamese-text&quot;&gt;&#10;              Bài viết của {isOwnProfile ? 'bạn' : (userName || 'người dùng')}&#10;            &lt;/h2&gt;&#10;            &lt;p className=&quot;text-sm text-gray-600 vietnamese-text&quot;&gt;&#10;              {totalPosts} bài viết&#10;            &lt;/p&gt;&#10;          &lt;/div&gt;&#10;&#10;          {/* Refresh Button */}&#10;          &lt;Button&#10;            variant=&quot;outline&quot;&#10;            onClick={handleRefresh}&#10;            className=&quot;flex items-center space-x-2&quot;&#10;            disabled={isLoading}&#10;          &gt;&#10;            &lt;RefreshCw className={`h-4 w-4 ${isLoading ? 'animate-spin' : ''}`} /&gt;&#10;            &lt;span className=&quot;vietnamese-text&quot;&gt;Làm mới&lt;/span&gt;&#10;          &lt;/Button&gt;&#10;        &lt;/div&gt;&#10;&#10;        {/* Filter Tabs */}&#10;        &lt;div className=&quot;mt-6 border-b border-gray-200&quot;&gt;&#10;          &lt;nav className=&quot;flex space-x-8&quot;&gt;&#10;            {[&#10;              { key: 'all', label: 'Tất cả' },&#10;              { key: 'text', label: 'Văn bản' },&#10;              { key: 'image', label: 'Hình ảnh' },&#10;              { key: 'video', label: 'Video' }&#10;            ].map((filter) =&gt; (&#10;              &lt;button&#10;                key={filter.key}&#10;                onClick={() =&gt; handleFilterChange(filter.key as any)}&#10;                className={`py-2 px-1 border-b-2 font-medium text-sm vietnamese-text transition-colors flex items-center space-x-2 ${&#10;                  activeFilter === filter.key&#10;                    ? 'border-blue-500 text-blue-600'&#10;                    : 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300'&#10;                }`}&#10;              &gt;&#10;                {getFilterIcon(filter.key)}&#10;                &lt;span&gt;{filter.label}&lt;/span&gt;&#10;              &lt;/button&gt;&#10;            ))}&#10;          &lt;/nav&gt;&#10;        &lt;/div&gt;&#10;      &lt;/div&gt;&#10;&#10;      {/* Posts List */}&#10;      {posts.length === 0 ? (&#10;        &lt;div className=&quot;bg-white rounded-lg shadow-sm p-12 text-center&quot;&gt;&#10;          &lt;div className=&quot;text-gray-400 mb-4&quot;&gt;&#10;            &lt;FileText className=&quot;h-16 w-16 mx-auto&quot; /&gt;&#10;          &lt;/div&gt;&#10;          &lt;h3 className=&quot;text-lg font-medium text-gray-900 mb-2 vietnamese-text&quot;&gt;&#10;            {isOwnProfile ? 'Bạn chưa có bài viết nào' : 'Người dùng này chưa có bài viết nào'}&#10;          &lt;/h3&gt;&#10;          &lt;p className=&quot;text-gray-600 vietnamese-text&quot;&gt;&#10;            {isOwnProfile&#10;              ? 'Hãy tạo bài viết đầu tiên để chia sẻ với mọi người!'&#10;              : 'Hãy quay lại sau để xem bài viết mới nhất.'&#10;            }&#10;          &lt;/p&gt;&#10;          {isOwnProfile &amp;&amp; (&#10;            &lt;Button&#10;              className=&quot;mt-4&quot;&#10;              onClick={() =&gt; window.location.href = '/posts/create'}&#10;            &gt;&#10;              Tạo bài viết đầu tiên&#10;            &lt;/Button&gt;&#10;          )}&#10;        &lt;/div&gt;&#10;      ) : (&#10;        &lt;&gt;&#10;          {/* Posts */}&#10;          &lt;div className=&quot;space-y-6&quot;&gt;&#10;            {posts.map((post) =&gt; (&#10;              &lt;PostCard&#10;                key={post.id}&#10;                post={post}&#10;                onPostUpdate={handlePostUpdate}&#10;                onPostDelete={handlePostDelete}&#10;                className=&quot;shadow-sm hover:shadow-md transition-shadow&quot;&#10;              /&gt;&#10;            ))}&#10;          &lt;/div&gt;&#10;&#10;          {/* Load More Button */}&#10;          {hasMore &amp;&amp; (&#10;            &lt;div className=&quot;text-center pt-6&quot;&gt;&#10;              &lt;Button&#10;                variant=&quot;outline&quot;&#10;                onClick={handleLoadMore}&#10;                disabled={isLoadingMore}&#10;                className=&quot;px-8&quot;&#10;              &gt;&#10;                {isLoadingMore ? (&#10;                  &lt;&gt;&#10;                    &lt;LoadingSpinner size=&quot;sm&quot; className=&quot;mr-2&quot; /&gt;&#10;                    &lt;span className=&quot;vietnamese-text&quot;&gt;Đang tải...&lt;/span&gt;&#10;                  &lt;/&gt;&#10;                ) : (&#10;                  &lt;span className=&quot;vietnamese-text&quot;&gt;Xem thêm bài viết&lt;/span&gt;&#10;                )}&#10;              &lt;/Button&gt;&#10;            &lt;/div&gt;&#10;          )}&#10;&#10;          {/* End Message */}&#10;          {!hasMore &amp;&amp; posts.length &gt; 0 &amp;&amp; (&#10;            &lt;div className=&quot;text-center py-8&quot;&gt;&#10;              &lt;p className=&quot;text-gray-500 vietnamese-text&quot;&gt;&#10;                Bạn đã xem hết tất cả bài viết&#10;              &lt;/p&gt;&#10;            &lt;/div&gt;&#10;          )}&#10;        &lt;/&gt;&#10;      )}&#10;    &lt;/div&gt;&#10;  );&#10;};&#10;" />
              <option name="updatedContent" value="'use client';&#13;&#10;&#13;&#10;import React, { useState, useEffect, useCallback } from 'react';&#13;&#10;import { Post, PaginatedResponse } from '@/types';&#13;&#10;import { postService } from '@/services/postService';&#13;&#10;import { PostCard } from '@/components/post/PostCard';&#13;&#10;import { LoadingSpinner } from '@/components/ui/LoadingSpinner';&#13;&#10;import { ErrorAlert } from '@/components/ui/ErrorAlert';&#13;&#10;import { Button } from '@/components/ui/Button';&#13;&#10;import { RefreshCw, FileText, Image, Video, Clock } from 'lucide-react';&#13;&#10;import { useAuth } from '@/contexts/AuthContext';&#13;&#10;&#13;&#10;interface ProfilePostFeedProps {&#13;&#10;  userId: string;&#13;&#10;  userName?: string;&#13;&#10;  isOwnProfile?: boolean;&#13;&#10;  className?: string;&#13;&#10;}&#13;&#10;&#13;&#10;export const ProfilePostFeed: React.FC&lt;ProfilePostFeedProps&gt; = ({&#13;&#10;  userId,&#13;&#10;  userName,&#13;&#10;  isOwnProfile = false,&#13;&#10;  className = ''&#13;&#10;}) =&gt; {&#13;&#10;  const [posts, setPosts] = useState&lt;Post[]&gt;([]);&#13;&#10;  const [isLoading, setIsLoading] = useState(true);&#13;&#10;  const [isLoadingMore, setIsLoadingMore] = useState(false);&#13;&#10;  const [error, setError] = useState&lt;string | null&gt;(null);&#13;&#10;  const [hasMore, setHasMore] = useState(true);&#13;&#10;  const [currentPage, setCurrentPage] = useState(0);&#13;&#10;  const [totalPosts, setTotalPosts] = useState(0);&#13;&#10;  const [activeFilter, setActiveFilter] = useState&lt;'all' | 'text' | 'image' | 'video'&gt;('all');&#13;&#10;  const {user} = useAuth();&#13;&#10;  const loadUserPosts = useCallback(async (page = 0, append = false, filter = 'all') =&gt; {&#13;&#10;    try {&#13;&#10;      if (!append) {&#13;&#10;        setIsLoading(true);&#13;&#10;        setError(null);&#13;&#10;      } else {&#13;&#10;        setIsLoadingMore(true);&#13;&#10;      }&#13;&#10;&#13;&#10;      // Call the correct API endpoint based on whether it's own profile or not&#13;&#10;      let response: PaginatedResponse&lt;Post&gt;;&#13;&#10;      &#13;&#10;      if (isOwnProfile) {&#13;&#10;        // For own profile, use getMyPosts which calls /posts/me&#13;&#10;        response = await postService.getMyPosts(page, 10);&#13;&#10;      } else {&#13;&#10;        // For other users, we need to implement getUserPosts in postService&#13;&#10;        // For now, let's create a temporary implementation&#13;&#10;        const apiResponse = await fetch(`/api/posts/user/${userId}?page=${page}&amp;size=10`, {&#13;&#10;          headers: {&#13;&#10;            'Authorization': `Bearer ${localStorage.getItem('token')}`,&#13;&#10;            'Content-Type': 'application/json'&#13;&#10;          }&#13;&#10;        });&#13;&#10;        &#13;&#10;        if (!apiResponse.ok) {&#13;&#10;          throw new Error('Failed to fetch user posts');&#13;&#10;        }&#13;&#10;        &#13;&#10;        response = await apiResponse.json();&#13;&#10;      }&#13;&#10;&#13;&#10;      if (append) {&#13;&#10;        setPosts(prev =&gt; [...prev, ...response.content]);&#13;&#10;      } else {&#13;&#10;        setPosts(response.content);&#13;&#10;      }&#13;&#10;&#13;&#10;      setTotalPosts(response.totalElements);&#13;&#10;      setHasMore(!response.last);&#13;&#10;      setCurrentPage(response.number);&#13;&#10;&#13;&#10;    } catch (err: any) {&#13;&#10;      console.error('Error loading user posts:', err);&#13;&#10;      setError('Không thể tải bài viết của người dùng');&#13;&#10;    } finally {&#13;&#10;      setIsLoading(false);&#13;&#10;      setIsLoadingMore(false);&#13;&#10;    }&#13;&#10;  }, [userId, isOwnProfile]);&#13;&#10;&#13;&#10;  useEffect(() =&gt; {&#13;&#10;    loadUserPosts(0, false, activeFilter);&#13;&#10;  }, [loadUserPosts, activeFilter]);&#13;&#10;&#13;&#10;  const handleLoadMore = () =&gt; {&#13;&#10;    if (hasMore &amp;&amp; !isLoadingMore) {&#13;&#10;      loadUserPosts(currentPage + 1, true, activeFilter);&#13;&#10;    }&#13;&#10;  };&#13;&#10;&#13;&#10;  const handleRefresh = () =&gt; {&#13;&#10;    loadUserPosts(0, false, activeFilter);&#13;&#10;  };&#13;&#10;&#13;&#10;  const handleFilterChange = (filter: 'all' | 'text' | 'image' | 'video') =&gt; {&#13;&#10;    setActiveFilter(filter);&#13;&#10;    setCurrentPage(0);&#13;&#10;  };&#13;&#10;&#13;&#10;  const handlePostUpdate = (updatedPost: Post) =&gt; {&#13;&#10;    setPosts(prev =&gt; prev.map(post =&gt;&#13;&#10;      post.id === updatedPost.id ? updatedPost : post&#13;&#10;    ));&#13;&#10;  };&#13;&#10;&#13;&#10;  const handlePostDelete = (postId: string) =&gt; {&#13;&#10;    setPosts(prev =&gt; prev.filter(post =&gt; post.id !== postId));&#13;&#10;    setTotalPosts(prev =&gt; prev - 1);&#13;&#10;  };&#13;&#10;&#13;&#10;  const getFilterIcon = (filter: string) =&gt; {&#13;&#10;    switch (filter) {&#13;&#10;      case 'text': return &lt;FileText className=&quot;h-4 w-4&quot; /&gt;;&#13;&#10;      case 'image': return &lt;Image className=&quot;h-4 w-4&quot; /&gt;;&#13;&#10;      case 'video': return &lt;Video className=&quot;h-4 w-4&quot; /&gt;;&#13;&#10;      default: return &lt;Clock className=&quot;h-4 w-4&quot; /&gt;;&#13;&#10;    }&#13;&#10;  };&#13;&#10;&#13;&#10;  const getFilterLabel = (filter: string) =&gt; {&#13;&#10;    switch (filter) {&#13;&#10;      case 'text': return 'Văn bản';&#13;&#10;      case 'image': return 'Hình ảnh';&#13;&#10;      case 'video': return 'Video';&#13;&#10;      default: return 'Tất cả';&#13;&#10;    }&#13;&#10;  };&#13;&#10;&#13;&#10;  if (isLoading) {&#13;&#10;    return (&#13;&#10;      &lt;div className={`space-y-6 ${className}`}&gt;&#13;&#10;        &lt;div className=&quot;flex justify-center py-12&quot;&gt;&#13;&#10;          &lt;div className=&quot;text-center&quot;&gt;&#13;&#10;            &lt;LoadingSpinner size=&quot;lg&quot; /&gt;&#13;&#10;            &lt;p className=&quot;text-gray-600 mt-4 vietnamese-text&quot;&gt;&#13;&#10;              Đang tải bài viết...&#13;&#10;            &lt;/p&gt;&#13;&#10;          &lt;/div&gt;&#13;&#10;        &lt;/div&gt;&#13;&#10;      &lt;/div&gt;&#13;&#10;    );&#13;&#10;  }&#13;&#10;&#13;&#10;  if (error) {&#13;&#10;    return (&#13;&#10;      &lt;div className={`space-y-6 ${className}`}&gt;&#13;&#10;        &lt;ErrorAlert&#13;&#10;          message={error}&#13;&#10;          onRetry={handleRefresh}&#13;&#10;        /&gt;&#13;&#10;      &lt;/div&gt;&#13;&#10;    );&#13;&#10;  }&#13;&#10;&#13;&#10;  return (&#13;&#10;    &lt;div className={`space-y-6 ${className}`}&gt;&#13;&#10;      {/* Header with Stats and Filters */}&#13;&#10;      &lt;div className=&quot;bg-white rounded-lg shadow-sm p-6&quot;&gt;&#13;&#10;        &lt;div className=&quot;flex flex-col sm:flex-row sm:items-center sm:justify-between gap-4&quot;&gt;&#13;&#10;          {/* Post Count */}&#13;&#10;          &lt;div&gt;&#13;&#10;            &lt;h2 className=&quot;text-xl font-bold text-gray-900 vietnamese-text&quot;&gt;&#13;&#10;              Bài viết của {isOwnProfile ? 'bạn' : (userName || 'người dùng')}&#13;&#10;            &lt;/h2&gt;&#13;&#10;            &lt;p className=&quot;text-sm text-gray-600 vietnamese-text&quot;&gt;&#13;&#10;              {totalPosts} bài viết&#13;&#10;            &lt;/p&gt;&#13;&#10;          &lt;/div&gt;&#13;&#10;&#13;&#10;          {/* Refresh Button */}&#13;&#10;          &lt;Button&#13;&#10;            variant=&quot;outline&quot;&#13;&#10;            onClick={handleRefresh}&#13;&#10;            className=&quot;flex items-center space-x-2&quot;&#13;&#10;            disabled={isLoading}&#13;&#10;          &gt;&#13;&#10;            &lt;RefreshCw className={`h-4 w-4 ${isLoading ? 'animate-spin' : ''}`} /&gt;&#13;&#10;            &lt;span className=&quot;vietnamese-text&quot;&gt;Làm mới&lt;/span&gt;&#13;&#10;          &lt;/Button&gt;&#13;&#10;        &lt;/div&gt;&#13;&#10;&#13;&#10;        {/* Filter Tabs */}&#13;&#10;        &lt;div className=&quot;mt-6 border-b border-gray-200&quot;&gt;&#13;&#10;          &lt;nav className=&quot;flex space-x-8&quot;&gt;&#13;&#10;            {[&#13;&#10;              { key: 'all', label: 'Tất cả' },&#13;&#10;              { key: 'text', label: 'Văn bản' },&#13;&#10;              { key: 'image', label: 'Hình ảnh' },&#13;&#10;              { key: 'video', label: 'Video' }&#13;&#10;            ].map((filter) =&gt; (&#13;&#10;              &lt;button&#13;&#10;                key={filter.key}&#13;&#10;                onClick={() =&gt; handleFilterChange(filter.key as any)}&#13;&#10;                className={`py-2 px-1 border-b-2 font-medium text-sm vietnamese-text transition-colors flex items-center space-x-2 ${&#13;&#10;                  activeFilter === filter.key&#13;&#10;                    ? 'border-blue-500 text-blue-600'&#13;&#10;                    : 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300'&#13;&#10;                }`}&#13;&#10;              &gt;&#13;&#10;                {getFilterIcon(filter.key)}&#13;&#10;                &lt;span&gt;{filter.label}&lt;/span&gt;&#13;&#10;              &lt;/button&gt;&#13;&#10;            ))}&#13;&#10;          &lt;/nav&gt;&#13;&#10;        &lt;/div&gt;&#13;&#10;      &lt;/div&gt;&#13;&#10;&#13;&#10;      {/* Posts List */}&#13;&#10;      {posts.length === 0 ? (&#13;&#10;        &lt;div className=&quot;bg-white rounded-lg shadow-sm p-12 text-center&quot;&gt;&#13;&#10;          &lt;div className=&quot;text-gray-400 mb-4&quot;&gt;&#13;&#10;            &lt;FileText className=&quot;h-16 w-16 mx-auto&quot; /&gt;&#13;&#10;          &lt;/div&gt;&#13;&#10;          &lt;h3 className=&quot;text-lg font-medium text-gray-900 mb-2 vietnamese-text&quot;&gt;&#13;&#10;            {isOwnProfile ? 'Bạn chưa có bài viết nào' : 'Người dùng này chưa có bài viết nào'}&#13;&#10;          &lt;/h3&gt;&#13;&#10;          &lt;p className=&quot;text-gray-600 vietnamese-text&quot;&gt;&#13;&#10;            {isOwnProfile&#13;&#10;              ? 'Hãy tạo bài viết đầu tiên để chia sẻ với mọi người!'&#13;&#10;              : 'Hãy quay lại sau để xem bài viết mới nhất.'&#13;&#10;            }&#13;&#10;          &lt;/p&gt;&#13;&#10;          {isOwnProfile &amp;&amp; (&#13;&#10;            &lt;Button&#13;&#10;              className=&quot;mt-4&quot;&#13;&#10;              onClick={() =&gt; window.location.href = '/posts/create'}&#13;&#10;            &gt;&#13;&#10;              Tạo bài viết đầu tiên&#13;&#10;            &lt;/Button&gt;&#13;&#10;          )}&#13;&#10;        &lt;/div&gt;&#13;&#10;      ) : (&#13;&#10;        &lt;&gt;&#13;&#10;          {/* Posts */}&#13;&#10;          &lt;div className=&quot;space-y-6&quot;&gt;&#13;&#10;            {posts.map((post) =&gt; (&#13;&#10;              &lt;PostCard&#13;&#10;                key={post.id}&#13;&#10;                post={post}&#13;&#10;                onPostUpdate={handlePostUpdate}&#13;&#10;                onPostDelete={handlePostDelete}&#13;&#10;                className=&quot;shadow-sm hover:shadow-md transition-shadow&quot;&#13;&#10;              /&gt;&#13;&#10;            ))}&#13;&#10;          &lt;/div&gt;&#13;&#10;&#13;&#10;          {/* Load More Button */}&#13;&#10;          {hasMore &amp;&amp; (&#13;&#10;            &lt;div className=&quot;text-center pt-6&quot;&gt;&#13;&#10;              &lt;Button&#13;&#10;                variant=&quot;outline&quot;&#13;&#10;                onClick={handleLoadMore}&#13;&#10;                disabled={isLoadingMore}&#13;&#10;                className=&quot;px-8&quot;&#13;&#10;              &gt;&#13;&#10;                {isLoadingMore ? (&#13;&#10;                  &lt;&gt;&#13;&#10;                    &lt;LoadingSpinner size=&quot;sm&quot; className=&quot;mr-2&quot; /&gt;&#13;&#10;                    &lt;span className=&quot;vietnamese-text&quot;&gt;Đang tải...&lt;/span&gt;&#13;&#10;                  &lt;/&gt;&#13;&#10;                ) : (&#13;&#10;                  &lt;span className=&quot;vietnamese-text&quot;&gt;Xem thêm bài viết&lt;/span&gt;&#13;&#10;                )}&#13;&#10;              &lt;/Button&gt;&#13;&#10;            &lt;/div&gt;&#13;&#10;          )}&#13;&#10;&#13;&#10;          {/* End Message */}&#13;&#10;          {!hasMore &amp;&amp; posts.length &gt; 0 &amp;&amp; (&#13;&#10;            &lt;div className=&quot;text-center py-8&quot;&gt;&#13;&#10;              &lt;p className=&quot;text-gray-500 vietnamese-text&quot;&gt;&#13;&#10;                Bạn đã xem hết tất cả bài viết&#13;&#10;              &lt;/p&gt;&#13;&#10;            &lt;/div&gt;&#13;&#10;          )}&#13;&#10;        &lt;/&gt;&#13;&#10;      )}&#13;&#10;    &lt;/div&gt;&#13;&#10;  );&#13;&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/client-frontend/src/components/profile/ProfileStats.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/client-frontend/src/components/profile/ProfileStats.tsx" />
              <option name="updatedContent" value="'use client';&#10;&#10;import React from 'react';&#10;import { Users, FileText, Heart, Eye } from 'lucide-react';&#10;&#10;interface ProfileStatsProps {&#10;  stats: {&#10;    posts?: number;&#10;    followers?: number;&#10;    following?: number;&#10;    likes?: number;&#10;    views?: number;&#10;  };&#10;  onStatsClick?: (type: 'posts' | 'followers' | 'following') =&gt; void;&#10;}&#10;&#10;export const ProfileStats: React.FC&lt;ProfileStatsProps&gt; = ({ stats, onStatsClick }) =&gt; {&#10;  const formatNumber = (num: number): string =&gt; {&#10;    if (num &gt;= 1000000) return `${(num / 1000000).toFixed(1)}M`;&#10;    if (num &gt;= 1000) return `${(num / 1000).toFixed(1)}K`;&#10;    return num.toString();&#10;  };&#10;&#10;  const statItems = [&#10;    {&#10;      key: 'posts' as const,&#10;      label: 'Bài viết',&#10;      value: stats.posts || 0,&#10;      icon: &lt;FileText className=&quot;h-5 w-5 text-blue-500&quot; /&gt;,&#10;      clickable: true&#10;    },&#10;    {&#10;      key: 'followers' as const,&#10;      label: 'Người theo dõi',&#10;      value: stats.followers || 0,&#10;      icon: &lt;Users className=&quot;h-5 w-5 text-green-500&quot; /&gt;,&#10;      clickable: true&#10;    },&#10;    {&#10;      key: 'following' as const,&#10;      label: 'Đang theo dõi',&#10;      value: stats.following || 0,&#10;      icon: &lt;Users className=&quot;h-5 w-5 text-purple-500&quot; /&gt;,&#10;      clickable: true&#10;    },&#10;    {&#10;      key: 'likes' as const,&#10;      label: 'Lượt thích',&#10;      value: stats.likes || 0,&#10;      icon: &lt;Heart className=&quot;h-5 w-5 text-red-500&quot; /&gt;,&#10;      clickable: false&#10;    },&#10;    {&#10;      key: 'views' as const,&#10;      label: 'Lượt xem',&#10;      value: stats.views || 0,&#10;      icon: &lt;Eye className=&quot;h-5 w-5 text-gray-500&quot; /&gt;,&#10;      clickable: false&#10;    }&#10;  ];&#10;&#10;  return (&#10;    &lt;div className=&quot;bg-white rounded-lg shadow-sm p-6&quot;&gt;&#10;      &lt;h2 className=&quot;text-xl font-bold text-gray-900 mb-6 vietnamese-text&quot;&gt;Thống kê&lt;/h2&gt;&#10;      &#10;      &lt;div className=&quot;grid grid-cols-2 lg:grid-cols-5 gap-4&quot;&gt;&#10;        {statItems.map((item) =&gt; (&#10;          &lt;div&#10;            key={item.key}&#10;            className={`text-center p-4 rounded-lg border ${&#10;              item.clickable &#10;                ? 'cursor-pointer hover:bg-gray-50 hover:border-gray-300 transition-all duration-200' &#10;                : 'bg-gray-50'&#10;            }`}&#10;            onClick={item.clickable ? () =&gt; onStatsClick?.(item.key) : undefined}&#10;          &gt;&#10;            &lt;div className=&quot;flex justify-center mb-2&quot;&gt;&#10;              {item.icon}&#10;            &lt;/div&gt;&#10;            &lt;div className=&quot;text-2xl font-bold text-gray-900 mb-1&quot;&gt;&#10;              {formatNumber(item.value)}&#10;            &lt;/div&gt;&#10;            &lt;div className=&quot;text-sm text-gray-600 vietnamese-text&quot;&gt;&#10;              {item.label}&#10;            &lt;/div&gt;&#10;          &lt;/div&gt;&#10;        ))}&#10;      &lt;/div&gt;&#10;    &lt;/div&gt;&#10;  );&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/client-frontend/src/components/profile/StudentProfileInfo.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/client-frontend/src/components/profile/StudentProfileInfo.tsx" />
              <option name="updatedContent" value="'use client';&#10;&#10;import React from 'react';&#10;import { User } from '@/types';&#10;import { &#10;  GraduationCap, &#10;  BookOpen, &#10;  Calendar, &#10;  Users, &#10;  MapPin,&#10;  Award,&#10;  Hash&#10;} from 'lucide-react';&#10;&#10;interface StudentProfileInfoProps {&#10;  user: User;&#10;}&#10;&#10;export const StudentProfileInfo: React.FC&lt;StudentProfileInfoProps&gt; = ({ user }) =&gt; {&#10;  const infoSections = [&#10;    {&#10;      title: 'Thông tin học tập',&#10;      icon: &lt;GraduationCap className=&quot;h-5 w-5 text-blue-500&quot; /&gt;,&#10;      items: [&#10;        user.studentId &amp;&amp; { label: 'Mã số sinh viên', value: user.studentId, icon: &lt;Hash className=&quot;h-4 w-4&quot; /&gt; },&#10;        user.major &amp;&amp; { label: 'Ngành học', value: user.major.name, icon: &lt;BookOpen className=&quot;h-4 w-4&quot; /&gt; },&#10;        user.faculty &amp;&amp; { label: 'Khoa', value: user.faculty.name, icon: &lt;Award className=&quot;h-4 w-4&quot; /&gt; },&#10;        user.college &amp;&amp; { label: 'Trường', value: user.college.name, icon: &lt;MapPin className=&quot;h-4 w-4&quot; /&gt; },&#10;        user.yearOfStudy &amp;&amp; { label: 'Năm học', value: `Năm ${user.yearOfStudy}`, icon: &lt;Calendar className=&quot;h-4 w-4&quot; /&gt; },&#10;        user.batch &amp;&amp; { label: 'Khóa', value: `Khóa ${user.batch.year}`, icon: &lt;Users className=&quot;h-4 w-4&quot; /&gt; },&#10;      ].filter(Boolean)&#10;    }&#10;  ];&#10;&#10;  return (&#10;    &lt;div className=&quot;bg-white rounded-lg shadow-sm p-6&quot;&gt;&#10;      &lt;h2 className=&quot;text-xl font-bold text-gray-900 mb-6 vietnamese-text&quot;&gt;Thông tin cá nhân&lt;/h2&gt;&#10;      &#10;      &lt;div className=&quot;space-y-6&quot;&gt;&#10;        {infoSections.map((section, sectionIndex) =&gt; (&#10;          &lt;div key={sectionIndex}&gt;&#10;            &lt;div className=&quot;flex items-center space-x-2 mb-4&quot;&gt;&#10;              {section.icon}&#10;              &lt;h3 className=&quot;font-semibold text-gray-800 vietnamese-text&quot;&gt;{section.title}&lt;/h3&gt;&#10;            &lt;/div&gt;&#10;            &#10;            &lt;div className=&quot;space-y-3&quot;&gt;&#10;              {section.items.map((item, itemIndex) =&gt; (&#10;                &lt;div key={itemIndex} className=&quot;flex items-center space-x-3 p-3 bg-gray-50 rounded-lg hover:bg-gray-100 transition-colors&quot;&gt;&#10;                  &lt;div className=&quot;text-gray-500&quot;&gt;&#10;                    {item.icon}&#10;                  &lt;/div&gt;&#10;                  &lt;div className=&quot;flex-1&quot;&gt;&#10;                    &lt;div className=&quot;text-sm text-gray-600 vietnamese-text&quot;&gt;{item.label}&lt;/div&gt;&#10;                    &lt;div className=&quot;font-medium text-gray-900 vietnamese-text&quot;&gt;{item.value}&lt;/div&gt;&#10;                  &lt;/div&gt;&#10;                &lt;/div&gt;&#10;              ))}&#10;            &lt;/div&gt;&#10;          &lt;/div&gt;&#10;        ))}&#10;      &lt;/div&gt;&#10;    &lt;/div&gt;&#10;  );&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/client-frontend/src/components/ui/Card.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/client-frontend/src/components/ui/Card.tsx" />
              <option name="updatedContent" value="import React, { HTMLAttributes, forwardRef, ReactNode } from 'react';&#10;import { cn } from '@/utils/helpers';&#10;&#10;interface CardProps extends HTMLAttributes&lt;HTMLDivElement&gt; {&#10;    variant?: 'default' | 'outlined' | 'elevated';&#10;    children: ReactNode;&#10;    className?: string;&#10;    padding?: 'none' | 'sm' | 'md' | 'lg';&#10;    hover?: boolean;&#10;    as?: React.ElementType;&#10;}&#10;&#10;const Card = forwardRef&lt;HTMLElement, CardProps&gt;(&#10;    (&#10;        {&#10;            as: Component = 'div',&#10;            className,&#10;            variant = 'default',&#10;            children,&#10;            padding = 'md',&#10;            hover = false,&#10;            ...props&#10;        },&#10;        ref&#10;    ) =&gt; {&#10;        const baseStyles = 'bg-white rounded-lg ';&#10;&#10;        const variants = {&#10;            default: 'shadow-md ',&#10;            outlined: 'border border-gray-200 ',&#10;            elevated: 'shadow-lg ',&#10;        };&#10;&#10;        const paddings = {&#10;            none: '',&#10;            sm: 'p-3',&#10;            md: 'p-6',&#10;            lg: 'p-8',&#10;        };&#10;&#10;        const classes = cn(&#10;            baseStyles,&#10;            variants[variant],&#10;            paddings[padding],&#10;            hover &amp;&amp; 'transition-shadow duration-300 ease-in-out hover:shadow-xl',&#10;            className&#10;        );&#10;&#10;        return (&#10;            &lt;Component&#10;                className={classes}&#10;                ref={ref}&#10;                {...props}&#10;            &gt;&#10;                {children}&#10;            &lt;/Component&gt;&#10;        );&#10;    }&#10;);&#10;&#10;Card.displayName = 'Card';&#10;&#10;export default Card;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/client-frontend/src/components/user/UserProfile.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/client-frontend/src/components/user/UserProfile.tsx" />
              <option name="originalContent" value="'use client';&#10;&#10;import React, { useState, useEffect } from 'react';&#10;import { useAuth } from '@/contexts/AuthContext';&#10;import { User, Post } from '@/types';&#10;import { userService } from '@/services/userService';&#10;import { postService } from '@/services/postService';&#10;import { ProfileHeader } from '@/components/profile/ProfileHeader';&#10;import { ProfileStats } from '@/components/profile/ProfileStats';&#10;import { StudentProfileInfo } from '@/components/profile/StudentProfileInfo';&#10;import { LecturerProfileInfo } from '@/components/profile/LecturerProfileInfo';&#10;import { ProfilePostFeed } from '@/components/profile/ProfilePostFeed';&#10;import { LoadingSpinner } from '@/components/ui/LoadingSpinner';&#10;import { ErrorAlert } from '@/components/ui/ErrorAlert';&#10;&#10;interface UserProfileProps {&#10;  userId: string;&#10;}&#10;&#10;const UserProfile: React.FC&lt;UserProfileProps&gt; = ({ userId }) =&gt; {&#10;  const { user: currentUser } = useAuth();&#10;  const [profileUser, setProfileUser] = useState&lt;User | null&gt;(null);&#10;  const [userPosts, setUserPosts] = useState&lt;Post[]&gt;([]);&#10;  const [isLoading, setIsLoading] = useState(true);&#10;  const [error, setError] = useState&lt;string | null&gt;(null);&#10;  const [isFollowing, setIsFollowing] = useState(false);&#10;  const [activeTab, setActiveTab] = useState&lt;'posts' | 'about' | 'photos' | 'videos'&gt;('posts');&#10;  const [stats, setStats] = useState({&#10;    posts: 0,&#10;    followers: 0,&#10;    following: 0,&#10;    likes: 0,&#10;    views: 0&#10;  });&#10;&#10;  const isOwnProfile = currentUser?.id === userId;&#10;&#10;  useEffect(() =&gt; {&#10;    loadUserProfile();&#10;    if (userId) {&#10;      loadUserPosts();&#10;      loadUserStats();&#10;    }&#10;  }, [userId]);&#10;&#10;  const loadUserProfile = async () =&gt; {&#10;    try {&#10;      setIsLoading(true);&#10;      const user = await userService.getMyProfile();&#10;      setError('Không thể tải thông tin người dùng');&#10;&#10;    } finally {&#10;      setIsLoading(false);&#10;    }&#10;  };&#10;&#10;  const loadUserPosts = async () =&gt; {&#10;    try {&#10;      // TODO: Implement user-specific posts loading&#10;      //  const posts = await postService.getMyPosts();&#10;      // setUserPosts(posts);&#10;      setUserPosts([]); // Temporary empty array&#10;    } catch (err) {&#10;      console.error('Error loading user posts:', err);&#10;    }&#10;  };&#10;&#10;  const loadUserStats = async () =&gt; {&#10;    try {&#10;      // TODO: Implement stats loading from backend&#10;      // For now, using mock data&#10;      setStats({&#10;        posts: Math.floor(Math.random() * 100),&#10;        followers: Math.floor(Math.random() * 1000),&#10;        following: Math.floor(Math.random() * 500),&#10;        likes: Math.floor(Math.random() * 5000),&#10;        views: Math.floor(Math.random() * 10000)&#10;      });&#10;    } catch (err) {&#10;      console.error('Error loading user stats:', err);&#10;    }&#10;  };&#10;&#10;  const handleFollow = async () =&gt; {&#10;    try {&#10;      if (isFollowing) {&#10;        await userService.unfollowUser(userId);&#10;        setIsFollowing(false);&#10;        setStats(prev =&gt; ({ ...prev, followers: prev.followers - 1 }));&#10;      } else {&#10;        await userService.followUser(userId);&#10;        setIsFollowing(true);&#10;        setStats(prev =&gt; ({ ...prev, followers: prev.followers + 1 }));&#10;      }&#10;    } catch (err) {&#10;      console.error('Error updating follow status:', err);&#10;    }&#10;  };&#10;&#10;  const handleMessage = () =&gt; {&#10;    // TODO: Implement messaging functionality&#10;    console.log('Open chat with user:', userId);&#10;  };&#10;&#10;  const handleEditProfile = () =&gt; {&#10;    // TODO: Implement profile editing&#10;    console.log('Edit profile');&#10;  };&#10;&#10;  const handleEditCover = () =&gt; {&#10;    // TODO: Implement cover photo editing&#10;    console.log('Edit cover photo');&#10;  };&#10;&#10;  const handleEditAvatar = () =&gt; {&#10;    // TODO: Implement avatar editing&#10;    console.log('Edit avatar');&#10;  };&#10;&#10;  const handleStatsClick = (type: 'posts' | 'followers' | 'following') =&gt; {&#10;    switch (type) {&#10;      case 'posts':&#10;        setActiveTab('posts');&#10;        break;&#10;      case 'followers':&#10;        // TODO: Show followers modal/page&#10;        console.log('Show followers');&#10;        break;&#10;      case 'following':&#10;        // TODO: Show following modal/page&#10;        console.log('Show following');&#10;        break;&#10;    }&#10;  };&#10;&#10;  if (isLoading) {&#10;    return (&#10;      &lt;div className=&quot;max-w-4xl mx-auto p-4&quot;&gt;&#10;        &lt;div className=&quot;flex justify-center items-center h-64&quot;&gt;&#10;          &lt;LoadingSpinner size=&quot;lg&quot; /&gt;&#10;        &lt;/div&gt;&#10;      &lt;/div&gt;&#10;    );&#10;  }&#10;&#10;  if (error || !profileUser) {&#10;    return (&#10;      &lt;div className=&quot;max-w-4xl mx-auto p-4&quot;&gt;&#10;        &lt;ErrorAlert message={error || 'Không tìm thấy người dùng'} /&gt;&#10;      &lt;/div&gt;&#10;    );&#10;  }&#10;&#10;  return (&#10;    &lt;div className=&quot;max-w-6xl mx-auto p-4 space-y-6&quot;&gt;&#10;      {/* Profile Header */}&#10;      &lt;ProfileHeader&#10;        user={profileUser}&#10;        isOwnProfile={isOwnProfile}&#10;        isFollowing={isFollowing}&#10;        onFollow={handleFollow}&#10;        onMessage={handleMessage}&#10;        onEditProfile={handleEditProfile}&#10;        onEditCover={handleEditCover}&#10;        onEditAvatar={handleEditAvatar}&#10;      /&gt;&#10;&#10;      {/* Profile Stats */}&#10;      &lt;ProfileStats&#10;        stats={stats}&#10;        onStatsClick={handleStatsClick}&#10;      /&gt;&#10;&#10;      {/* Navigation Tabs */}&#10;      &lt;div className=&quot;bg-white rounded-lg shadow-sm&quot;&gt;&#10;        &lt;div className=&quot;border-b border-gray-200&quot;&gt;&#10;          &lt;nav className=&quot;flex space-x-8 px-6&quot;&gt;&#10;            {[&#10;              { key: 'posts', label: 'Bài viết' },&#10;              { key: 'about', label: 'Giới thiệu' },&#10;              { key: 'photos', label: 'Ảnh' },&#10;              { key: 'videos', label: 'Video' }&#10;            ].map((tab) =&gt; (&#10;              &lt;button&#10;                key={tab.key}&#10;                onClick={() =&gt; setActiveTab(tab.key as any)}&#10;                className={`py-4 px-1 border-b-2 font-medium text-sm vietnamese-text transition-colors ${&#10;                  activeTab === tab.key&#10;                    ? 'border-blue-500 text-blue-600'&#10;                    : 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300'&#10;                }`}&#10;              &gt;&#10;                {tab.label}&#10;              &lt;/button&gt;&#10;            ))}&#10;          &lt;/nav&gt;&#10;        &lt;/div&gt;&#10;&#10;        {/* Tab Content */}&#10;        &lt;div className=&quot;p-6&quot;&gt;&#10;          {activeTab === 'posts' &amp;&amp; (&#10;            &lt;ProfilePostFeed&#10;              userId={userId}&#10;              userName={profileUser.fullName || profileUser.name}&#10;              isOwnProfile={isOwnProfile}&#10;            /&gt;&#10;          )}&#10;&#10;          {activeTab === 'about' &amp;&amp; (&#10;            &lt;div className=&quot;grid grid-cols-1 lg:grid-cols-2 gap-6&quot;&gt;&#10;              {profileUser.role === 'STUDENT' ? (&#10;                &lt;StudentProfileInfo user={profileUser} /&gt;&#10;              ) : (&#10;                &lt;LecturerProfileInfo user={profileUser} /&gt;&#10;              )}&#10;&#10;              {/* Additional Info Section */}&#10;              &lt;div className=&quot;space-y-6&quot;&gt;&#10;                {profileUser.bio &amp;&amp; (&#10;                  &lt;div className=&quot;bg-white rounded-lg shadow-sm p-6&quot;&gt;&#10;                    &lt;h3 className=&quot;text-lg font-semibold text-gray-900 mb-4 vietnamese-text&quot;&gt;&#10;                      Giới thiệu bản thân&#10;                    &lt;/h3&gt;&#10;                    &lt;p className=&quot;text-gray-700 leading-relaxed vietnamese-text&quot;&gt;&#10;                      {profileUser.bio}&#10;                    &lt;/p&gt;&#10;                  &lt;/div&gt;&#10;                )}&#10;              &lt;/div&gt;&#10;            &lt;/div&gt;&#10;          )}&#10;&#10;          {activeTab === 'photos' &amp;&amp; (&#10;            &lt;div className=&quot;text-center py-12&quot;&gt;&#10;              &lt;div className=&quot;text-gray-400 mb-4&quot;&gt;&#10;                &lt;svg className=&quot;w-16 h-16 mx-auto&quot; fill=&quot;currentColor&quot; viewBox=&quot;0 0 20 20&quot;&gt;&#10;                  &lt;path fillRule=&quot;evenodd&quot; d=&quot;M4 3a2 2 0 00-2 2v10a2 2 0 002 2h12a2 2 0 002-2V5a2 2 0 00-2-2H4zm12 12H4l4-8 3 6 2-4 3 6z&quot; clipRule=&quot;evenodd&quot; /&gt;&#10;                &lt;/svg&gt;&#10;              &lt;/div&gt;&#10;              &lt;p className=&quot;text-gray-500 vietnamese-text&quot;&gt;Chức năng xem ảnh đang được phát triển&lt;/p&gt;&#10;            &lt;/div&gt;&#10;          )}&#10;&#10;          {activeTab === 'videos' &amp;&amp; (&#10;            &lt;div className=&quot;text-center py-12&quot;&gt;&#10;              &lt;div className=&quot;text-gray-400 mb-4&quot;&gt;&#10;                &lt;svg className=&quot;w-16 h-16 mx-auto&quot; fill=&quot;currentColor&quot; viewBox=&quot;0 0 20 20&quot;&gt;&#10;                  &lt;path fillRule=&quot;evenodd&quot; d=&quot;M2 6a2 2 0 012-2h6a2 2 0 012 2v8a2 2 0 01-2 2H4a2 2 0 01-2-2V6zM14.553 7.106A1 1 0 0014 8v4a1 1 0 00.553.894l2 1A1 1 0 0018 13V7a1 1 0 00-1.447-.894l-2 1z&quot; clipRule=&quot;evenodd&quot; /&gt;&#10;                &lt;/svg&gt;&#10;              &lt;/div&gt;&#10;              &lt;p className=&quot;text-gray-500 vietnamese-text&quot;&gt;Chức năng xem video đang được phát triển&lt;/p&gt;&#10;            &lt;/div&gt;&#10;          )}&#10;        &lt;/div&gt;&#10;      &lt;/div&gt;&#10;    &lt;/div&gt;&#10;  );&#10;};&#10;&#10;export default UserProfile;&#10;" />
              <option name="updatedContent" value="'use client';&#13;&#10;&#13;&#10;import React, { useState, useEffect } from 'react';&#13;&#10;import { useAuth } from '@/contexts/AuthContext';&#13;&#10;import { User, Post } from '@/types';&#13;&#10;import { userService } from '@/services/userService';&#13;&#10;import { postService } from '@/services/postService';&#13;&#10;import { ProfileHeader } from '@/components/profile/ProfileHeader';&#13;&#10;import { ProfileStats } from '@/components/profile/ProfileStats';&#13;&#10;import { StudentProfileInfo } from '@/components/profile/StudentProfileInfo';&#13;&#10;import { LecturerProfileInfo } from '@/components/profile/LecturerProfileInfo';&#13;&#10;import { ProfilePostFeed } from '@/components/profile/ProfilePostFeed';&#13;&#10;import { LoadingSpinner } from '@/components/ui/LoadingSpinner';&#13;&#10;import { ErrorAlert } from '@/components/ui/ErrorAlert';&#13;&#10;&#13;&#10;interface UserProfileProps {&#13;&#10;  userId: string;&#13;&#10;}&#13;&#10;&#13;&#10;const UserProfile: React.FC&lt;UserProfileProps&gt; = ({ userId }) =&gt; {&#13;&#10;  const { user: currentUser } = useAuth();&#13;&#10;  const [profileUser, setProfileUser] = useState&lt;User | null&gt;(null);&#13;&#10;  const [userPosts, setUserPosts] = useState&lt;Post[]&gt;([]);&#13;&#10;  const [isLoading, setIsLoading] = useState(true);&#13;&#10;  const [error, setError] = useState&lt;string | null&gt;(null);&#13;&#10;  const [isFollowing, setIsFollowing] = useState(false);&#13;&#10;  const [friendshipStatus, setFriendshipStatus] = useState&lt;'friends' | 'pending' | 'none'&gt;('none');&#13;&#10;  const [activeTab, setActiveTab] = useState&lt;'posts' | 'about' | 'photos' | 'videos' | 'friends'&gt;('posts');&#13;&#10;  const [stats, setStats] = useState({&#13;&#10;    posts: 0,&#13;&#10;    followers: 0,&#13;&#10;    following: 0,&#13;&#10;    likes: 0,&#13;&#10;    views: 0&#13;&#10;  });&#13;&#10;&#13;&#10;  const isOwnProfile = currentUser?.id === userId;&#13;&#10;&#13;&#10;  useEffect(() =&gt; {&#13;&#10;    loadUserProfile();&#13;&#10;    if (userId) {&#13;&#10;      loadUserPosts();&#13;&#10;      loadUserStats();&#13;&#10;    }&#13;&#10;  }, [userId]);&#13;&#10;&#13;&#10;  const loadUserProfile = async () =&gt; {&#13;&#10;    try {&#13;&#10;      setIsLoading(true);&#13;&#10;      // Use the correct method based on whether it's own profile or not&#13;&#10;      const user = isOwnProfile &#13;&#10;        ? await userService.getMyProfile() &#13;&#10;        : await userService.getProfile(userId);&#13;&#10;      setProfileUser(user);&#13;&#10;      &#13;&#10;      // Check if current user is following this user&#13;&#10;      if (!isOwnProfile &amp;&amp; currentUser) {&#13;&#10;        // TODO: Implement follow status check&#13;&#10;        // const followStatus = await userService.getFollowStatus(userId);&#13;&#10;        // setIsFollowing(followStatus.isFollowing);&#13;&#10;      }&#13;&#10;    } catch (err) {&#13;&#10;      setError('Không thể tải thông tin người dùng');&#13;&#10;      console.error('Error loading user profile:', err);&#13;&#10;    } finally {&#13;&#10;      setIsLoading(false);&#13;&#10;    }&#13;&#10;  };&#13;&#10;&#13;&#10;  const loadUserPosts = async () =&gt; {&#13;&#10;    try {&#13;&#10;      // TODO: Implement user-specific posts loading&#13;&#10;      //  const posts = await postService.getMyPosts();&#13;&#10;      // setUserPosts(posts);&#13;&#10;      setUserPosts([]); // Temporary empty array&#13;&#10;    } catch (err) {&#13;&#10;      console.error('Error loading user posts:', err);&#13;&#10;    }&#13;&#10;  };&#13;&#10;&#13;&#10;  const loadUserStats = async () =&gt; {&#13;&#10;    try {&#13;&#10;      // TODO: Implement stats loading from backend&#13;&#10;      // For now, using mock data&#13;&#10;      setStats({&#13;&#10;        posts: Math.floor(Math.random() * 100),&#13;&#10;        followers: Math.floor(Math.random() * 1000),&#13;&#10;        following: Math.floor(Math.random() * 500),&#13;&#10;        likes: Math.floor(Math.random() * 5000),&#13;&#10;        views: Math.floor(Math.random() * 10000)&#13;&#10;      });&#13;&#10;    } catch (err) {&#13;&#10;      console.error('Error loading user stats:', err);&#13;&#10;    }&#13;&#10;  };&#13;&#10;&#13;&#10;  const handleFollow = async () =&gt; {&#13;&#10;    try {&#13;&#10;      if (isFollowing) {&#13;&#10;        await userService.unfollowUser(userId);&#13;&#10;        setIsFollowing(false);&#13;&#10;        setStats(prev =&gt; ({ ...prev, followers: prev.followers - 1 }));&#13;&#10;      } else {&#13;&#10;        await userService.followUser(userId);&#13;&#10;        setIsFollowing(true);&#13;&#10;        setStats(prev =&gt; ({ ...prev, followers: prev.followers + 1 }));&#13;&#10;      }&#13;&#10;    } catch (err) {&#13;&#10;      console.error('Error updating follow status:', err);&#13;&#10;    }&#13;&#10;  };&#13;&#10;&#13;&#10;  const handleMessage = () =&gt; {&#13;&#10;    // TODO: Implement messaging functionality&#13;&#10;    console.log('Open chat with user:', userId);&#13;&#10;  };&#13;&#10;&#13;&#10;  const handleEditProfile = () =&gt; {&#13;&#10;    // TODO: Implement profile editing&#13;&#10;    console.log('Edit profile');&#13;&#10;  };&#13;&#10;&#13;&#10;  const handleEditCover = () =&gt; {&#13;&#10;    // TODO: Implement cover photo editing&#13;&#10;    console.log('Edit cover photo');&#13;&#10;  };&#13;&#10;&#13;&#10;  const handleEditAvatar = () =&gt; {&#13;&#10;    // TODO: Implement avatar editing&#13;&#10;    console.log('Edit avatar');&#13;&#10;  };&#13;&#10;&#13;&#10;  const handleStatsClick = (type: 'posts' | 'followers' | 'following') =&gt; {&#13;&#10;    switch (type) {&#13;&#10;      case 'posts':&#13;&#10;        setActiveTab('posts');&#13;&#10;        break;&#13;&#10;      case 'followers':&#13;&#10;        // TODO: Show followers modal/page&#13;&#10;        console.log('Show followers');&#13;&#10;        break;&#13;&#10;      case 'following':&#13;&#10;        // TODO: Show following modal/page&#13;&#10;        console.log('Show following');&#13;&#10;        break;&#13;&#10;    }&#13;&#10;  };&#13;&#10;&#13;&#10;  if (isLoading) {&#13;&#10;    return (&#13;&#10;      &lt;div className=&quot;max-w-4xl mx-auto p-4&quot;&gt;&#13;&#10;        &lt;div className=&quot;flex justify-center items-center h-64&quot;&gt;&#13;&#10;          &lt;LoadingSpinner size=&quot;lg&quot; /&gt;&#13;&#10;        &lt;/div&gt;&#13;&#10;      &lt;/div&gt;&#13;&#10;    );&#13;&#10;  }&#13;&#10;&#13;&#10;  if (error || !profileUser) {&#13;&#10;    return (&#13;&#10;      &lt;div className=&quot;max-w-4xl mx-auto p-4&quot;&gt;&#13;&#10;        &lt;ErrorAlert message={error || 'Không tìm thấy người dùng'} /&gt;&#13;&#10;      &lt;/div&gt;&#13;&#10;    );&#13;&#10;  }&#13;&#10;&#13;&#10;  return (&#13;&#10;    &lt;div className=&quot;max-w-6xl mx-auto p-4 space-y-6&quot;&gt;&#13;&#10;      {/* Profile Header */}&#13;&#10;      &lt;ProfileHeader&#13;&#10;        user={profileUser}&#13;&#10;        isOwnProfile={isOwnProfile}&#13;&#10;        isFollowing={isFollowing}&#13;&#10;        onFollow={handleFollow}&#13;&#10;        onMessage={handleMessage}&#13;&#10;        onEditProfile={handleEditProfile}&#13;&#10;        onEditCover={handleEditCover}&#13;&#10;        onEditAvatar={handleEditAvatar}&#13;&#10;      /&gt;&#13;&#10;&#13;&#10;      {/* Profile Stats */}&#13;&#10;      &lt;ProfileStats&#13;&#10;        stats={stats}&#13;&#10;        onStatsClick={handleStatsClick}&#13;&#10;      /&gt;&#13;&#10;&#13;&#10;      {/* Navigation Tabs */}&#13;&#10;      &lt;div className=&quot;bg-white rounded-lg shadow-sm&quot;&gt;&#13;&#10;        &lt;div className=&quot;border-b border-gray-200&quot;&gt;&#13;&#10;          &lt;nav className=&quot;flex space-x-8 px-6&quot;&gt;&#13;&#10;            {[&#13;&#10;              { key: 'posts', label: 'Bài viết' },&#13;&#10;              { key: 'about', label: 'Giới thiệu' },&#13;&#10;              { key: 'photos', label: 'Ảnh' },&#13;&#10;              { key: 'videos', label: 'Video' },&#13;&#10;              { key: 'friends', label: 'Bạn bè' }&#13;&#10;            ].map((tab) =&gt; (&#13;&#10;              &lt;button&#13;&#10;                key={tab.key}&#13;&#10;                onClick={() =&gt; setActiveTab(tab.key as any)}&#13;&#10;                className={`py-4 px-1 border-b-2 font-medium text-sm vietnamese-text transition-colors ${&#13;&#10;                  activeTab === tab.key&#13;&#10;                    ? 'border-blue-500 text-blue-600'&#13;&#10;                    : 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300'&#13;&#10;                }`}&#13;&#10;              &gt;&#13;&#10;                {tab.label}&#13;&#10;              &lt;/button&gt;&#13;&#10;            ))}&#13;&#10;          &lt;/nav&gt;&#13;&#10;        &lt;/div&gt;&#13;&#10;&#13;&#10;        {/* Tab Content */}&#13;&#10;        &lt;div className=&quot;p-6&quot;&gt;&#13;&#10;          {activeTab === 'posts' &amp;&amp; (&#13;&#10;            &lt;ProfilePostFeed&#13;&#10;              userId={userId}&#13;&#10;              userName={profileUser.fullName || profileUser.name}&#13;&#10;              isOwnProfile={isOwnProfile}&#13;&#10;            /&gt;&#13;&#10;          )}&#13;&#10;&#13;&#10;          {activeTab === 'about' &amp;&amp; (&#13;&#10;            &lt;div className=&quot;grid grid-cols-1 lg:grid-cols-2 gap-6&quot;&gt;&#13;&#10;              {profileUser.role === 'STUDENT' ? (&#13;&#10;                &lt;StudentProfileInfo user={profileUser} /&gt;&#13;&#10;              ) : (&#13;&#10;                &lt;LecturerProfileInfo user={profileUser} /&gt;&#13;&#10;              )}&#13;&#10;&#13;&#10;              {/* Additional Info Section */}&#13;&#10;              &lt;div className=&quot;space-y-6&quot;&gt;&#13;&#10;                {profileUser.bio &amp;&amp; (&#13;&#10;                  &lt;div className=&quot;bg-white rounded-lg shadow-sm p-6&quot;&gt;&#13;&#10;                    &lt;h3 className=&quot;text-lg font-semibold text-gray-900 mb-4 vietnamese-text&quot;&gt;&#13;&#10;                      Giới thiệu bản thân&#13;&#10;                    &lt;/h3&gt;&#13;&#10;                    &lt;p className=&quot;text-gray-700 leading-relaxed vietnamese-text&quot;&gt;&#13;&#10;                      {profileUser.bio}&#13;&#10;                    &lt;/p&gt;&#13;&#10;                  &lt;/div&gt;&#13;&#10;                )}&#13;&#10;              &lt;/div&gt;&#13;&#10;            &lt;/div&gt;&#13;&#10;          )}&#13;&#10;&#13;&#10;          {activeTab === 'photos' &amp;&amp; (&#13;&#10;            &lt;div className=&quot;text-center py-12&quot;&gt;&#13;&#10;              &lt;div className=&quot;text-gray-400 mb-4&quot;&gt;&#13;&#10;                &lt;svg className=&quot;w-16 h-16 mx-auto&quot; fill=&quot;currentColor&quot; viewBox=&quot;0 0 20 20&quot;&gt;&#13;&#10;                  &lt;path fillRule=&quot;evenodd&quot; d=&quot;M4 3a2 2 0 00-2 2v10a2 2 0 002 2h12a2 2 0 002-2V5a2 2 0 00-2-2H4zm12 12H4l4-8 3 6 2-4 3 6z&quot; clipRule=&quot;evenodd&quot; /&gt;&#13;&#10;                &lt;/svg&gt;&#13;&#10;              &lt;/div&gt;&#13;&#10;              &lt;p className=&quot;text-gray-500 vietnamese-text&quot;&gt;Chức năng xem ảnh đang được phát triển&lt;/p&gt;&#13;&#10;            &lt;/div&gt;&#13;&#10;          )}&#13;&#10;&#13;&#10;          {activeTab === 'videos' &amp;&amp; (&#13;&#10;            &lt;div className=&quot;text-center py-12&quot;&gt;&#13;&#10;              &lt;div className=&quot;text-gray-400 mb-4&quot;&gt;&#13;&#10;                &lt;svg className=&quot;w-16 h-16 mx-auto&quot; fill=&quot;currentColor&quot; viewBox=&quot;0 0 20 20&quot;&gt;&#13;&#10;                  &lt;path fillRule=&quot;evenodd&quot; d=&quot;M2 6a2 2 0 012-2h6a2 2 0 012 2v8a2 2 0 01-2 2H4a2 2 0 01-2-2V6zM14.553 7.106A1 1 0 0014 8v4a1 1 0 00.553.894l2 1A1 1 0 0018 13V7a1 1 0 00-1.447-.894l-2 1z&quot; clipRule=&quot;evenodd&quot; /&gt;&#13;&#10;                &lt;/svg&gt;&#13;&#10;              &lt;/div&gt;&#13;&#10;              &lt;p className=&quot;text-gray-500 vietnamese-text&quot;&gt;Chức năng xem video đang được phát triển&lt;/p&gt;&#13;&#10;            &lt;/div&gt;&#13;&#10;          )}&#13;&#10;&#13;&#10;          {activeTab === 'friends' &amp;&amp; (&#13;&#10;            &lt;div className=&quot;text-center py-12&quot;&gt;&#13;&#10;              &lt;div className=&quot;text-gray-400 mb-4&quot;&gt;&#13;&#10;                &lt;svg className=&quot;w-16 h-16 mx-auto&quot; fill=&quot;currentColor&quot; viewBox=&quot;0 0 20 20&quot;&gt;&#13;&#10;                  &lt;path fillRule=&quot;evenodd&quot; d=&quot;M10 3a7 7 0 00-7 7v1a7 7 0 0014 0v-1a7 7 0 00-7-7zm0 12a5 5 0 01-5-5v-1a5 5 0 0110 0v1a5 5 0 01-5 5zm-2-5a2 2 0 114 0 2 2 0 01-4 0zm8 0a2 2 0 114 0 2 2 0 01-4 0z&quot; clipRule=&quot;evenodd&quot; /&gt;&#13;&#10;                &lt;/svg&gt;&#13;&#10;              &lt;/div&gt;&#13;&#10;              &lt;p className=&quot;text-gray-500 vietnamese-text&quot;&gt;Chức năng quản lý bạn bè đang được phát triển&lt;/p&gt;&#13;&#10;            &lt;/div&gt;&#13;&#10;          )}&#13;&#10;        &lt;/div&gt;&#13;&#10;      &lt;/div&gt;&#13;&#10;    &lt;/div&gt;&#13;&#10;  );&#13;&#10;};&#13;&#10;&#13;&#10;export default UserProfile;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/client-frontend/src/contexts/ChatContext.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/client-frontend/src/contexts/ChatContext.tsx" />
              <option name="originalContent" value="'use client';&#10;&#10;import React, { createContext, useContext, useState, useEffect, useCallback, ReactNode } from 'react';&#10;import { webSocketService, TypingEvent, PresenceEvent } from '@/services/websocket.service';&#10;import { chatService } from '@/features/chat/services/chat.service';&#10;import { useAuth } from '@/contexts/AuthContext';&#10;import {ChatMessage, ChatRoom, MessageReadStatus} from '@/shared/types/chat';&#10;import { PaginatedResponse } from '@/shared/types';&#10;import {User} from &quot;@/types&quot;;&#10;&#10;// Chat State Interface&#10;export interface ChatState {&#10;  conversations: ChatRoom[];&#10;  activeConversationId: string | null;&#10;  messages: { [conversationId: string]: ChatMessage[] };&#10;  onlineUsers: Set&lt;string&gt;;&#10;  typingUsers: { [conversationId: string]: Set&lt;string&gt; };&#10;  isConnected: boolean;&#10;  isLoading: boolean;&#10;  error: string | null;&#10;}&#10;&#10;// Chat Context Interface&#10;export interface ChatContextType extends ChatState {&#10;  // Connection management&#10;  connectToChat: () =&gt; Promise&lt;void&gt;;&#10;  disconnectFromChat: () =&gt; Promise&lt;void&gt;;&#10;&#10;  // Conversation management&#10;  setActiveConversation: (conversationId: string | null) =&gt; void;&#10;  loadConversations: () =&gt; Promise&lt;void&gt;;&#10;&#10;  // Message management&#10;  sendMessage: (conversationId: string, content: string, type?: string) =&gt; void;&#10;  loadMessages: (conversationId: string, page?: number) =&gt; Promise&lt;void&gt;;&#10;&#10;  // Typing indicators&#10;  startTyping: (conversationId: string) =&gt; void;&#10;  stopTyping: (conversationId: string) =&gt; void;&#10;&#10;  // Utilities&#10;  clearError: () =&gt; void;&#10;  getUnreadCount: (conversationId: string) =&gt; number;&#10;  markAsRead: (conversationId: string) =&gt; void;&#10;}&#10;&#10;const ChatContext = createContext&lt;ChatContextType | undefined&gt;(undefined);&#10;&#10;export const useChat = () =&gt; {&#10;  const context = useContext(ChatContext);&#10;  if (context === undefined) {&#10;    throw new Error('useChat must be used within a ChatProvider');&#10;  }&#10;  return context;&#10;};&#10;&#10;interface ChatProviderProps {&#10;  children: ReactNode;&#10;}&#10;&#10;export const ChatProvider: React.FC&lt;ChatProviderProps&gt; = ({ children }) =&gt; {&#10;  const { user, token } = useAuth();&#10;  const [state, setState] = useState&lt;ChatState&gt;({&#10;    conversations: [],&#10;    activeConversationId: null,&#10;    messages: {},&#10;    onlineUsers: new Set(),&#10;    typingUsers: {},&#10;    isConnected: false,&#10;    isLoading: false,&#10;    error: null,&#10;  });&#10;&#10;  // WebSocket event handlers&#10;  const handleMessage = useCallback((message: ChatMessage) =&gt; {&#10;    setState(prev =&gt; ({&#10;      ...prev,&#10;      messages: {&#10;        ...prev.messages,&#10;        [message.roomId]: [&#10;          ...(prev.messages[message.roomId] || []),&#10;          message&#10;        ].sort((a, b) =&gt; new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime())&#10;      }&#10;    }));&#10;  }, []);&#10;&#10;  const handleTyping = useCallback((event: TypingEvent) =&gt; {&#10;    setState(prev =&gt; {&#10;      const conversationTyping = new Set(prev.typingUsers[event.conversationId] || []);&#10;&#10;      if (event.isTyping) {&#10;        conversationTyping.add(event.userId);&#10;      } else {&#10;        conversationTyping.delete(event.userId);&#10;      }&#10;&#10;      return {&#10;        ...prev,&#10;        typingUsers: {&#10;          ...prev.typingUsers,&#10;          [event.conversationId]: conversationTyping&#10;        }&#10;      };&#10;    });&#10;  }, []);&#10;&#10;  const handlePresence = useCallback((event: PresenceEvent) =&gt; {&#10;    setState(prev =&gt; {&#10;      const newOnlineUsers = new Set(prev.onlineUsers);&#10;&#10;      if (event.status === 'ONLINE') {&#10;        newOnlineUsers.add(event.userId);&#10;      } else {&#10;        newOnlineUsers.delete(event.userId);&#10;      }&#10;&#10;      return {&#10;        ...prev,&#10;        onlineUsers: newOnlineUsers&#10;      };&#10;    });&#10;  }, []);&#10;&#10;  const handleConnected = useCallback(() =&gt; {&#10;    setState(prev =&gt; ({ ...prev, isConnected: true, error: null }));&#10;  }, []);&#10;&#10;  const handleDisconnected = useCallback(() =&gt; {&#10;    setState(prev =&gt; ({ ...prev, isConnected: false }));&#10;  }, []);&#10;&#10;  const handleError = useCallback((error: Error) =&gt; {&#10;    setState(prev =&gt; ({ ...prev, error: error.message, isConnected: false }));&#10;  }, []);&#10;&#10;  // Connection management&#10;  const connectToChat = useCallback(async () =&gt; {&#10;    if (!token) {&#10;      setState(prev =&gt; ({ ...prev, error: 'Authentication token not available' }));&#10;      return;&#10;    }&#10;&#10;    try {&#10;      setState(prev =&gt; ({ ...prev, isLoading: true, error: null }));&#10;&#10;      // Setup event listeners&#10;      webSocketService.on('message', handleMessage);&#10;      webSocketService.on('typing', handleTyping);&#10;      webSocketService.on('presence', handlePresence);&#10;      webSocketService.on('connected', handleConnected);&#10;      webSocketService.on('disconnected', handleDisconnected);&#10;      webSocketService.on('error', handleError);&#10;&#10;      await webSocketService.connect(token);&#10;&#10;      // Load conversations after connection&#10;      await loadConversations();&#10;&#10;      setState(prev =&gt; ({ ...prev, isLoading: false }));&#10;    } catch (error) {&#10;      setState(prev =&gt; ({&#10;        ...prev,&#10;        error: error instanceof Error ? error.message : 'Connection failed',&#10;        isLoading: false&#10;      }));&#10;    }&#10;  }, [token, handleMessage, handleTyping, handlePresence, handleConnected, handleDisconnected, handleError]);&#10;&#10;  const disconnectFromChat = useCallback(async () =&gt; {&#10;    await webSocketService.disconnect();&#10;    webSocketService.removeAllListeners();&#10;&#10;    setState(prev =&gt; ({&#10;      ...prev,&#10;      isConnected: false,&#10;      activeConversationId: null,&#10;      typingUsers: {}&#10;    }));&#10;  }, []);&#10;&#10;  // Conversation management&#10;  const setActiveConversation = useCallback((conversationId: string | null) =&gt; {&#10;    setState(prev =&gt; {&#10;      // Leave previous conversation&#10;      if (prev.activeConversationId &amp;&amp; prev.activeConversationId !== conversationId) {&#10;        webSocketService.leaveConversation(prev.activeConversationId);&#10;      }&#10;&#10;      // Join new conversation&#10;      if (conversationId) {&#10;        webSocketService.joinConversation(conversationId);&#10;        // Load messages for this conversation&#10;        loadMessages(conversationId);&#10;      }&#10;&#10;      return { ...prev, activeConversationId: conversationId };&#10;    });&#10;  }, []);&#10;&#10;  const loadConversations = useCallback(async () =&gt; {&#10;    try {&#10;      setState(prev =&gt; ({ ...prev, isLoading: true }));&#10;&#10;      const response: PaginatedResponse&lt;ChatRoom&gt; = await chatService.getChatRooms();&#10;&#10;      setState(prev =&gt; ({&#10;        ...prev,&#10;        conversations: response.content,&#10;        isLoading: false&#10;      }));&#10;    } catch (error) {&#10;      setState(prev =&gt; ({&#10;        ...prev,&#10;        error: error instanceof Error ? error.message : 'Failed to load conversations',&#10;        isLoading: false&#10;      }));&#10;    }&#10;  }, []);&#10;&#10;  // Message management&#10;  const sendMessage = useCallback((conversationId: string, content: string, type = 'TEXT') =&gt; {&#10;    if (state.isConnected) {&#10;      webSocketService.sendMessage(conversationId, content, type);&#10;    } else {&#10;      setState(prev =&gt; ({ ...prev, error: 'Not connected to chat service' }));&#10;    }&#10;  }, [state.isConnected]);&#10;&#10;  const loadMessages = useCallback(async (conversationId: string, page = 0) =&gt; {&#10;    try {&#10;      const response: PaginatedResponse&lt;ChatMessage&gt; = await chatService.getMessages(conversationId, page, 50);&#10;&#10;      setState(prev =&gt; ({&#10;        ...prev,&#10;        messages: {&#10;          ...prev.messages,&#10;          [conversationId]: page === 0 ? response.content : [&#10;            ...response.content,&#10;            ...(prev.messages[conversationId] || [])&#10;          ].sort((a, b) =&gt; new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime())&#10;        }&#10;      }));&#10;    } catch (error) {&#10;      setState(prev =&gt; ({&#10;        ...prev,&#10;        error: error instanceof Error ? error.message : 'Failed to load messages'&#10;      }));&#10;    }&#10;  }, []);&#10;&#10;  // Typing indicators&#10;  const startTyping = useCallback((conversationId: string) =&gt; {&#10;    if (state.isConnected) {&#10;      webSocketService.sendTyping(conversationId, true);&#10;    }&#10;  }, [state.isConnected]);&#10;&#10;  const stopTyping = useCallback((conversationId: string) =&gt; {&#10;    if (state.isConnected) {&#10;      webSocketService.sendTyping(conversationId, false);&#10;    }&#10;  }, [state.isConnected]);&#10;&#10;  // Utilities&#10;  const clearError = useCallback(() =&gt; {&#10;    setState(prev =&gt; ({ ...prev, error: null }));&#10;  }, []);&#10;&#10;  const getUnreadCount = useCallback((conversationId: string) =&gt; {&#10;    const messages = state.messages[conversationId] || [];&#10;    return messages.filter(msg =&gt;&#10;      msg.senderId !== user?.id &amp;&amp;&#10;      !msg.readBy?.some(readStatus =&gt; readStatus.userId === user?.id)&#10;    ).length;&#10;  }, [state.messages, user?.id]);&#10;&#10;  const markAsRead = useCallback(async (conversationId: string) =&gt; {&#10;    try {&#10;      await chatService.markRoomAsRead(conversationId);&#10;&#10;      setState(prev =&gt; ({&#10;        ...prev,&#10;        messages: {&#10;          ...prev.messages,&#10;          [conversationId]: prev.messages[conversationId]?.map(msg =&gt; {&#10;            const alreadyRead = msg.readBy?.some(readStatus =&gt; readStatus.userId === user?.id);&#10;&#10;            if (alreadyRead) return msg;&#10;&#10;            // Create a chat-compatible user object that matches the MessageReadStatus type&#10;            const chatUser: User = {&#10;              id: user?.id || '',&#10;              email: user?.email || '',&#10;              username: user?.username || '',&#10;              fullName: user?.fullName || '',&#10;              avatar: user?.avatar,&#10;              bio: user?.bio,&#10;              faculty: typeof user?.faculty === 'object' ? user?.faculty?.name : user?.faculty,&#10;              yearOfStudy: user?.yearOfStudy,&#10;              isVerified: user?.isVerified || false,&#10;              isOnline: user?.isOnline || false,&#10;              followersCount: user?.followersCount,&#10;              followingCount: user?.followingCount,&#10;              postsCount: user?.postsCount,&#10;              createdAt: user?.createdAt || new Date().toISOString(),&#10;              updatedAt: user?.updatedAt || new Date().toISOString()&#10;            };&#10;&#10;            const newReadStatus: MessageReadStatus = {&#10;              userId: user?.id || '',&#10;              user: chatUser,&#10;              readAt: new Date().toISOString(),&#10;            };&#10;&#10;            return {&#10;              ...msg,&#10;              readBy: [...(msg.readBy || []), newReadStatus],&#10;              isRead: true,&#10;            };&#10;          }) || []&#10;        }&#10;      }));&#10;    } catch (error) {&#10;      console.error('Failed to mark messages as read:', error);&#10;    }&#10;  }, [user]);&#10;&#10;  const contextValue: ChatContextType = {&#10;    ...state,&#10;    connectToChat,&#10;    disconnectFromChat,&#10;    setActiveConversation,&#10;    loadConversations,&#10;    sendMessage,&#10;    loadMessages,&#10;    startTyping,&#10;    stopTyping,&#10;    clearError,&#10;    getUnreadCount,&#10;    markAsRead,&#10;  };&#10;&#10;  return (&#10;    &lt;ChatContext.Provider value={contextValue}&gt;&#10;      {children}&#10;    &lt;/ChatContext.Provider&gt;&#10;  );&#10;};&#10;" />
              <option name="updatedContent" value="'use client';&#10;&#10;import React, { createContext, useContext, useState, useEffect, useCallback, ReactNode } from 'react';&#10;import { webSocketService, TypingEvent, PresenceEvent } from '@/services/websocket.service';&#10;import { chatService } from '@/features/chat/services/chat.service';&#10;import { useAuth } from '@/contexts/AuthContext';&#10;import { ChatMessage, ChatRoom, MessageReadStatus, User as ChatUser } from '@/shared/types/chat';&#10;import { PaginatedResponse } from '@/shared/types';&#10;&#10;// Chat State Interface&#10;export interface ChatState {&#10;  conversations: ChatRoom[];&#10;  activeConversationId: string | null;&#10;  messages: { [conversationId: string]: ChatMessage[] };&#10;  onlineUsers: Set&lt;string&gt;;&#10;  typingUsers: { [conversationId: string]: Set&lt;string&gt; };&#10;  isConnected: boolean;&#10;  isLoading: boolean;&#10;  error: string | null;&#10;}&#10;&#10;// Chat Context Interface&#10;export interface ChatContextType extends ChatState {&#10;  // Connection management&#10;  connectToChat: () =&gt; Promise&lt;void&gt;;&#10;  disconnectFromChat: () =&gt; Promise&lt;void&gt;;&#10;&#10;  // Conversation management&#10;  setActiveConversation: (conversationId: string | null) =&gt; void;&#10;  loadConversations: () =&gt; Promise&lt;void&gt;;&#10;&#10;  // Message management&#10;  sendMessage: (conversationId: string, content: string, type?: string) =&gt; void;&#10;  loadMessages: (conversationId: string, page?: number) =&gt; Promise&lt;void&gt;;&#10;&#10;  // Typing indicators&#10;  startTyping: (conversationId: string) =&gt; void;&#10;  stopTyping: (conversationId: string) =&gt; void;&#10;&#10;  // Utilities&#10;  clearError: () =&gt; void;&#10;  getUnreadCount: (conversationId: string) =&gt; number;&#10;  markAsRead: (conversationId: string) =&gt; void;&#10;}&#10;&#10;const ChatContext = createContext&lt;ChatContextType | undefined&gt;(undefined);&#10;&#10;export const useChat = () =&gt; {&#10;  const context = useContext(ChatContext);&#10;  if (context === undefined) {&#10;    throw new Error('useChat must be used within a ChatProvider');&#10;  }&#10;  return context;&#10;};&#10;&#10;interface ChatProviderProps {&#10;  children: ReactNode;&#10;}&#10;&#10;export const ChatProvider: React.FC&lt;ChatProviderProps&gt; = ({ children }) =&gt; {&#10;  const { user, token } = useAuth();&#10;  const [state, setState] = useState&lt;ChatState&gt;({&#10;    conversations: [],&#10;    activeConversationId: null,&#10;    messages: {},&#10;    onlineUsers: new Set(),&#10;    typingUsers: {},&#10;    isConnected: false,&#10;    isLoading: false,&#10;    error: null,&#10;  });&#10;&#10;  // WebSocket event handlers&#10;  const handleMessage = useCallback((message: ChatMessage) =&gt; {&#10;    setState(prev =&gt; ({&#10;      ...prev,&#10;      messages: {&#10;        ...prev.messages,&#10;        [message.roomId]: [&#10;          ...(prev.messages[message.roomId] || []),&#10;          message&#10;        ].sort((a, b) =&gt; new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime())&#10;      }&#10;    }));&#10;  }, []);&#10;&#10;  const handleTyping = useCallback((event: TypingEvent) =&gt; {&#10;    setState(prev =&gt; {&#10;      const conversationTyping = new Set(prev.typingUsers[event.conversationId] || []);&#10;&#10;      if (event.isTyping) {&#10;        conversationTyping.add(event.userId);&#10;      } else {&#10;        conversationTyping.delete(event.userId);&#10;      }&#10;&#10;      return {&#10;        ...prev,&#10;        typingUsers: {&#10;          ...prev.typingUsers,&#10;          [event.conversationId]: conversationTyping&#10;        }&#10;      };&#10;    });&#10;  }, []);&#10;&#10;  const handlePresence = useCallback((event: PresenceEvent) =&gt; {&#10;    setState(prev =&gt; {&#10;      const newOnlineUsers = new Set(prev.onlineUsers);&#10;&#10;      if (event.status === 'ONLINE') {&#10;        newOnlineUsers.add(event.userId);&#10;      } else {&#10;        newOnlineUsers.delete(event.userId);&#10;      }&#10;&#10;      return {&#10;        ...prev,&#10;        onlineUsers: newOnlineUsers&#10;      };&#10;    });&#10;  }, []);&#10;&#10;  const handleConnected = useCallback(() =&gt; {&#10;    setState(prev =&gt; ({ ...prev, isConnected: true, error: null }));&#10;  }, []);&#10;&#10;  const handleDisconnected = useCallback(() =&gt; {&#10;    setState(prev =&gt; ({ ...prev, isConnected: false }));&#10;  }, []);&#10;&#10;  const handleError = useCallback((error: Error) =&gt; {&#10;    setState(prev =&gt; ({ ...prev, error: error.message, isConnected: false }));&#10;  }, []);&#10;&#10;  // Connection management&#10;  const connectToChat = useCallback(async () =&gt; {&#10;    if (!token) {&#10;      setState(prev =&gt; ({ ...prev, error: 'Authentication token not available' }));&#10;      return;&#10;    }&#10;&#10;    try {&#10;      setState(prev =&gt; ({ ...prev, isLoading: true, error: null }));&#10;&#10;      // Setup event listeners&#10;      webSocketService.on('message', handleMessage);&#10;      webSocketService.on('typing', handleTyping);&#10;      webSocketService.on('presence', handlePresence);&#10;      webSocketService.on('connected', handleConnected);&#10;      webSocketService.on('disconnected', handleDisconnected);&#10;      webSocketService.on('error', handleError);&#10;&#10;      await webSocketService.connect(token);&#10;&#10;      // Load conversations after connection&#10;      await loadConversations();&#10;&#10;      setState(prev =&gt; ({ ...prev, isLoading: false }));&#10;    } catch (error) {&#10;      setState(prev =&gt; ({&#10;        ...prev,&#10;        error: error instanceof Error ? error.message : 'Connection failed',&#10;        isLoading: false&#10;      }));&#10;    }&#10;  }, [token, handleMessage, handleTyping, handlePresence, handleConnected, handleDisconnected, handleError]);&#10;&#10;  const disconnectFromChat = useCallback(async () =&gt; {&#10;    await webSocketService.disconnect();&#10;    webSocketService.removeAllListeners();&#10;&#10;    setState(prev =&gt; ({&#10;      ...prev,&#10;      isConnected: false,&#10;      activeConversationId: null,&#10;      typingUsers: {}&#10;    }));&#10;  }, []);&#10;&#10;  // Conversation management&#10;  const setActiveConversation = useCallback((conversationId: string | null) =&gt; {&#10;    setState(prev =&gt; {&#10;      // Leave previous conversation&#10;      if (prev.activeConversationId &amp;&amp; prev.activeConversationId !== conversationId) {&#10;        webSocketService.leaveConversation(prev.activeConversationId);&#10;      }&#10;&#10;      // Join new conversation&#10;      if (conversationId) {&#10;        webSocketService.joinConversation(conversationId);&#10;        // Load messages for this conversation&#10;        loadMessages(conversationId);&#10;      }&#10;&#10;      return { ...prev, activeConversationId: conversationId };&#10;    });&#10;  }, []);&#10;&#10;  const loadConversations = useCallback(async () =&gt; {&#10;    try {&#10;      setState(prev =&gt; ({ ...prev, isLoading: true }));&#10;&#10;      const response: PaginatedResponse&lt;ChatRoom&gt; = await chatService.getChatRooms();&#10;&#10;      setState(prev =&gt; ({&#10;        ...prev,&#10;        conversations: response.content,&#10;        isLoading: false&#10;      }));&#10;    } catch (error) {&#10;      setState(prev =&gt; ({&#10;        ...prev,&#10;        error: error instanceof Error ? error.message : 'Failed to load conversations',&#10;        isLoading: false&#10;      }));&#10;    }&#10;  }, []);&#10;&#10;  // Message management&#10;  const sendMessage = useCallback((conversationId: string, content: string, type = 'TEXT') =&gt; {&#10;    if (state.isConnected) {&#10;      webSocketService.sendMessage(conversationId, content, type);&#10;    } else {&#10;      setState(prev =&gt; ({ ...prev, error: 'Not connected to chat service' }));&#10;    }&#10;  }, [state.isConnected]);&#10;&#10;  const loadMessages = useCallback(async (conversationId: string, page = 0) =&gt; {&#10;    try {&#10;      const response: PaginatedResponse&lt;ChatMessage&gt; = await chatService.getMessages(conversationId, page, 50);&#10;&#10;      setState(prev =&gt; ({&#10;        ...prev,&#10;        messages: {&#10;          ...prev.messages,&#10;          [conversationId]: page === 0 ? response.content : [&#10;            ...response.content,&#10;            ...(prev.messages[conversationId] || [])&#10;          ].sort((a, b) =&gt; new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime())&#10;        }&#10;      }));&#10;    } catch (error) {&#10;      setState(prev =&gt; ({&#10;        ...prev,&#10;        error: error instanceof Error ? error.message : 'Failed to load messages'&#10;      }));&#10;    }&#10;  }, []);&#10;&#10;  // Typing indicators&#10;  const startTyping = useCallback((conversationId: string) =&gt; {&#10;    if (state.isConnected) {&#10;      webSocketService.sendTyping(conversationId, true);&#10;    }&#10;  }, [state.isConnected]);&#10;&#10;  const stopTyping = useCallback((conversationId: string) =&gt; {&#10;    if (state.isConnected) {&#10;      webSocketService.sendTyping(conversationId, false);&#10;    }&#10;  }, [state.isConnected]);&#10;&#10;  // Utilities&#10;  const clearError = useCallback(() =&gt; {&#10;    setState(prev =&gt; ({ ...prev, error: null }));&#10;  }, []);&#10;&#10;  const getUnreadCount = useCallback((conversationId: string) =&gt; {&#10;    const messages = state.messages[conversationId] || [];&#10;    return messages.filter(msg =&gt;&#10;      msg.senderId !== user?.id &amp;&amp;&#10;      !msg.readBy?.some(readStatus =&gt; readStatus.userId === user?.id)&#10;    ).length;&#10;  }, [state.messages, user?.id]);&#10;&#10;  const markAsRead = useCallback(async (conversationId: string) =&gt; {&#10;    try {&#10;      await chatService.markRoomAsRead(conversationId);&#10;&#10;      setState(prev =&gt; ({&#10;        ...prev,&#10;        messages: {&#10;          ...prev.messages,&#10;          [conversationId]: prev.messages[conversationId]?.map(msg =&gt; {&#10;            const alreadyRead = msg.readBy?.some(readStatus =&gt; readStatus.userId === user?.id);&#10;&#10;            if (alreadyRead) return msg;&#10;&#10;            // Create a chat-compatible user object that matches the MessageReadStatus type&#10;            const chatUser: ChatUser = {&#10;              id: user?.id || '',&#10;              email: user?.email || '',&#10;              username: user?.username || '',&#10;              fullName: user?.fullName || '',&#10;              avatar: user?.avatar,&#10;              bio: user?.bio,&#10;              faculty: typeof user?.faculty === 'object' ? user?.faculty?.name : user?.faculty,&#10;              yearOfStudy: user?.yearOfStudy,&#10;              isVerified: user?.isVerified || false,&#10;              isOnline: user?.isOnline || false,&#10;              followersCount: user?.followersCount,&#10;              followingCount: user?.followingCount,&#10;              postsCount: user?.postsCount,&#10;              createdAt: user?.createdAt || new Date().toISOString(),&#10;              updatedAt: user?.updatedAt || new Date().toISOString()&#10;            };&#10;&#10;            const newReadStatus: MessageReadStatus = {&#10;              userId: user?.id || '',&#10;              user: chatUser,&#10;              readAt: new Date().toISOString(),&#10;            };&#10;&#10;            return {&#10;              ...msg,&#10;              readBy: [...(msg.readBy || []), newReadStatus],&#10;              isRead: true,&#10;            };&#10;          }) || []&#10;        }&#10;      }));&#10;    } catch (error) {&#10;      console.error('Failed to mark messages as read:', error);&#10;    }&#10;  }, [user]);&#10;&#10;  const contextValue: ChatContextType = {&#10;    ...state,&#10;    connectToChat,&#10;    disconnectFromChat,&#10;    setActiveConversation,&#10;    loadConversations,&#10;    sendMessage,&#10;    loadMessages,&#10;    startTyping,&#10;    stopTyping,&#10;    clearError,&#10;    getUnreadCount,&#10;    markAsRead,&#10;  };&#10;&#10;  return (&#10;    &lt;ChatContext.Provider value={contextValue}&gt;&#10;      {children}&#10;    &lt;/ChatContext.Provider&gt;&#10;  );&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/client-frontend/src/features/chat/services/chat.service.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/client-frontend/src/features/chat/services/chat.service.ts" />
              <option name="originalContent" value="/*&#10;/*&#10;import { apiClient } from '@/shared/config/api-client';&#10;import { API_ENDPOINTS } from '@/shared/constants';&#10;import { createApiUrl } from '@/shared/utils';&#10;import {&#10;  ChatRoom,&#10;  ChatMessage,&#10;  CreateChatRoomRequest,&#10;  SendMessageRequest,&#10;  UpdateMessageRequest,&#10;  PaginatedResponse,&#10;  ApiResponse,&#10;  OnlineStatus,&#10;} from '@/shared/types';&#10;/!**&#10;/!**&#10; *!/&#10; * Handles all chat-related API calls&#10;  /!**&#10;export class ChatService {&#10;   *!/&#10;   * Get chat rooms&#10;   *!/&#10;  async getChatRooms(page = 0, size = 20): Promise&lt;PaginatedResponse&lt;ChatRoom&gt;&gt; {&#10;    const url = createApiUrl(API_ENDPOINTS.CHAT.ROOMS, undefined, { page, size });&#10;    return apiClient.get&lt;PaginatedResponse&lt;ChatRoom&gt;&gt;(url);&#10;  /!**&#10;&#10;   *!/&#10;   * Get single chat room&#10;   *!/&#10;  async getChatRoom(roomId: string): Promise&lt;ChatRoom&gt; {&#10;    const url = createApiUrl(API_ENDPOINTS.CHAT.ROOMS + '/:id', { id: roomId });&#10;    return apiClient.get&lt;ChatRoom&gt;(url);&#10;  /!**&#10;&#10;   *!/&#10;   * Create new chat room&#10;   *!/&#10;  async createChatRoom(roomData: CreateChatRoomRequest): Promise&lt;ChatRoom&gt; {&#10;    return apiClient.post&lt;ChatRoom&gt;(API_ENDPOINTS.CHAT.ROOMS, roomData);&#10;  /!**&#10;&#10;   *!/&#10;   * Get messages for a chat room&#10;   *!/&#10;  async getMessages(&#10;    roomId: string,&#10;    page = 0,&#10;    size = 50&#10;  ): Promise&lt;PaginatedResponse&lt;ChatMessage&gt;&gt; {&#10;    const url = createApiUrl(&#10;      API_ENDPOINTS.CHAT.MESSAGES,&#10;      { roomId },&#10;      { page, size }&#10;    );&#10;    return apiClient.get&lt;PaginatedResponse&lt;ChatMessage&gt;&gt;(url);&#10;  /!**&#10;&#10;   *!/&#10;   * Send message&#10;   *!/&#10;  async sendMessage(messageData: SendMessageRequest): Promise&lt;ChatMessage&gt; {&#10;    const { roomId, ...data } = messageData;&#10;    const url = createApiUrl(API_ENDPOINTS.CHAT.MESSAGES, { roomId });&#10;&#10;    // Handle file attachments&#10;    if (data.attachments &amp;&amp; data.attachments.length &gt; 0) {&#10;      const formData = new FormData();&#10;      formData.append('content', data.content);&#10;      formData.append('type', data.type);&#10;&#10;      if (data.replyTo) {&#10;        formData.append('replyTo', data.replyTo);&#10;      }&#10;&#10;      data.attachments.forEach(file =&gt; {&#10;        formData.append('attachments', file);&#10;      });&#10;&#10;      return apiClient.post&lt;ChatMessage&gt;(url, formData, {&#10;        headers: {&#10;          'Content-Type': 'multipart/form-data',&#10;        },&#10;      });&#10;    }&#10;&#10;    return apiClient.post&lt;ChatMessage&gt;(url, data);&#10;  /!**&#10;&#10;   *!/&#10;   * Update message&#10;   *!/&#10;  async updateMessage(&#10;    messageId: string,&#10;    updateData: UpdateMessageRequest&#10;  ): Promise&lt;ChatMessage&gt; {&#10;    const url = createApiUrl('/chat/messages/:id', { id: messageId });&#10;    return apiClient.put&lt;ChatMessage&gt;(url, updateData);&#10;  /!**&#10;&#10;   *!/&#10;   * Delete message&#10;   *!/&#10;  async deleteMessage(messageId: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#10;    const url = createApiUrl('/chat/messages/:id', { id: messageId });&#10;    return apiClient.delete&lt;ApiResponse&lt;null&gt;&gt;(url);&#10;  /!**&#10;&#10;   *!/&#10;   * Mark message as read&#10;   *!/&#10;  async markAsRead(messageId: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#10;    const url = createApiUrl(API_ENDPOINTS.CHAT.MARK_READ, { id: messageId });&#10;    return apiClient.put&lt;ApiResponse&lt;null&gt;&gt;(url);&#10;  /!**&#10;&#10;   *!/&#10;   * Mark all messages in room as read&#10;   *!/&#10;  async markRoomAsRead(roomId: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#10;    const url = createApiUrl(API_ENDPOINTS.CHAT.ROOM_READ, { id: roomId });&#10;    return apiClient.put&lt;ApiResponse&lt;null&gt;&gt;(url);&#10;  /!**&#10;&#10;   *!/&#10;   * Get unread messages count&#10;   *!/&#10;  async getUnreadCount(): Promise&lt;number&gt; {&#10;    const response = await apiClient.get&lt;{ count: number }&gt;(&#10;      API_ENDPOINTS.CHAT.UNREAD_COUNT&#10;    );&#10;    return response.count;&#10;  /!**&#10;&#10;   *!/&#10;   * Get online users&#10;   *!/&#10;  async getOnlineUsers(): Promise&lt;OnlineStatus[]&gt; {&#10;    return apiClient.get&lt;OnlineStatus[]&gt;('/chat/online-users');&#10;  /!**&#10;&#10;   *!/&#10;   * Start typing indicator&#10;   *!/&#10;  async startTyping(roomId: string): Promise&lt;void&gt; {&#10;    const url = createApiUrl('/chat/rooms/:roomId/typing/start', { roomId });&#10;    return apiClient.post(url);&#10;  /!**&#10;&#10;   *!/&#10;   * Stop typing indicator&#10;   *!/&#10;  async stopTyping(roomId: string): Promise&lt;void&gt; {&#10;    const url = createApiUrl('/chat/rooms/:roomId/typing/stop', { roomId });&#10;    return apiClient.post(url);&#10;  /!**&#10;&#10;   *!/&#10;   * Leave chat room&#10;   *!/&#10;  async leaveRoom(roomId: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#10;    const url = createApiUrl('/chat/rooms/:roomId/leave', { roomId });&#10;    return apiClient.post&lt;ApiResponse&lt;null&gt;&gt;(url);&#10;  /!**&#10;&#10;   *!/&#10;   * Add users to chat room&#10;   *!/&#10;  async addUsersToRoom(&#10;    roomId: string,&#10;    userIds: string[]&#10;  ): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#10;    const url = createApiUrl('/chat/rooms/:roomId/users', { roomId });&#10;    return apiClient.post&lt;ApiResponse&lt;null&gt;&gt;(url, { userIds });&#10;  /!**&#10;&#10;   *!/&#10;   * Remove user from chat room&#10;   *!/&#10;  async removeUserFromRoom(&#10;    roomId: string,&#10;    userId: string&#10;  ): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#10;    const url = createApiUrl('/chat/rooms/:roomId/users/:userId', { roomId, userId });&#10;    return apiClient.delete&lt;ApiResponse&lt;null&gt;&gt;(url);&#10;  }&#10;}&#10;&#10;*/&#10;// Export singleton instance&#10;export const chatService = new ChatService();&#10;*/&#10;" />
              <option name="updatedContent" value="import { apiClient } from '@/shared/config/api-client';&#13;&#10;import { API_ENDPOINTS } from '@/shared/constants';&#13;&#10;import { createApiUrl } from '@/shared/utils';&#13;&#10;import {&#13;&#10;  ChatRoom,&#13;&#10;  ChatMessage,&#13;&#10;  CreateChatRoomRequest,&#13;&#10;  SendMessageRequest,&#13;&#10;  UpdateMessageRequest,&#13;&#10;  PaginatedResponse,&#13;&#10;  ApiResponse,&#13;&#10;  OnlineStatus,&#13;&#10;} from '@/shared/types';&#13;&#10;&#13;&#10;/**&#13;&#10; * Chat Service&#13;&#10; * Handles all chat-related API calls&#13;&#10; */&#13;&#10;export class ChatService {&#13;&#10;  /**&#13;&#10;   * Get chat rooms&#13;&#10;   */&#13;&#10;  async getChatRooms(page = 0, size = 20): Promise&lt;PaginatedResponse&lt;ChatRoom&gt;&gt; {&#13;&#10;    const url = createApiUrl(API_ENDPOINTS.CHAT.ROOMS, undefined, { page, size });&#13;&#10;    return apiClient.get&lt;PaginatedResponse&lt;ChatRoom&gt;&gt;(url);&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Get single chat room&#13;&#10;   */&#13;&#10;  async getChatRoom(roomId: string): Promise&lt;ChatRoom&gt; {&#13;&#10;    const url = createApiUrl(API_ENDPOINTS.CHAT.ROOMS + '/:id', { id: roomId });&#13;&#10;    return apiClient.get&lt;ChatRoom&gt;(url);&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Create new chat room&#13;&#10;   */&#13;&#10;  async createChatRoom(roomData: CreateChatRoomRequest): Promise&lt;ChatRoom&gt; {&#13;&#10;    return apiClient.post&lt;ChatRoom&gt;(API_ENDPOINTS.CHAT.ROOMS, roomData);&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Get messages for a chat room&#13;&#10;   */&#13;&#10;  async getMessages(&#13;&#10;    roomId: string,&#13;&#10;    page = 0,&#13;&#10;    size = 50&#13;&#10;  ): Promise&lt;PaginatedResponse&lt;ChatMessage&gt;&gt; {&#13;&#10;    const url = createApiUrl(&#13;&#10;      API_ENDPOINTS.CHAT.MESSAGES,&#13;&#10;      { roomId },&#13;&#10;      { page, size }&#13;&#10;    );&#13;&#10;    return apiClient.get&lt;PaginatedResponse&lt;ChatMessage&gt;&gt;(url);&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Send message&#13;&#10;   */&#13;&#10;  async sendMessage(messageData: SendMessageRequest): Promise&lt;ChatMessage&gt; {&#13;&#10;    const { roomId, ...data } = messageData;&#13;&#10;    const url = createApiUrl(API_ENDPOINTS.CHAT.MESSAGES, { roomId });&#13;&#10;&#13;&#10;    // Handle file attachments&#13;&#10;    if (data.attachments &amp;&amp; data.attachments.length &gt; 0) {&#13;&#10;      const formData = new FormData();&#13;&#10;      formData.append('content', data.content);&#13;&#10;      formData.append('type', data.type);&#13;&#10;&#13;&#10;      if (data.replyTo) {&#13;&#10;        formData.append('replyTo', data.replyTo);&#13;&#10;      }&#13;&#10;&#13;&#10;      data.attachments.forEach(file =&gt; {&#13;&#10;        formData.append('attachments', file);&#13;&#10;      });&#13;&#10;&#13;&#10;      return apiClient.post&lt;ChatMessage&gt;(url, formData, {&#13;&#10;        headers: {&#13;&#10;          'Content-Type': 'multipart/form-data',&#13;&#10;        },&#13;&#10;      });&#13;&#10;    }&#13;&#10;&#13;&#10;    return apiClient.post&lt;ChatMessage&gt;(url, data);&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Update message&#13;&#10;   */&#13;&#10;  async updateMessage(&#13;&#10;    messageId: string,&#13;&#10;    updateData: UpdateMessageRequest&#13;&#10;  ): Promise&lt;ChatMessage&gt; {&#13;&#10;    const url = createApiUrl('/chat/messages/:id', { id: messageId });&#13;&#10;    return apiClient.put&lt;ChatMessage&gt;(url, updateData);&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Delete message&#13;&#10;   */&#13;&#10;  async deleteMessage(messageId: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#13;&#10;    const url = createApiUrl('/chat/messages/:id', { id: messageId });&#13;&#10;    return apiClient.delete&lt;ApiResponse&lt;null&gt;&gt;(url);&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Mark message as read&#13;&#10;   */&#13;&#10;  async markAsRead(messageId: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#13;&#10;    const url = createApiUrl(API_ENDPOINTS.CHAT.MARK_READ, { id: messageId });&#13;&#10;    return apiClient.put&lt;ApiResponse&lt;null&gt;&gt;(url);&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Mark all messages in room as read&#13;&#10;   */&#13;&#10;  async markRoomAsRead(roomId: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#13;&#10;    const url = createApiUrl(API_ENDPOINTS.CHAT.ROOM_READ, { id: roomId });&#13;&#10;    return apiClient.put&lt;ApiResponse&lt;null&gt;&gt;(url);&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Get unread messages count&#13;&#10;   */&#13;&#10;  async getUnreadCount(): Promise&lt;number&gt; {&#13;&#10;    const response = await apiClient.get&lt;{ count: number }&gt;(&#13;&#10;      API_ENDPOINTS.CHAT.UNREAD_COUNT&#13;&#10;    );&#13;&#10;    return response.count;&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Get online users&#13;&#10;   */&#13;&#10;  async getOnlineUsers(): Promise&lt;OnlineStatus[]&gt; {&#13;&#10;    return apiClient.get&lt;OnlineStatus[]&gt;('/chat/online-users');&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Start typing indicator&#13;&#10;   */&#13;&#10;  async startTyping(roomId: string): Promise&lt;void&gt; {&#13;&#10;    const url = createApiUrl('/chat/rooms/:roomId/typing/start', { roomId });&#13;&#10;    return apiClient.post(url);&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Stop typing indicator&#13;&#10;   */&#13;&#10;  async stopTyping(roomId: string): Promise&lt;void&gt; {&#13;&#10;    const url = createApiUrl('/chat/rooms/:roomId/typing/stop', { roomId });&#13;&#10;    return apiClient.post(url);&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Leave chat room&#13;&#10;   */&#13;&#10;  async leaveRoom(roomId: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#13;&#10;    const url = createApiUrl('/chat/rooms/:roomId/leave', { roomId });&#13;&#10;    return apiClient.post&lt;ApiResponse&lt;null&gt;&gt;(url);&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Add users to chat room&#13;&#10;   */&#13;&#10;  async addUsersToRoom(&#13;&#10;    roomId: string,&#13;&#10;    userIds: string[]&#13;&#10;  ): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#13;&#10;    const url = createApiUrl('/chat/rooms/:roomId/users', { roomId });&#13;&#10;    return apiClient.post&lt;ApiResponse&lt;null&gt;&gt;(url, { userIds });&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Remove user from chat room&#13;&#10;   */&#13;&#10;  async removeUserFromRoom(&#13;&#10;    roomId: string,&#13;&#10;    userId: string&#13;&#10;  ): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#13;&#10;    const url = createApiUrl('/chat/rooms/:roomId/users/:userId', { roomId, userId });&#13;&#10;    return apiClient.delete&lt;ApiResponse&lt;null&gt;&gt;(url);&#13;&#10;  }&#13;&#10;}&#13;&#10;&#13;&#10;// Export singleton instance&#13;&#10;export const chatService = new ChatService();" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/client-frontend/src/features/users/components/UserCard.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/client-frontend/src/features/users/components/UserCard.tsx" />
              <option name="updatedContent" value="'use client';&#10;&#10;import React from 'react';&#10;import { User, FriendshipStatus } from '@/shared/types';&#10;import Link from 'next/link';&#10;&#10;interface UserCardProps {&#10;  user: User;&#10;  showActions?: boolean;&#10;  compact?: boolean;&#10;  friendshipStatus?: FriendshipStatus;&#10;  onSendFriendRequest?: () =&gt; void;&#10;  onAcceptFriendRequest?: () =&gt; void;&#10;  onRejectFriendRequest?: () =&gt; void;&#10;  onRemoveFriend?: () =&gt; void;&#10;  onCancelRequest?: () =&gt; void;&#10;}&#10;&#10;export const UserCard: React.FC&lt;UserCardProps&gt; = ({&#10;  user,&#10;  showActions = true,&#10;  compact = false,&#10;  friendshipStatus,&#10;  onSendFriendRequest,&#10;  onAcceptFriendRequest,&#10;  onRejectFriendRequest,&#10;  onRemoveFriend,&#10;  onCancelRequest&#10;}) =&gt; {&#10;  const renderActionButton = () =&gt; {&#10;    if (!showActions) return null;&#10;&#10;    switch (friendshipStatus) {&#10;      case 'FRIENDS':&#10;        return (&#10;          &lt;button&#10;            onClick={onRemoveFriend}&#10;            className=&quot;px-3 py-1 bg-red-500 text-white rounded text-sm hover:bg-red-600&quot;&#10;          &gt;&#10;            Unfriend&#10;          &lt;/button&gt;&#10;        );&#10;      case 'REQUEST_SENT':&#10;        return (&#10;          &lt;button&#10;            onClick={onCancelRequest}&#10;            className=&quot;px-3 py-1 bg-gray-500 text-white rounded text-sm hover:bg-gray-600&quot;&#10;          &gt;&#10;            Cancel Request&#10;          &lt;/button&gt;&#10;        );&#10;      case 'REQUEST_RECEIVED':&#10;        return (&#10;          &lt;div className=&quot;flex space-x-1&quot;&gt;&#10;            &lt;button&#10;              onClick={onAcceptFriendRequest}&#10;              className=&quot;px-3 py-1 bg-green-500 text-white rounded text-sm hover:bg-green-600&quot;&#10;            &gt;&#10;              Accept&#10;            &lt;/button&gt;&#10;            &lt;button&#10;              onClick={onRejectFriendRequest}&#10;              className=&quot;px-3 py-1 bg-gray-500 text-white rounded text-sm hover:bg-gray-600&quot;&#10;            &gt;&#10;              Reject&#10;            &lt;/button&gt;&#10;          &lt;/div&gt;&#10;        );&#10;      case 'NOT_FRIENDS':&#10;      default:&#10;        return (&#10;          &lt;button&#10;            onClick={onSendFriendRequest}&#10;            className=&quot;px-3 py-1 bg-blue-500 text-white rounded text-sm hover:bg-blue-600&quot;&#10;          &gt;&#10;            Add Friend&#10;          &lt;/button&gt;&#10;        );&#10;    }&#10;  };&#10;&#10;  if (compact) {&#10;    return (&#10;      &lt;div className=&quot;flex items-center space-x-3&quot;&gt;&#10;        &lt;Link href={`/profile/${user.id}`}&gt;&#10;          &lt;div className=&quot;w-10 h-10 rounded-full bg-gray-200 flex items-center justify-center overflow-hidden cursor-pointer&quot;&gt;&#10;            {user.avatar ? (&#10;              &lt;img &#10;                src={user.avatar} &#10;                alt={user.fullName}&#10;                className=&quot;w-full h-full object-cover&quot;&#10;              /&gt;&#10;            ) : (&#10;              &lt;span className=&quot;text-gray-500&quot;&gt;&#10;                {user.fullName.charAt(0).toUpperCase()}&#10;              &lt;/span&gt;&#10;            )}&#10;          &lt;/div&gt;&#10;        &lt;/Link&gt;&#10;        &lt;div className=&quot;flex-1 min-w-0&quot;&gt;&#10;          &lt;Link href={`/profile/${user.id}`}&gt;&#10;            &lt;h4 className=&quot;font-semibold text-gray-900 hover:text-blue-600 cursor-pointer truncate&quot;&gt;&#10;              {user.fullName}&#10;            &lt;/h4&gt;&#10;          &lt;/Link&gt;&#10;          &lt;p className=&quot;text-sm text-gray-500 truncate&quot;&gt;@{user.username}&lt;/p&gt;&#10;          {user.faculty &amp;&amp; (&#10;            &lt;p className=&quot;text-xs text-gray-400 truncate&quot;&gt;{user.faculty}&lt;/p&gt;&#10;          )}&#10;        &lt;/div&gt;&#10;      &lt;/div&gt;&#10;    );&#10;  }&#10;&#10;  return (&#10;    &lt;div className=&quot;bg-white rounded-lg border p-4 shadow-sm hover:shadow-md transition-shadow&quot;&gt;&#10;      &lt;div className=&quot;flex flex-col items-center space-y-3&quot;&gt;&#10;        {/* Avatar */}&#10;        &lt;Link href={`/profile/${user.id}`}&gt;&#10;          &lt;div className=&quot;w-16 h-16 rounded-full bg-gray-200 flex items-center justify-center overflow-hidden cursor-pointer hover:opacity-80&quot;&gt;&#10;            {user.avatar ? (&#10;              &lt;img &#10;                src={user.avatar} &#10;                alt={user.fullName}&#10;                className=&quot;w-full h-full object-cover&quot;&#10;              /&gt;&#10;            ) : (&#10;              &lt;span className=&quot;text-gray-500 text-xl&quot;&gt;&#10;                {user.fullName.charAt(0).toUpperCase()}&#10;              &lt;/span&gt;&#10;            )}&#10;          &lt;/div&gt;&#10;        &lt;/Link&gt;&#10;&#10;        {/* User Info */}&#10;        &lt;div className=&quot;text-center&quot;&gt;&#10;          &lt;Link href={`/profile/${user.id}`}&gt;&#10;            &lt;h4 className=&quot;font-semibold text-gray-900 hover:text-blue-600 cursor-pointer&quot;&gt;&#10;              {user.fullName}&#10;            &lt;/h4&gt;&#10;          &lt;/Link&gt;&#10;          &lt;p className=&quot;text-sm text-gray-500&quot;&gt;@{user.username}&lt;/p&gt;&#10;          {user.faculty &amp;&amp; (&#10;            &lt;p className=&quot;text-xs text-gray-400&quot;&gt;{user.faculty}&lt;/p&gt;&#10;          )}&#10;        &lt;/div&gt;&#10;&#10;        {/* Bio */}&#10;        {user.bio &amp;&amp; (&#10;          &lt;p className=&quot;text-xs text-gray-600 text-center line-clamp-2&quot;&gt;&#10;            {user.bio}&#10;          &lt;/p&gt;&#10;        )}&#10;&#10;        {/* Stats */}&#10;        &lt;div className=&quot;flex space-x-4 text-xs text-gray-500&quot;&gt;&#10;          {user.postsCount !== undefined &amp;&amp; (&#10;            &lt;span&gt;{user.postsCount} posts&lt;/span&gt;&#10;          )}&#10;          {user.followersCount !== undefined &amp;&amp; (&#10;            &lt;span&gt;{user.followersCount} followers&lt;/span&gt;&#10;          )}&#10;        &lt;/div&gt;&#10;&#10;        {/* Online Status */}&#10;        {user.isOnline &amp;&amp; (&#10;          &lt;div className=&quot;flex items-center space-x-1 text-xs text-green-600&quot;&gt;&#10;            &lt;div className=&quot;w-2 h-2 bg-green-500 rounded-full&quot;&gt;&lt;/div&gt;&#10;            &lt;span&gt;Online&lt;/span&gt;&#10;          &lt;/div&gt;&#10;        )}&#10;&#10;        {/* Action Button */}&#10;        {renderActionButton()}&#10;      &lt;/div&gt;&#10;    &lt;/div&gt;&#10;  );&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/client-frontend/src/features/users/components/friends/FriendRequests.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/client-frontend/src/features/users/components/friends/FriendRequests.tsx" />
              <option name="originalContent" value="'use client';&#10;&#10;import React, { useEffect, useState } from 'react';&#10;import { User } from '@/shared/types';&#10;import { userService } from '../../services';&#10;import { toast } from 'react-hot-toast';&#10;import { UserCard } from '../UserCard';&#10;import { LoadingSpinner } from '@/shared/components';&#10;&#10;export const FriendRequests: React.FC = () =&gt; {&#10;  const [incomingRequests, setIncomingRequests] = useState&lt;User[]&gt;([]);&#10;  const [outgoingRequests, setOutgoingRequests] = useState&lt;User[]&gt;([]);&#10;  const [loading, setLoading] = useState(true);&#10;  const [activeTab, setActiveTab] = useState&lt;'incoming' | 'outgoing'&gt;('incoming');&#10;&#10;  useEffect(() =&gt; {&#10;    loadFriendRequests();&#10;  }, []);&#10;&#10;  const loadFriendRequests = async () =&gt; {&#10;    try {&#10;      setLoading(true);&#10;      const [incoming, outgoing] = await Promise.all([&#10;        userService.getFriendRequests(),&#10;        userService.getSentFriendRequests()&#10;      ]);&#10;      setIncomingRequests(incoming);&#10;      setOutgoingRequests(outgoing);&#10;    } catch (err) {&#10;      toast.error('Failed to load friend requests');&#10;      console.error('Error loading friend requests:', err);&#10;    } finally {&#10;      setLoading(false);&#10;    }&#10;  };&#10;&#10;  const handleAcceptRequest = async (userId: string) =&gt; {&#10;    try {&#10;      await userService.acceptFriendRequest(userId);&#10;      setIncomingRequests(prev =&gt; prev.filter(user =&gt; user.id !== userId));&#10;      toast.success('Friend request accepted');&#10;    } catch (err) {&#10;      toast.error('Failed to accept friend request');&#10;      console.error('Error accepting friend request:', err);&#10;    }&#10;  };&#10;&#10;  const handleRejectRequest = async (userId: string) =&gt; {&#10;    try {&#10;      await userService.rejectFriendRequest(userId);&#10;      setIncomingRequests(prev =&gt; prev.filter(user =&gt; user.id !== userId));&#10;      toast.success('Friend request rejected');&#10;    } catch (err) {&#10;      toast.error('Failed to reject friend request');&#10;      console.error('Error rejecting friend request:', err);&#10;    }&#10;  };&#10;&#10;  const handleCancelRequest = async (userId: string) =&gt; {&#10;    try {&#10;      await userService.rejectFriendRequest(userId); // Cancel is same as reject for outgoing&#10;      setOutgoingRequests(prev =&gt; prev.filter(user =&gt; user.id !== userId));&#10;      toast.success('Friend request cancelled');&#10;    } catch (err) {&#10;      toast.error('Failed to cancel friend request');&#10;      console.error('Error cancelling friend request:', err);&#10;    }&#10;  };&#10;&#10;  if (loading) {&#10;    return (&#10;      &lt;div className=&quot;flex justify-center items-center py-8&quot;&gt;&#10;        &lt;LoadingSpinner /&gt;&#10;      &lt;/div&gt;&#10;    );&#10;  }&#10;&#10;  return (&#10;    &lt;div className=&quot;space-y-6&quot;&gt;&#10;      {/* Tab Navigation */}&#10;      &lt;div className=&quot;flex space-x-1 bg-gray-100 p-1 rounded-lg&quot;&gt;&#10;        &lt;button&#10;          onClick={() =&gt; setActiveTab('incoming')}&#10;          className={`flex-1 py-2 px-4 rounded-md text-sm font-medium transition-colors ${&#10;            activeTab === 'incoming'&#10;              ? 'bg-white text-blue-600 shadow-sm'&#10;              : 'text-gray-500 hover:text-gray-700'&#10;          }`}&#10;        &gt;&#10;          Received ({incomingRequests.length})&#10;        &lt;/button&gt;&#10;        &lt;button&#10;          onClick={() =&gt; setActiveTab('outgoing')}&#10;          className={`flex-1 py-2 px-4 rounded-md text-sm font-medium transition-colors ${&#10;            activeTab === 'outgoing'&#10;              ? 'bg-white text-blue-600 shadow-sm'&#10;              : 'text-gray-500 hover:text-gray-700'&#10;          }`}&#10;        &gt;&#10;          Sent ({outgoingRequests.length})&#10;        &lt;/button&gt;&#10;      &lt;/div&gt;&#10;&#10;      {/* Content */}&#10;      &lt;div&gt;&#10;        {activeTab === 'incoming' &amp;&amp; (&#10;          &lt;div className=&quot;space-y-4&quot;&gt;&#10;            &lt;h3 className=&quot;text-lg font-semibold&quot;&gt;Friend Requests Received&lt;/h3&gt;&#10;            {incomingRequests.length === 0 ? (&#10;              &lt;p className=&quot;text-gray-500&quot;&gt;No pending friend requests&lt;/p&gt;&#10;            ) : (&#10;              &lt;div className=&quot;space-y-3&quot;&gt;&#10;                {incomingRequests.map((user) =&gt; (&#10;                  &lt;div key={user.id} className=&quot;flex items-center justify-between p-4 bg-white rounded-lg border&quot;&gt;&#10;                    &lt;UserCard&#10;                      user={user}&#10;                      showActions={false}&#10;                      compact={true}&#10;                    /&gt;&#10;                    &lt;div className=&quot;flex space-x-2&quot;&gt;&#10;                      &lt;button&#10;                        onClick={() =&gt; handleAcceptRequest(user.id)}&#10;                        className=&quot;px-4 py-2 bg-green-500 text-white rounded hover:bg-green-600 transition-colors&quot;&#10;                      &gt;&#10;                        Accept&#10;                      &lt;/button&gt;&#10;                      &lt;button&#10;                        onClick={() =&gt; handleRejectRequest(user.id)}&#10;                        className=&quot;px-4 py-2 bg-gray-500 text-white rounded hover:bg-gray-600 transition-colors&quot;&#10;                      &gt;&#10;                        Reject&#10;                      &lt;/button&gt;&#10;                    &lt;/div&gt;&#10;                  &lt;/div&gt;&#10;                ))}&#10;              &lt;/div&gt;&#10;            )}&#10;          &lt;/div&gt;&#10;        )}&#10;&#10;        {activeTab === 'outgoing' &amp;&amp; (&#10;          &lt;div className=&quot;space-y-4&quot;&gt;&#10;            &lt;h3 className=&quot;text-lg font-semibold&quot;&gt;Friend Requests Sent&lt;/h3&gt;&#10;            {outgoingRequests.length === 0 ? (&#10;              &lt;p className=&quot;text-gray-500&quot;&gt;No pending sent requests&lt;/p&gt;&#10;            ) : (&#10;              &lt;div className=&quot;space-y-3&quot;&gt;&#10;                {outgoingRequests.map((user) =&gt; (&#10;                  &lt;div key={user.id} className=&quot;flex items-center justify-between p-4 bg-white rounded-lg border&quot;&gt;&#10;                    &lt;UserCard&#10;                      user={user}&#10;                      showActions={false}&#10;                      compact={true}&#10;                    /&gt;&#10;                    &lt;button&#10;                      onClick={() =&gt; handleCancelRequest(user.id)}&#10;                      className=&quot;px-4 py-2 bg-red-500 text-white rounded hover:bg-red-600 transition-colors&quot;&#10;                    &gt;&#10;                      Cancel&#10;                    &lt;/button&gt;&#10;                  &lt;/div&gt;&#10;                ))}&#10;              &lt;/div&gt;&#10;            )}&#10;          &lt;/div&gt;&#10;        )}&#10;      &lt;/div&gt;&#10;    &lt;/div&gt;&#10;  );&#10;};&#10;" />
              <option name="updatedContent" value="'use client';&#10;&#10;import React, { useEffect, useState } from 'react';&#10;import { User } from '@/types';&#10;import { userService } from '@/services/userService';&#10;import { toast } from 'react-hot-toast';&#10;import LoadingSpinner from '@/components/ui/LoadingSpinner';&#10;&#10;export const FriendRequests: React.FC = () =&gt; {&#10;  const [incomingRequests, setIncomingRequests] = useState&lt;User[]&gt;([]);&#10;  const [outgoingRequests, setOutgoingRequests] = useState&lt;User[]&gt;([]);&#10;  const [loading, setLoading] = useState(true);&#10;  const [activeTab, setActiveTab] = useState&lt;'incoming' | 'outgoing'&gt;('incoming');&#10;&#10;  useEffect(() =&gt; {&#10;    loadFriendRequests();&#10;  }, []);&#10;&#10;  const loadFriendRequests = async () =&gt; {&#10;    try {&#10;      setLoading(true);&#10;      const [incoming, outgoing] = await Promise.all([&#10;        userService.getFriendRequests(),&#10;        userService.getSentFriendRequests()&#10;      ]);&#10;      setIncomingRequests(incoming);&#10;      setOutgoingRequests(outgoing);&#10;    } catch (err) {&#10;      toast.error('Failed to load friend requests');&#10;      console.error('Error loading friend requests:', err);&#10;    } finally {&#10;      setLoading(false);&#10;    }&#10;  };&#10;&#10;  const handleAcceptRequest = async (userId: string) =&gt; {&#10;    try {&#10;      await userService.acceptFriendRequest(userId);&#10;      setIncomingRequests(prev =&gt; prev.filter(user =&gt; user.id !== userId));&#10;      toast.success('Friend request accepted');&#10;    } catch (err) {&#10;      toast.error('Failed to accept friend request');&#10;    }&#10;  };&#10;&#10;  const handleRejectRequest = async (userId: string) =&gt; {&#10;    try {&#10;      await userService.rejectFriendRequest(userId);&#10;      setIncomingRequests(prev =&gt; prev.filter(user =&gt; user.id !== userId));&#10;      toast.success('Friend request rejected');&#10;    } catch (err) {&#10;      toast.error('Failed to reject friend request');&#10;    }&#10;  };&#10;&#10;  const handleCancelRequest = async (userId: string) =&gt; {&#10;    try {&#10;      await userService.rejectFriendRequest(userId);&#10;      setOutgoingRequests(prev =&gt; prev.filter(user =&gt; user.id !== userId));&#10;      toast.success('Friend request cancelled');&#10;    } catch (err) {&#10;      toast.error('Failed to cancel friend request');&#10;    }&#10;  };&#10;&#10;  if (loading) {&#10;    return (&#10;      &lt;div className=&quot;flex justify-center items-center py-8&quot;&gt;&#10;        &lt;LoadingSpinner /&gt;&#10;      &lt;/div&gt;&#10;    );&#10;  }&#10;&#10;  return (&#10;    &lt;div className=&quot;space-y-6&quot;&gt;&#10;      {/* Tab Navigation */}&#10;      &lt;div className=&quot;flex space-x-1 bg-gray-100 p-1 rounded-lg&quot;&gt;&#10;        &lt;button&#10;          onClick={() =&gt; setActiveTab('incoming')}&#10;          className={`flex-1 py-2 px-4 rounded-md text-sm font-medium transition-colors ${&#10;            activeTab === 'incoming'&#10;              ? 'bg-white text-blue-600 shadow-sm'&#10;              : 'text-gray-500 hover:text-gray-700'&#10;          }`}&#10;        &gt;&#10;          Received ({incomingRequests.length})&#10;        &lt;/button&gt;&#10;        &lt;button&#10;          onClick={() =&gt; setActiveTab('outgoing')}&#10;          className={`flex-1 py-2 px-4 rounded-md text-sm font-medium transition-colors ${&#10;            activeTab === 'outgoing'&#10;              ? 'bg-white text-blue-600 shadow-sm'&#10;              : 'text-gray-500 hover:text-gray-700'&#10;          }`}&#10;        &gt;&#10;          Sent ({outgoingRequests.length})&#10;        &lt;/button&gt;&#10;      &lt;/div&gt;&#10;&#10;      {/* Content */}&#10;      &lt;div&gt;&#10;        {activeTab === 'incoming' &amp;&amp; (&#10;          &lt;div className=&quot;space-y-4&quot;&gt;&#10;            &lt;h3 className=&quot;text-lg font-semibold&quot;&gt;Friend Requests Received&lt;/h3&gt;&#10;            {incomingRequests.length === 0 ? (&#10;              &lt;p className=&quot;text-gray-500&quot;&gt;No pending friend requests&lt;/p&gt;&#10;            ) : (&#10;              &lt;div className=&quot;space-y-3&quot;&gt;&#10;                {incomingRequests.map((user) =&gt; (&#10;                  &lt;div key={user.id} className=&quot;flex items-center justify-between p-4 bg-white rounded-lg border&quot;&gt;&#10;                    &lt;div className=&quot;flex items-center space-x-3&quot;&gt;&#10;                      &lt;div className=&quot;w-12 h-12 rounded-full bg-gray-200 flex items-center justify-center overflow-hidden&quot;&gt;&#10;                        {user.avatarUrl ? (&#10;                          &lt;img src={user.avatarUrl} alt={user.fullName} className=&quot;w-full h-full object-cover&quot; /&gt;&#10;                        ) : (&#10;                          &lt;span className=&quot;text-gray-500&quot;&gt;{user.fullName?.charAt(0).toUpperCase()}&lt;/span&gt;&#10;                        )}&#10;                      &lt;/div&gt;&#10;                      &lt;div&gt;&#10;                        &lt;h4 className=&quot;font-semibold&quot;&gt;{user.fullName}&lt;/h4&gt;&#10;                        &lt;p className=&quot;text-sm text-gray-500&quot;&gt;@{user.username}&lt;/p&gt;&#10;                      &lt;/div&gt;&#10;                    &lt;/div&gt;&#10;                    &lt;div className=&quot;flex space-x-2&quot;&gt;&#10;                      &lt;button&#10;                        onClick={() =&gt; handleAcceptRequest(user.id)}&#10;                        className=&quot;px-4 py-2 bg-green-500 text-white rounded hover:bg-green-600 transition-colors&quot;&#10;                      &gt;&#10;                        Accept&#10;                      &lt;/button&gt;&#10;                      &lt;button&#10;                        onClick={() =&gt; handleRejectRequest(user.id)}&#10;                        className=&quot;px-4 py-2 bg-gray-500 text-white rounded hover:bg-gray-600 transition-colors&quot;&#10;                      &gt;&#10;                        Reject&#10;                      &lt;/button&gt;&#10;                    &lt;/div&gt;&#10;                  &lt;/div&gt;&#10;                ))}&#10;              &lt;/div&gt;&#10;            )}&#10;          &lt;/div&gt;&#10;        )}&#10;&#10;        {activeTab === 'outgoing' &amp;&amp; (&#10;          &lt;div className=&quot;space-y-4&quot;&gt;&#10;            &lt;h3 className=&quot;text-lg font-semibold&quot;&gt;Friend Requests Sent&lt;/h3&gt;&#10;            {outgoingRequests.length === 0 ? (&#10;              &lt;p className=&quot;text-gray-500&quot;&gt;No pending sent requests&lt;/p&gt;&#10;            ) : (&#10;              &lt;div className=&quot;space-y-3&quot;&gt;&#10;                {outgoingRequests.map((user) =&gt; (&#10;                  &lt;div key={user.id} className=&quot;flex items-center justify-between p-4 bg-white rounded-lg border&quot;&gt;&#10;                    &lt;div className=&quot;flex items-center space-x-3&quot;&gt;&#10;                      &lt;div className=&quot;w-12 h-12 rounded-full bg-gray-200 flex items-center justify-center overflow-hidden&quot;&gt;&#10;                        {user.avatarUrl ? (&#10;                          &lt;img src={user.avatarUrl} alt={user.fullName} className=&quot;w-full h-full object-cover&quot; /&gt;&#10;                        ) : (&#10;                          &lt;span className=&quot;text-gray-500&quot;&gt;{user.fullName?.charAt(0).toUpperCase()}&lt;/span&gt;&#10;                        )}&#10;                      &lt;/div&gt;&#10;                      &lt;div&gt;&#10;                        &lt;h4 className=&quot;font-semibold&quot;&gt;{user.fullName}&lt;/h4&gt;&#10;                        &lt;p className=&quot;text-sm text-gray-500&quot;&gt;@{user.username}&lt;/p&gt;&#10;                      &lt;/div&gt;&#10;                    &lt;/div&gt;&#10;                    &lt;button&#10;                      onClick={() =&gt; handleCancelRequest(user.id)}&#10;                      className=&quot;px-4 py-2 bg-red-500 text-white rounded hover:bg-red-600 transition-colors&quot;&#10;                    &gt;&#10;                      Cancel&#10;                    &lt;/button&gt;&#10;                  &lt;/div&gt;&#10;                ))}&#10;              &lt;/div&gt;&#10;            )}&#10;          &lt;/div&gt;&#10;        )}&#10;      &lt;/div&gt;&#10;    &lt;/div&gt;&#10;  );&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/client-frontend/src/features/users/components/friends/FriendSuggestions.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/client-frontend/src/features/users/components/friends/FriendSuggestions.tsx" />
              <option name="originalContent" value="'use client';&#10;&#10;import React, { useEffect, useState } from 'react';&#10;import { FriendSuggestionDTO, FriendsDTO } from '@/shared/types';&#10;import { userService } from '@/services/userService';&#10;import { toast } from 'react-hot-toast';&#10;import LoadingSpinner from '@/components/ui/LoadingSpinner';&#10;&#10;&#10;export const FriendSuggestions: React.FC = () =&gt; {&#10;  const [suggestions, setSuggestions] = useState&lt;FriendSuggestionDTO[]&gt;([]);&#10;  const [loading, setLoading] = useState(true);&#10;  const [sendingRequests, setSendingRequests] = useState&lt;Set&lt;string&gt;&gt;(new Set());&#10;&#10;  useEffect(() =&gt; {&#10;    loadSuggestions();&#10;  }, []);&#10;&#10;  const loadSuggestions = async () =&gt; {&#10;    try {&#10;      setLoading(true);&#10;      const suggestionsData: FriendsDTO = await userService.getFriendSuggestions();&#10;      // Transform FriendsDTO to FriendSuggestionDTO format&#10;      const transformedSuggestions = suggestionsData.friendSuggestions?.map(user =&gt; ({&#10;        userId: user.id,&#10;        username: user.username,&#10;        fullName: user.fullName,&#10;        avatarUrl: user.avatar,&#10;        mutualFriendsCount: 0, // This would be populated by the backend&#10;        suggestionReason: 'Suggested for you',&#10;        relevanceScore: 1.0,&#10;        suggestionType: 'MUTUAL_FRIENDS' as const&#10;      })) || [];&#10;      setSuggestions(transformedSuggestions);&#10;    } catch (err) {&#10;      toast.error('Failed to load friend suggestions');&#10;      console.error('Error loading friend suggestions:', err);&#10;    } finally {&#10;      setLoading(false);&#10;    }&#10;  };&#10;&#10;  const handleSendRequest = async (userId: string) =&gt; {&#10;    try {&#10;      setSendingRequests(prev =&gt; new Set([...prev, userId]));&#10;      await userService.sendFriendRequest(userId);&#10;      setSuggestions(prev =&gt; prev.filter(suggestion =&gt; suggestion.userId !== userId));&#10;      toast.success('Friend request sent');&#10;    } catch (err) {&#10;      toast.error('Failed to send friend request');&#10;      console.error('Error sending friend request:', err);&#10;    } finally {&#10;      setSendingRequests(prev =&gt; {&#10;        const newSet = new Set(prev);&#10;        newSet.delete(userId);&#10;        return newSet;&#10;      });&#10;    }&#10;  };&#10;&#10;  const getSuggestionIcon = (type: FriendSuggestionDTO['suggestionType']) =&gt; {&#10;    switch (type) {&#10;      case 'MUTUAL_FRIENDS':&#10;        return '';&#10;      case 'ACADEMIC_CONNECTION':&#10;        return '';&#10;      case 'FRIENDS_OF_FRIENDS':&#10;        return '';&#10;      case 'PROFILE_VIEWERS':&#10;        return '️';&#10;      case 'SIMILAR_INTERESTS':&#10;        return '❤️';&#10;      default:&#10;        return '';&#10;    }&#10;  };&#10;&#10;  if (loading) {&#10;    return (&#10;      &lt;div className=&quot;flex justify-center items-center py-8&quot;&gt;&#10;        &lt;LoadingSpinner/&gt;&#10;      &lt;/div&gt;&#10;    );&#10;  }&#10;&#10;  if (suggestions.length === 0) {&#10;    return (&#10;      &lt;div className=&quot;text-center py-8&quot;&gt;&#10;        &lt;p className=&quot;text-gray-500&quot;&gt;No friend suggestions available&lt;/p&gt;&#10;        &lt;button&#10;          onClick={loadSuggestions}&#10;          className=&quot;mt-2 px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600&quot;&#10;        &gt;&#10;          Refresh Suggestions&#10;        &lt;/button&gt;&#10;      &lt;/div&gt;&#10;    );&#10;  }&#10;&#10;  return (&#10;    &lt;div className=&quot;space-y-4&quot;&gt;&#10;      &lt;div className=&quot;flex items-center justify-between&quot;&gt;&#10;        &lt;h3 className=&quot;text-lg font-semibold&quot;&gt;People You May Know&lt;/h3&gt;&#10;        &lt;button&#10;          onClick={loadSuggestions}&#10;          className=&quot;text-blue-500 hover:text-blue-600 text-sm&quot;&#10;        &gt;&#10;          Refresh&#10;        &lt;/button&gt;&#10;      &lt;/div&gt;&#10;&#10;      &lt;div className=&quot;grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4&quot;&gt;&#10;        {suggestions.map((suggestion) =&gt; (&#10;          &lt;div key={suggestion.userId} className=&quot;bg-white rounded-lg border p-4 shadow-sm&quot;&gt;&#10;            &lt;div className=&quot;flex flex-col items-center space-y-3&quot;&gt;&#10;              {/* Avatar */}&#10;              &lt;div className=&quot;w-16 h-16 rounded-full bg-gray-200 flex items-center justify-center overflow-hidden&quot;&gt;&#10;                {suggestion.avatarUrl ? (&#10;                  &lt;img&#10;                    src={suggestion.avatarUrl}&#10;                    alt={suggestion.fullName}&#10;                    className=&quot;w-full h-full object-cover&quot;&#10;                  /&gt;&#10;                ) : (&#10;                  &lt;span className=&quot;text-gray-500 text-xl&quot;&gt;&#10;                    {suggestion.fullName.charAt(0).toUpperCase()}&#10;                  &lt;/span&gt;&#10;                )}&#10;              &lt;/div&gt;&#10;&#10;              {/* User Info */}&#10;              &lt;div className=&quot;text-center&quot;&gt;&#10;                &lt;h4 className=&quot;font-semibold text-gray-900&quot;&gt;{suggestion.fullName}&lt;/h4&gt;&#10;                &lt;p className=&quot;text-sm text-gray-500&quot;&gt;@{suggestion.username}&lt;/p&gt;&#10;              &lt;/div&gt;&#10;&#10;              {/* Suggestion Reason */}&#10;              &lt;div className=&quot;flex items-center space-x-1 text-xs text-gray-600 bg-gray-50 px-2 py-1 rounded&quot;&gt;&#10;                &lt;span&gt;{getSuggestionIcon(suggestion.suggestionType)}&lt;/span&gt;&#10;                &lt;span&gt;{suggestion.suggestionReason}&lt;/span&gt;&#10;              &lt;/div&gt;&#10;&#10;              {/* Mutual Friends Count */}&#10;              {suggestion.mutualFriendsCount &gt; 0 &amp;&amp; (&#10;                &lt;p className=&quot;text-xs text-blue-600&quot;&gt;&#10;                  {suggestion.mutualFriendsCount} mutual friends&#10;                &lt;/p&gt;&#10;              )}&#10;&#10;              {/* Action Buttons */}&#10;              &lt;div className=&quot;flex space-x-2 w-full&quot;&gt;&#10;                &lt;button&#10;                  onClick={() =&gt; handleSendRequest(suggestion.userId)}&#10;                  disabled={sendingRequests.has(suggestion.userId)}&#10;                  className=&quot;flex-1 px-3 py-2 bg-blue-500 text-white rounded text-sm hover:bg-blue-600 disabled:opacity-50 disabled:cursor-not-allowed&quot;&#10;                &gt;&#10;                  {sendingRequests.has(suggestion.userId) ? 'Sending...' : 'Add Friend'}&#10;                &lt;/button&gt;&#10;                &lt;button&#10;                  onClick={() =&gt; setSuggestions(prev =&gt; prev.filter(s =&gt; s.userId !== suggestion.userId))}&#10;                  className=&quot;px-3 py-2 bg-gray-200 text-gray-700 rounded text-sm hover:bg-gray-300&quot;&#10;                &gt;&#10;                  ✕&#10;                &lt;/button&gt;&#10;              &lt;/div&gt;&#10;            &lt;/div&gt;&#10;          &lt;/div&gt;&#10;        ))}&#10;      &lt;/div&gt;&#10;    &lt;/div&gt;&#10;  );&#10;};&#10;" />
              <option name="updatedContent" value="'use client';&#10;&#10;import React, { useEffect, useState } from 'react';&#10;import { User, PaginatedResponse } from '@/types';&#10;import { userService } from '@/services/userService';&#10;import { toast } from 'react-hot-toast';&#10;import LoadingSpinner from '@/components/ui/LoadingSpinner';&#10;&#10;export const FriendSuggestions: React.FC = () =&gt; {&#10;  const [suggestions, setSuggestions] = useState&lt;User[]&gt;([]);&#10;  const [loading, setLoading] = useState(true);&#10;  const [sendingRequests, setSendingRequests] = useState&lt;Set&lt;string&gt;&gt;(new Set());&#10;&#10;  useEffect(() =&gt; {&#10;    loadSuggestions();&#10;  }, []);&#10;&#10;  const loadSuggestions = async () =&gt; {&#10;    try {&#10;      setLoading(true);&#10;      // Sử dụng PaginatedResponse&lt;User&gt; thay vì FriendsDTO&#10;      const suggestionsData: PaginatedResponse&lt;User&gt; = await userService.getFriendSuggestions();&#10;      setSuggestions(suggestionsData.content || []);&#10;    } catch (err) {&#10;      toast.error('Failed to load friend suggestions');&#10;      console.error('Error loading friend suggestions:', err);&#10;    } finally {&#10;      setLoading(false);&#10;    }&#10;  };&#10;&#10;  const handleSendRequest = async (userId: string) =&gt; {&#10;    try {&#10;      setSendingRequests(prev =&gt; new Set([...prev, userId]));&#10;      await userService.sendFriendRequest(userId);&#10;      setSuggestions(prev =&gt; prev.filter(suggestion =&gt; suggestion.id !== userId));&#10;      toast.success('Friend request sent');&#10;    } catch (err) {&#10;      toast.error('Failed to send friend request');&#10;      console.error('Error sending friend request:', err);&#10;    } finally {&#10;      setSendingRequests(prev =&gt; {&#10;        const newSet = new Set(prev);&#10;        newSet.delete(userId);&#10;        return newSet;&#10;      });&#10;    }&#10;  };&#10;&#10;  if (loading) {&#10;    return (&#10;      &lt;div className=&quot;flex justify-center items-center py-8&quot;&gt;&#10;        &lt;LoadingSpinner /&gt;&#10;      &lt;/div&gt;&#10;    );&#10;  }&#10;&#10;  if (suggestions.length === 0) {&#10;    return (&#10;      &lt;div className=&quot;text-center py-8&quot;&gt;&#10;        &lt;p className=&quot;text-gray-500&quot;&gt;No friend suggestions available&lt;/p&gt;&#10;        &lt;button&#10;          onClick={loadSuggestions}&#10;          className=&quot;mt-2 px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600&quot;&#10;        &gt;&#10;          Refresh Suggestions&#10;        &lt;/button&gt;&#10;      &lt;/div&gt;&#10;    );&#10;  }&#10;&#10;  return (&#10;    &lt;div className=&quot;space-y-4&quot;&gt;&#10;      &lt;div className=&quot;flex items-center justify-between&quot;&gt;&#10;        &lt;h3 className=&quot;text-lg font-semibold&quot;&gt;People You May Know&lt;/h3&gt;&#10;        &lt;button&#10;          onClick={loadSuggestions}&#10;          className=&quot;text-blue-500 hover:text-blue-600 text-sm&quot;&#10;        &gt;&#10;          Refresh&#10;        &lt;/button&gt;&#10;      &lt;/div&gt;&#10;&#10;      &lt;div className=&quot;grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4&quot;&gt;&#10;        {suggestions.map((user) =&gt; (&#10;          &lt;div key={user.id} className=&quot;bg-white rounded-lg border p-4 shadow-sm&quot;&gt;&#10;            &lt;div className=&quot;flex flex-col items-center space-y-3&quot;&gt;&#10;              {/* Avatar */}&#10;              &lt;div className=&quot;w-16 h-16 rounded-full bg-gray-200 flex items-center justify-center overflow-hidden&quot;&gt;&#10;                {user.avatarUrl ? (&#10;                  &lt;img&#10;                    src={user.avatarUrl}&#10;                    alt={user.fullName}&#10;                    className=&quot;w-full h-full object-cover&quot;&#10;                  /&gt;&#10;                ) : (&#10;                  &lt;span className=&quot;text-gray-500 text-xl&quot;&gt;&#10;                    {user.fullName?.charAt(0).toUpperCase() || 'U'}&#10;                  &lt;/span&gt;&#10;                )}&#10;              &lt;/div&gt;&#10;&#10;              {/* User Info */}&#10;              &lt;div className=&quot;text-center&quot;&gt;&#10;                &lt;h4 className=&quot;font-semibold text-gray-900&quot;&gt;{user.fullName}&lt;/h4&gt;&#10;                &lt;p className=&quot;text-sm text-gray-500&quot;&gt;@{user.username}&lt;/p&gt;&#10;                {user.faculty &amp;&amp; (&#10;                  &lt;p className=&quot;text-xs text-gray-400&quot;&gt;{user.faculty}&lt;/p&gt;&#10;                )}&#10;              &lt;/div&gt;&#10;&#10;              {/* Simple suggestion reason */}&#10;              &lt;div className=&quot;text-xs text-gray-600 bg-gray-50 px-2 py-1 rounded&quot;&gt;&#10;                 Suggested for you&#10;              &lt;/div&gt;&#10;&#10;              {/* Action Buttons */}&#10;              &lt;div className=&quot;flex space-x-2 w-full&quot;&gt;&#10;                &lt;button&#10;                  onClick={() =&gt; handleSendRequest(user.id)}&#10;                  disabled={sendingRequests.has(user.id)}&#10;                  className=&quot;flex-1 px-3 py-2 bg-blue-500 text-white rounded text-sm hover:bg-blue-600 disabled:opacity-50 disabled:cursor-not-allowed&quot;&#10;                &gt;&#10;                  {sendingRequests.has(user.id) ? 'Sending...' : 'Add Friend'}&#10;                &lt;/button&gt;&#10;                &lt;button&#10;                  onClick={() =&gt; setSuggestions(prev =&gt; prev.filter(s =&gt; s.id !== user.id))}&#10;                  className=&quot;px-3 py-2 bg-gray-200 text-gray-700 rounded text-sm hover:bg-gray-300&quot;&#10;                &gt;&#10;                  ✕&#10;                &lt;/button&gt;&#10;              &lt;/div&gt;&#10;            &lt;/div&gt;&#10;          &lt;/div&gt;&#10;        ))}&#10;      &lt;/div&gt;&#10;    &lt;/div&gt;&#10;  );&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/client-frontend/src/features/users/components/friends/FriendsDashboard.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/client-frontend/src/features/users/components/friends/FriendsDashboard.tsx" />
              <option name="updatedContent" value="'use client';&#10;&#10;import React, { useState } from 'react';&#10;import { FriendsList } from './FriendsList';&#10;import { FriendRequests } from './FriendRequests';&#10;import { FriendSuggestions } from './FriendSuggestions';&#10;&#10;type FriendsTab = 'friends' | 'requests' | 'suggestions';&#10;&#10;export const FriendsDashboard: React.FC = () =&gt; {&#10;  const [activeTab, setActiveTab] = useState&lt;FriendsTab&gt;('friends');&#10;&#10;  const tabs = [&#10;    { id: 'friends' as const, label: 'My Friends', icon: '' },&#10;    { id: 'requests' as const, label: 'Friend Requests', icon: '' },&#10;    { id: 'suggestions' as const, label: 'Suggestions', icon: '' }&#10;  ];&#10;&#10;  return (&#10;    &lt;div className=&quot;max-w-6xl mx-auto p-6&quot;&gt;&#10;      {/* Header */}&#10;      &lt;div className=&quot;mb-6&quot;&gt;&#10;        &lt;h1 className=&quot;text-2xl font-bold text-gray-900 mb-2&quot;&gt;Friends&lt;/h1&gt;&#10;        &lt;p className=&quot;text-gray-600&quot;&gt;Manage your friends and discover new connections&lt;/p&gt;&#10;      &lt;/div&gt;&#10;&#10;      {/* Tab Navigation */}&#10;      &lt;div className=&quot;flex space-x-1 bg-gray-100 p-1 rounded-lg mb-6&quot;&gt;&#10;        {tabs.map((tab) =&gt; (&#10;          &lt;button&#10;            key={tab.id}&#10;            onClick={() =&gt; setActiveTab(tab.id)}&#10;            className={`flex-1 flex items-center justify-center space-x-2 py-3 px-4 rounded-md text-sm font-medium transition-colors ${&#10;              activeTab === tab.id&#10;                ? 'bg-white text-blue-600 shadow-sm'&#10;                : 'text-gray-500 hover:text-gray-700 hover:bg-gray-50'&#10;            }`}&#10;          &gt;&#10;            &lt;span&gt;{tab.icon}&lt;/span&gt;&#10;            &lt;span&gt;{tab.label}&lt;/span&gt;&#10;          &lt;/button&gt;&#10;        ))}&#10;      &lt;/div&gt;&#10;&#10;      {/* Tab Content */}&#10;      &lt;div className=&quot;bg-white rounded-lg border shadow-sm p-6&quot;&gt;&#10;        {activeTab === 'friends' &amp;&amp; &lt;FriendsList /&gt;}&#10;        {activeTab === 'requests' &amp;&amp; &lt;FriendRequests /&gt;}&#10;        {activeTab === 'suggestions' &amp;&amp; &lt;FriendSuggestions /&gt;}&#10;      &lt;/div&gt;&#10;    &lt;/div&gt;&#10;  );&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/client-frontend/src/features/users/components/friends/FriendsList.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/client-frontend/src/features/users/components/friends/FriendsList.tsx" />
              <option name="originalContent" value="'use client';&#10;&#10;import React, { useEffect, useState } from 'react';&#10;import { User, FriendsDTO } from '@/shared/types';&#10;import { toast } from 'react-hot-toast';&#10;import { UserCard } from '../UserCard';&#10;import { userService } from '../../services';&#10;import { LoadingSpinner } from '@/shared/components';&#10;&#10;interface FriendsListProps {&#10;  userId?: string;&#10;  showActions?: boolean;&#10;}&#10;&#10;export const FriendsList: React.FC&lt;FriendsListProps&gt; = ({&#10;  userId,&#10;  showActions = true&#10;}) =&gt; {&#10;  const [friends, setFriends] = useState&lt;User[]&gt;([]);&#10;  const [loading, setLoading] = useState(true);&#10;  const [error, setError] = useState&lt;string | null&gt;(null);&#10;&#10;  useEffect(() =&gt; {&#10;    loadFriends();&#10;  }, [userId]);&#10;&#10;  const loadFriends = async () =&gt; {&#10;    try {&#10;      setLoading(true);&#10;      setError(null);&#10;      const friendsData: FriendsDTO = await userService.getFriends(userId);&#10;      setFriends(friendsData.friends || []);&#10;    } catch (err) {&#10;      setError('Failed to load friends');&#10;      toast.error('Failed to load friends');&#10;      console.error('Error loading friends:', err);&#10;    } finally {&#10;      setLoading(false);&#10;    }&#10;  };&#10;&#10;  const handleRemoveFriend = async (friendId: string) =&gt; {&#10;    try {&#10;      await userService.removeFriend(friendId);&#10;      setFriends(prev =&gt; prev.filter(friend =&gt; friend.id !== friendId));&#10;      toast.success('Friend removed successfully');&#10;    } catch (err) {&#10;      toast.error('Failed to remove friend');&#10;      console.error('Error removing friend:', err);&#10;    }&#10;  };&#10;&#10;  if (loading) {&#10;    return (&#10;      &lt;div className=&quot;flex justify-center items-center py-8&quot;&gt;&#10;        &lt;LoadingSpinner /&gt;&#10;      &lt;/div&gt;&#10;    );&#10;  }&#10;&#10;  if (error) {&#10;    return (&#10;      &lt;div className=&quot;text-center py-8&quot;&gt;&#10;        &lt;p className=&quot;text-red-500&quot;&gt;{error}&lt;/p&gt;&#10;        &lt;button&#10;          onClick={loadFriends}&#10;          className=&quot;mt-2 px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600&quot;&#10;        &gt;&#10;          Try Again&#10;        &lt;/button&gt;&#10;      &lt;/div&gt;&#10;    );&#10;  }&#10;&#10;  if (friends.length === 0) {&#10;    return (&#10;      &lt;div className=&quot;text-center py-8&quot;&gt;&#10;        &lt;p className=&quot;text-gray-500&quot;&gt;No friends yet&lt;/p&gt;&#10;      &lt;/div&gt;&#10;    );&#10;  }&#10;&#10;  return (&#10;    &lt;div className=&quot;space-y-4&quot;&gt;&#10;      &lt;h3 className=&quot;text-lg font-semibold&quot;&gt;&#10;        Friends ({friends.length})&#10;      &lt;/h3&gt;&#10;      &lt;div className=&quot;grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4&quot;&gt;&#10;        {friends.map((friend) =&gt; (&#10;          &lt;UserCard&#10;            key={friend.id}&#10;            user={friend}&#10;            showActions={showActions}&#10;            onRemoveFriend={showActions ? () =&gt; handleRemoveFriend(friend.id) : undefined}&#10;          /&gt;&#10;        ))}&#10;      &lt;/div&gt;&#10;    &lt;/div&gt;&#10;  );&#10;};&#10;" />
              <option name="updatedContent" value="'use client';&#10;&#10;import React, { useEffect, useState } from 'react';&#10;import { User, PaginatedResponse } from '@/types';&#10;import { userService } from '@/services/userService';&#10;import { toast } from 'react-hot-toast';&#10;import LoadingSpinner from '@/components/ui/LoadingSpinner';&#10;&#10;interface FriendsListProps {&#10;  userId?: string;&#10;  showActions?: boolean;&#10;}&#10;&#10;export const FriendsList: React.FC&lt;FriendsListProps&gt; = ({&#10;  userId,&#10;  showActions = true&#10;}) =&gt; {&#10;  const [friends, setFriends] = useState&lt;User[]&gt;([]);&#10;  const [loading, setLoading] = useState(true);&#10;  const [error, setError] = useState&lt;string | null&gt;(null);&#10;  const [pagination, setPagination] = useState({&#10;    page: 0,&#10;    totalPages: 0,&#10;    totalElements: 0&#10;  });&#10;&#10;  useEffect(() =&gt; {&#10;    loadFriends();&#10;  }, [userId]);&#10;&#10;  const loadFriends = async () =&gt; {&#10;    try {&#10;      setLoading(true);&#10;      setError(null);&#10;      &#10;      // Sử dụng service có sẵn - trả về PaginatedResponse&lt;User&gt;&#10;      const response: PaginatedResponse&lt;User&gt; = userId &#10;        ? await userService.getFriends(userId, 0, 20)&#10;        : await userService.getMyFriends();&#10;        &#10;      setFriends(response.content);&#10;      setPagination({&#10;        page: response.number,&#10;        totalPages: response.totalPages,&#10;        totalElements: response.totalElements&#10;      });&#10;    } catch (err) {&#10;      setError('Failed to load friends');&#10;      toast.error('Failed to load friends');&#10;      console.error('Error loading friends:', err);&#10;    } finally {&#10;      setLoading(false);&#10;    }&#10;  };&#10;&#10;  const handleRemoveFriend = async (friendId: string) =&gt; {&#10;    try {&#10;      await userService.removeFriend(friendId);&#10;      setFriends(prev =&gt; prev.filter(friend =&gt; friend.id !== friendId));&#10;      toast.success('Friend removed successfully');&#10;    } catch (err) {&#10;      toast.error('Failed to remove friend');&#10;      console.error('Error removing friend:', err);&#10;    }&#10;  };&#10;&#10;  if (loading) {&#10;    return (&#10;      &lt;div className=&quot;flex justify-center items-center py-8&quot;&gt;&#10;        &lt;LoadingSpinner /&gt;&#10;      &lt;/div&gt;&#10;    );&#10;  }&#10;&#10;  if (error) {&#10;    return (&#10;      &lt;div className=&quot;text-center py-8&quot;&gt;&#10;        &lt;p className=&quot;text-red-500&quot;&gt;{error}&lt;/p&gt;&#10;        &lt;button&#10;          onClick={loadFriends}&#10;          className=&quot;mt-2 px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600&quot;&#10;        &gt;&#10;          Try Again&#10;        &lt;/button&gt;&#10;      &lt;/div&gt;&#10;    );&#10;  }&#10;&#10;  if (friends.length === 0) {&#10;    return (&#10;      &lt;div className=&quot;text-center py-8&quot;&gt;&#10;        &lt;p className=&quot;text-gray-500&quot;&gt;No friends yet&lt;/p&gt;&#10;      &lt;/div&gt;&#10;    );&#10;  }&#10;&#10;  return (&#10;    &lt;div className=&quot;space-y-4&quot;&gt;&#10;      &lt;h3 className=&quot;text-lg font-semibold&quot;&gt;&#10;        Friends ({pagination.totalElements})&#10;      &lt;/h3&gt;&#10;      &lt;div className=&quot;grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4&quot;&gt;&#10;        {friends.map((friend) =&gt; (&#10;          &lt;div key={friend.id} className=&quot;bg-white rounded-lg border p-4 shadow-sm&quot;&gt;&#10;            &lt;div className=&quot;flex flex-col items-center space-y-3&quot;&gt;&#10;              &lt;div className=&quot;w-16 h-16 rounded-full bg-gray-200 flex items-center justify-center overflow-hidden&quot;&gt;&#10;                {friend.avatarUrl ? (&#10;                  &lt;img &#10;                    src={friend.avatarUrl} &#10;                    alt={friend.fullName}&#10;                    className=&quot;w-full h-full object-cover&quot;&#10;                  /&gt;&#10;                ) : (&#10;                  &lt;span className=&quot;text-gray-500 text-xl&quot;&gt;&#10;                    {friend.fullName?.charAt(0).toUpperCase() || 'U'}&#10;                  &lt;/span&gt;&#10;                )}&#10;              &lt;/div&gt;&#10;              &#10;              &lt;div className=&quot;text-center&quot;&gt;&#10;                &lt;h4 className=&quot;font-semibold text-gray-900&quot;&gt;{friend.fullName}&lt;/h4&gt;&#10;                &lt;p className=&quot;text-sm text-gray-500&quot;&gt;@{friend.username}&lt;/p&gt;&#10;              &lt;/div&gt;&#10;&#10;              {showActions &amp;&amp; (&#10;                &lt;button&#10;                  onClick={() =&gt; handleRemoveFriend(friend.id)}&#10;                  className=&quot;px-3 py-1 bg-red-500 text-white rounded text-sm hover:bg-red-600&quot;&#10;                &gt;&#10;                  Unfriend&#10;                &lt;/button&gt;&#10;              )}&#10;            &lt;/div&gt;&#10;          &lt;/div&gt;&#10;        ))}&#10;      &lt;/div&gt;&#10;    &lt;/div&gt;&#10;  );&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/client-frontend/src/features/users/components/friends/MutualFriends.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/client-frontend/src/features/users/components/friends/MutualFriends.tsx" />
              <option name="originalContent" value="'use client';&#10;&#10;import React, { useEffect, useState } from 'react';&#10;import { User, FriendsDTO } from '@/shared/types';&#10;&#10;import LoadingSpinner from &quot;@/components/ui/LoadingSpinner&quot;;&#10;&#10;interface MutualFriendsProps {&#10;  otherUserId: string;&#10;  otherUserName: string;&#10;}&#10;&#10;export const MutualFriends: React.FC&lt;MutualFriendsProps&gt; = ({&#10;  otherUserId,&#10;  otherUserName&#10;}) =&gt; {&#10;  const [mutualFriends, setMutualFriends] = useState&lt;User[]&gt;([]);&#10;  const [loading, setLoading] = useState(true);&#10;  const [error, setError] = useState&lt;string | null&gt;(null);&#10;&#10;  useEffect(() =&gt; {&#10;    loadMutualFriends();&#10;  }, [otherUserId]);&#10;&#10;  const loadMutualFriends = async () =&gt; {&#10;    try {&#10;      setLoading(true);&#10;      setError(null);&#10;      const mutualData: FriendsDTO = await userService.getMutualFriends(otherUserId);&#10;      setMutualFriends(mutualData.mutualFriends || []);&#10;    } catch (err) {&#10;      setError('Failed to load mutual friends');&#10;      console.error('Error loading mutual friends:', err);&#10;    } finally {&#10;      setLoading(false);&#10;    }&#10;  };&#10;&#10;  if (loading) {&#10;    return (&#10;      &lt;div className=&quot;flex justify-center items-center py-4&quot;&gt;&#10;        &lt;LoadingSpinner size=&quot;sm&quot; /&gt;&#10;      &lt;/div&gt;&#10;    );&#10;  }&#10;&#10;  if (error) {&#10;    return (&#10;      &lt;div className=&quot;text-center py-4&quot;&gt;&#10;        &lt;p className=&quot;text-red-500 text-sm&quot;&gt;{error}&lt;/p&gt;&#10;      &lt;/div&gt;&#10;    );&#10;  }&#10;&#10;  if (mutualFriends.length === 0) {&#10;    return (&#10;      &lt;div className=&quot;text-center py-4&quot;&gt;&#10;        &lt;p className=&quot;text-gray-500 text-sm&quot;&gt;&#10;          No mutual friends with {otherUserName}&#10;        &lt;/p&gt;&#10;      &lt;/div&gt;&#10;    );&#10;  }&#10;&#10;  return (&#10;    &lt;div className=&quot;space-y-3&quot;&gt;&#10;      &lt;h4 className=&quot;text-sm font-semibold text-gray-700&quot;&gt;&#10;        Mutual Friends ({mutualFriends.length})&#10;      &lt;/h4&gt;&#10;&#10;      {/* Compact list view for mutual friends */}&#10;      &lt;div className=&quot;space-y-2&quot;&gt;&#10;        {mutualFriends.slice(0, 5).map((friend) =&gt; (&#10;          &lt;div key={friend.id} className=&quot;flex items-center space-x-2 p-2 bg-gray-50 rounded&quot;&gt;&#10;            &lt;div className=&quot;w-8 h-8 rounded-full bg-gray-200 flex items-center justify-center overflow-hidden flex-shrink-0&quot;&gt;&#10;              {friend.avatar ? (&#10;                &lt;img&#10;                  src={friend.avatar}&#10;                  alt={friend.fullName}&#10;                  className=&quot;w-full h-full object-cover&quot;&#10;                /&gt;&#10;              ) : (&#10;                &lt;span className=&quot;text-gray-500 text-xs&quot;&gt;&#10;                  {friend.fullName.charAt(0).toUpperCase()}&#10;                &lt;/span&gt;&#10;              )}&#10;            &lt;/div&gt;&#10;            &lt;div className=&quot;flex-1 min-w-0&quot;&gt;&#10;              &lt;p className=&quot;text-sm font-medium text-gray-900 truncate&quot;&gt;&#10;                {friend.fullName}&#10;              &lt;/p&gt;&#10;              &lt;p className=&quot;text-xs text-gray-500 truncate&quot;&gt;&#10;                @{friend.username}&#10;              &lt;/p&gt;&#10;            &lt;/div&gt;&#10;          &lt;/div&gt;&#10;        ))}&#10;&#10;        {mutualFriends.length &gt; 5 &amp;&amp; (&#10;          &lt;div className=&quot;text-center&quot;&gt;&#10;            &lt;button className=&quot;text-blue-500 text-sm hover:text-blue-600&quot;&gt;&#10;              View all {mutualFriends.length} mutual friends&#10;            &lt;/button&gt;&#10;          &lt;/div&gt;&#10;        )}&#10;      &lt;/div&gt;&#10;    &lt;/div&gt;&#10;  );&#10;};&#10;" />
              <option name="updatedContent" value="'use client';&#10;&#10;import React, { useEffect, useState } from 'react';&#10;import { User, PaginatedResponse } from '@/types';&#10;import { userService } from '@/services/userService';&#10;import LoadingSpinner from '@/components/ui/LoadingSpinner';&#10;&#10;interface MutualFriendsProps {&#10;  otherUserId: string;&#10;  otherUserName: string;&#10;}&#10;&#10;export const MutualFriends: React.FC&lt;MutualFriendsProps&gt; = ({ &#10;  otherUserId, &#10;  otherUserName &#10;}) =&gt; {&#10;  const [mutualFriends, setMutualFriends] = useState&lt;User[]&gt;([]);&#10;  const [loading, setLoading] = useState(true);&#10;  const [error, setError] = useState&lt;string | null&gt;(null);&#10;&#10;  useEffect(() =&gt; {&#10;    loadMutualFriends();&#10;  }, [otherUserId]);&#10;&#10;  const loadMutualFriends = async () =&gt; {&#10;    try {&#10;      setLoading(true);&#10;      setError(null);&#10;      // Sử dụng PaginatedResponse&lt;User&gt; thay vì FriendsDTO&#10;      const mutualData: PaginatedResponse&lt;User&gt; = await userService.getMutualFriends(otherUserId);&#10;      setMutualFriends(mutualData.content || []);&#10;    } catch (err) {&#10;      setError('Failed to load mutual friends');&#10;      console.error('Error loading mutual friends:', err);&#10;    } finally {&#10;      setLoading(false);&#10;    }&#10;  };&#10;&#10;  if (loading) {&#10;    return (&#10;      &lt;div className=&quot;flex justify-center items-center py-4&quot;&gt;&#10;        &lt;LoadingSpinner /&gt;&#10;      &lt;/div&gt;&#10;    );&#10;  }&#10;&#10;  if (error) {&#10;    return (&#10;      &lt;div className=&quot;text-center py-4&quot;&gt;&#10;        &lt;p className=&quot;text-red-500 text-sm&quot;&gt;{error}&lt;/p&gt;&#10;      &lt;/div&gt;&#10;    );&#10;  }&#10;&#10;  if (mutualFriends.length === 0) {&#10;    return (&#10;      &lt;div className=&quot;text-center py-4&quot;&gt;&#10;        &lt;p className=&quot;text-gray-500 text-sm&quot;&gt;&#10;          No mutual friends with {otherUserName}&#10;        &lt;/p&gt;&#10;      &lt;/div&gt;&#10;    );&#10;  }&#10;&#10;  return (&#10;    &lt;div className=&quot;space-y-3&quot;&gt;&#10;      &lt;h4 className=&quot;text-sm font-semibold text-gray-700&quot;&gt;&#10;        Mutual Friends ({mutualFriends.length})&#10;      &lt;/h4&gt;&#10;      &#10;      {/* Compact list view for mutual friends */}&#10;      &lt;div className=&quot;space-y-2&quot;&gt;&#10;        {mutualFriends.slice(0, 5).map((friend) =&gt; (&#10;          &lt;div key={friend.id} className=&quot;flex items-center space-x-2 p-2 bg-gray-50 rounded&quot;&gt;&#10;            &lt;div className=&quot;w-8 h-8 rounded-full bg-gray-200 flex items-center justify-center overflow-hidden flex-shrink-0&quot;&gt;&#10;              {friend.avatarUrl ? (&#10;                &lt;img &#10;                  src={friend.avatarUrl} &#10;                  alt={friend.fullName}&#10;                  className=&quot;w-full h-full object-cover&quot;&#10;                /&gt;&#10;              ) : (&#10;                &lt;span className=&quot;text-gray-500 text-xs&quot;&gt;&#10;                  {friend.fullName?.charAt(0).toUpperCase() || 'U'}&#10;                &lt;/span&gt;&#10;              )}&#10;            &lt;/div&gt;&#10;            &lt;div className=&quot;flex-1 min-w-0&quot;&gt;&#10;              &lt;p className=&quot;text-sm font-medium text-gray-900 truncate&quot;&gt;&#10;                {friend.fullName}&#10;              &lt;/p&gt;&#10;              &lt;p className=&quot;text-xs text-gray-500 truncate&quot;&gt;&#10;                @{friend.username}&#10;              &lt;/p&gt;&#10;            &lt;/div&gt;&#10;          &lt;/div&gt;&#10;        ))}&#10;        &#10;        {mutualFriends.length &gt; 5 &amp;&amp; (&#10;          &lt;div className=&quot;text-center&quot;&gt;&#10;            &lt;button className=&quot;text-blue-500 text-sm hover:text-blue-600&quot;&gt;&#10;              View all {mutualFriends.length} mutual friends&#10;            &lt;/button&gt;&#10;          &lt;/div&gt;&#10;        )}&#10;      &lt;/div&gt;&#10;    &lt;/div&gt;&#10;  );&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/client-frontend/src/features/users/components/friends/index.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/client-frontend/src/features/users/components/friends/index.ts" />
              <option name="updatedContent" value="// Export all friends-related components&#10;export { FriendsList } from './FriendsList';&#10;export { FriendRequests } from './FriendRequests';&#10;export { FriendSuggestions } from './FriendSuggestions';&#10;export { MutualFriends } from './MutualFriends';&#10;export { FriendsDashboard } from './FriendsDashboard';&#10;&#10;// Re-export related components&#10;export { UserCard } from '../UserCard';" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/client-frontend/src/features/users/index.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/client-frontend/src/features/users/index.ts" />
              <option name="originalContent" value="/*&#10;// Users feature exports&#10;export { default as UserProfile } from './components/UserProfile';&#10;export { default as UserCard } from './components/UserCard';&#10;export { default as UserList } from './components/UserList';&#10;export { default as UserSearch } from './components/UserSearch';&#10;export { default as FollowButton } from './components/FollowButton';&#10;export { default as EditProfileModal } from './components/EditProfileModal';&#10;&#10;// Users hooks&#10;export { useUserHooks } from './hooks/useUserHooks';&#10;export { useUserProfile } from './hooks/useUserProfile';&#10;export { useUserActions } from './hooks/useUserActions';&#10;&#10;// Users services&#10;export { userService } from './services';&#10;&#10;// Users types&#10;export type {&#10;  User,&#10;  UpdateUserRequest,&#10;  UserStats,&#10;  UserRelationship,&#10;} from '@/shared/types';&#10;&#10;// Users utils&#10;export { validateUserProfile, formatUserInfo } from './utils/validation';&#10;*/&#10;" />
              <option name="updatedContent" value="/*&#13;&#10;// Users feature exports&#13;&#10;export { default as UserProfile } from './components/UserProfile';&#13;&#10;export { default as UserCard } from './components/UserCard';&#13;&#10;export { default as UserList } from './components/UserList';&#13;&#10;export { default as UserSearch } from './components/UserSearch';&#13;&#10;export { default as FollowButton } from './components/FollowButton';&#13;&#10;export { default as EditProfileModal } from './components/EditProfileModal';&#13;&#10;&#13;&#10;// Users hooks&#13;&#10;export { useUserHooks } from './hooks/useUserHooks';&#13;&#10;export { useUserProfile } from './hooks/useUserProfile';&#13;&#10;export { useUserActions } from './hooks/useUserActions';&#13;&#10;&#13;&#10;// Users services&#13;&#10;export { userService } from './services';&#13;&#10;&#13;&#10;// Users types&#13;&#10;export type {&#13;&#10;  User,&#13;&#10;  UpdateUserRequest,&#13;&#10;  UserStats,&#13;&#10;  UserRelationship,&#13;&#10;} from '@/shared/types';&#13;&#10;&#13;&#10;// Users utils&#13;&#10;export { validateUserProfile, formatUserInfo } from './utils/validation';&#13;&#10;&#13;&#10;// Export all user-related components and services&#13;&#10;export * from './services';&#13;&#10;export * from './components/UserCard';&#13;&#10;export * from './components/friends';&#13;&#10;*/" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/client-frontend/src/features/users/services/user.service.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/client-frontend/src/features/users/services/user.service.ts" />
              <option name="originalContent" value="/*&#10;import { apiClient } from '@/shared/config/api-client';&#10;import { API_ENDPOINTS } from '@/shared/constants';&#10;import { createApiUrl } from '@/shared/utils';&#10;import {&#10;  User,&#10;  UpdateUserRequest,&#10;  PaginatedResponse,&#10;  ApiResponse,&#10;  UserStats,&#10;  FileUploadResponse,&#10;  FriendsDTO,&#10;} from '@/shared/types';&#10;&#10;/!**&#10; * User Service&#10; * Handles all user-related API calls&#10; *!/&#10;export class UserService {&#10;  /!**&#10;   * Get user profile by ID&#10;   *!/&#10;  async getUserProfile(userId: string): Promise&lt;User&gt; {&#10;    const url = createApiUrl(API_ENDPOINTS.USERS.PROFILE, { id: userId });&#10;    return apiClient.get&lt;User&gt;(url);&#10;  }&#10;&#10;  /!**&#10;   * Update current user profile&#10;   *!/&#10;  async updateProfile(userData: UpdateUserRequest): Promise&lt;User&gt; {&#10;    return apiClient.put&lt;User&gt;(API_ENDPOINTS.USERS.PROFILE, userData);&#10;  }&#10;&#10;  /!**&#10;   * Upload user avatar&#10;   *!/&#10;  async uploadAvatar(&#10;    file: File,&#10;    onProgress?: (progress: number) =&gt; void&#10;  ): Promise&lt;FileUploadResponse&gt; {&#10;    return apiClient.uploadFile&lt;FileUploadResponse&gt;(&#10;      API_ENDPOINTS.USERS.AVATAR,&#10;      file,&#10;      onProgress&#10;    );&#10;  }&#10;&#10;  /!**&#10;   * Search users&#10;   *!/&#10;  async searchUsers(&#10;    query: string,&#10;    page = 0,&#10;    size = 10&#10;  ): Promise&lt;PaginatedResponse&lt;User&gt;&gt; {&#10;    const url = createApiUrl(API_ENDPOINTS.USERS.SEARCH, undefined, {&#10;      q: query,&#10;      page,&#10;      size,&#10;    });&#10;    return apiClient.get&lt;PaginatedResponse&lt;User&gt;&gt;(url);&#10;  }&#10;&#10;  /!**&#10;   * Follow user&#10;   *!/&#10;  async followUser(userId: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#10;    const url = createApiUrl(API_ENDPOINTS.USERS.FOLLOW, { id: userId });&#10;    return apiClient.post&lt;ApiResponse&lt;null&gt;&gt;(url);&#10;  }&#10;&#10;  /!**&#10;   * Unfollow user&#10;   *!/&#10;  async unfollowUser(userId: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#10;    const url = createApiUrl(API_ENDPOINTS.USERS.FOLLOW, { id: userId });&#10;    return apiClient.delete&lt;ApiResponse&lt;null&gt;&gt;(url);&#10;  }&#10;&#10;  /!**&#10;   * Get user followers&#10;   *!/&#10;  async getFollowers(&#10;    userId: string,&#10;    page = 0,&#10;    size = 10&#10;  ): Promise&lt;PaginatedResponse&lt;User&gt;&gt; {&#10;    const url = createApiUrl(&#10;      API_ENDPOINTS.USERS.FOLLOWERS,&#10;      { id: userId },&#10;      { page, size }&#10;    );&#10;    return apiClient.get&lt;PaginatedResponse&lt;User&gt;&gt;(url);&#10;  }&#10;&#10;  /!**&#10;   * Get users that user is following&#10;   *!/&#10;  async getFollowing(&#10;    userId: string,&#10;    page = 0,&#10;    size = 10&#10;  ): Promise&lt;PaginatedResponse&lt;User&gt;&gt; {&#10;    const url = createApiUrl(&#10;      API_ENDPOINTS.USERS.FOLLOWING,&#10;      { id: userId },&#10;      { page, size }&#10;    );&#10;    return apiClient.get&lt;PaginatedResponse&lt;User&gt;&gt;(url);&#10;  }&#10;&#10;&#10;  /!**&#10;   * Get user statistics&#10;   *!/&#10;  async getUserStats(userId: string): Promise&lt;UserStats&gt; {&#10;    const url = createApiUrl('/users/:id/stats', { id: userId });&#10;    return apiClient.get&lt;UserStats&gt;(url);&#10;  }&#10;&#10;  /!**&#10;   * Check if user is following another user&#10;   *!/&#10;  async isFollowing(userId: string): Promise&lt;boolean&gt; {&#10;    const url = createApiUrl('/users/:id/following/check', { id: userId });&#10;    const response = await apiClient.get&lt;{ isFollowing: boolean }&gt;(url);&#10;    return response.isFollowing;&#10;  }&#10;&#10;  /**&#10;   * Friends Management API calls&#10;   */&#10;&#10;  // Get user's friends list&#10;  async getFriends(userId?: string): Promise&lt;FriendsDTO&gt; {&#10;    const endpoint = userId&#10;      ? createApiUrl(API_ENDPOINTS.USERS.FRIENDS, { id: userId })&#10;      : API_ENDPOINTS.USERS.MY_FRIENDS;&#10;    return apiClient.get&lt;FriendsDTO&gt;(endpoint);&#10;  }&#10;&#10;  // Get friend requests received&#10;  async getFriendRequests(): Promise&lt;User[]&gt; {&#10;    return apiClient.get&lt;User[]&gt;(API_ENDPOINTS.USERS.FRIEND_REQUESTS);&#10;  }&#10;&#10;  // Get friend requests sent&#10;  async getSentFriendRequests(): Promise&lt;User[]&gt; {&#10;    return apiClient.get&lt;User[]&gt;(API_ENDPOINTS.USERS.FRIEND_REQUESTED);&#10;  }&#10;&#10;  // Get mutual friends with another user&#10;  async getMutualFriends(otherUserId: string): Promise&lt;FriendsDTO&gt; {&#10;    const url = createApiUrl(API_ENDPOINTS.USERS.MUTUAL_FRIENDS, { id: otherUserId });&#10;    return apiClient.get&lt;FriendsDTO&gt;(url);&#10;  }&#10;&#10;  // Get friend suggestions&#10;  async getFriendSuggestions(): Promise&lt;FriendsDTO&gt; {&#10;    return apiClient.get&lt;FriendsDTO&gt;(API_ENDPOINTS.USERS.FRIEND_SUGGESTIONS);&#10;  }&#10;&#10;  // Send friend request&#10;  async sendFriendRequest(friendId: string): Promise&lt;void&gt; {&#10;    const url = createApiUrl(API_ENDPOINTS.USERS.SEND_FRIEND_REQUEST, { id: friendId });&#10;    return apiClient.post&lt;void&gt;(url);&#10;  }&#10;&#10;  // Accept friend request&#10;  async acceptFriendRequest(friendId: string): Promise&lt;void&gt; {&#10;    const url = createApiUrl(API_ENDPOINTS.USERS.ACCEPT_FRIEND_REQUEST, { id: friendId });&#10;    return apiClient.post&lt;void&gt;(url);&#10;  }&#10;&#10;  // Reject friend request&#10;  async rejectFriendRequest(friendId: string): Promise&lt;void&gt; {&#10;    const url = createApiUrl(API_ENDPOINTS.USERS.REJECT_FRIEND_REQUEST, { id: friendId });&#10;    return apiClient.post&lt;void&gt;(url);&#10;  }&#10;&#10;  // Remove friend (unfriend)&#10;  async removeFriend(friendId: string): Promise&lt;void&gt; {&#10;    const url = createApiUrl(API_ENDPOINTS.USERS.REMOVE_FRIEND, { id: friendId });&#10;    return apiClient.delete&lt;void&gt;(url);&#10;  }&#10;}&#10;&#10;// Export singleton instance&#10;export const userService = new UserService();&#10;*/&#10;" />
              <option name="updatedContent" value="/*&#10;import { apiClient } from '@/shared/config/api-client';&#10;import { API_ENDPOINTS } from '@/shared/constants';&#10;import { createApiUrl } from '@/shared/utils';&#10;import {&#10;  User,&#10;  UpdateUserRequest,&#10;  PaginatedResponse,&#10;  ApiResponse,&#10;  UserStats,&#10;  FileUploadResponse,&#10;  FriendsDTO,&#10;} from '@/shared/types';&#10;&#10;/**&#10; * User Service&#10; * Handles all user-related API calls&#10; */&#10;export class UserService {&#10;  /**&#10;   * Get user profile by ID&#10;   */&#10;  async getUserProfile(userId: string): Promise&lt;User&gt; {&#10;    const url = createApiUrl(API_ENDPOINTS.USERS.PROFILE, { id: userId });&#10;    return apiClient.get&lt;User&gt;(url);&#10;  }&#10;&#10;  /**&#10;   * Update current user profile&#10;   */&#10;  async updateProfile(userData: UpdateUserRequest): Promise&lt;User&gt; {&#10;    return apiClient.put&lt;User&gt;(API_ENDPOINTS.USERS.PROFILE, userData);&#10;  }&#10;&#10;  /**&#10;   * Upload user avatar&#10;   */&#10;  async uploadAvatar(&#10;    file: File,&#10;    onProgress?: (progress: number) =&gt; void&#10;  ): Promise&lt;FileUploadResponse&gt; {&#10;    return apiClient.uploadFile&lt;FileUploadResponse&gt;(&#10;      API_ENDPOINTS.USERS.AVATAR,&#10;      file,&#10;      onProgress&#10;    );&#10;  }&#10;&#10;  /**&#10;   * Search users&#10;   */&#10;  async searchUsers(&#10;    query: string,&#10;    page = 0,&#10;    size = 10&#10;  ): Promise&lt;PaginatedResponse&lt;User&gt;&gt; {&#10;    const url = createApiUrl(API_ENDPOINTS.USERS.SEARCH, undefined, {&#10;      q: query,&#10;      page,&#10;      size,&#10;    });&#10;    return apiClient.get&lt;PaginatedResponse&lt;User&gt;&gt;(url);&#10;  }&#10;&#10;  /**&#10;   * Follow user&#10;   */&#10;  async followUser(userId: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#10;    const url = createApiUrl(API_ENDPOINTS.USERS.FOLLOW, { id: userId });&#10;    return apiClient.post&lt;ApiResponse&lt;null&gt;&gt;(url);&#10;  }&#10;&#10;  /**&#10;   * Unfollow user&#10;   */&#10;  async unfollowUser(userId: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#10;    const url = createApiUrl(API_ENDPOINTS.USERS.FOLLOW, { id: userId });&#10;    return apiClient.delete&lt;ApiResponse&lt;null&gt;&gt;(url);&#10;  }&#10;&#10;  /**&#10;   * Get user followers&#10;   */&#10;  async getFollowers(&#10;    userId: string,&#10;    page = 0,&#10;    size = 10&#10;  ): Promise&lt;PaginatedResponse&lt;User&gt;&gt; {&#10;    const url = createApiUrl(&#10;      API_ENDPOINTS.USERS.FOLLOWERS,&#10;      { id: userId },&#10;      { page, size }&#10;    );&#10;    return apiClient.get&lt;PaginatedResponse&lt;User&gt;&gt;(url);&#10;  }&#10;&#10;  /**&#10;   * Get users that user is following&#10;   */&#10;  async getFollowing(&#10;    userId: string,&#10;    page = 0,&#10;    size = 10&#10;  ): Promise&lt;PaginatedResponse&lt;User&gt;&gt; {&#10;    const url = createApiUrl(&#10;      API_ENDPOINTS.USERS.FOLLOWING,&#10;      { id: userId },&#10;      { page, size }&#10;    );&#10;    return apiClient.get&lt;PaginatedResponse&lt;User&gt;&gt;(url);&#10;  }&#10;&#10;  /**&#10;   * Get user statistics&#10;   */&#10;  async getUserStats(userId: string): Promise&lt;UserStats&gt; {&#10;    const url = createApiUrl('/users/:id/stats', { id: userId });&#10;    return apiClient.get&lt;UserStats&gt;(url);&#10;  }&#10;&#10;  /**&#10;   * Check if user is following another user&#10;   */&#10;  async isFollowing(userId: string): Promise&lt;boolean&gt; {&#10;    const url = createApiUrl('/users/:id/following/check', { id: userId });&#10;    const response = await apiClient.get&lt;{ isFollowing: boolean }&gt;(url);&#10;    return response.isFollowing;&#10;  }&#10;&#10;  /**&#10;   * Friends Management API calls&#10;   */&#10;&#10;  // Get user's friends list&#10;  async getFriends(userId?: string): Promise&lt;FriendsDTO&gt; {&#10;    const endpoint = userId&#10;      ? createApiUrl(API_ENDPOINTS.USERS.FRIENDS, { id: userId })&#10;      : API_ENDPOINTS.USERS.MY_FRIENDS;&#10;    return apiClient.get&lt;FriendsDTO&gt;(endpoint);&#10;  }&#10;&#10;  // Get friend requests received&#10;  async getFriendRequests(): Promise&lt;User[]&gt; {&#10;    return apiClient.get&lt;User[]&gt;(API_ENDPOINTS.USERS.FRIEND_REQUESTS);&#10;  }&#10;&#10;  // Get friend requests sent&#10;  async getSentFriendRequests(): Promise&lt;User[]&gt; {&#10;    return apiClient.get&lt;User[]&gt;(API_ENDPOINTS.USERS.FRIEND_REQUESTED);&#10;  }&#10;&#10;  // Get mutual friends with another user&#10;  async getMutualFriends(otherUserId: string): Promise&lt;FriendsDTO&gt; {&#10;    const url = createApiUrl(API_ENDPOINTS.USERS.MUTUAL_FRIENDS, { id: otherUserId });&#10;    return apiClient.get&lt;FriendsDTO&gt;(url);&#10;  }&#10;&#10;  // Get friend suggestions&#10;  async getFriendSuggestions(): Promise&lt;FriendsDTO&gt; {&#10;    return apiClient.get&lt;FriendsDTO&gt;(API_ENDPOINTS.USERS.FRIEND_SUGGESTIONS);&#10;  }&#10;&#10;  // Send friend request&#10;  async sendFriendRequest(friendId: string): Promise&lt;void&gt; {&#10;    const url = createApiUrl(API_ENDPOINTS.USERS.SEND_FRIEND_REQUEST, { id: friendId });&#10;    return apiClient.post&lt;void&gt;(url);&#10;  }&#10;&#10;  // Accept friend request&#10;  async acceptFriendRequest(friendId: string): Promise&lt;void&gt; {&#10;    const url = createApiUrl(API_ENDPOINTS.USERS.ACCEPT_FRIEND_REQUEST, { id: friendId });&#10;    return apiClient.post&lt;void&gt;(url);&#10;  }&#10;&#10;  // Reject friend request&#10;  async rejectFriendRequest(friendId: string): Promise&lt;void&gt; {&#10;    const url = createApiUrl(API_ENDPOINTS.USERS.REJECT_FRIEND_REQUEST, { id: friendId });&#10;    return apiClient.post&lt;void&gt;(url);&#10;  }&#10;&#10;  // Remove friend (unfriend)&#10;  async removeFriend(friendId: string): Promise&lt;void&gt; {&#10;    const url = createApiUrl(API_ENDPOINTS.USERS.REMOVE_FRIEND, { id: friendId });&#10;    return apiClient.delete&lt;void&gt;(url);&#10;  }&#10;}&#10;&#10;// Export singleton instance&#10;export const userService = new UserService();&#10;*/" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/client-frontend/src/hooks/useChat.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/client-frontend/src/hooks/useChat.ts" />
              <option name="originalContent" value="import { useState, useEffect, useCallback, useRef } from 'react';&#10;import { webSocketService, TypingEvent, PresenceEvent } from '@/services/websocket.service';&#10;import { chatService } from '@/features/chat/services/chat.service';&#10;import { useAuth } from '@/contexts/AuthContext';&#10;import { PaginatedResponse } from '@/shared/types';&#10;import { ChatMessage, ChatRoom } from '@/shared/types/chat';&#10;&#10;export interface ChatState {&#10;  conversations: any[];&#10;  activeConversation: string | null;&#10;  messages: { [conversationId: string]: ChatMessage[] };&#10;  onlineUsers: Set&lt;string&gt;;&#10;  typingUsers: { [conversationId: string]: Set&lt;string&gt; };&#10;  isConnected: boolean;&#10;  isLoading: boolean;&#10;  error: string | null;&#10;}&#10;&#10;export interface UseChatReturn extends ChatState {&#10;  // Connection management&#10;  connect: () =&gt; Promise&lt;void&gt;;&#10;  disconnect: () =&gt; Promise&lt;void&gt;;&#10;&#10;  // Conversation management&#10;  joinConversation: (conversationId: string) =&gt; void;&#10;  leaveConversation: (conversationId: string) =&gt; void;&#10;  setActiveConversation: (conversationId: string | null) =&gt; void;&#10;  loadConversations: () =&gt; Promise&lt;void&gt;;&#10;&#10;  // Message management&#10;  sendMessage: (conversationId: string, content: string, type?: string) =&gt; void;&#10;  loadMessages: (conversationId: string, page?: number) =&gt; Promise&lt;void&gt;;&#10;  loadMoreMessages: (conversationId: string) =&gt; Promise&lt;void&gt;;&#10;&#10;  // Typing indicators&#10;  startTyping: (conversationId: string) =&gt; void;&#10;  stopTyping: (conversationId: string) =&gt; void;&#10;&#10;  // Presence management&#10;  updatePresence: (status: 'ONLINE' | 'AWAY' | 'OFFLINE') =&gt; void;&#10;&#10;  // Utilities&#10;  clearError: () =&gt; void;&#10;  getUnreadCount: (conversationId: string) =&gt; number;&#10;  markAsRead: (conversationId: string) =&gt; void;&#10;}&#10;&#10;export const useChat = (): UseChatReturn =&gt; {&#10;  const { user, token } = useAuth();&#10;  const [state, setState] = useState&lt;ChatState&gt;({&#10;    conversations: [],&#10;    activeConversation: null,&#10;    messages: {},&#10;    onlineUsers: new Set(),&#10;    typingUsers: {},&#10;    isConnected: false,&#10;    isLoading: false,&#10;    error: null,&#10;  });&#10;&#10;  const messagePages = useRef&lt;{ [conversationId: string]: number }&gt;({});&#10;  const hasMoreMessages = useRef&lt;{ [conversationId: string]: boolean }&gt;({});&#10;  const typingTimeouts = useRef&lt;{ [key: string]: NodeJS.Timeout }&gt;({});&#10;&#10;  // WebSocket event handlers&#10;  const handleMessage = useCallback((message: ChatMessage) =&gt; {&#10;    setState(prev =&gt; ({&#10;      ...prev,&#10;      messages: {&#10;        ...prev.messages,&#10;        [message.conversationId]: [&#10;          ...(prev.messages[message.conversationId] || []),&#10;          message&#10;        ].sort((a, b) =&gt; new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime())&#10;      }&#10;    }));&#10;  }, []);&#10;&#10;  const handleTyping = useCallback((event: TypingEvent) =&gt; {&#10;    setState(prev =&gt; {&#10;      const conversationTyping = new Set(prev.typingUsers[event.conversationId] || []);&#10;&#10;      if (event.isTyping) {&#10;        conversationTyping.add(event.userId);&#10;      } else {&#10;        conversationTyping.delete(event.userId);&#10;      }&#10;&#10;      return {&#10;        ...prev,&#10;        typingUsers: {&#10;          ...prev.typingUsers,&#10;          [event.conversationId]: conversationTyping&#10;        }&#10;      };&#10;    });&#10;&#10;    // Auto-clear typing indicator after timeout&#10;    if (event.isTyping) {&#10;      const timeoutKey = `${event.conversationId}-${event.userId}`;&#10;      if (typingTimeouts.current[timeoutKey]) {&#10;        clearTimeout(typingTimeouts.current[timeoutKey]);&#10;      }&#10;&#10;      typingTimeouts.current[timeoutKey] = setTimeout(() =&gt; {&#10;        setState(prev =&gt; {&#10;          const conversationTyping = new Set(prev.typingUsers[event.conversationId] || []);&#10;          conversationTyping.delete(event.userId);&#10;&#10;          return {&#10;            ...prev,&#10;            typingUsers: {&#10;              ...prev.typingUsers,&#10;              [event.conversationId]: conversationTyping&#10;            }&#10;          };&#10;        });&#10;      }, 3000);&#10;    }&#10;  }, []);&#10;&#10;  const handlePresence = useCallback((event: PresenceEvent) =&gt; {&#10;    setState(prev =&gt; {&#10;      const newOnlineUsers = new Set(prev.onlineUsers);&#10;&#10;      if (event.status === 'ONLINE') {&#10;        newOnlineUsers.add(event.userId);&#10;      } else {&#10;        newOnlineUsers.delete(event.userId);&#10;      }&#10;&#10;      return {&#10;        ...prev,&#10;        onlineUsers: newOnlineUsers&#10;      };&#10;    });&#10;  }, []);&#10;&#10;  const handleConnected = useCallback(() =&gt; {&#10;    setState(prev =&gt; ({ ...prev, isConnected: true, error: null }));&#10;  }, []);&#10;&#10;  const handleDisconnected = useCallback(() =&gt; {&#10;    setState(prev =&gt; ({ ...prev, isConnected: false }));&#10;  }, []);&#10;&#10;  const handleError = useCallback((error: Error) =&gt; {&#10;    setState(prev =&gt; ({ ...prev, error: error.message, isConnected: false }));&#10;  }, []);&#10;&#10;  // Connection management&#10;  const connect = useCallback(async () =&gt; {&#10;    if (!token) {&#10;      setState(prev =&gt; ({ ...prev, error: 'Authentication token not available' }));&#10;      return;&#10;    }&#10;&#10;    try {&#10;      setState(prev =&gt; ({ ...prev, isLoading: true, error: null }));&#10;&#10;      // Setup event listeners&#10;      webSocketService.on('message', handleMessage);&#10;      webSocketService.on('typing', handleTyping);&#10;      webSocketService.on('presence', handlePresence);&#10;      webSocketService.on('connected', handleConnected);&#10;      webSocketService.on('disconnected', handleDisconnected);&#10;      webSocketService.on('error', handleError);&#10;&#10;      await webSocketService.connect(token);&#10;&#10;      setState(prev =&gt; ({ ...prev, isLoading: false }));&#10;    } catch (error) {&#10;      setState(prev =&gt; ({&#10;        ...prev,&#10;        error: error instanceof Error ? error.message : 'Connection failed',&#10;        isLoading: false&#10;      }));&#10;    }&#10;  }, [token, handleMessage, handleTyping, handlePresence, handleConnected, handleDisconnected, handleError]);&#10;&#10;  const disconnect = useCallback(async () =&gt; {&#10;    await webSocketService.disconnect();&#10;&#10;    // Clear event listeners&#10;    webSocketService.removeAllListeners();&#10;&#10;    setState(prev =&gt; ({&#10;      ...prev,&#10;      isConnected: false,&#10;      activeConversation: null,&#10;      typingUsers: {}&#10;    }));&#10;  }, []);&#10;&#10;  // Conversation management&#10;  const joinConversation = useCallback((conversationId: string) =&gt; {&#10;    if (state.isConnected) {&#10;      webSocketService.joinConversation(conversationId);&#10;    }&#10;  }, [state.isConnected]);&#10;&#10;  const leaveConversation = useCallback((conversationId: string) =&gt; {&#10;    if (state.isConnected) {&#10;      webSocketService.leaveConversation(conversationId);&#10;    }&#10;  }, [state.isConnected]);&#10;&#10;  const setActiveConversation = useCallback((conversationId: string | null) =&gt; {&#10;    setState(prev =&gt; {&#10;      // Leave previous conversation&#10;      if (prev.activeConversation &amp;&amp; prev.activeConversation !== conversationId) {&#10;        webSocketService.leaveConversation(prev.activeConversation);&#10;      }&#10;&#10;      // Join new conversation&#10;      if (conversationId) {&#10;        webSocketService.joinConversation(conversationId);&#10;      }&#10;&#10;      return { ...prev, activeConversation: conversationId };&#10;    });&#10;  }, []);&#10;&#10;  const loadConversations = useCallback(async () =&gt; {&#10;    try {&#10;      setState(prev =&gt; ({ ...prev, isLoading: true }));&#10;&#10;      const response: PaginatedResponse&lt;any&gt; = await chatService.getChatRooms();&#10;&#10;      setState(prev =&gt; ({&#10;        ...prev,&#10;        conversations: response.content,&#10;        isLoading: false&#10;      }));&#10;    } catch (error) {&#10;      setState(prev =&gt; ({&#10;        ...prev,&#10;        error: error instanceof Error ? error.message : 'Failed to load conversations',&#10;        isLoading: false&#10;      }));&#10;    }&#10;  }, []);&#10;&#10;  // Message management&#10;  const sendMessage = useCallback((conversationId: string, content: string, type = 'TEXT') =&gt; {&#10;    if (state.isConnected) {&#10;      webSocketService.sendMessage(conversationId, content, type);&#10;    }&#10;  }, [state.isConnected]);&#10;&#10;  const loadMessages = useCallback(async (conversationId: string, page = 0) =&gt; {&#10;    try {&#10;      const response: PaginatedResponse&lt;ChatMessage&gt; = await chatService.getMessages(conversationId, page, 50);&#10;&#10;      setState(prev =&gt; ({&#10;        ...prev,&#10;        messages: {&#10;          ...prev.messages,&#10;          [conversationId]: page === 0 ? response.content : [&#10;            ...response.content,&#10;            ...(prev.messages[conversationId] || [])&#10;          ].sort((a, b) =&gt; new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime())&#10;        }&#10;      }));&#10;&#10;      messagePages.current[conversationId] = page;&#10;      hasMoreMessages.current[conversationId] = !response.last;&#10;    } catch (error) {&#10;      setState(prev =&gt; ({&#10;        ...prev,&#10;        error: error instanceof Error ? error.message : 'Failed to load messages'&#10;      }));&#10;    }&#10;  }, []);&#10;&#10;  const loadMoreMessages = useCallback(async (conversationId: string) =&gt; {&#10;    const currentPage = messagePages.current[conversationId] || 0;&#10;    const hasMore = hasMoreMessages.current[conversationId] !== false;&#10;&#10;    if (hasMore) {&#10;      await loadMessages(conversationId, currentPage + 1);&#10;    }&#10;  }, [loadMessages]);&#10;&#10;  // Typing indicators&#10;  const startTyping = useCallback((conversationId: string) =&gt; {&#10;    if (state.isConnected) {&#10;      webSocketService.sendTyping(conversationId, true);&#10;    }&#10;  }, [state.isConnected]);&#10;&#10;  const stopTyping = useCallback((conversationId: string) =&gt; {&#10;    if (state.isConnected) {&#10;      webSocketService.sendTyping(conversationId, false);&#10;    }&#10;  }, [state.isConnected]);&#10;&#10;  // Presence management&#10;  const updatePresence = useCallback((status: 'ONLINE' | 'AWAY' | 'OFFLINE') =&gt; {&#10;    if (state.isConnected) {&#10;      webSocketService.updatePresence(status);&#10;    }&#10;  }, [state.isConnected]);&#10;&#10;  // Utilities&#10;  const clearError = useCallback(() =&gt; {&#10;    setState(prev =&gt; ({ ...prev, error: null }));&#10;  }, []);&#10;&#10;  const getUnreadCount = useCallback((conversationId: string) =&gt; {&#10;    const messages = state.messages[conversationId] || [];&#10;    return messages.filter(msg =&gt; msg.senderId !== user?.id &amp;&amp; !msg.readBy?.includes(user?.id || '')).length;&#10;  }, [state.messages, user?.id]);&#10;&#10;  const markAsRead = useCallback(async (conversationId: string) =&gt; {&#10;    try {&#10;      await chatService.markRoomAsRead(conversationId);&#10;&#10;      setState(prev =&gt; ({&#10;        ...prev,&#10;        messages: {&#10;          ...prev.messages,&#10;          [conversationId]: prev.messages[conversationId]?.map(msg =&gt; ({&#10;            ...msg,&#10;            readBy: [...(msg.readBy || []), user?.id || '']&#10;          })) || []&#10;        }&#10;      }));&#10;    } catch (error) {&#10;      console.error('Failed to mark messages as read:', error);&#10;    }&#10;  }, [user?.id]);&#10;&#10;  // Auto-connect when token is available&#10;  useEffect(() =&gt; {&#10;    if (token &amp;&amp; !state.isConnected &amp;&amp; !state.isLoading) {&#10;      connect();&#10;    }&#10;  }, [token, state.isConnected, state.isLoading, connect]);&#10;&#10;  // Auto-disconnect on unmount&#10;  useEffect(() =&gt; {&#10;    return () =&gt; {&#10;      disconnect();&#10;&#10;      // Clear all timeouts&#10;      Object.values(typingTimeouts.current).forEach(timeout =&gt; clearTimeout(timeout));&#10;    };&#10;  }, [disconnect]);&#10;&#10;  return {&#10;    ...state,&#10;    connect,&#10;    disconnect,&#10;    joinConversation,&#10;    leaveConversation,&#10;    setActiveConversation,&#10;    loadConversations,&#10;    sendMessage,&#10;    loadMessages,&#10;    loadMoreMessages,&#10;    startTyping,&#10;    stopTyping,&#10;    updatePresence,&#10;    clearError,&#10;    getUnreadCount,&#10;    markAsRead,&#10;  };&#10;};&#10;" />
              <option name="updatedContent" value="import { useState, useEffect, useCallback, useRef } from 'react';&#10;import { webSocketService, TypingEvent, PresenceEvent } from '@/services/websocket.service';&#10;import { chatService } from '@/features/chat/services/chat.service';&#10;import { useAuth } from '@/contexts/AuthContext';&#10;import { PaginatedResponse } from '@/shared/types';&#10;import { ChatMessage, ChatRoom } from '@/shared/types/chat';&#10;&#10;export interface ChatState {&#10;  conversations: any[];&#10;  activeConversation: string | null;&#10;  messages: { [conversationId: string]: ChatMessage[] };&#10;  onlineUsers: Set&lt;string&gt;;&#10;  typingUsers: { [conversationId: string]: Set&lt;string&gt; };&#10;  isConnected: boolean;&#10;  isLoading: boolean;&#10;  error: string | null;&#10;}&#10;&#10;export interface UseChatReturn extends ChatState {&#10;  // Connection management&#10;  connect: () =&gt; Promise&lt;void&gt;;&#10;  disconnect: () =&gt; Promise&lt;void&gt;;&#10;&#10;  // Conversation management&#10;  joinConversation: (conversationId: string) =&gt; void;&#10;  leaveConversation: (conversationId: string) =&gt; void;&#10;  setActiveConversation: (conversationId: string | null) =&gt; void;&#10;  loadConversations: () =&gt; Promise&lt;void&gt;;&#10;&#10;  // Message management&#10;  sendMessage: (conversationId: string, content: string, type?: string) =&gt; void;&#10;  loadMessages: (conversationId: string, page?: number) =&gt; Promise&lt;void&gt;;&#10;  loadMoreMessages: (conversationId: string) =&gt; Promise&lt;void&gt;;&#10;&#10;  // Typing indicators&#10;  startTyping: (conversationId: string) =&gt; void;&#10;  stopTyping: (conversationId: string) =&gt; void;&#10;&#10;  // Presence management&#10;  updatePresence: (status: 'ONLINE' | 'AWAY' | 'OFFLINE') =&gt; void;&#10;&#10;  // Utilities&#10;  clearError: () =&gt; void;&#10;  getUnreadCount: (conversationId: string) =&gt; number;&#10;  markAsRead: (conversationId: string) =&gt; void;&#10;}&#10;&#10;export const useChat = (): UseChatReturn =&gt; {&#10;  const { user, token } = useAuth();&#10;  const [state, setState] = useState&lt;ChatState&gt;({&#10;    conversations: [],&#10;    activeConversation: null,&#10;    messages: {},&#10;    onlineUsers: new Set(),&#10;    typingUsers: {},&#10;    isConnected: false,&#10;    isLoading: false,&#10;    error: null,&#10;  });&#10;&#10;  const messagePages = useRef&lt;{ [conversationId: string]: number }&gt;({});&#10;  const hasMoreMessages = useRef&lt;{ [conversationId: string]: boolean }&gt;({});&#10;  const typingTimeouts = useRef&lt;{ [key: string]: NodeJS.Timeout }&gt;({});&#10;&#10;  // WebSocket event handlers&#10;  const handleMessage = useCallback((message: ChatMessage) =&gt; {&#10;    setState(prev =&gt; ({&#10;      ...prev,&#10;      messages: {&#10;        ...prev.messages,&#10;        [message.conversationId]: [&#10;          ...(prev.messages[message.conversationId] || []),&#10;          message&#10;        ].sort((a, b) =&gt; new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime())&#10;      }&#10;    }));&#10;  }, []);&#10;&#10;  const handleTyping = useCallback((event: TypingEvent) =&gt; {&#10;    setState(prev =&gt; {&#10;      const conversationTyping = new Set(prev.typingUsers[event.conversationId] || []);&#10;&#10;      if (event.isTyping) {&#10;        conversationTyping.add(event.userId);&#10;      } else {&#10;        conversationTyping.delete(event.userId);&#10;      }&#10;&#10;      return {&#10;        ...prev,&#10;        typingUsers: {&#10;          ...prev.typingUsers,&#10;          [event.conversationId]: conversationTyping&#10;        }&#10;      };&#10;    });&#10;&#10;    // Auto-clear typing indicator after timeout&#10;    if (event.isTyping) {&#10;      const timeoutKey = `${event.conversationId}-${event.userId}`;&#10;      if (typingTimeouts.current[timeoutKey]) {&#10;        clearTimeout(typingTimeouts.current[timeoutKey]);&#10;      }&#10;&#10;      typingTimeouts.current[timeoutKey] = setTimeout(() =&gt; {&#10;        setState(prev =&gt; {&#10;          const conversationTyping = new Set(prev.typingUsers[event.conversationId] || []);&#10;          conversationTyping.delete(event.userId);&#10;&#10;          return {&#10;            ...prev,&#10;            typingUsers: {&#10;              ...prev.typingUsers,&#10;              [event.conversationId]: conversationTyping&#10;            }&#10;          };&#10;        });&#10;      }, 3000);&#10;    }&#10;  }, []);&#10;&#10;  const handlePresence = useCallback((event: PresenceEvent) =&gt; {&#10;    setState(prev =&gt; {&#10;      const newOnlineUsers = new Set(prev.onlineUsers);&#10;&#10;      if (event.status === 'ONLINE') {&#10;        newOnlineUsers.add(event.userId);&#10;      } else {&#10;        newOnlineUsers.delete(event.userId);&#10;      }&#10;&#10;      return {&#10;        ...prev,&#10;        onlineUsers: newOnlineUsers&#10;      };&#10;    });&#10;  }, []);&#10;&#10;  const handleConnected = useCallback(() =&gt; {&#10;    setState(prev =&gt; ({ ...prev, isConnected: true, error: null }));&#10;  }, []);&#10;&#10;  const handleDisconnected = useCallback(() =&gt; {&#10;    setState(prev =&gt; ({ ...prev, isConnected: false }));&#10;  }, []);&#10;&#10;  const handleError = useCallback((error: Error) =&gt; {&#10;    setState(prev =&gt; ({ ...prev, error: error.message, isConnected: false }));&#10;  }, []);&#10;&#10;  // Connection management&#10;  const connect = useCallback(async () =&gt; {&#10;    if (!token) {&#10;      setState(prev =&gt; ({ ...prev, error: 'Authentication token not available' }));&#10;      return;&#10;    }&#10;&#10;    try {&#10;      setState(prev =&gt; ({ ...prev, isLoading: true, error: null }));&#10;&#10;      // Setup event listeners&#10;      webSocketService.on('message', handleMessage);&#10;      webSocketService.on('typing', handleTyping);&#10;      webSocketService.on('presence', handlePresence);&#10;      webSocketService.on('connected', handleConnected);&#10;      webSocketService.on('disconnected', handleDisconnected);&#10;      webSocketService.on('error', handleError);&#10;&#10;      await webSocketService.connect(token);&#10;&#10;      setState(prev =&gt; ({ ...prev, isLoading: false }));&#10;    } catch (error) {&#10;      setState(prev =&gt; ({&#10;        ...prev,&#10;        error: error instanceof Error ? error.message : 'Connection failed',&#10;        isLoading: false&#10;      }));&#10;    }&#10;  }, [token, handleMessage, handleTyping, handlePresence, handleConnected, handleDisconnected, handleError]);&#10;&#10;  const disconnect = useCallback(async () =&gt; {&#10;    await webSocketService.disconnect();&#10;&#10;    // Clear event listeners&#10;    webSocketService.removeAllListeners();&#10;&#10;    setState(prev =&gt; ({&#10;      ...prev,&#10;      isConnected: false,&#10;      activeConversation: null,&#10;      typingUsers: {}&#10;    }));&#10;  }, []);&#10;&#10;  // Conversation management&#10;  const joinConversation = useCallback((conversationId: string) =&gt; {&#10;    if (state.isConnected) {&#10;      webSocketService.joinConversation(conversationId);&#10;    }&#10;  }, [state.isConnected]);&#10;&#10;  const leaveConversation = useCallback((conversationId: string) =&gt; {&#10;    if (state.isConnected) {&#10;      webSocketService.leaveConversation(conversationId);&#10;    }&#10;  }, [state.isConnected]);&#10;&#10;  const setActiveConversation = useCallback((conversationId: string | null) =&gt; {&#10;    setState(prev =&gt; {&#10;      // Leave previous conversation&#10;      if (prev.activeConversation &amp;&amp; prev.activeConversation !== conversationId) {&#10;        webSocketService.leaveConversation(prev.activeConversation);&#10;      }&#10;&#10;      // Join new conversation&#10;      if (conversationId) {&#10;        webSocketService.joinConversation(conversationId);&#10;      }&#10;&#10;      return { ...prev, activeConversation: conversationId };&#10;    });&#10;  }, []);&#10;&#10;  const loadConversations = useCallback(async () =&gt; {&#10;    try {&#10;      setState(prev =&gt; ({ ...prev, isLoading: true }));&#10;&#10;      const response: PaginatedResponse&lt;any&gt; = await chatService.getChatRooms();&#10;&#10;      setState(prev =&gt; ({&#10;        ...prev,&#10;        conversations: response.content,&#10;        isLoading: false&#10;      }));&#10;    } catch (error) {&#10;      setState(prev =&gt; ({&#10;        ...prev,&#10;        error: error instanceof Error ? error.message : 'Failed to load conversations',&#10;        isLoading: false&#10;      }));&#10;    }&#10;  }, []);&#10;&#10;  // Message management&#10;  const sendMessage = useCallback((conversationId: string, content: string, type = 'TEXT') =&gt; {&#10;    if (state.isConnected) {&#10;      webSocketService.sendMessage(conversationId, content, type);&#10;    }&#10;  }, [state.isConnected]);&#10;&#10;  const loadMessages = useCallback(async (conversationId: string, page = 0) =&gt; {&#10;    try {&#10;      const response: PaginatedResponse&lt;ChatMessage&gt; = await chatService.getMessages(conversationId, page, 50);&#10;&#10;      setState(prev =&gt; ({&#10;        ...prev,&#10;        messages: {&#10;          ...prev.messages,&#10;          [conversationId]: page === 0 ? response.content : [&#10;            ...response.content,&#10;            ...(prev.messages[conversationId] || [])&#10;          ].sort((a, b) =&gt; new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime())&#10;        }&#10;      }));&#10;&#10;      messagePages.current[conversationId] = page;&#10;      hasMoreMessages.current[conversationId] = !response.last;&#10;    } catch (error) {&#10;      setState(prev =&gt; ({&#10;        ...prev,&#10;        error: error instanceof Error ? error.message : 'Failed to load messages'&#10;      }));&#10;    }&#10;  }, []);&#10;&#10;  const loadMoreMessages = useCallback(async (conversationId: string) =&gt; {&#10;    const currentPage = messagePages.current[conversationId] || 0;&#10;    const hasMore = hasMoreMessages.current[conversationId] !== false;&#10;&#10;    if (hasMore) {&#10;      await loadMessages(conversationId, currentPage + 1);&#10;    }&#10;  }, [loadMessages]);&#10;&#10;  // Typing indicators&#10;  const startTyping = useCallback((conversationId: string) =&gt; {&#10;    if (state.isConnected) {&#10;      webSocketService.sendTyping(conversationId, true);&#10;    }&#10;  }, [state.isConnected]);&#10;&#10;  const stopTyping = useCallback((conversationId: string) =&gt; {&#10;    if (state.isConnected) {&#10;      webSocketService.sendTyping(conversationId, false);&#10;    }&#10;  }, [state.isConnected]);&#10;&#10;  // Presence management&#10;  const updatePresence = useCallback((status: 'ONLINE' | 'AWAY' | 'OFFLINE') =&gt; {&#10;    if (state.isConnected) {&#10;      webSocketService.updatePresence(status);&#10;    }&#10;  }, [state.isConnected]);&#10;&#10;  // Utilities&#10;  const clearError = useCallback(() =&gt; {&#10;    setState(prev =&gt; ({ ...prev, error: null }));&#10;  }, []);&#10;&#10;  const getUnreadCount = useCallback((conversationId: string) =&gt; {&#10;    const messages = state.messages[conversationId] || [];&#10;    return messages.filter(msg =&gt; &#10;      msg.senderId !== user?.id &amp;&amp; &#10;      !msg.readBy?.some(readStatus =&gt; readStatus.userId === user?.id)&#10;    ).length;&#10;  }, [state.messages, user?.id]);&#10;&#10;  const markAsRead = useCallback(async (conversationId: string) =&gt; {&#10;    try {&#10;      await chatService.markRoomAsRead(conversationId);&#10;&#10;      setState(prev =&gt; ({&#10;        ...prev,&#10;        messages: {&#10;          ...prev.messages,&#10;          [conversationId]: prev.messages[conversationId]?.map(msg =&gt; {&#10;            // Check if user already read this message&#10;            const alreadyRead = msg.readBy?.some(readStatus =&gt; readStatus.userId === user?.id);&#10;            &#10;            if (alreadyRead) {&#10;              return msg;&#10;            }&#10;            &#10;            // Add read status for current user&#10;            const newReadStatus = {&#10;              userId: user?.id || '',&#10;              user: user!,&#10;              readAt: new Date().toISOString()&#10;            };&#10;            &#10;            return {&#10;              ...msg,&#10;              readBy: [...(msg.readBy || []), newReadStatus],&#10;              isRead: true&#10;            };&#10;          }) || []&#10;        }&#10;      }));&#10;    } catch (error) {&#10;      console.error('Failed to mark messages as read:', error);&#10;    }&#10;  }, [user]);&#10;&#10;  // Auto-connect when token is available&#10;  useEffect(() =&gt; {&#10;    if (token &amp;&amp; !state.isConnected &amp;&amp; !state.isLoading) {&#10;      connect();&#10;    }&#10;  }, [token, state.isConnected, state.isLoading, connect]);&#10;&#10;  // Auto-disconnect on unmount&#10;  useEffect(() =&gt; {&#10;    return () =&gt; {&#10;      disconnect();&#10;&#10;      // Clear all timeouts&#10;      Object.values(typingTimeouts.current).forEach(timeout =&gt; clearTimeout(timeout));&#10;    };&#10;  }, [disconnect]);&#10;&#10;  return {&#10;    ...state,&#10;    connect,&#10;    disconnect,&#10;    joinConversation,&#10;    leaveConversation,&#10;    setActiveConversation,&#10;    loadConversations,&#10;    sendMessage,&#10;    loadMessages,&#10;    loadMoreMessages,&#10;    startTyping,&#10;    stopTyping,&#10;    updatePresence,&#10;    clearError,&#10;    getUnreadCount,&#10;    markAsRead,&#10;  };&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/client-frontend/src/lib/locales/vi.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/client-frontend/src/lib/locales/vi.ts" />
              <option name="updatedContent" value="// Vietnamese localization constants&#10;export const VI_LOCALE = {&#10;  // Common actions&#10;  actions: {&#10;    save: 'Lưu',&#10;    cancel: 'Hủy',&#10;    delete: 'Xóa',&#10;    edit: 'Chỉnh sửa',&#10;    submit: 'Gửi',&#10;    confirm: 'Xác nhận',&#10;    back: 'Quay lại',&#10;    next: 'Tiếp theo',&#10;    loading: 'Đang tải...',&#10;    retry: 'Thử lại',&#10;    close: 'Đóng',&#10;    open: 'Mở',&#10;    view: 'Xem',&#10;    share: 'Chia sẻ',&#10;    copy: 'Sao chép',&#10;    download: 'Tải xuống',&#10;    upload: 'Tải lên',&#10;    search: 'Tìm kiếm',&#10;    filter: 'Lọc',&#10;    sort: 'Sắp xếp',&#10;    refresh: 'Làm mới'&#10;  },&#10;&#10;  // Authentication&#10;  auth: {&#10;    login: 'Đăng nhập',&#10;    logout: 'Đăng xuất',&#10;    register: 'Đăng ký',&#10;    forgotPassword: 'Quên mật khẩu',&#10;    resetPassword: 'Đặt lại mật khẩu',&#10;    changePassword: 'Đổi mật khẩu',&#10;    verifyEmail: 'Xác thực email',&#10;    resendVerification: 'Gửi lại mã xác thực'&#10;  },&#10;&#10;  // Posts&#10;  posts: {&#10;    createPost: 'Tạo bài viết',&#10;    editPost: 'Chỉnh sửa bài viết',&#10;    deletePost: 'Xóa bài viết',&#10;    sharePost: 'Chia sẻ bài viết',&#10;    likePost: 'Thích bài viết',&#10;    unlikePost: 'Bỏ thích',&#10;    bookmarkPost: 'Lưu bài viết',&#10;    removeBookmark: 'Bỏ lưu',&#10;    commentPost: 'Bình luận',&#10;    viewComments: 'Xem bình luận',&#10;    hideComments: 'Ẩn bình luận',&#10;    writeComment: 'Viết bình luận...',&#10;    replyComment: 'Trả lời',&#10;    postTitle: 'Tiêu đề bài viết',&#10;    postContent: 'Nội dung bài viết',&#10;    addMedia: 'Thêm ảnh/video',&#10;    addTag: 'Thêm thẻ',&#10;    selectCategory: 'Chọn danh mục',&#10;    noPostsFound: 'Không tìm thấy bài viết nào',&#10;    loadMorePosts: 'Tải thêm bài viết'&#10;  },&#10;&#10;  // User profile&#10;  profile: {&#10;    profile: 'Hồ sơ',&#10;    editProfile: 'Chỉnh sửa hồ sơ',&#10;    viewProfile: 'Xem hồ sơ',&#10;    fullName: 'Họ và tên',&#10;    email: 'Email',&#10;    username: 'Tên đăng nhập',&#10;    bio: 'Giới thiệu',&#10;    avatar: 'Ảnh đại diện',&#10;    coverPhoto: 'Ảnh bìa',&#10;    birthday: 'Ngày sinh',&#10;    gender: 'Giới tính',&#10;    faculty: 'Khoa',&#10;    major: 'Ngành học',&#10;    studentId: 'Mã số sinh viên',&#10;    academicYear: 'Niên khóa',&#10;    phone: 'Số điện thoại',&#10;    address: 'Địa chỉ'&#10;  },&#10;&#10;  // Messages and notifications&#10;  messages: {&#10;    success: {&#10;      loginSuccess: 'Đăng nhập thành công',&#10;      logoutSuccess: 'Đăng xuất thành công',&#10;      registrationSuccess: 'Đăng ký thành công',&#10;      profileUpdated: 'Cập nhật hồ sơ thành công',&#10;      postCreated: 'Tạo bài viết thành công',&#10;      postUpdated: 'Cập nhật bài viết thành công',&#10;      postDeleted: 'Xóa bài viết thành công',&#10;      commentAdded: 'Thêm bình luận thành công',&#10;      passwordChanged: 'Đổi mật khẩu thành công',&#10;      emailVerified: 'Xác thực email thành công'&#10;    },&#10;    error: {&#10;      genericError: 'Đã xảy ra lỗi. Vui lòng thử lại.',&#10;      networkError: 'Lỗi kết nối mạng. Vui lòng kiểm tra kết nối internet.',&#10;      unauthorized: 'Bạn không có quyền truy cập.',&#10;      forbidden: 'Truy cập bị từ chối.',&#10;      notFound: 'Không tìm thấy tài nguyên.',&#10;      serverError: 'Lỗi máy chủ. Vui lòng thử lại sau.',&#10;      validationError: 'Dữ liệu không hợp lệ.',&#10;      loginFailed: 'Đăng nhập thất bại',&#10;      registrationFailed: 'Đăng ký thất bại',&#10;      uploadFailed: 'Tải file thất bại',&#10;      securityError: 'Xác thực bảo mật thất bại. Vui lòng thử lại.'&#10;    },&#10;    validation: {&#10;      required: 'Trường này là bắt buộc',&#10;      invalidEmail: 'Email không hợp lệ',&#10;      invalidPassword: 'Mật khẩu không hợp lệ',&#10;      passwordMismatch: 'Mật khẩu xác nhận không khớp',&#10;      minLength: 'Tối thiểu {min} ký tự',&#10;      maxLength: 'Tối đa {max} ký tự',&#10;      invalidFormat: 'Định dạng không hợp lệ'&#10;    }&#10;  },&#10;&#10;  // Time formatting&#10;  time: {&#10;    now: 'Vừa xong',&#10;    minutesAgo: '{count} phút trước',&#10;    hoursAgo: '{count} giờ trước',&#10;    daysAgo: '{count} ngày trước',&#10;    weeksAgo: '{count} tuần trước',&#10;    monthsAgo: '{count} tháng trước',&#10;    yearsAgo: '{count} năm trước'&#10;  },&#10;&#10;  // File upload&#10;  upload: {&#10;    selectFiles: 'Chọn tệp',&#10;    dragAndDrop: 'Kéo thả tệp vào đây',&#10;    maxFileSize: 'Kích thước tệp tối đa: {size}MB',&#10;    supportedFormats: 'Định dạng hỗ trợ: {formats}',&#10;    uploadProgress: 'Đang tải lên... {progress}%',&#10;    uploadComplete: 'Tải lên hoàn tất',&#10;    uploadFailed: 'Tải lên thất bại'&#10;  },&#10;&#10;  // Search and filters&#10;  search: {&#10;    searchPlaceholder: 'Tìm kiếm...',&#10;    noResults: 'Không tìm thấy kết quả',&#10;    searchResults: 'Kết quả tìm kiếm',&#10;    filters: 'Bộ lọc',&#10;    sortBy: 'Sắp xếp theo',&#10;    sortNewest: 'Mới nhất',&#10;    sortOldest: 'Cũ nhất',&#10;    sortMostLiked: 'Nhiều lượt thích nhất',&#10;    sortMostViewed: 'Nhiều lượt xem nhất'&#10;  },&#10;&#10;  // Categories&#10;  categories: {&#10;    academic: 'Học tập',&#10;    social: 'Sinh hoạt',&#10;    announcement: 'Thông báo',&#10;    career: 'Nghề nghiệp',&#10;    technology: 'Công nghệ',&#10;    sports: 'Thể thao',&#10;    entertainment: 'Giải trí',&#10;    other: 'Khác'&#10;  }&#10;} as const;&#10;&#10;export type LocaleKey = keyof typeof VI_LOCALE;&#10;export type LocaleValue = typeof VI_LOCALE[LocaleKey];" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/client-frontend/src/services/authService.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/client-frontend/src/services/authService.ts" />
              <option name="originalContent" value="import api from '@/lib/api';&#10;import { LoginRequest, RegisterRequest, AuthResponse, ApiResponse, User } from '@/types';&#10;&#10;export const authService = {&#10;  async login(credentials: LoginRequest): Promise&lt;AuthResponse&gt; {&#10;    const response = await api.post('/auth/login', credentials, {&#10;      withCredentials: true, // Để nhận cookies&#10;    });&#10;    return response.data;&#10;  },&#10;&#10;  async register(userData: RegisterRequest): Promise&lt;{ message: string }&gt; {&#10;    const response = await api.post('/auth/register', userData, {&#10;      withCredentials: true, // Để nhận cookies nếu cần&#10;    });&#10;    return { message: response.data };&#10;  },&#10;&#10;  async logout(): Promise&lt;void&gt; {&#10;    // Simply call logout endpoint - no need to manually handle tokens&#10;    await api.post('/auth/logout', {}, {&#10;      withCredentials: true,&#10;    });&#10;  },&#10;&#10;  async refreshToken(): Promise&lt;AuthResponse&gt; {&#10;    // API Gateway will automatically handle refresh token from HttpOnly cookies&#10;    const response = await api.post('/auth/refresh-token', {}, {&#10;      withCredentials: true,&#10;    });&#10;    return response.data;&#10;  },&#10;&#10;  async verifyEmail(token: string): Promise&lt;{ message: string }&gt; {&#10;    const response = await api.post(`/auth/verify-email?token=${token}`);&#10;    return { message: response.data };&#10;  },&#10;&#10;  async resendVerificationEmail(token: string): Promise&lt;{ message: string }&gt; {&#10;    const response = await api.post('/auth/resend-verification', { token });&#10;    return { message: response.data };&#10;  },&#10;&#10;  async forgotPassword(email: string): Promise&lt;{ message: string }&gt; {&#10;    const response = await api.post('/auth/forgot-password', { email });&#10;    return { message: response.data };&#10;  },&#10;&#10;  async resetPassword(token: string, newPassword: string): Promise&lt;{ message: string }&gt; {&#10;    const response = await api.post('/auth/reset-password', { token, newPassword });&#10;    return { message: response.data };&#10;  },&#10;&#10;  async getCurrentUser(): Promise&lt;ApiResponse&lt;User&gt;&gt; {&#10;    const response = await api.get('/auth/me', {&#10;      withCredentials: true,&#10;    });&#10;    return response.data;&#10;  },&#10;&#10;    error?: any;&#10;  }&gt; =&gt; {&#10;    console.log('DEBUG: ========== Starting checkAuthenticationWithUser ==========');&#10;    console.log('DEBUG: Current URL:', typeof window !== 'undefined' ? window.location.href : 'server-side');&#10;&#10;    try {&#10;      console.log('DEBUG: Making API call to /auth/me');&#10;      const response = await api.get('/auth/me', {&#10;        withCredentials: true,&#10;      });&#10;&#10;      console.log('DEBUG: API response status:', response.status);&#10;      console.log('DEBUG: API response data:', response.data.user);&#10;&#10;      // Check if the response indicates authentication success&#10;      if (response.data &amp;&amp; response.status === 200) {&#10;        console.log('DEBUG: Authentication successful, user data found');&#10;        return {&#10;          isAuthenticated: true,&#10;          user: response.data.user,&#10;        };&#10;      } else if (response.data &amp;&amp; !(response.status === 200)) {&#10;        console.log('DEBUG: Authentication failed - response indicates failure');&#10;        return {&#10;          isAuthenticated: false,&#10;          user: null,&#10;        };&#10;      } else {&#10;        console.log('DEBUG: Unexpected response format:', response.data);&#10;        return {&#10;          isAuthenticated: false,&#10;          user: null,&#10;        };&#10;      }&#10;    } catch (error: any) {&#10;      console.error('DEBUG: checkAuthenticationWithUser error:', error);&#10;      console.error('DEBUG: Error status:', error.response?.status);&#10;      console.error('DEBUG: Error data:', error.response?.data);&#10;&#10;      return {&#10;        isAuthenticated: false,&#10;        user: null,&#10;        error,&#10;      };&#10;    } finally {&#10;      console.log('DEBUG: ========== checkAuthenticationWithUser completed ==========');&#10;    }&#10;  }&#10;};&#10;" />
              <option name="updatedContent" value="import api from '@/lib/api';&#13;&#10;import { LoginRequest, RegisterRequest, AuthResponse, ApiResponse, User } from '@/types';&#13;&#10;&#13;&#10;export const authService = {&#13;&#10;  async login(credentials: LoginRequest): Promise&lt;AuthResponse&gt; {&#13;&#10;    const response = await api.post('/auth/login', credentials, {&#13;&#10;      withCredentials: true, // Để nhận cookies&#13;&#10;    });&#13;&#10;    return response.data;&#13;&#10;  },&#13;&#10;&#13;&#10;  async register(userData: RegisterRequest): Promise&lt;{ message: string }&gt; {&#13;&#10;    const response = await api.post('/auth/register', userData, {&#13;&#10;      withCredentials: true, // Để nhận cookies nếu cần&#13;&#10;    });&#13;&#10;    return { message: response.data };&#13;&#10;  },&#13;&#10;&#13;&#10;  async logout(): Promise&lt;void&gt; {&#13;&#10;    // Simply call logout endpoint - no need to manually handle tokens&#13;&#10;    await api.post('/auth/logout', {}, {&#13;&#10;      withCredentials: true,&#13;&#10;    });&#13;&#10;  },&#13;&#10;&#13;&#10;  async refreshToken(): Promise&lt;AuthResponse&gt; {&#13;&#10;    // API Gateway will automatically handle refresh token from HttpOnly cookies&#13;&#10;    const response = await api.post('/auth/refresh-token', {}, {&#13;&#10;      withCredentials: true,&#13;&#10;    });&#13;&#10;    return response.data;&#13;&#10;  },&#13;&#10;&#13;&#10;  async verifyEmail(token: string): Promise&lt;{ message: string }&gt; {&#13;&#10;    const response = await api.post(`/auth/verify-email?token=${token}`);&#13;&#10;    return { message: response.data };&#13;&#10;  },&#13;&#10;&#13;&#10;  async resendVerificationEmail(token: string): Promise&lt;{ message: string }&gt; {&#13;&#10;    const response = await api.post('/auth/resend-verification', { token });&#13;&#10;    return { message: response.data };&#13;&#10;  },&#13;&#10;&#13;&#10;  async forgotPassword(email: string): Promise&lt;{ message: string }&gt; {&#13;&#10;    const response = await api.post('/auth/forgot-password', { email });&#13;&#10;    return { message: response.data };&#13;&#10;  },&#13;&#10;&#13;&#10;  async resetPassword(token: string, newPassword: string): Promise&lt;{ message: string }&gt; {&#13;&#10;    const response = await api.post('/auth/reset-password', { token, newPassword });&#13;&#10;    return { message: response.data };&#13;&#10;  },&#13;&#10;&#13;&#10;  async getCurrentUser(): Promise&lt;ApiResponse&lt;User&gt;&gt; {&#13;&#10;    const response = await api.get('/auth/me', {&#13;&#10;      withCredentials: true,&#13;&#10;    });&#13;&#10;    return response.data;&#13;&#10;  },&#13;&#10;&#13;&#10;  async getWebSocketToken(): Promise&lt;{ token: string }&gt; {&#13;&#10;    const response = await api.get('/auth/websocket-token', {&#13;&#10;      withCredentials: true,&#13;&#10;    });&#13;&#10;    return response.data;&#13;&#10;  },&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Kiểm tra xác thực người dùng và trả về thông tin người dùng nếu đã xác thực&#13;&#10;   * @returns {Promise&lt;{ isAuthenticated: boolean; user: User | null; error?: any }&gt;}&#13;&#10;   */&#13;&#10;  checkAuthenticationWithUser: async (): Promise&lt;{&#13;&#10;    isAuthenticated: boolean;&#13;&#10;    user: User | null;&#13;&#10;    error?: any;&#13;&#10;  }&gt; =&gt; {&#13;&#10;    console.log('DEBUG: ========== Starting checkAuthenticationWithUser ==========');&#13;&#10;    console.log('DEBUG: Current URL:', typeof window !== 'undefined' ? window.location.href : 'server-side');&#13;&#10;&#13;&#10;    try {&#13;&#10;      console.log('DEBUG: Making API call to /auth/me');&#13;&#10;      const response = await api.get('/auth/me', {&#13;&#10;        withCredentials: true,&#13;&#10;      });&#13;&#10;&#13;&#10;      console.log('DEBUG: API response status:', response.status);&#13;&#10;      console.log('DEBUG: API response data:', response.data.user);&#13;&#10;&#13;&#10;      // Check if the response indicates authentication success&#13;&#10;      if (response.data &amp;&amp; response.status === 200) {&#13;&#10;        console.log('DEBUG: Authentication successful, user data found');&#13;&#10;        return {&#13;&#10;          isAuthenticated: true,&#13;&#10;          user: response.data.user,&#13;&#10;        };&#13;&#10;      } else if (response.data &amp;&amp; !(response.status === 200)) {&#13;&#10;        console.log('DEBUG: Authentication failed - response indicates failure');&#13;&#10;        return {&#13;&#10;          isAuthenticated: false,&#13;&#10;          user: null,&#13;&#10;        };&#13;&#10;      } else {&#13;&#10;        console.log('DEBUG: Unexpected response format:', response.data);&#13;&#10;        return {&#13;&#10;          isAuthenticated: false,&#13;&#10;          user: null,&#13;&#10;        };&#13;&#10;      }&#13;&#10;    } catch (error: any) {&#13;&#10;      console.error('DEBUG: checkAuthenticationWithUser error:', error);&#13;&#10;      console.error('DEBUG: Error status:', error.response?.status);&#13;&#10;      console.error('DEBUG: Error data:', error.response?.data);&#13;&#10;&#13;&#10;      return {&#13;&#10;        isAuthenticated: false,&#13;&#10;        user: null,&#13;&#10;        error,&#13;&#10;      };&#13;&#10;    } finally {&#13;&#10;      console.log('DEBUG: ========== checkAuthenticationWithUser completed ==========');&#13;&#10;    }&#13;&#10;  }&#13;&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/client-frontend/src/services/userService.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/client-frontend/src/services/userService.ts" />
              <option name="originalContent" value="import api from '@/lib/api';&#10;import {ApiResponse, LecturerProfileUpdateRequest, PaginatedResponse, StudentProfileUpdateRequest, User} from '@/types';&#10;import {categoryService} from './categoryService';&#10;&#10;export const userService = {&#10;  async getProfile(userId: string): Promise&lt;User&gt; {&#10;    const response = await api.get(`/users/${userId}/profile`);&#10;    return response.data;&#10;  },&#10;&#10;  async updateProfile(userData: Partial&lt;User&gt;): Promise&lt;User&gt; {&#10;    console.log('Updating user profile with data:', userData);&#10;    const response = await api.put('/users/profile', userData);&#10;    return response.data;&#10;  },&#10;&#10;  async uploadAvatar(file: File): Promise&lt;ApiResponse&lt;string&gt;&gt; {&#10;    const formData = new FormData();&#10;    formData.append('avatar', file);&#10;    const response = await api.post('/users/avatar', formData, {&#10;      headers: {&#10;        'Content-Type': 'multipart/form-data',&#10;      },&#10;    });&#10;    return response.data;&#10;  },&#10;&#10;  async searchUsers(query: string, page = 0, size = 10): Promise&lt;PaginatedResponse&lt;User&gt;&gt; {&#10;    const response = await api.get(`/users/search?q=${query}&amp;page=${page}&amp;size=${size}`);&#10;    return response.data;&#10;  },&#10;&#10;  async followUser(userId: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#10;    const response = await api.post(`/users/${userId}/follow`);&#10;    return response.data;&#10;  },&#10;&#10;  async unfollowUser(userId: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#10;    const response = await api.delete(`/users/${userId}/follow`);&#10;    return response.data;&#10;  },&#10;&#10;  async getFollowers(userId: string, page = 0, size = 10): Promise&lt;PaginatedResponse&lt;User&gt;&gt; {&#10;    const response = await api.get(`/users/${userId}/followers?page=${page}&amp;size=${size}`);&#10;    return response.data;&#10;  },&#10;&#10;  async getFollowing(userId: string, page = 0, size = 10): Promise&lt;PaginatedResponse&lt;User&gt;&gt; {&#10;    const response = await api.get(`/users/${userId}/following?page=${page}&amp;size=${size}`);&#10;    return response.data;&#10;  },&#10;&#10;  async getFriends(userId: string, page = 0, size = 10): Promise&lt;PaginatedResponse&lt;User&gt;&gt; {&#10;    const response = await api.get(`/users/${userId}/friends?page=${page}&amp;size=${size}`);&#10;    return response.data;&#10;  },&#10;&#10;  async getMyProfile(): Promise&lt;User&gt; {&#10;    const response = await api.get('/users/me/profile');&#10;    return response.data;&#10;  },&#10;&#10;  async updateMyProfile(userData: StudentProfileUpdateRequest | LecturerProfileUpdateRequest): Promise&lt;User&gt; {&#10;    const response = await api.put('/users/me/profile', userData);&#10;    return response.data;&#10;  },&#10;&#10;  async checkProfileCompletion(): Promise&lt;boolean&gt; {&#10;    const response = await api.get('/users/checkMyInfo');&#10;    return response.data;&#10;  }&#10;};&#10;" />
              <option name="updatedContent" value="import api from '@/lib/api';&#10;import {ApiResponse, LecturerProfileUpdateRequest, PaginatedResponse, StudentProfileUpdateRequest, User} from '@/types';&#10;import {categoryService} from './categoryService';&#10;&#10;export const userService = {&#10;  async getProfile(userId: string): Promise&lt;User&gt; {&#10;    const response = await api.get(`/users/${userId}/profile`);&#10;    return response.data;&#10;  },&#10;&#10;  async updateProfile(userData: Partial&lt;User&gt;): Promise&lt;User&gt; {&#10;    console.log('Updating user profile with data:', userData);&#10;    const response = await api.put('/users/profile', userData);&#10;    return response.data;&#10;  },&#10;&#10;  async uploadAvatar(file: File): Promise&lt;ApiResponse&lt;string&gt;&gt; {&#10;    const formData = new FormData();&#10;    formData.append('avatar', file);&#10;    const response = await api.post('/users/avatar', formData, {&#10;      headers: {&#10;        'Content-Type': 'multipart/form-data',&#10;      },&#10;    });&#10;    return response.data;&#10;  },&#10;&#10;  async searchUsers(query: string, page = 0, size = 10): Promise&lt;PaginatedResponse&lt;User&gt;&gt; {&#10;    const response = await api.get(`/users/search?q=${query}&amp;page=${page}&amp;size=${size}`);&#10;    return response.data;&#10;  },&#10;&#10;  async followUser(userId: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#10;    const response = await api.post(`/users/${userId}/follow`);&#10;    return response.data;&#10;  },&#10;&#10;  async unfollowUser(userId: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#10;    const response = await api.delete(`/users/${userId}/follow`);&#10;    return response.data;&#10;  },&#10;&#10;  async getFollowers(userId: string, page = 0, size = 10): Promise&lt;PaginatedResponse&lt;User&gt;&gt; {&#10;    const response = await api.get(`/users/${userId}/followers?page=${page}&amp;size=${size}`);&#10;    return response.data;&#10;  },&#10;&#10;  async getFollowing(userId: string, page = 0, size = 10): Promise&lt;PaginatedResponse&lt;User&gt;&gt; {&#10;    const response = await api.get(`/users/${userId}/following?page=${page}&amp;size=${size}`);&#10;    return response.data;&#10;  },&#10;&#10;  async getFriends(userId: string, page = 0, size = 10): Promise&lt;PaginatedResponse&lt;User&gt;&gt; {&#10;    const response = await api.get(`/users/${userId}/friends?page=${page}&amp;size=${size}`);&#10;    return response.data;&#10;  },&#10;&#10;  async getMyProfile(): Promise&lt;User&gt; {&#10;    const response = await api.get('/users/me/profile');&#10;    return response.data;&#10;  },&#10;&#10;  async updateMyProfile(userData: StudentProfileUpdateRequest | LecturerProfileUpdateRequest): Promise&lt;User&gt; {&#10;    const response = await api.put('/users/me/profile', userData);&#10;    return response.data;&#10;  },&#10;&#10;  async checkProfileCompletion(): Promise&lt;boolean&gt; {&#10;    const response = await api.get('/users/checkMyInfo');&#10;    return response.data;&#10;  },&#10;&#10;  // ========================= FRIENDS MANAGEMENT =========================&#10;  &#10;  // Get current user's friends&#10;  async getMyFriends(): Promise&lt;PaginatedResponse&lt;User&gt;&gt; {&#10;    const response = await api.get('/users/me/friends');&#10;    return response.data;&#10;  },&#10;&#10;  // Get friend requests received&#10;  async getFriendRequests(): Promise&lt;User[]&gt; {&#10;    const response = await api.get('/users/me/friend-requests');&#10;    return response.data;&#10;  },&#10;&#10;  // Get friend requests sent  &#10;  async getSentFriendRequests(): Promise&lt;User[]&gt; {&#10;    const response = await api.get('/users/me/friend-requested');&#10;    return response.data;&#10;  },&#10;&#10;  // Get friend suggestions&#10;  async getFriendSuggestions(): Promise&lt;PaginatedResponse&lt;User&gt;&gt; {&#10;    const response = await api.get('/users/me/friend-suggestions');&#10;    return response.data;&#10;  },&#10;&#10;  // Get mutual friends with another user&#10;  async getMutualFriends(otherUserId: string): Promise&lt;PaginatedResponse&lt;User&gt;&gt; {&#10;    const response = await api.get(`/users/me/mutual-friends/${otherUserId}`);&#10;    return response.data;&#10;  },&#10;&#10;  // Send friend request&#10;  async sendFriendRequest(friendId: string): Promise&lt;ApiResponse&lt;string&gt;&gt; {&#10;    const response = await api.post(`/users/me/invite/${friendId}`);&#10;    return response.data;&#10;  },&#10;&#10;  // Accept friend request&#10;  async acceptFriendRequest(friendId: string): Promise&lt;ApiResponse&lt;string&gt;&gt; {&#10;    const response = await api.post(`/users/me/accept-invite/${friendId}`);&#10;    return response.data;&#10;  },&#10;&#10;  // Reject friend request&#10;  async rejectFriendRequest(friendId: string): Promise&lt;ApiResponse&lt;string&gt;&gt; {&#10;    const response = await api.post(`/users/me/reject-invite/${friendId}`);&#10;    return response.data;&#10;  },&#10;&#10;  // Remove friend&#10;  async removeFriend(friendId: string): Promise&lt;ApiResponse&lt;string&gt;&gt; {&#10;    const response = await api.delete(`/users/me/friends/${friendId}`);&#10;    return response.data;&#10;  }&#10;&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/client-frontend/src/services/websocket.service.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/client-frontend/src/services/websocket.service.ts" />
              <option name="originalContent" value="import SockJS from 'sockjs-client';&#10;import { Client, IMessage, StompSubscription } from '@stomp/stompjs';&#10;import { EventEmitter } from 'events';&#10;&#10;export interface ChatMessage {&#10;  readBy: any[];&#10;  id: string;&#10;  conversationId: string;&#10;  senderId: string;&#10;  content: string;&#10;  type: 'TEXT' | 'IMAGE' | 'FILE' | 'SYSTEM';&#10;  timestamp: Date;&#10;  replyTo?: string;&#10;  reactions?: { [key: string]: string[] };&#10;  attachments?: any[];&#10;}&#10;export interface ChatMessage {&#10;  readBy: any[];&#10;  id: string;&#10;  conversationId: string;&#10;  senderId: string;&#10;  content: string;&#10;  type: 'TEXT' | 'IMAGE' | 'FILE' | 'SYSTEM';&#10;  timestamp: Date;&#10;  replyTo?: string;&#10;  reactions?: { [key: string]: string[] };&#10;  attachments?: any[];&#10;}&#10;&#10;export interface TypingEvent {&#10;  userId: string;&#10;  conversationId: string;&#10;  isTyping: boolean;&#10;}&#10;&#10;export interface PresenceEvent {&#10;  userId: string;&#10;  status: 'ONLINE' | 'OFFLINE' | 'AWAY';&#10;}&#10;&#10;export class WebSocketService extends EventEmitter {&#10;  private client: Client | null = null;&#10;  private subscriptions: Map&lt;string, StompSubscription&gt; = new Map();&#10;  private reconnectAttempts = 0;&#10;  private maxReconnectAttempts = 5;&#10;  private reconnectInterval = 5000;&#10;  private isConnected = false;&#10;&#10;  constructor(private gatewayUrl: string = 'http://localhost:8090') {&#10;    super();&#10;  }&#10;&#10;  /**&#10;   * Connect to WebSocket server through API Gateway with JWT authentication&#10;   */&#10;  async connect(token: string): Promise&lt;void&gt; {&#10;    if (this.isConnected) {&#10;      console.warn('WebSocket already connected');&#10;      return;&#10;    }&#10;&#10;    try {&#10;      // Connect through API Gateway WebSocket endpoint&#10;      const socket = new SockJS(`${this.gatewayUrl}/ws/chat`);&#10;&#10;      this.client = new Client({&#10;        webSocketFactory: () =&gt; socket,&#10;        connectHeaders: {&#10;          'Authorization': `Bearer ${token}`,&#10;          // These headers will be processed by API Gateway's JWT filter&#10;          // and converted to X-User-Id, X-Username headers for downstream services&#10;        },&#10;        debug: (str) =&gt; console.debug('STOMP Debug:', str),&#10;        reconnectDelay: this.reconnectInterval,&#10;        heartbeatIncoming: 4000,&#10;        heartbeatOutgoing: 4000,&#10;      });&#10;&#10;      // Setup connection handlers&#10;      this.client.onConnect = (frame) =&gt; {&#10;        console.log('WebSocket connected through API Gateway:', frame);&#10;        this.isConnected = true;&#10;        this.reconnectAttempts = 0;&#10;        this.emit('connected');&#10;        this.setupGlobalSubscriptions();&#10;      };&#10;&#10;      this.client.onDisconnect = (frame) =&gt; {&#10;        console.log('WebSocket disconnected:', frame);&#10;        this.isConnected = false;&#10;        this.emit('disconnected');&#10;        this.cleanup();&#10;      };&#10;&#10;      this.client.onStompError = (frame) =&gt; {&#10;        console.error('WebSocket STOMP error:', frame);&#10;        this.emit('error', new Error(frame.body));&#10;      };&#10;&#10;      this.client.onWebSocketError = (error) =&gt; {&#10;        console.error('WebSocket error:', error);&#10;        this.emit('error', error);&#10;        this.handleReconnect();&#10;      };&#10;&#10;      // Activate the client&#10;      this.client.activate();&#10;    } catch (error) {&#10;      console.error('Failed to connect to WebSocket through API Gateway:', error);&#10;      throw error;&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Disconnect from WebSocket server&#10;   */&#10;  async disconnect(): Promise&lt;void&gt; {&#10;    if (this.client) {&#10;      this.client.deactivate();&#10;      this.cleanup();&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Join a conversation to receive real-time messages&#10;   */&#10;  joinConversation(conversationId: string): void {&#10;    if (!this.client || !this.isConnected) {&#10;      throw new Error('WebSocket not connected');&#10;    }&#10;&#10;    const destination = `/topic/conversations/${conversationId}`;&#10;&#10;    if (this.subscriptions.has(conversationId)) {&#10;      console.warn(`Already subscribed to conversation ${conversationId}`);&#10;      return;&#10;    }&#10;&#10;    const subscription = this.client.subscribe(destination, (message: IMessage) =&gt; {&#10;      try {&#10;        const chatMessage: ChatMessage = JSON.parse(message.body);&#10;        this.emit('message', chatMessage);&#10;      } catch (error) {&#10;        console.error('Error parsing message:', error);&#10;      }&#10;    });&#10;&#10;    this.subscriptions.set(conversationId, subscription);&#10;    console.log(`Joined conversation: ${conversationId}`);&#10;  }&#10;&#10;  /**&#10;   * Leave a conversation&#10;   */&#10;  leaveConversation(conversationId: string): void {&#10;    const subscription = this.subscriptions.get(conversationId);&#10;    if (subscription) {&#10;      subscription.unsubscribe();&#10;      this.subscriptions.delete(conversationId);&#10;      console.log(`Left conversation: ${conversationId}`);&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Send a chat message&#10;   */&#10;  sendMessage(conversationId: string, content: string, type: string = 'TEXT', replyTo?: string): void {&#10;    if (!this.client || !this.isConnected) {&#10;      throw new Error('WebSocket not connected');&#10;    }&#10;&#10;    const messagePayload = {&#10;      conversationId,&#10;      content,&#10;      type,&#10;      replyTo,&#10;      timestamp: new Date().toISOString()&#10;    };&#10;&#10;    this.client.publish({&#10;      destination: '/app/chat.sendMessage',&#10;      body: JSON.stringify(messagePayload)&#10;    });&#10;  }&#10;&#10;  /**&#10;   * Send typing indicator&#10;   */&#10;  sendTyping(conversationId: string, isTyping: boolean): void {&#10;    if (!this.client || !this.isConnected) {&#10;      return;&#10;    }&#10;&#10;    const typingPayload = {&#10;      conversationId,&#10;      isTyping,&#10;      timestamp: new Date().toISOString()&#10;    };&#10;&#10;    this.client.publish({&#10;      destination: '/app/chat.typing',&#10;      body: JSON.stringify(typingPayload)&#10;    });&#10;  }&#10;&#10;  /**&#10;   * Update user presence status&#10;   */&#10;  updatePresence(status: 'ONLINE' | 'AWAY' | 'OFFLINE'): void {&#10;    if (!this.client || !this.isConnected) {&#10;      return;&#10;    }&#10;&#10;    const presencePayload = {&#10;      status,&#10;      timestamp: new Date().toISOString()&#10;    };&#10;&#10;    this.client.publish({&#10;      destination: '/app/user.presence',&#10;      body: JSON.stringify(presencePayload)&#10;    });&#10;  }&#10;&#10;  /**&#10;   * Get connection status&#10;   */&#10;  isWebSocketConnected(): boolean {&#10;    return this.isConnected &amp;&amp; this.client?.connected === true;&#10;  }&#10;&#10;  /**&#10;   * Setup global subscriptions for user-specific events&#10;   */&#10;  private setupGlobalSubscriptions(): void {&#10;    if (!this.client || !this.isConnected) {&#10;      return;&#10;    }&#10;&#10;    // Subscribe to personal notifications&#10;    this.client.subscribe('/user/queue/notifications', (message: IMessage) =&gt; {&#10;      try {&#10;        const notification = JSON.parse(message.body);&#10;        this.emit('notification', notification);&#10;      } catch (error) {&#10;        console.error('Error parsing notification:', error);&#10;      }&#10;    });&#10;&#10;    // Subscribe to typing indicators&#10;    this.client.subscribe('/user/queue/typing', (message: IMessage) =&gt; {&#10;      try {&#10;        const typingEvent: TypingEvent = JSON.parse(message.body);&#10;        this.emit('typing', typingEvent);&#10;      } catch (error) {&#10;        console.error('Error parsing typing event:', error);&#10;      }&#10;    });&#10;&#10;    // Subscribe to presence updates&#10;    this.client.subscribe('/topic/presence', (message: IMessage) =&gt; {&#10;      try {&#10;        const presenceEvent: PresenceEvent = JSON.parse(message.body);&#10;        this.emit('presence', presenceEvent);&#10;      } catch (error) {&#10;        console.error('Error parsing presence event:', error);&#10;      }&#10;    });&#10;  }&#10;&#10;  /**&#10;   * Handle reconnection logic&#10;   */&#10;  private handleReconnect(): void {&#10;    if (this.reconnectAttempts &lt; this.maxReconnectAttempts) {&#10;      this.reconnectAttempts++;&#10;      console.log(`Attempting to reconnect... (${this.reconnectAttempts}/${this.maxReconnectAttempts})`);&#10;&#10;      setTimeout(() =&gt; {&#10;        if (!this.isConnected &amp;&amp; this.client) {&#10;          this.client.activate();&#10;        }&#10;      }, this.reconnectInterval);&#10;    } else {&#10;      console.error('Max reconnection attempts reached');&#10;      this.emit('maxReconnectAttemptsReached');&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Cleanup resources&#10;   */&#10;  private cleanup(): void {&#10;    this.subscriptions.forEach(subscription =&gt; subscription.unsubscribe());&#10;    this.subscriptions.clear();&#10;    this.isConnected = false;&#10;    this.client = null;&#10;  }&#10;}&#10;&#10;// Export singleton instance&#10;export const webSocketService = new WebSocketService();&#10;" />
              <option name="updatedContent" value="import SockJS from 'sockjs-client';&#10;import { Client, IMessage, StompSubscription } from '@stomp/stompjs';&#10;import { EventEmitter } from 'events';&#10;import { ChatMessage } from '@/shared/types/chat';&#10;&#10;export interface TypingEvent {&#10;  userId: string;&#10;  conversationId: string;&#10;  isTyping: boolean;&#10;}&#10;&#10;export interface PresenceEvent {&#10;  userId: string;&#10;  status: 'ONLINE' | 'OFFLINE' | 'AWAY';&#10;}&#10;&#10;export class WebSocketService extends EventEmitter {&#10;  private client: Client | null = null;&#10;  private subscriptions: Map&lt;string, StompSubscription&gt; = new Map();&#10;  private reconnectAttempts = 0;&#10;  private maxReconnectAttempts = 5;&#10;  private reconnectInterval = 5000;&#10;  private isConnected = false;&#10;&#10;  constructor(private gatewayUrl: string = 'http://localhost:8090') {&#10;    super();&#10;  }&#10;&#10;  /**&#10;   * Connect to WebSocket server through API Gateway with JWT authentication&#10;   */&#10;  async connect(token: string): Promise&lt;void&gt; {&#10;    if (this.isConnected) {&#10;      console.warn('WebSocket already connected');&#10;      return;&#10;    }&#10;&#10;    try {&#10;      // Connect through API Gateway WebSocket endpoint&#10;      const socket = new SockJS(`${this.gatewayUrl}/ws/chat`);&#10;&#10;      this.client = new Client({&#10;        webSocketFactory: () =&gt; socket,&#10;        connectHeaders: {&#10;          'Authorization': `Bearer ${token}`,&#10;          // These headers will be processed by API Gateway's JWT filter&#10;          // and converted to X-User-Id, X-Username headers for downstream services&#10;        },&#10;        debug: (str) =&gt; console.debug('STOMP Debug:', str),&#10;        reconnectDelay: this.reconnectInterval,&#10;        heartbeatIncoming: 4000,&#10;        heartbeatOutgoing: 4000,&#10;      });&#10;&#10;      // Setup connection handlers&#10;      this.client.onConnect = (frame) =&gt; {&#10;        console.log('WebSocket connected through API Gateway:', frame);&#10;        this.isConnected = true;&#10;        this.reconnectAttempts = 0;&#10;        this.emit('connected');&#10;        this.setupGlobalSubscriptions();&#10;      };&#10;&#10;      this.client.onDisconnect = (frame) =&gt; {&#10;        console.log('WebSocket disconnected:', frame);&#10;        this.isConnected = false;&#10;        this.emit('disconnected');&#10;        this.cleanup();&#10;      };&#10;&#10;      this.client.onStompError = (frame) =&gt; {&#10;        console.error('WebSocket STOMP error:', frame);&#10;        this.emit('error', new Error(frame.body));&#10;      };&#10;&#10;      this.client.onWebSocketError = (error) =&gt; {&#10;        console.error('WebSocket error:', error);&#10;        this.emit('error', error);&#10;        this.handleReconnect();&#10;      };&#10;&#10;      // Activate the client&#10;      this.client.activate();&#10;    } catch (error) {&#10;      console.error('Failed to connect to WebSocket through API Gateway:', error);&#10;      throw error;&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Disconnect from WebSocket server&#10;   */&#10;  async disconnect(): Promise&lt;void&gt; {&#10;    if (this.client) {&#10;      this.client.deactivate();&#10;      this.cleanup();&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Join a conversation to receive real-time messages&#10;   */&#10;  joinConversation(conversationId: string): void {&#10;    if (!this.client || !this.isConnected) {&#10;      throw new Error('WebSocket not connected');&#10;    }&#10;&#10;    const destination = `/topic/conversations/${conversationId}`;&#10;&#10;    if (this.subscriptions.has(conversationId)) {&#10;      console.warn(`Already subscribed to conversation ${conversationId}`);&#10;      return;&#10;    }&#10;&#10;    const subscription = this.client.subscribe(destination, (message: IMessage) =&gt; {&#10;      try {&#10;        const chatMessage: ChatMessage = JSON.parse(message.body);&#10;        this.emit('message', chatMessage);&#10;      } catch (error) {&#10;        console.error('Error parsing message:', error);&#10;      }&#10;    });&#10;&#10;    this.subscriptions.set(conversationId, subscription);&#10;    console.log(`Joined conversation: ${conversationId}`);&#10;  }&#10;&#10;  /**&#10;   * Leave a conversation&#10;   */&#10;  leaveConversation(conversationId: string): void {&#10;    const subscription = this.subscriptions.get(conversationId);&#10;    if (subscription) {&#10;      subscription.unsubscribe();&#10;      this.subscriptions.delete(conversationId);&#10;      console.log(`Left conversation: ${conversationId}`);&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Send a chat message&#10;   */&#10;  sendMessage(conversationId: string, content: string, type: string = 'TEXT', replyTo?: string): void {&#10;    if (!this.client || !this.isConnected) {&#10;      throw new Error('WebSocket not connected');&#10;    }&#10;&#10;    const messagePayload = {&#10;      conversationId,&#10;      content,&#10;      type,&#10;      replyTo,&#10;      timestamp: new Date().toISOString()&#10;    };&#10;&#10;    this.client.publish({&#10;      destination: '/app/chat.sendMessage',&#10;      body: JSON.stringify(messagePayload)&#10;    });&#10;  }&#10;&#10;  /**&#10;   * Send typing indicator&#10;   */&#10;  sendTyping(conversationId: string, isTyping: boolean): void {&#10;    if (!this.client || !this.isConnected) {&#10;      return;&#10;    }&#10;&#10;    const typingPayload = {&#10;      conversationId,&#10;      isTyping,&#10;      timestamp: new Date().toISOString()&#10;    };&#10;&#10;    this.client.publish({&#10;      destination: '/app/chat.typing',&#10;      body: JSON.stringify(typingPayload)&#10;    });&#10;  }&#10;&#10;  /**&#10;   * Update user presence status&#10;   */&#10;  updatePresence(status: 'ONLINE' | 'AWAY' | 'OFFLINE'): void {&#10;    if (!this.client || !this.isConnected) {&#10;      return;&#10;    }&#10;&#10;    const presencePayload = {&#10;      status,&#10;      timestamp: new Date().toISOString()&#10;    };&#10;&#10;    this.client.publish({&#10;      destination: '/app/user.presence',&#10;      body: JSON.stringify(presencePayload)&#10;    });&#10;  }&#10;&#10;  /**&#10;   * Get connection status&#10;   */&#10;  isWebSocketConnected(): boolean {&#10;    return this.isConnected &amp;&amp; this.client?.connected === true;&#10;  }&#10;&#10;  /**&#10;   * Setup global subscriptions for user-specific events&#10;   */&#10;  private setupGlobalSubscriptions(): void {&#10;    if (!this.client || !this.isConnected) {&#10;      return;&#10;    }&#10;&#10;    // Subscribe to personal notifications&#10;    this.client.subscribe('/user/queue/notifications', (message: IMessage) =&gt; {&#10;      try {&#10;        const notification = JSON.parse(message.body);&#10;        this.emit('notification', notification);&#10;      } catch (error) {&#10;        console.error('Error parsing notification:', error);&#10;      }&#10;    });&#10;&#10;    // Subscribe to typing indicators&#10;    this.client.subscribe('/user/queue/typing', (message: IMessage) =&gt; {&#10;      try {&#10;        const typingEvent: TypingEvent = JSON.parse(message.body);&#10;        this.emit('typing', typingEvent);&#10;      } catch (error) {&#10;        console.error('Error parsing typing event:', error);&#10;      }&#10;    });&#10;&#10;    // Subscribe to presence updates&#10;    this.client.subscribe('/topic/presence', (message: IMessage) =&gt; {&#10;      try {&#10;        const presenceEvent: PresenceEvent = JSON.parse(message.body);&#10;        this.emit('presence', presenceEvent);&#10;      } catch (error) {&#10;        console.error('Error parsing presence event:', error);&#10;      }&#10;    });&#10;  }&#10;&#10;  /**&#10;   * Handle reconnection logic&#10;   */&#10;  private handleReconnect(): void {&#10;    if (this.reconnectAttempts &lt; this.maxReconnectAttempts) {&#10;      this.reconnectAttempts++;&#10;      console.log(`Attempting to reconnect... (${this.reconnectAttempts}/${this.maxReconnectAttempts})`);&#10;&#10;      setTimeout(() =&gt; {&#10;        if (!this.isConnected &amp;&amp; this.client) {&#10;          this.client.activate();&#10;        }&#10;      }, this.reconnectInterval);&#10;    } else {&#10;      console.error('Max reconnection attempts reached');&#10;      this.emit('maxReconnectAttemptsReached');&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Cleanup resources&#10;   */&#10;  private cleanup(): void {&#10;    this.subscriptions.forEach(subscription =&gt; subscription.unsubscribe());&#10;    this.subscriptions.clear();&#10;    this.isConnected = false;&#10;    this.client = null;&#10;  }&#10;}&#10;&#10;// Export singleton instance&#10;export const webSocketService = new WebSocketService();" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/client-frontend/src/shared/constants/api-endpoints.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/client-frontend/src/shared/constants/api-endpoints.ts" />
              <option name="originalContent" value="// API Endpoints Constants for Client-Frontend&#10;export const API_ENDPOINTS = {&#10;  // Base URLs for services&#10;  BASE_URL: process.env.NEXT_PUBLIC_API_URL || 'http://localhost:8080',&#10;  &#10;  // Authentication endpoints&#10;  AUTH: {&#10;    BASE: '/api/auth',&#10;    LOGIN: '/api/auth/login',&#10;    REGISTER: '/api/auth/register',&#10;    REFRESH: '/api/auth/refresh',&#10;    LOGOUT: '/api/auth/logout',&#10;    VERIFY_EMAIL: '/api/auth/verify-email',&#10;    FORGOT_PASSWORD: '/api/auth/forgot-password',&#10;    RESET_PASSWORD: '/api/auth/reset-password',&#10;    PROFILE: '/api/auth/profile'&#10;  },&#10;&#10;  // User management endpoints&#10;  USERS: {&#10;    BASE: '/api/users',&#10;    PROFILE: '/api/users/profile',&#10;    BY_ID: '/api/users/:id',&#10;    UPDATE_PROFILE: '/api/users/profile',&#10;    SEARCH: '/api/users/search',&#10;    FRIENDS: '/api/users/:id/friends',&#10;    FRIEND_SUGGESTIONS: '/api/users/friend-suggestions',&#10;    SEND_FRIEND_REQUEST: '/api/users/:id/friend-request',&#10;    ACCEPT_FRIEND_REQUEST: '/api/users/:id/accept-friend',&#10;    MUTUAL_FRIENDS: '/api/users/:id/mutual-friends-count',&#10;    TIMELINE: '/api/users/:id/timeline',&#10;    ACTIVITIES: '/api/users/:id/activities'&#10;  },&#10;&#10;  // Post management endpoints&#10;  POSTS: {&#10;    BASE: '/api/posts',&#10;    BY_ID: '/api/posts/:id',&#10;    BY_USER: '/api/posts/user/:userId',&#10;    FEED: '/api/posts/feed',&#10;    TRENDING: '/api/posts/trending',&#10;    TIMELINE: '/api/posts/timeline/:userId',&#10;    SEARCH: '/api/posts/search',&#10;    LIKE: '/api/posts/:id/interact',&#10;    COMMENTS: '/api/posts/:id/comments',&#10;    COMMENT_LIKE: '/api/posts/comments/:id/like',&#10;    SCHEDULE: '/api/posts/schedule',&#10;    ANALYTICS: '/api/posts/:id/analytics'&#10;  },&#10;&#10;  // Chat endpoints&#10;  CHAT: {&#10;    BASE: '/api/chats',&#10;    ROOMS: '/api/chats/conversations',&#10;    MESSAGES: '/api/chats/messages',&#10;    SEND_MESSAGE: '/api/chats/messages',&#10;    MARK_READ: '/api/chats/messages/:id/read',&#10;    ROOM_READ: '/api/chats/conversations/:id/read',&#10;    UNREAD_COUNT: '/api/chats/messages/unread-count',&#10;    ONLINE_USERS: '/api/chats/users/online',&#10;    TYPING_START: '/api/chats/conversations/:roomId/typing/start',&#10;    TYPING_STOP: '/api/chats/conversations/:roomId/typing/stop',&#10;    USER_PRESENCE: '/api/chats/users/presence'&#10;  },&#10;&#10;  // Media endpoints&#10;  MEDIA: {&#10;    BASE: '/api/media',&#10;    UPLOAD: '/api/media/upload',&#10;    BY_ID: '/api/media/:id'&#10;  },&#10;&#10;  // Notification endpoints&#10;  NOTIFICATIONS: {&#10;    BASE: '/api/notifications',&#10;    UNREAD_COUNT: '/api/notifications/unread-count',&#10;    MARK_READ: '/api/notifications/:id/read',&#10;    MARK_ALL_READ: '/api/notifications/mark-all-read'&#10;  },&#10;&#10;  // Analytics endpoints&#10;  ANALYTICS: {&#10;    BASE: '/api/analytics',&#10;    USER_STATS: '/api/analytics/users/:id/stats',&#10;    POST_STATS: '/api/analytics/posts/:id/stats'&#10;  }&#10;};&#10;&#10;// API Response types&#10;export interface ApiResponse&lt;T = any&gt; {&#10;  success: boolean;&#10;  data?: T;&#10;  message?: string;&#10;  errors?: string[];&#10;}&#10;&#10;export interface PaginatedResponse&lt;T = any&gt; {&#10;  content: T[];&#10;  totalElements: number;&#10;  totalPages: number;&#10;  size: number;&#10;  number: number;&#10;  first: boolean;&#10;  last: boolean;&#10;}&#10;" />
              <option name="updatedContent" value="// API Endpoints Constants for Client-Frontend&#13;&#10;export const API_ENDPOINTS = {&#13;&#10;  // Base URLs for services&#13;&#10;  BASE_URL: process.env.NEXT_PUBLIC_API_URL || 'http://localhost:8080',&#13;&#10;  &#13;&#10;  // Authentication endpoints&#13;&#10;  AUTH: {&#13;&#10;    BASE: '/api/auth',&#13;&#10;    LOGIN: '/api/auth/login',&#13;&#10;    REGISTER: '/api/auth/register',&#13;&#10;    REFRESH: '/api/auth/refresh',&#13;&#10;    LOGOUT: '/api/auth/logout',&#13;&#10;    VERIFY_EMAIL: '/api/auth/verify-email',&#13;&#10;    FORGOT_PASSWORD: '/api/auth/forgot-password',&#13;&#10;    RESET_PASSWORD: '/api/auth/reset-password',&#13;&#10;    PROFILE: '/api/auth/profile'&#13;&#10;  },&#13;&#10;&#13;&#10;  // User management endpoints&#13;&#10;  USERS: {&#13;&#10;    BASE: '/api/users',&#13;&#10;    PROFILE: '/api/users/profile',&#13;&#10;    BY_ID: '/api/users/:id',&#13;&#10;    UPDATE_PROFILE: '/api/users/profile',&#13;&#10;    SEARCH: '/api/users/search',&#13;&#10;    FRIENDS: '/api/users/:id/friends',&#13;&#10;    MY_FRIENDS: '/api/users/me/friends',&#13;&#10;    FRIEND_REQUESTS: '/api/users/me/friend-requests',&#13;&#10;    FRIEND_REQUESTED: '/api/users/me/friend-requested',&#13;&#10;    FRIEND_SUGGESTIONS: '/api/users/me/friend-suggestions',&#13;&#10;    MUTUAL_FRIENDS: '/api/users/me/mutual-friends/:id',&#13;&#10;    SEND_FRIEND_REQUEST: '/api/users/me/invite/:id',&#13;&#10;    ACCEPT_FRIEND_REQUEST: '/api/users/me/accept-invite/:id',&#13;&#10;    REJECT_FRIEND_REQUEST: '/api/users/me/reject-invite/:id',&#13;&#10;    REMOVE_FRIEND: '/api/users/me/friends/:id',&#13;&#10;    TIMELINE: '/api/users/:id/timeline',&#13;&#10;    ACTIVITIES: '/api/users/:id/activities'&#13;&#10;  },&#13;&#10;&#13;&#10;  // Post management endpoints&#13;&#10;  POSTS: {&#13;&#10;    BASE: '/api/posts',&#13;&#10;    BY_ID: '/api/posts/:id',&#13;&#10;    BY_USER: '/api/posts/user/:userId',&#13;&#10;    FEED: '/api/posts/feed',&#13;&#10;    TRENDING: '/api/posts/trending',&#13;&#10;    TIMELINE: '/api/posts/timeline/:userId',&#13;&#10;    SEARCH: '/api/posts/search',&#13;&#10;    LIKE: '/api/posts/:id/interact',&#13;&#10;    COMMENTS: '/api/posts/:id/comments',&#13;&#10;    COMMENT_LIKE: '/api/posts/comments/:id/like',&#13;&#10;    SCHEDULE: '/api/posts/schedule',&#13;&#10;    ANALYTICS: '/api/posts/:id/analytics'&#13;&#10;  },&#13;&#10;&#13;&#10;  // Chat endpoints&#13;&#10;  CHAT: {&#13;&#10;    BASE: '/api/chats',&#13;&#10;    ROOMS: '/api/chats/conversations',&#13;&#10;    MESSAGES: '/api/chats/messages',&#13;&#10;    SEND_MESSAGE: '/api/chats/messages',&#13;&#10;    MARK_READ: '/api/chats/messages/:id/read',&#13;&#10;    ROOM_READ: '/api/chats/conversations/:id/read',&#13;&#10;    UNREAD_COUNT: '/api/chats/messages/unread-count',&#13;&#10;    ONLINE_USERS: '/api/chats/users/online',&#13;&#10;    TYPING_START: '/api/chats/conversations/:roomId/typing/start',&#13;&#10;    TYPING_STOP: '/api/chats/conversations/:roomId/typing/stop',&#13;&#10;    USER_PRESENCE: '/api/chats/users/presence'&#13;&#10;  },&#13;&#10;&#13;&#10;  // Media endpoints&#13;&#10;  MEDIA: {&#13;&#10;    BASE: '/api/media',&#13;&#10;    UPLOAD: '/api/media/upload',&#13;&#10;    BY_ID: '/api/media/:id'&#13;&#10;  },&#13;&#10;&#13;&#10;  // Notification endpoints&#13;&#10;  NOTIFICATIONS: {&#13;&#10;    BASE: '/api/notifications',&#13;&#10;    UNREAD_COUNT: '/api/notifications/unread-count',&#13;&#10;    MARK_READ: '/api/notifications/:id/read',&#13;&#10;    MARK_ALL_READ: '/api/notifications/mark-all-read'&#13;&#10;  },&#13;&#10;&#13;&#10;  // Analytics endpoints&#13;&#10;  ANALYTICS: {&#13;&#10;    BASE: '/api/analytics',&#13;&#10;    USER_STATS: '/api/analytics/users/:id/stats',&#13;&#10;    POST_STATS: '/api/analytics/posts/:id/stats'&#13;&#10;  }&#13;&#10;};&#13;&#10;&#13;&#10;// API Response types&#13;&#10;export interface ApiResponse&lt;T = any&gt; {&#13;&#10;  success: boolean;&#13;&#10;  data?: T;&#13;&#10;  message?: string;&#13;&#10;  errors?: string[];&#13;&#10;}&#13;&#10;&#13;&#10;export interface PaginatedResponse&lt;T = any&gt; {&#13;&#10;  content: T[];&#13;&#10;  totalElements: number;&#13;&#10;  totalPages: number;&#13;&#10;  size: number;&#13;&#10;  number: number;&#13;&#10;  first: boolean;&#13;&#10;  last: boolean;&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/client-frontend/src/shared/services/post.service.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/client-frontend/src/shared/services/post.service.ts" />
              <option name="originalContent" value="import { apiClient } from '@/shared/config/api-client';&#10;import { API_ENDPOINTS } from '@/shared/constants';&#10;import { createApiUrl } from '@/shared/utils';&#10;import {&#10;  Post,&#10;  Comment,&#10;  CreatePostRequest,&#10;  UpdatePostRequest,&#10;  CreateCommentRequest,&#10;  UpdateCommentRequest,&#10;  PaginatedResponse,&#10;  ApiResponse,&#10;  PostVisibility,&#10;} from '@/shared/types';&#10;&#10;/**&#10; * Post Service&#10; * Handles all post-related API calls&#10; * Handles all post-related API calls&#10; * Handles all post-related API calls&#10; * Handles all post-related API calls&#10;   * Create new post&#10;   * Create new post&#10;    const formData = new FormData();&#10;    formData.append('content', postData.content);&#10;&#10;    if (postData.visibility) {&#10;      formData.append('visibility', postData.visibility);&#10;    }&#10;    formData.append('content', postData.content);&#10;    if (postData.tags) {&#10;      postData.tags.forEach(tag =&gt; formData.append('tags', tag));&#10;    }&#10;&#10;    if (postData.images) {&#10;      postData.images.forEach(image =&gt; formData.append('images', image));&#10;    }&#10;&#10;    return apiClient.post&lt;Post&gt;(API_ENDPOINTS.POSTS.BASE, formData, {&#10;      headers: {&#10;        'Content-Type': 'multipart/form-data',&#10;      },&#10;    });&#10;      postData.tags.forEach(tag =&gt; formData.append('tags', tag));&#10;    }&#10;&#10;    if (postData.images) {&#10;      postData.images.forEach(image =&gt; formData.append('images', image));&#10;    return apiClient.post&lt;Post&gt;(API_ENDPOINTS.POSTS.BASE, formData, {&#10;      headers: {&#10;        'Content-Type': 'multipart/form-data',&#10;      },&#10;    });&#10;      postData.tags.forEach(tag =&gt; formData.append('tags', tag));&#10;    }&#10;&#10;    if (postData.images) {&#10;      postData.images.forEach(image =&gt; formData.append('images', image));&#10;    }&#10;    if (postData.visibility) {&#10;    return apiClient.post&lt;Post&gt;(API_ENDPOINTS.POSTS.BASE, formData, {&#10;      headers: {&#10;        'Content-Type': 'multipart/form-data',&#10;      },&#10;    });&#10;      postData.tags.forEach(tag =&gt; formData.append('tags', tag));&#10;    }&#10;&#10;    if (postData.images) {&#10;      postData.images.forEach(image =&gt; formData.append('images', image));&#10;    }&#10;&#10;    return apiClient.post&lt;Post&gt;(API_ENDPOINTS.POSTS.BASE, formData, {&#10;      headers: {&#10;        'Content-Type': 'multipart/form-data',&#10;      },&#10;    });&#10;&#10;    if (postData.images) {&#10;      postData.images.forEach(image =&gt; formData.append('images', image));&#10;    }&#10;    if (postData.visibility) {&#10;    return apiClient.post&lt;Post&gt;(API_ENDPOINTS.POSTS.BASE, formData, {&#10;      headers: {&#10;        'Content-Type': 'multipart/form-data',&#10;      },&#10;    });&#10;      postData.tags.forEach(tag =&gt; formData.append('tags', tag));&#10;    }&#10;&#10;    if (postData.images) {&#10;      postData.images.forEach(image =&gt; formData.append('images', image));&#10;    return apiClient.post&lt;Post&gt;(API_ENDPOINTS.POSTS.BASE, formData, {&#10;      headers: {&#10;        'Content-Type': 'multipart/form-data',&#10;      },&#10;    });&#10;      postData.tags.forEach(tag =&gt; formData.append('tags', tag));&#10;    }&#10;&#10;    if (postData.images) {&#10;      postData.images.forEach(image =&gt; formData.append('images', image));&#10;    }&#10;&#10;    return apiClient.post&lt;Post&gt;(API_ENDPOINTS.POSTS.BASE, formData, {&#10;      headers: {&#10;        'Content-Type': 'multipart/form-data',&#10;      },&#10;    });&#10;      postData.tags.forEach(tag =&gt; formData.append('tags', tag));&#10;    }&#10;&#10;    if (postData.images) {&#10;      postData.images.forEach(image =&gt; formData.append('images', image));&#10;    }&#10;&#10;    return apiClient.post&lt;Post&gt;(API_ENDPOINTS.POSTS.BASE, formData, {&#10;      headers: {&#10;        'Content-Type': 'multipart/form-data',&#10;      },&#10;    });&#10;&#10;    if (postData.images) {&#10;      postData.images.forEach(image =&gt; formData.append('images', image));&#10;    }&#10;&#10;    return apiClient.post&lt;Post&gt;(API_ENDPOINTS.POSTS.BASE, formData, {&#10;      headers: {&#10;        'Content-Type': 'multipart/form-data',&#10;      },&#10;    });&#10;      postData.tags.forEach(tag =&gt; formData.append('tags', tag));&#10;    }&#10;&#10;    if (postData.images) {&#10;      postData.images.forEach(image =&gt; formData.append('images', image));&#10;    return apiClient.post&lt;Post&gt;(API_ENDPOINTS.POSTS.BASE, formData, {&#10;      headers: {&#10;        'Content-Type': 'multipart/form-data',&#10;      },&#10;    });&#10;      postData.tags.forEach(tag =&gt; formData.append('tags', tag));&#10;    }&#10;&#10;    if (postData.images) {&#10;      postData.images.forEach(image =&gt; formData.append('images', image));&#10;    }&#10;    if (postData.visibility) {&#10;    return apiClient.post&lt;Post&gt;(API_ENDPOINTS.POSTS.BASE, formData, {&#10;      headers: {&#10;        'Content-Type': 'multipart/form-data',&#10;      },&#10;    });&#10;      postData.tags.forEach(tag =&gt; formData.append('tags', tag));&#10;    }&#10;&#10;    if (postData.images) {&#10;      postData.images.forEach(image =&gt; formData.append('images', image));&#10;    }&#10;&#10;    return apiClient.post&lt;Post&gt;(API_ENDPOINTS.POSTS.BASE, formData, {&#10;      headers: {&#10;        'Content-Type': 'multipart/form-data',&#10;      },&#10;    });&#10;&#10;    if (postData.images) {&#10;      postData.images.forEach(image =&gt; formData.append('images', image));&#10;    }&#10;&#10;    return apiClient.post&lt;Post&gt;(API_ENDPOINTS.POSTS.BASE, formData, {&#10;      headers: {&#10;        'Content-Type': 'multipart/form-data',&#10;      },&#10;    });&#10;      postData.tags.forEach(tag =&gt; formData.append('tags', tag));&#10;    }&#10;&#10;    if (postData.images) {&#10;      postData.images.forEach(image =&gt; formData.append('images', image));&#10;    return apiClient.post&lt;Post&gt;(API_ENDPOINTS.POSTS.BASE, formData, {&#10;      headers: {&#10;        'Content-Type': 'multipart/form-data',&#10;      },&#10;    });&#10;      postData.tags.forEach(tag =&gt; formData.append('tags', tag));&#10;    }&#10;&#10;    if (postData.images) {&#10;      postData.images.forEach(image =&gt; formData.append('images', image));&#10;    }&#10;&#10;    return apiClient.post&lt;Post&gt;(API_ENDPOINTS.POSTS.BASE, formData, {&#10;      headers: {&#10;        'Content-Type': 'multipart/form-data',&#10;      },&#10;    });&#10;      postData.tags.forEach(tag =&gt; formData.append('tags', tag));&#10;    }&#10;&#10;    if (postData.images) {&#10;      postData.images.forEach(image =&gt; formData.append('images', image));&#10;    }&#10;&#10;    return apiClient.post&lt;Post&gt;(API_ENDPOINTS.POSTS.BASE, formData, {&#10;      headers: {&#10;        'Content-Type': 'multipart/form-data',&#10;      },&#10;    });&#10;  }&#10;&#10;  /**&#10;   * Get posts feed&#10;   */&#10;  async getPosts(page = 0, size = 10): Promise&lt;PaginatedResponse&lt;Post&gt;&gt; {&#10;    const url = createApiUrl(API_ENDPOINTS.POSTS.BASE, undefined, { page, size });&#10;    return apiClient.get&lt;PaginatedResponse&lt;Post&gt;&gt;(url);&#10;  }&#10;&#10;  /**&#10;   * Get single post by ID&#10;   */&#10;  async getPost(postId: string): Promise&lt;Post&gt; {&#10;    const url = createApiUrl(API_ENDPOINTS.POSTS.BASE + '/:id', { id: postId });&#10;    return apiClient.get&lt;Post&gt;(url);&#10;  }&#10;&#10;  /**&#10;   * Get posts by user&#10;   */&#10;  async getUserPosts(&#10;    userId: string,&#10;    page = 0,&#10;    size = 10&#10;  ): Promise&lt;PaginatedResponse&lt;Post&gt;&gt; {&#10;    const url = createApiUrl(&#10;      API_ENDPOINTS.POSTS.BY_USER,&#10;      { id: userId },&#10;      { page, size }&#10;    );&#10;    return apiClient.get&lt;PaginatedResponse&lt;Post&gt;&gt;(url);&#10;  }&#10;&#10;  /**&#10;   * Update post&#10;   */&#10;  async updatePost(postId: string, updateData: UpdatePostRequest): Promise&lt;Post&gt; {&#10;    const url = createApiUrl(API_ENDPOINTS.POSTS.BASE + '/:id', { id: postId });&#10;    return apiClient.put&lt;Post&gt;(url, updateData);&#10;  }&#10;&#10;  /**&#10;   * Delete post&#10;   */&#10;  async deletePost(postId: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#10;    const url = createApiUrl(API_ENDPOINTS.POSTS.BASE + '/:id', { id: postId });&#10;    return apiClient.delete&lt;ApiResponse&lt;null&gt;&gt;(url);&#10;  }&#10;&#10;  /**&#10;   * Like post&#10;   */&#10;  async likePost(postId: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#10;    const url = createApiUrl(API_ENDPOINTS.POSTS.LIKE, { id: postId });&#10;    return apiClient.post&lt;ApiResponse&lt;null&gt;&gt;(url);&#10;  }&#10;&#10;  /**&#10;   * Unlike post&#10;   */&#10;  async unlikePost(postId: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#10;    const url = createApiUrl(API_ENDPOINTS.POSTS.LIKE, { id: postId });&#10;    return apiClient.delete&lt;ApiResponse&lt;null&gt;&gt;(url);&#10;  }&#10;&#10;  /**&#10;   * Get post comments&#10;   */&#10;  async getComments(&#10;    postId: string,&#10;    page = 0,&#10;    size = 10&#10;  ): Promise&lt;PaginatedResponse&lt;Comment&gt;&gt; {&#10;    const url = createApiUrl(&#10;      API_ENDPOINTS.POSTS.COMMENTS,&#10;      { id: postId },&#10;      { page, size }&#10;    );&#10;    return apiClient.get&lt;PaginatedResponse&lt;Comment&gt;&gt;(url);&#10;  }&#10;&#10;  /**&#10;   * Create comment&#10;   */&#10;  async createComment(commentData: CreateCommentRequest): Promise&lt;Comment&gt; {&#10;    const url = createApiUrl(API_ENDPOINTS.POSTS.COMMENTS, { id: commentData.postId });&#10;    return apiClient.post&lt;Comment&gt;(url, {&#10;      content: commentData.content,&#10;      parentId: commentData.parentId,&#10;    });&#10;  }&#10;&#10;  /**&#10;   * Update comment&#10;   */&#10;  async updateComment(&#10;    commentId: string,&#10;    updateData: UpdateCommentRequest&#10;  ): Promise&lt;Comment&gt; {&#10;    const url = createApiUrl('/comments/:id', { id: commentId });&#10;    return apiClient.put&lt;Comment&gt;(url, updateData);&#10;  }&#10;&#10;  /**&#10;   * Delete comment&#10;   */&#10;  async deleteComment(commentId: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#10;    const url = createApiUrl('/comments/:id', { id: commentId });&#10;    return apiClient.delete&lt;ApiResponse&lt;null&gt;&gt;(url);&#10;  }&#10;&#10;  /**&#10;   * Like comment&#10;   */&#10;  async likeComment(commentId: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#10;    const url = createApiUrl(API_ENDPOINTS.POSTS.COMMENT_LIKE, { id: commentId });&#10;    return apiClient.post&lt;ApiResponse&lt;null&gt;&gt;(url);&#10;  }&#10;&#10;  /**&#10;   * Unlike comment&#10;   */&#10;  async unlikeComment(commentId: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#10;    const url = createApiUrl(API_ENDPOINTS.POSTS.COMMENT_LIKE, { id: commentId });&#10;    return apiClient.delete&lt;ApiResponse&lt;null&gt;&gt;(url);&#10;  }&#10;&#10;  /**&#10;   * Share post&#10;   */&#10;  async sharePost(postId: string, content?: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#10;    const url = createApiUrl('/posts/:id/share', { id: postId });&#10;    return apiClient.post&lt;ApiResponse&lt;null&gt;&gt;(url, { content });&#10;  }&#10;&#10;  /**&#10;   * Bookmark post&#10;   */&#10;  async bookmarkPost(postId: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#10;    const url = createApiUrl('/posts/:id/bookmark', { id: postId });&#10;    return apiClient.post&lt;ApiResponse&lt;null&gt;&gt;(url);&#10;  }&#10;&#10;  /**&#10;   * Remove bookmark&#10;   */&#10;  async removeBookmark(postId: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#10;    const url = createApiUrl('/posts/:id/bookmark', { id: postId });&#10;    return apiClient.delete&lt;ApiResponse&lt;null&gt;&gt;(url);&#10;  }&#10;}&#10;&#10;// Export singleton instance&#10;export const postService = new PostService();&#10;" />
              <option name="updatedContent" value="import { apiClient } from '@/shared/config/api-client';&#13;&#10;import { API_ENDPOINTS } from '@/shared/constants';&#13;&#10;import { createApiUrl } from '@/shared/utils';&#13;&#10;import {&#13;&#10;  Post,&#13;&#10;  Comment,&#13;&#10;  CreatePostRequest,&#13;&#10;  UpdatePostRequest,&#13;&#10;  CreateCommentRequest,&#13;&#10;  UpdateCommentRequest,&#13;&#10;  PaginatedResponse,&#13;&#10;  ApiResponse,&#13;&#10;  PostVisibility,&#13;&#10;} from '@/shared/types';&#13;&#10;&#13;&#10;/**&#13;&#10; * Post Service - Updated to sync with backend APIs&#13;&#10; */&#13;&#10;export class PostService {&#13;&#10;  /**&#13;&#10;   * Create new post - Updated to match EnhancedPostController&#13;&#10;   */&#13;&#10;  async createPost(postData: CreatePostRequest): Promise&lt;Post&gt; {&#13;&#10;    // Use JSON instead of FormData to match EnhancedPostController&#13;&#10;    return apiClient.post&lt;Post&gt;(API_ENDPOINTS.POSTS.BASE, postData);&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Get personalized feed - Updated to match backend&#13;&#10;   */&#13;&#10;  async getPersonalizedFeed(page = 0, size = 10): Promise&lt;Post[]&gt; {&#13;&#10;    const url = createApiUrl(API_ENDPOINTS.POSTS.FEED, undefined, { page, size });&#13;&#10;    return apiClient.get&lt;Post[]&gt;(url);&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Get posts feed&#13;&#10;   */&#13;&#10;  async getPosts(page = 0, size = 10): Promise&lt;PaginatedResponse&lt;Post&gt;&gt; {&#13;&#10;    const url = createApiUrl(API_ENDPOINTS.POSTS.BASE, undefined, { page, size });&#13;&#10;    return apiClient.get&lt;PaginatedResponse&lt;Post&gt;&gt;(url);&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Get single post by ID&#13;&#10;   */&#13;&#10;  async getPost(postId: string): Promise&lt;Post&gt; {&#13;&#10;    const url = createApiUrl(API_ENDPOINTS.POSTS.BASE + '/:id', { id: postId });&#13;&#10;    return apiClient.get&lt;Post&gt;(url);&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Get posts by user&#13;&#10;   */&#13;&#10;  async getUserPosts(&#13;&#10;    userId: string,&#13;&#10;    page = 0,&#13;&#10;    size = 10&#13;&#10;  ): Promise&lt;PaginatedResponse&lt;Post&gt;&gt; {&#13;&#10;    const url = createApiUrl(&#13;&#10;      API_ENDPOINTS.POSTS.BY_USER,&#13;&#10;      { id: userId },&#13;&#10;      { page, size }&#13;&#10;    );&#13;&#10;    return apiClient.get&lt;PaginatedResponse&lt;Post&gt;&gt;(url);&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Update post&#13;&#10;   */&#13;&#10;  async updatePost(postId: string, updateData: UpdatePostRequest): Promise&lt;Post&gt; {&#13;&#10;    const url = createApiUrl(API_ENDPOINTS.POSTS.BASE + '/:id', { id: postId });&#13;&#10;    return apiClient.put&lt;Post&gt;(url, updateData);&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Delete post&#13;&#10;   */&#13;&#10;  async deletePost(postId: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#13;&#10;    const url = createApiUrl(API_ENDPOINTS.POSTS.BASE + '/:id', { id: postId });&#13;&#10;    return apiClient.delete&lt;ApiResponse&lt;null&gt;&gt;(url);&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Like post&#13;&#10;   */&#13;&#10;  async likePost(postId: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#13;&#10;    const url = createApiUrl(API_ENDPOINTS.POSTS.LIKE, { id: postId });&#13;&#10;    return apiClient.post&lt;ApiResponse&lt;null&gt;&gt;(url);&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Unlike post&#13;&#10;   */&#13;&#10;  async unlikePost(postId: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#13;&#10;    const url = createApiUrl(API_ENDPOINTS.POSTS.LIKE, { id: postId });&#13;&#10;    return apiClient.delete&lt;ApiResponse&lt;null&gt;&gt;(url);&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Get post comments&#13;&#10;   */&#13;&#10;  async getComments(&#13;&#10;    postId: string,&#13;&#10;    page = 0,&#13;&#10;    size = 10&#13;&#10;  ): Promise&lt;PaginatedResponse&lt;Comment&gt;&gt; {&#13;&#10;    const url = createApiUrl(&#13;&#10;      API_ENDPOINTS.POSTS.COMMENTS,&#13;&#10;      { id: postId },&#13;&#10;      { page, size }&#13;&#10;    );&#13;&#10;    return apiClient.get&lt;PaginatedResponse&lt;Comment&gt;&gt;(url);&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Create comment&#13;&#10;   */&#13;&#10;  async createComment(commentData: CreateCommentRequest): Promise&lt;Comment&gt; {&#13;&#10;    const url = createApiUrl(API_ENDPOINTS.POSTS.COMMENTS, { id: commentData.postId });&#13;&#10;    return apiClient.post&lt;Comment&gt;(url, {&#13;&#10;      content: commentData.content,&#13;&#10;      parentId: commentData.parentId,&#13;&#10;    });&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Update comment&#13;&#10;   */&#13;&#10;  async updateComment(&#13;&#10;    commentId: string,&#13;&#10;    updateData: UpdateCommentRequest&#13;&#10;  ): Promise&lt;Comment&gt; {&#13;&#10;    const url = createApiUrl('/comments/:id', { id: commentId });&#13;&#10;    return apiClient.put&lt;Comment&gt;(url, updateData);&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Delete comment&#13;&#10;   */&#13;&#10;  async deleteComment(commentId: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#13;&#10;    const url = createApiUrl('/comments/:id', { id: commentId });&#13;&#10;    return apiClient.delete&lt;ApiResponse&lt;null&gt;&gt;(url);&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Like comment&#13;&#10;   */&#13;&#10;  async likeComment(commentId: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#13;&#10;    const url = createApiUrl(API_ENDPOINTS.POSTS.COMMENT_LIKE, { id: commentId });&#13;&#10;    return apiClient.post&lt;ApiResponse&lt;null&gt;&gt;(url);&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Unlike comment&#13;&#10;   */&#13;&#10;  async unlikeComment(commentId: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#13;&#10;    const url = createApiUrl(API_ENDPOINTS.POSTS.COMMENT_LIKE, { id: commentId });&#13;&#10;    return apiClient.delete&lt;ApiResponse&lt;null&gt;&gt;(url);&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Share post&#13;&#10;   */&#13;&#10;  async sharePost(postId: string, content?: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#13;&#10;    const url = createApiUrl('/posts/:id/share', { id: postId });&#13;&#10;    return apiClient.post&lt;ApiResponse&lt;null&gt;&gt;(url, { content });&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Bookmark post&#13;&#10;   */&#13;&#10;  async bookmarkPost(postId: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#13;&#10;    const url = createApiUrl('/posts/:id/bookmark', { id: postId });&#13;&#10;    return apiClient.post&lt;ApiResponse&lt;null&gt;&gt;(url);&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Remove bookmark&#13;&#10;   */&#13;&#10;  async removeBookmark(postId: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#13;&#10;    const url = createApiUrl('/posts/:id/bookmark', { id: postId });&#13;&#10;    return apiClient.delete&lt;ApiResponse&lt;null&gt;&gt;(url);&#13;&#10;  }&#13;&#10;}&#13;&#10;&#13;&#10;// Export singleton instance&#13;&#10;export const postService = new PostService();" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/client-frontend/src/shared/types/user.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/client-frontend/src/shared/types/user.ts" />
              <option name="originalContent" value="import { BaseEntity } from './common';&#10;&#10;// ============================&#10;// User Model&#10;// ============================&#10;export interface User extends BaseEntity {&#10;  email: string;&#10;  username: string;&#10;  fullName: string;&#10;  avatar?: string;&#10;  bio?: string;&#10;  faculty?: string;&#10;  yearOfStudy?: number;&#10;  isVerified: boolean;&#10;  isOnline: boolean;&#10;  followersCount?: number;&#10;  followingCount?: number;&#10;  postsCount?: number;&#10;}&#10;&#10;// ============================&#10;// User Profile (Extended User Info)&#10;// ============================&#10;export interface UserProfile extends User {&#10;  avatarUrl?: string;&#10;  facultyId?: string;&#10;  facultyName?: string;&#10;  majorId?: string;&#10;  majorName?: string;&#10;  batchId?: string;&#10;  batchName?: string;&#10;  collegeId?: string;&#10;  collegeName?: string;&#10;  genderId?: string;&#10;  phoneNumber?: string;&#10;  dateOfBirth?: string;&#10;  address?: string;&#10;  interests?: string[];&#10;  socialLinks?: {&#10;    facebook?: string;&#10;    twitter?: string;&#10;    linkedin?: string;&#10;    instagram?: string;&#10;  };&#10;  privacySettings?: {&#10;    profileVisibility: 'PUBLIC' | 'FRIENDS' | 'PRIVATE';&#10;    contactInfoVisibility: 'PUBLIC' | 'FRIENDS' | 'PRIVATE';&#10;  };&#10;}&#10;&#10;// ============================&#10;// Create / Update DTOs&#10;// ============================&#10;export interface CreateUserRequest {&#10;  email: string;&#10;  username: string;&#10;  fullName: string;&#10;  password: string;&#10;}&#10;&#10;export interface UpdateUserRequest {&#10;  fullName?: string;&#10;  bio?: string;&#10;  faculty?: string;&#10;  yearOfStudy?: number;&#10;}&#10;&#10;// ============================&#10;// Update Profile Request (More comprehensive than UpdateUserRequest)&#10;// ============================&#10;export interface UpdateProfileRequest {&#10;  fullName?: string;&#10;  bio?: string;&#10;  facultyId?: string;&#10;  majorId?: string;&#10;  batchId?: string;&#10;  collegeId?: string;&#10;  genderId?: string;&#10;  phoneNumber?: string;&#10;  dateOfBirth?: string;&#10;  address?: string;&#10;  interests?: string[];&#10;  socialLinks?: {&#10;    facebook?: string;&#10;    twitter?: string;&#10;    linkedin?: string;&#10;    instagram?: string;&#10;  };&#10;  privacySettings?: {&#10;    profileVisibility: 'PUBLIC' | 'FRIENDS' | 'PRIVATE';&#10;    contactInfoVisibility: 'PUBLIC' | 'FRIENDS' | 'PRIVATE';&#10;  };&#10;}&#10;&#10;// ============================&#10;// Relationship&#10;// ============================&#10;export interface UserRelationship {&#10;  id: string;&#10;  followerId: string;&#10;  followingId: string;&#10;  createdAt: string;&#10;}&#10;&#10;// ============================&#10;// Stats Object&#10;// ============================&#10;export interface UserStats {&#10;  postsCount: number;&#10;  followersCount: number;&#10;  followingCount: number;&#10;  friendsCount: number;&#10;}&#10;" />
              <option name="updatedContent" value="import { BaseEntity } from './common';&#13;&#10;&#13;&#10;// ============================&#13;&#10;// User Model&#13;&#10;// ============================&#13;&#10;export interface User extends BaseEntity {&#13;&#10;  email: string;&#13;&#10;  username: string;&#13;&#10;  fullName: string;&#13;&#10;  avatar?: string;&#13;&#10;  bio?: string;&#13;&#10;  faculty?: string;&#13;&#10;  yearOfStudy?: number;&#13;&#10;  isVerified: boolean;&#13;&#10;  isOnline: boolean;&#13;&#10;  followersCount?: number;&#13;&#10;  followingCount?: number;&#13;&#10;  postsCount?: number;&#13;&#10;}&#13;&#10;&#13;&#10;// ============================&#13;&#10;// User Profile (Extended User Info)&#13;&#10;// ============================&#13;&#10;export interface UserProfile extends User {&#13;&#10;  avatarUrl?: string;&#13;&#10;  facultyId?: string;&#13;&#10;  facultyName?: string;&#13;&#10;  majorId?: string;&#13;&#10;  majorName?: string;&#13;&#10;  batchId?: string;&#13;&#10;  batchName?: string;&#13;&#10;  collegeId?: string;&#13;&#10;  collegeName?: string;&#13;&#10;  genderId?: string;&#13;&#10;  phoneNumber?: string;&#13;&#10;  dateOfBirth?: string;&#13;&#10;  address?: string;&#13;&#10;  interests?: string[];&#13;&#10;  socialLinks?: {&#13;&#10;    facebook?: string;&#13;&#10;    twitter?: string;&#13;&#10;    linkedin?: string;&#13;&#10;    instagram?: string;&#13;&#10;  };&#13;&#10;  privacySettings?: {&#13;&#10;    profileVisibility: 'PUBLIC' | 'FRIENDS' | 'PRIVATE';&#13;&#10;    contactInfoVisibility: 'PUBLIC' | 'FRIENDS' | 'PRIVATE';&#13;&#10;  };&#13;&#10;}&#13;&#10;&#13;&#10;// ============================&#13;&#10;// Create / Update DTOs&#13;&#10;// ============================&#13;&#10;export interface CreateUserRequest {&#13;&#10;  email: string;&#13;&#10;  username: string;&#13;&#10;  fullName: string;&#13;&#10;  password: string;&#13;&#10;}&#13;&#10;&#13;&#10;export interface UpdateUserRequest {&#13;&#10;  fullName?: string;&#13;&#10;  bio?: string;&#13;&#10;  faculty?: string;&#13;&#10;  yearOfStudy?: number;&#13;&#10;}&#13;&#10;&#13;&#10;// ============================&#13;&#10;// Update Profile Request (More comprehensive than UpdateUserRequest)&#13;&#10;// ============================&#13;&#10;export interface UpdateProfileRequest {&#13;&#10;  fullName?: string;&#13;&#10;  bio?: string;&#13;&#10;  facultyId?: string;&#13;&#10;  majorId?: string;&#13;&#10;  batchId?: string;&#13;&#10;  collegeId?: string;&#13;&#10;  genderId?: string;&#13;&#10;  phoneNumber?: string;&#13;&#10;  dateOfBirth?: string;&#13;&#10;  address?: string;&#13;&#10;  interests?: string[];&#13;&#10;  socialLinks?: {&#13;&#10;    facebook?: string;&#13;&#10;    twitter?: string;&#13;&#10;    linkedin?: string;&#13;&#10;    instagram?: string;&#13;&#10;  };&#13;&#10;  privacySettings?: {&#13;&#10;    profileVisibility: 'PUBLIC' | 'FRIENDS' | 'PRIVATE';&#13;&#10;    contactInfoVisibility: 'PUBLIC' | 'FRIENDS' | 'PRIVATE';&#13;&#10;  };&#13;&#10;}&#13;&#10;&#13;&#10;// ============================&#13;&#10;// Relationship&#13;&#10;// ============================&#13;&#10;export interface UserRelationship {&#13;&#10;  id: string;&#13;&#10;  followerId: string;&#13;&#10;  followingId: string;&#13;&#10;  createdAt: string;&#13;&#10;}&#13;&#10;&#13;&#10;// ============================&#13;&#10;// Stats Object&#13;&#10;// ============================&#13;&#10;export interface UserStats {&#13;&#10;  postsCount: number;&#13;&#10;  followersCount: number;&#13;&#10;  followingCount: number;&#13;&#10;  friendsCount: number;&#13;&#10;}&#13;&#10;&#13;&#10;// ============================&#13;&#10;// Friends Feature Types&#13;&#10;// ============================&#13;&#10;export interface FriendsDTO {&#13;&#10;  userId?: string;&#13;&#10;  friendIds?: string[];&#13;&#10;  friends?: User[];&#13;&#10;  mutualFriends?: User[];&#13;&#10;  friendSuggestions?: User[];&#13;&#10;  mutualFriendsCount?: number;&#13;&#10;}&#13;&#10;&#13;&#10;export interface FriendSuggestionDTO {&#13;&#10;  userId: string;&#13;&#10;  username: string;&#13;&#10;  fullName: string;&#13;&#10;  avatarUrl?: string;&#13;&#10;  mutualFriendsCount: number;&#13;&#10;  suggestionReason: string;&#13;&#10;  relevanceScore: number;&#13;&#10;  suggestionType: 'MUTUAL_FRIENDS' | 'ACADEMIC_CONNECTION' | 'FRIENDS_OF_FRIENDS' | 'PROFILE_VIEWERS' | 'SIMILAR_INTERESTS';&#13;&#10;}&#13;&#10;&#13;&#10;export interface RelationshipFilterDTO {&#13;&#10;  sameCollege?: boolean;&#13;&#10;  sameFaculty?: boolean;&#13;&#10;  sameMajor?: boolean;&#13;&#10;  sameBatch?: boolean;&#13;&#10;  college?: string;&#13;&#10;  faculty?: string;&#13;&#10;  major?: string;&#13;&#10;  batch?: string;&#13;&#10;  gender?: string;&#13;&#10;}&#13;&#10;&#13;&#10;// Friendship status enum&#13;&#10;export type FriendshipStatus = 'FRIENDS' | 'REQUEST_SENT' | 'REQUEST_RECEIVED' | 'NOT_FRIENDS';" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/PostServiceApplication.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/PostServiceApplication.java" />
              <option name="originalContent" value="package com.ctuconnect;&#10;&#10;import org.springframework.boot.SpringApplication;&#10;import org.springframework.boot.autoconfigure.SpringBootApplication;&#10;import org.springframework.cloud.client.discovery.EnableDiscoveryClient;&#10;import org.springframework.cloud.openfeign.EnableFeignClients;&#10;import org.springframework.kafka.annotation.EnableKafka;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.ctuconnect;&#13;&#10;&#13;&#10;import org.springframework.boot.SpringApplication;&#13;&#10;import org.springframework.boot.autoconfigure.SpringBootApplication;&#13;&#10;import org.springframework.cloud.client.discovery.EnableDiscoveryClient;&#13;&#10;import org.springframework.cloud.openfeign.EnableFeignClients;&#13;&#10;import org.springframework.kafka.annotation.EnableKafka;&#13;&#10;import org.springframework.data.mongodb.config.EnableMongoAuditing;&#13;&#10;&#13;&#10;@SpringBootApplication&#13;&#10;@EnableDiscoveryClient&#13;&#10;@EnableFeignClients&#13;&#10;@EnableKafka&#13;&#10;@EnableMongoAuditing // Enable MongoDB auditing for @CreatedDate and @LastModifiedDate&#13;&#10;public class PostServiceApplication {&#13;&#10;&#13;&#10;    public static void main(String[] args) {&#13;&#10;        SpringApplication.run(PostServiceApplication.class, args);&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/client/MediaServiceClient.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/client/MediaServiceClient.java" />
              <option name="originalContent" value="package com.ctuconnect.client;&#10;&#10;import lombok.Data;&#10;import org.springframework.cloud.openfeign.FeignClient;&#10;import org.springframework.http.MediaType;&#10;import org.springframework.web.bind.annotation.*;&#10;import org.springframework.web.multipart.MultipartFile;&#10;&#10;        public void setId(String id) {&#10;            this.id = id;&#10;@FeignClient(name = &quot;media-service&quot;, url = &quot;${media-service.url:http://localhost:8080}&quot;)&#10;        public String getFileName() {&#10;            return fileName;&#10;        }&#10;&#10;        public void setFileName(String fileName) {&#10;            this.fileName = fileName;&#10;        }&#10;&#10;        public String getFileUrl() {&#10;            return fileUrl;&#10;        }&#10;&#10;        public void setFileUrl(String fileUrl) {&#10;            this.fileUrl = fileUrl;&#10;        }&#10;&#10;        public String getFileType() {&#10;            return fileType;&#10;        }&#10;&#10;        public void setFileType(String fileType) {&#10;            this.fileType = fileType;&#10;        }&#10;&#10;        public long getFileSize() {&#10;            return fileSize;&#10;        }&#10;&#10;        public void setFileSize(long fileSize) {&#10;            this.fileSize = fileSize;&#10;        }&#10;    }&#10;&#10;    @Data&#10;    class MediaResponse {&#10;        private String id;&#10;        private String fileName;&#10;        private String fileUrl;&#10;        private String fileType;&#10;        private long fileSize;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.ctuconnect.client;&#13;&#10;&#13;&#10;import lombok.Data;&#13;&#10;import org.springframework.cloud.openfeign.FeignClient;&#13;&#10;import org.springframework.http.MediaType;&#13;&#10;import org.springframework.web.bind.annotation.*;&#13;&#10;import org.springframework.web.multipart.MultipartFile;&#13;&#10;import com.ctuconnect.config.FeignConfig;&#13;&#10;&#13;&#10;@FeignClient(&#13;&#10;    name = &quot;media-service&quot;, &#13;&#10;    url = &quot;${media-service.url}&quot;, &#13;&#10;    configuration = FeignConfig.class&#13;&#10;)&#13;&#10;public interface MediaServiceClient {&#13;&#10;&#13;&#10;    @PostMapping(value = &quot;/api/media/upload&quot;, consumes = MediaType.MULTIPART_FORM_DATA_VALUE)&#13;&#10;    MediaUploadResponse uploadFile(@RequestPart(&quot;file&quot;) MultipartFile file,&#13;&#10;                                  @RequestParam(&quot;type&quot;) String type);&#13;&#10;&#13;&#10;    @DeleteMapping(&quot;/api/media/{id}&quot;)&#13;&#10;    void deleteFile(@PathVariable(&quot;id&quot;) String fileId);&#13;&#10;&#13;&#10;    @GetMapping(&quot;/api/media/{id}&quot;)&#13;&#10;    MediaResponse getFileInfo(@PathVariable(&quot;id&quot;) String fileId);&#13;&#10;&#13;&#10;    // Response DTOs for media service&#13;&#10;    class MediaUploadResponse {&#13;&#10;        private String id;&#13;&#10;        private String fileName;&#13;&#10;        private String fileUrl;&#13;&#10;        private String fileType;&#13;&#10;        private long fileSize;&#13;&#10;&#13;&#10;        // Getters and Setters&#13;&#10;        public String getId() {&#13;&#10;            return id;&#13;&#10;        }&#13;&#10;&#13;&#10;        public void setId(String id) {&#13;&#10;            this.id = id;&#13;&#10;        }&#13;&#10;&#13;&#10;        public String getFileName() {&#13;&#10;            return fileName;&#13;&#10;        }&#13;&#10;&#13;&#10;        public void setFileName(String fileName) {&#13;&#10;            this.fileName = fileName;&#13;&#10;        }&#13;&#10;&#13;&#10;        public String getFileUrl() {&#13;&#10;            return fileUrl;&#13;&#10;        }&#13;&#10;&#13;&#10;        public void setFileUrl(String fileUrl) {&#13;&#10;            this.fileUrl = fileUrl;&#13;&#10;        }&#13;&#10;&#13;&#10;        public String getFileType() {&#13;&#10;            return fileType;&#13;&#10;        }&#13;&#10;&#13;&#10;        public void setFileType(String fileType) {&#13;&#10;            this.fileType = fileType;&#13;&#10;        }&#13;&#10;&#13;&#10;        public long getFileSize() {&#13;&#10;            return fileSize;&#13;&#10;        }&#13;&#10;&#13;&#10;        public void setFileSize(long fileSize) {&#13;&#10;            this.fileSize = fileSize;&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    @Data&#13;&#10;    class MediaResponse {&#13;&#10;        private String id;&#13;&#10;        private String fileName;&#13;&#10;        private String fileUrl;&#13;&#10;        private String fileType;&#13;&#10;        private long fileSize;&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/client/UserServiceClientFallback.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/client/UserServiceClientFallback.java" />
              <option name="updatedContent" value="package com.ctuconnect.client;&#10;&#10;import com.ctuconnect.dto.AuthorInfo;&#10;import lombok.extern.slf4j.Slf4j;&#10;import org.springframework.stereotype.Component;&#10;&#10;import java.util.HashSet;&#10;import java.util.Set;&#10;&#10;/**&#10; * Fallback implementation for UserServiceClient when user-service is unavailable&#10; * Provides default values to prevent service failures&#10; */&#10;@Component&#10;@Slf4j&#10;public class UserServiceClientFallback implements UserServiceClient {&#10;&#10;    @Override&#10;    public AuthorInfo getAuthorInfo(String authorId) {&#10;        log.warn(&quot;User service unavailable, returning fallback author info for user: {}&quot;, authorId);&#10;        return AuthorInfo.builder()&#10;                .userId(authorId)&#10;                .username(&quot;Unknown User&quot;)&#10;                .fullName(&quot;Unknown User&quot;)&#10;                .avatarUrl(null)&#10;                .isVerified(false)&#10;                .build();&#10;    }&#10;&#10;    @Override&#10;    public Set&lt;String&gt; getFriendIds(String userId) {&#10;        log.warn(&quot;User service unavailable, returning empty friend list for user: {}&quot;, userId);&#10;        return new HashSet&lt;&gt;();&#10;    }&#10;&#10;    @Override&#10;    public Set&lt;String&gt; getCloseInteractionIds(String userId) {&#10;        log.warn(&quot;User service unavailable, returning empty close interactions for user: {}&quot;, userId);&#10;        return new HashSet&lt;&gt;();&#10;    }&#10;&#10;    @Override&#10;    public Set&lt;String&gt; getSameFacultyUserIds(String userId) {&#10;        log.warn(&quot;User service unavailable, returning empty same faculty users for user: {}&quot;, userId);&#10;        return new HashSet&lt;&gt;();&#10;    }&#10;&#10;    @Override&#10;    public Set&lt;String&gt; getSameMajorUserIds(String userId) {&#10;        log.warn(&quot;User service unavailable, returning empty same major users for user: {}&quot;, userId);&#10;        return new HashSet&lt;&gt;();&#10;    }&#10;&#10;    @Override&#10;    public Set&lt;String&gt; getUserInterestTags(String userId) {&#10;        log.warn(&quot;User service unavailable, returning empty interest tags for user: {}&quot;, userId);&#10;        return new HashSet&lt;&gt;();&#10;    }&#10;&#10;    @Override&#10;    public Set&lt;String&gt; getUserPreferredCategories(String userId) {&#10;        log.warn(&quot;User service unavailable, returning empty preferred categories for user: {}&quot;, userId);&#10;        return new HashSet&lt;&gt;();&#10;    }&#10;&#10;    @Override&#10;    public String getUserFacultyId(String userId) {&#10;        log.warn(&quot;User service unavailable, returning null faculty ID for user: {}&quot;, userId);&#10;        return null;&#10;    }&#10;&#10;    @Override&#10;    public String getUserMajorId(String userId) {&#10;        log.warn(&quot;User service unavailable, returning null major ID for user: {}&quot;, userId);&#10;        return null;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/config/CacheConfig.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/config/CacheConfig.java" />
              <option name="updatedContent" value="package com.ctuconnect.config;&#10;&#10;import org.springframework.beans.factory.annotation.Value;&#10;import org.springframework.context.annotation.Bean;&#10;import org.springframework.context.annotation.Configuration;&#10;import org.springframework.data.redis.connection.RedisConnectionFactory;&#10;import org.springframework.data.redis.connection.lettuce.LettuceConnectionFactory;&#10;import org.springframework.data.redis.core.RedisTemplate;&#10;import org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer;&#10;import org.springframework.data.redis.serializer.StringRedisSerializer;&#10;&#10;@Configuration&#10;public class CacheConfig {&#10;&#10;    @Value(&quot;${spring.data.redis.host:localhost}&quot;)&#10;    private String redisHost;&#10;&#10;    @Value(&quot;${spring.data.redis.port:6379}&quot;)&#10;    private int redisPort;&#10;&#10;    @Bean&#10;    public RedisConnectionFactory redisConnectionFactory() {&#10;        return new LettuceConnectionFactory(redisHost, redisPort);&#10;    }&#10;&#10;    @Bean&#10;    public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory connectionFactory) {&#10;        RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;();&#10;        template.setConnectionFactory(connectionFactory);&#10;        &#10;        // Use String serializer for keys&#10;        template.setKeySerializer(new StringRedisSerializer());&#10;        template.setHashKeySerializer(new StringRedisSerializer());&#10;        &#10;        // Use JSON serializer for values&#10;        template.setValueSerializer(new GenericJackson2JsonRedisSerializer());&#10;        template.setHashValueSerializer(new GenericJackson2JsonRedisSerializer());&#10;        &#10;        template.afterPropertiesSet();&#10;        return template;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/config/FeignConfig.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/config/FeignConfig.java" />
              <option name="updatedContent" value="package com.ctuconnect.config;&#10;&#10;import feign.Logger;&#10;import feign.Request;&#10;import feign.Retryer;&#10;import feign.codec.ErrorDecoder;&#10;import org.springframework.context.annotation.Bean;&#10;import org.springframework.context.annotation.Configuration;&#10;&#10;import java.util.concurrent.TimeUnit;&#10;&#10;/**&#10; * Feign client configuration for better error handling and retry mechanism&#10; */&#10;@Configuration&#10;public class FeignConfig {&#10;&#10;    @Bean&#10;    Logger.Level feignLoggerLevel() {&#10;        return Logger.Level.BASIC;&#10;    }&#10;&#10;    @Bean&#10;    public Request.Options requestOptions() {&#10;        return new Request.Options(&#10;                10, TimeUnit.SECONDS, // connect timeout&#10;                60, TimeUnit.SECONDS, // read timeout&#10;                true // follow redirects&#10;        );&#10;    }&#10;&#10;    @Bean&#10;    public Retryer retryer() {&#10;        return new Retryer.Default(&#10;                1000, // initial interval&#10;                3000, // max interval&#10;                3     // max attempts&#10;        );&#10;    }&#10;&#10;    @Bean&#10;    public ErrorDecoder errorDecoder() {&#10;        return new CustomFeignErrorDecoder();&#10;    }&#10;&#10;    /**&#10;     * Custom error decoder to handle service communication errors gracefully&#10;     */&#10;    public static class CustomFeignErrorDecoder implements ErrorDecoder {&#10;        &#10;        @Override&#10;        public Exception decode(String methodKey, feign.Response response) {&#10;            switch (response.status()) {&#10;                case 400:&#10;                    return new IllegalArgumentException(&quot;Bad Request: &quot; + methodKey);&#10;                case 404:&#10;                    return new RuntimeException(&quot;Service not found: &quot; + methodKey);&#10;                case 500:&#10;                    return new RuntimeException(&quot;Internal Server Error in &quot; + methodKey);&#10;                case 503:&#10;                    return new RuntimeException(&quot;Service Unavailable: &quot; + methodKey);&#10;                default:&#10;                    return new RuntimeException(&quot;Unknown error occurred in &quot; + methodKey + &quot;: &quot; + response.status());&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/config/HealthCheckConfig.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/config/HealthCheckConfig.java" />
              <option name="updatedContent" value="package com.ctuconnect.config;&#10;&#10;import org.springframework.boot.actuator.health.Health;&#10;import org.springframework.boot.actuator.health.HealthIndicator;&#10;import org.springframework.context.annotation.Bean;&#10;import org.springframework.context.annotation.Configuration;&#10;import org.springframework.data.redis.connection.RedisConnectionFactory;&#10;import org.springframework.data.mongodb.core.MongoTemplate;&#10;&#10;@Configuration&#10;public class HealthCheckConfig {&#10;    &#10;    @Bean&#10;    public HealthIndicator redisHealthIndicator(RedisConnectionFactory redisConnectionFactory) {&#10;        return () -&gt; {&#10;            try {&#10;                redisConnectionFactory.getConnection().ping();&#10;                return Health.up()&#10;                    .withDetail(&quot;redis&quot;, &quot;Available&quot;)&#10;                    .build();&#10;            } catch (Exception e) {&#10;                return Health.down()&#10;                    .withDetail(&quot;redis&quot;, &quot;Unavailable&quot;)&#10;                    .withDetail(&quot;error&quot;, e.getMessage())&#10;                    .build();&#10;            }&#10;        };&#10;    }&#10;    &#10;    @Bean&#10;    public HealthIndicator mongoHealthIndicator(MongoTemplate mongoTemplate) {&#10;        return () -&gt; {&#10;            try {&#10;                mongoTemplate.getCollection(&quot;health_check&quot;).countDocuments();&#10;                return Health.up()&#10;                    .withDetail(&quot;mongodb&quot;, &quot;Available&quot;)&#10;                    .build();&#10;            } catch (Exception e) {&#10;                return Health.down()&#10;                    .withDetail(&quot;mongodb&quot;, &quot;Unavailable&quot;)&#10;                    .withDetail(&quot;error&quot;, e.getMessage())&#10;                    .build();&#10;            }&#10;        };&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/config/WebSocketConfig.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/config/WebSocketConfig.java" />
              <option name="updatedContent" value="package com.ctuconnect.config;&#10;&#10;import org.springframework.context.annotation.Configuration;&#10;import org.springframework.messaging.simp.config.MessageBrokerRegistry;&#10;import org.springframework.web.socket.config.annotation.EnableWebSocketMessageBroker;&#10;import org.springframework.web.socket.config.annotation.StompEndpointRegistry;&#10;import org.springframework.web.socket.config.annotation.WebSocketMessageBrokerConfigurer;&#10;&#10;@Configuration&#10;@EnableWebSocketMessageBroker&#10;public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {&#10;&#10;    @Override&#10;    public void configureMessageBroker(MessageBrokerRegistry config) {&#10;        // Enable simple message broker for in-memory message handling&#10;        config.enableSimpleBroker(&quot;/topic&quot;, &quot;/queue&quot;);&#10;        config.setApplicationDestinationPrefixes(&quot;/app&quot;);&#10;        config.setUserDestinationPrefix(&quot;/user&quot;);&#10;    }&#10;&#10;    @Override&#10;    public void registerStompEndpoints(StompEndpointRegistry registry) {&#10;        // Register STOMP endpoints for WebSocket connections&#10;        registry.addEndpoint(&quot;/ws&quot;)&#10;                .setAllowedOriginPatterns(&quot;*&quot;)&#10;                .withSockJS();&#10;        &#10;        registry.addEndpoint(&quot;/ws-notifications&quot;)&#10;                .setAllowedOriginPatterns(&quot;*&quot;)&#10;                .withSockJS();&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/controller/EnhancedPostController.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/controller/EnhancedPostController.java" />
              <option name="updatedContent" value="// This file has been merged into PostController.java&#10;// Delete this file to avoid conflicts" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/dto/request/InteractionRequest.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/dto/request/InteractionRequest.java" />
              <option name="originalContent" value="package com.ctuconnect.dto.request;&#10;&#10;import jakarta.validation.constraints.NotNull;&#10;import lombok.AllArgsConstructor;&#10;import lombok.Builder;&#10;import lombok.Data;&#10;import lombok.NoArgsConstructor;&#10;import com.ctuconnect.entity.InteractionEntity;&#10;&#10;import java.util.HashMap;&#10;import java.util.Map;&#10;&#10;@Data&#10;@AllArgsConstructor&#10;@NoArgsConstructor&#10;@Builder&#10;public class InteractionRequest {&#10;&#10;    @NotNull(message = &quot;Interaction type is required&quot;)&#10;    private InteractionEntity.InteractionType reaction;&#10;&#10;        } else {&#10;            throw new IllegalArgumentException(&quot;Interaction type cannot be null&quot;);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.ctuconnect.dto.request;&#10;&#10;import jakarta.validation.constraints.NotNull;&#10;import lombok.AllArgsConstructor;&#10;import lombok.Builder;&#10;import lombok.Data;&#10;import lombok.NoArgsConstructor;&#10;import com.ctuconnect.entity.InteractionEntity;&#10;&#10;import java.util.HashMap;&#10;import java.util.Map;&#10;&#10;@Data&#10;@AllArgsConstructor&#10;@NoArgsConstructor&#10;@Builder&#10;public class InteractionRequest {&#10;&#10;    @NotNull(message = &quot;Interaction type is required&quot;)&#10;    private InteractionEntity.InteractionType reaction;&#10;&#10;    // Add missing reactionType field for specific reaction types&#10;    private InteractionEntity.ReactionType reactionType;&#10;&#10;    private Map&lt;String, Object&gt; metadata = new HashMap&lt;&gt;();&#10;&#10;    public void setType(String s) {&#10;        if (s != null) {&#10;            try {&#10;                this.reaction = InteractionEntity.InteractionType.valueOf(s.toUpperCase());&#10;            } catch (IllegalArgumentException e) {&#10;                throw new IllegalArgumentException(&quot;Invalid interaction type: &quot; + s);&#10;            }&#10;        } else {&#10;            throw new IllegalArgumentException(&quot;Interaction type cannot be null&quot;);&#10;        }&#10;    }&#10;&#10;    // Add missing setReactionType method&#10;    public void setReactionType(InteractionEntity.ReactionType reactionType) {&#10;        this.reactionType = reactionType;&#10;    }&#10;&#10;    // Add getter for reactionType&#10;    public InteractionEntity.ReactionType getReactionType() {&#10;        return this.reactionType;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/dto/response/InteractionResponse.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/dto/response/InteractionResponse.java" />
              <option name="originalContent" value="package com.ctuconnect.dto.response;&#10;&#10;import com.ctuconnect.entity.InteractionEntity;&#10;import lombok.*;&#10;&#10;import java.time.LocalDateTime;&#10;import java.util.Map;&#10;&#10;@Data&#10;@Builder&#10;@AllArgsConstructor&#10;public class InteractionResponse {&#10;&#10;    // Getters and Setters&#10;    private String id;&#10;    private String postId;&#10;    private String userId;&#10;    private InteractionEntity.InteractionType type;&#10;    private Map&lt;String, Object&gt; metadata;&#10;    private LocalDateTime createdAt;&#10;&#10;    // New fields for status responses&#10;    private boolean hasInteraction;&#10;    private String message;&#10;&#10;    // Constructors&#10;    public InteractionResponse() {}&#10;&#10;    public InteractionResponse(InteractionEntity interaction) {&#10;        this.id = interaction.getId();&#10;        this.postId = interaction.getPostId();&#10;        this.userId = interaction.getUserId();&#10;        this.type = interaction.getType();&#10;        this.metadata = interaction.getMetadata();&#10;        this.createdAt = interaction.getCreatedAt();&#10;        this.hasInteraction = true;&#10;    }&#10;&#10;    // Constructor for status responses&#10;    public InteractionResponse(boolean hasInteraction, String message) {&#10;        this.hasInteraction = hasInteraction;&#10;        this.message = message;&#10;    }&#10;&#10;}&#10;" />
              <option name="updatedContent" value="package com.ctuconnect.dto.response;&#13;&#10;&#13;&#10;import com.ctuconnect.entity.InteractionEntity;&#13;&#10;import lombok.*;&#13;&#10;&#13;&#10;import java.time.LocalDateTime;&#13;&#10;import java.util.Map;&#13;&#10;&#13;&#10;@Data&#13;&#10;@Builder&#13;&#10;@AllArgsConstructor&#13;&#10;public class InteractionResponse {&#13;&#10;&#13;&#10;    // Getters and Setters&#13;&#10;    private String id;&#13;&#10;    private String postId;&#13;&#10;    private String userId;&#13;&#10;    private InteractionEntity.InteractionType type;&#13;&#10;    private Map&lt;String, Object&gt; metadata;&#13;&#10;    private LocalDateTime createdAt;&#13;&#10;&#13;&#10;    // New fields for status responses&#13;&#10;    private boolean hasInteraction;&#13;&#10;    private String message;&#13;&#10;&#13;&#10;    // Constructors&#13;&#10;    public InteractionResponse() {}&#13;&#10;&#13;&#10;    public InteractionResponse(InteractionEntity interaction) {&#13;&#10;        this.id = interaction.getId();&#13;&#10;        this.postId = interaction.getPostId();&#13;&#10;        this.userId = interaction.getUserId();&#13;&#10;        this.type = interaction.getType();&#13;&#10;        this.metadata = interaction.getMetadata();&#13;&#10;        this.createdAt = interaction.getCreatedAt();&#13;&#10;        this.hasInteraction = true;&#13;&#10;    }&#13;&#10;&#13;&#10;    // Constructor for status responses&#13;&#10;    public InteractionResponse(boolean hasInteraction, String message) {&#13;&#10;        this.hasInteraction = hasInteraction;&#13;&#10;        this.message = message;&#13;&#10;    }&#13;&#10;&#13;&#10;    // Add missing isActive method - this determines if the interaction is currently active&#13;&#10;    public boolean isActive() {&#13;&#10;        return this.hasInteraction;&#13;&#10;    }&#13;&#10;&#13;&#10;    // Alternative method name for clarity&#13;&#10;    public boolean hasActiveInteraction() {&#13;&#10;        return this.hasInteraction;&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/entity/InteractionEntity.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/entity/InteractionEntity.java" />
              <option name="originalContent" value="package com.ctuconnect.entity;&#10;&#10;import lombok.*;&#10;import org.springframework.data.annotation.Id;&#10;import org.springframework.data.mongodb.core.mapping.Document;&#10;import org.springframework.data.mongodb.core.mapping.Field;&#10;import com.ctuconnect.dto.AuthorInfo;&#10;&#10;import java.time.LocalDateTime;&#10;import java.util.HashMap;&#10;import java.util.Map;&#10;import java.util.Objects;&#10;import java.util.Objects;&#10;import java.util.Objects;&#10;import java.util.Objects;&#10;import java.util.Objects;&#10;import java.util.Objects;&#10;import java.util.Objects;&#10;import java.util.Objects;&#10;&#10;@Data&#10;@NoArgsConstructor&#10;@AllArgsConstructor&#10;@Builder&#10;@Document(collection = &quot;interactions&quot;)&#10;public class InteractionEntity {&#10;&#10;    @Id&#10;    private String id;&#10;&#10;    @Field(&quot;post_id&quot;)&#10;    // Getter for reaction type (backwards compatibility)&#10;    // Add reactionType field for REACTION interactions&#10;    // Getter for reaction type (backwards compatibility)&#10;    // Add reactionType field for REACTION interactions&#10;    // Getter for reaction type (backwards compatibility)&#10;    // Add reactionType field for REACTION interactions&#10;    // Constructors&#10;    // Constructors&#10;        this.type = newReaction;&#10;        if (newReaction == InteractionType.REACTION) {&#10;    public void setReaction(InteractionType newReaction) {&#10;        if (newReaction == null) {&#10;            throw new IllegalArgumentException(&quot;Interaction type cannot be null&quot;);&#10;        }&#10;        this.type = newReaction;&#10;        if (newReaction == InteractionType.REACTION) {&#10;    public void setReaction(InteractionType newReaction) {&#10;        if (newReaction == null) {&#10;            throw new IllegalArgumentException(&quot;Interaction type cannot be null&quot;);&#10;        }&#10;        this.type = newReaction;&#10;        if (newReaction == InteractionType.REACTION) {&#10;    public void setReaction(InteractionType newReaction) {&#10;        if (newReaction == null) {&#10;            throw new IllegalArgumentException(&quot;Interaction type cannot be null&quot;);&#10;        }&#10;            this.reactionType = newReaction.getReactionType();&#10;        } else {&#10;            this.reactionType = null; // Clear reaction type for non-REACTION interactions&#10;        REACTION // Add REACTION type&#10;        ;&#10;        ANGRY&#10;        REACTION // Add REACTION type&#10;        ;&#10;&#10;            return null; // No reaction type for other interaction types&#10;        }&#10;        }&#10;            }&#10;    @Override&#10;    public int hashCode() {&#10;        return Objects.hash(id, postId, author, type, reactionType);&#10;                return ReactionType.LIKE; // Default to LIKE for REACTION type&#10;            }&#10;            return null; // No reaction type for other interaction types&#10;        }&#10;        return this.type == InteractionType.LIKE ||&#10;    }&#10;&#10;&#10;    public boolean isBookmark() {&#10;        return this.type == InteractionType.BOOKMARK;&#10;    }&#10;&#10;    public boolean isComment() {&#10;        return this.type == InteractionType.COMMENT;&#10;    }&#10;        ANGRY&#10;    }&#10;&#10;&#10;    public boolean isBookmark() {&#10;        return this.type == InteractionType.BOOKMARK;&#10;    }&#10;&#10;    public boolean isComment() {&#10;        return this.type == InteractionType.COMMENT;&#10;        return this.type == InteractionType.LIKE ||&#10;&#10;    // Equals and hashCode&#10;    @Override&#10;               Objects.equals(postId, that.postId) &amp;&amp;&#10;               Objects.equals(author, that.author) &amp;&amp;&#10;               type == that.type &amp;&amp;&#10;               reactionType == that.reactionType;&#10;    public boolean isBookmark() {&#10;        return this.type == InteractionType.BOOKMARK;&#10;    @Override&#10;    public int hashCode() {&#10;        return Objects.hash(id, postId, author, type, reactionType);&#10;    }&#10;    }&#10;&#10;    public boolean isBookmark() {&#10;        return this.type == InteractionType.BOOKMARK;&#10;    }&#10;&#10;    public boolean isComment() {&#10;        return this.type == InteractionType.COMMENT;&#10;    }&#10;&#10;    // Equals and hashCode&#10;    @Override&#10;    public boolean equals(Object o) {&#10;        if (this == o) return true;&#10;        if (o == null || getClass() != o.getClass()) return false;&#10;        InteractionEntity that = (InteractionEntity) o;&#10;        return Objects.equals(id, that.id) &amp;&amp;&#10;               Objects.equals(postId, that.postId) &amp;&amp;&#10;               Objects.equals(author, that.author) &amp;&amp;&#10;               type == that.type &amp;&amp;&#10;               reactionType == that.reactionType;&#10;    }&#10;&#10;    @Override&#10;    public int hashCode() {&#10;        return Objects.hash(id, postId, author, type, reactionType);&#10;    }&#10;&#10;    public boolean isComment() {&#10;        return this.type == InteractionType.COMMENT;&#10;    }&#10;&#10;    // Equals and hashCode&#10;    @Override&#10;    public boolean equals(Object o) {&#10;        if (this == o) return true;&#10;        if (o == null || getClass() != o.getClass()) return false;&#10;        InteractionEntity that = (InteractionEntity) o;&#10;        return Objects.equals(id, that.id) &amp;&amp;&#10;               Objects.equals(postId, that.postId) &amp;&amp;&#10;               Objects.equals(author, that.author) &amp;&amp;&#10;               type == that.type &amp;&amp;&#10;               reactionType == that.reactionType;&#10;    }&#10;&#10;    @Override&#10;    public int hashCode() {&#10;        return Objects.hash(id, postId, author, type, reactionType);&#10;    }&#10;    // Equals and hashCode&#10;    @Override&#10;    public boolean equals(Object o) {&#10;        if (this == o) return true;&#10;        if (o == null || getClass() != o.getClass()) return false;&#10;        REACTION // Add REACTION type&#10;        ;&#10;        ANGRY&#10;    // Enum for reaction types (for REACTION interactions)&#10;        ;&#10;&#10;        public ReactionType getReactionType() {&#10;            if (this == REACTION) {&#10;                return ReactionType.LIKE; // Default to LIKE for REACTION type&#10;            }&#10;            return null; // No reaction type for other interaction types&#10;        }&#10;                return ReactionType.LIKE; // Default to LIKE for REACTION type&#10;            }&#10;            return null; // No reaction type for other interaction types&#10;        }&#10;        }&#10;        this.type = newReaction;&#10;        if (newReaction == InteractionType.REACTION) {&#10;    public void setReaction(InteractionType newReaction) {&#10;        if (newReaction == null) {&#10;            throw new IllegalArgumentException(&quot;Interaction type cannot be null&quot;);&#10;        }&#10;        this.type = newReaction;&#10;        if (newReaction == InteractionType.REACTION) {&#10;            this.reactionType = newReaction.getReactionType();&#10;        } else {&#10;            this.reactionType = null; // Clear reaction type for non-REACTION interactions&#10;        }&#10;    }&#10;&#10;            this.reactionType = newReaction.getReactionType();&#10;        } else {&#10;            this.reactionType = null; // Clear reaction type for non-REACTION interactions&#10;        }&#10;    }&#10;&#10;            this.reactionType = newReaction.getReactionType();&#10;        } else {&#10;            this.reactionType = null; // Clear reaction type for non-REACTION interactions&#10;        REACTION // Add REACTION type&#10;        ;&#10;        ANGRY&#10;        REACTION // Add REACTION type&#10;        ;&#10;&#10;        public ReactionType getReactionType() {&#10;            if (this == REACTION) {&#10;                return ReactionType.LIKE; // Default to LIKE for REACTION type&#10;            }&#10;            return null; // No reaction type for other interaction types&#10;        }&#10;                return ReactionType.LIKE; // Default to LIKE for REACTION type&#10;            }&#10;    @Override&#10;    public int hashCode() {&#10;        return Objects.hash(id, postId, author, type, reactionType);&#10;    }&#10;            return null; // No reaction type for other interaction types&#10;        }&#10;        }&#10;    }&#10;&#10;    // Enum for interaction types&#10;        return this.type == InteractionType.LIKE ||&#10;    }&#10;&#10;&#10;    public boolean isBookmark() {&#10;        return this.type == InteractionType.BOOKMARK;&#10;    }&#10;&#10;    public boolean isComment() {&#10;        return this.type == InteractionType.COMMENT;&#10;    }&#10;&#10;&#10;    public boolean isBookmark() {&#10;        return this.type == InteractionType.BOOKMARK;&#10;    }&#10;&#10;    public boolean isComment() {&#10;        return this.type == InteractionType.COMMENT;&#10;    }&#10;&#10;    // Equals and hashCode&#10;    @Override&#10;    public boolean equals(Object o) {&#10;        if (this == o) return true;&#10;        if (o == null || getClass() != o.getClass()) return false;&#10;        InteractionEntity that = (InteractionEntity) o;&#10;        return Objects.equals(id, that.id) &amp;&amp;&#10;               Objects.equals(postId, that.postId) &amp;&amp;&#10;               Objects.equals(author, that.author) &amp;&amp;&#10;               type == that.type &amp;&amp;&#10;               reactionType == that.reactionType;&#10;    }&#10;&#10;    @Override&#10;    public int hashCode() {&#10;        return Objects.hash(id, postId, author, type, reactionType);&#10;    }&#10;    // Equals and hashCode&#10;    @Override&#10;    public boolean equals(Object o) {&#10;        if (this == o) return true;&#10;        if (o == null || getClass() != o.getClass()) return false;&#10;        InteractionEntity that = (InteractionEntity) o;&#10;        return Objects.equals(id, that.id) &amp;&amp;&#10;               Objects.equals(postId, that.postId) &amp;&amp;&#10;               Objects.equals(author, that.author) &amp;&amp;&#10;        COMMENT,&#10;        REACTION // Add REACTION type&#10;        ;&#10;        ANGRY&#10;    // Enum for reaction types (for REACTION interactions)&#10;        ;&#10;&#10;        public ReactionType getReactionType() {&#10;            if (this == REACTION) {&#10;                return ReactionType.LIKE; // Default to LIKE for REACTION type&#10;            }&#10;            return null; // No reaction type for other interaction types&#10;        }&#10;                return ReactionType.LIKE; // Default to LIKE for REACTION type&#10;            }&#10;            return null; // No reaction type for other interaction types&#10;        }&#10;        LOVE,&#10;        HAHA,&#10;        WOW,&#10;        SAD,&#10;        ANGRY&#10;    }&#10;&#10;&#10;    public boolean isBookmark() {&#10;        return this.type == InteractionType.BOOKMARK;&#10;    }&#10;&#10;    public boolean isComment() {&#10;        return this.type == InteractionType.COMMENT;&#10;    }&#10;&#10;    // Equals and hashCode&#10;    @Override&#10;    public boolean equals(Object o) {&#10;        if (this == o) return true;&#10;        if (o == null || getClass() != o.getClass()) return false;&#10;        InteractionEntity that = (InteractionEntity) o;&#10;        return Objects.equals(id, that.id) &amp;&amp;&#10;               Objects.equals(postId, that.postId) &amp;&amp;&#10;               Objects.equals(author, that.author) &amp;&amp;&#10;               type == that.type &amp;&amp;&#10;               reactionType == that.reactionType;&#10;    }&#10;&#10;    @Override&#10;    public int hashCode() {&#10;        return Objects.hash(id, postId, author, type, reactionType);&#10;    }&#10;    // Helper methods&#10;    public boolean isReaction() {&#10;        return this.type == InteractionType.REACTION;&#10;    }&#10;&#10;    public boolean isLike() {&#10;        return this.type == InteractionType.LIKE ||&#10;               (this.type == InteractionType.REACTION &amp;&amp; this.reactionType == ReactionType.LIKE);&#10;    }&#10;&#10;    public boolean isView() {&#10;        return this.type == InteractionType.VIEW;&#10;    }&#10;&#10;    public boolean isShare() {&#10;        return this.type == InteractionType.SHARE;&#10;    }&#10;&#10;    public boolean isBookmark() {&#10;        return this.type == InteractionType.BOOKMARK;&#10;    }&#10;&#10;    public boolean isComment() {&#10;        return this.type == InteractionType.COMMENT;&#10;    }&#10;&#10;    // Equals and hashCode&#10;    @Override&#10;    public boolean equals(Object o) {&#10;        if (this == o) return true;&#10;        if (o == null || getClass() != o.getClass()) return false;&#10;        InteractionEntity that = (InteractionEntity) o;&#10;        return Objects.equals(id, that.id) &amp;&amp;&#10;               Objects.equals(postId, that.postId) &amp;&amp;&#10;               Objects.equals(author, that.author) &amp;&amp;&#10;               type == that.type &amp;&amp;&#10;               reactionType == that.reactionType;&#10;    }&#10;&#10;    @Override&#10;    public int hashCode() {&#10;        return Objects.hash(id, postId, author, type, reactionType);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.ctuconnect.entity;&#13;&#10;&#13;&#10;import lombok.*;&#13;&#10;import org.springframework.data.annotation.Id;&#13;&#10;import org.springframework.data.mongodb.core.mapping.Document;&#13;&#10;import org.springframework.data.mongodb.core.mapping.Field;&#13;&#10;import com.ctuconnect.dto.AuthorInfo;&#13;&#10;&#13;&#10;import java.time.LocalDateTime;&#13;&#10;import java.util.HashMap;&#13;&#10;import java.util.Map;&#13;&#10;&#13;&#10;@Data&#13;&#10;@NoArgsConstructor&#13;&#10;@AllArgsConstructor&#13;&#10;@Builder&#13;&#10;@Document(collection = &quot;interactions&quot;)&#13;&#10;public class InteractionEntity {&#13;&#10;&#13;&#10;    @Id&#13;&#10;    private String id;&#13;&#10;&#13;&#10;    @Field(&quot;post_id&quot;)&#13;&#10;    private String postId;&#13;&#10;&#13;&#10;    @Field(&quot;author&quot;)&#13;&#10;    private AuthorInfo author;&#13;&#10;&#13;&#10;    private InteractionType type;&#13;&#10;&#13;&#10;    // For REACTION type interactions, store the specific reaction&#13;&#10;    private ReactionType reactionType;&#13;&#10;&#13;&#10;    private Map&lt;String, Object&gt; metadata = new HashMap&lt;&gt;();&#13;&#10;&#13;&#10;    @Field(&quot;created_at&quot;)&#13;&#10;    private LocalDateTime createdAt;&#13;&#10;&#13;&#10;    // Constructor&#13;&#10;    public InteractionEntity(String postId, AuthorInfo author, InteractionType type) {&#13;&#10;        this.postId = postId;&#13;&#10;        this.author = author;&#13;&#10;        this.type = type;&#13;&#10;        this.createdAt = LocalDateTime.now();&#13;&#10;        this.metadata = new HashMap&lt;&gt;();&#13;&#10;    }&#13;&#10;&#13;&#10;    // Constructor with reaction type&#13;&#10;    public InteractionEntity(String postId, AuthorInfo author, InteractionType type, ReactionType reactionType) {&#13;&#10;        this.postId = postId;&#13;&#10;        this.author = author;&#13;&#10;        this.type = type;&#13;&#10;        this.reactionType = reactionType;&#13;&#10;        this.createdAt = LocalDateTime.now();&#13;&#10;        this.metadata = new HashMap&lt;&gt;();&#13;&#10;    }&#13;&#10;&#13;&#10;    // Pre-persist hook&#13;&#10;    public void prePersist() {&#13;&#10;        if (this.createdAt == null) {&#13;&#10;            this.createdAt = LocalDateTime.now();&#13;&#10;        }&#13;&#10;        if (this.metadata == null) {&#13;&#10;            this.metadata = new HashMap&lt;&gt;();&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    public String getUserId() {&#13;&#10;        return author != null ? author.getId() : null;&#13;&#10;    }&#13;&#10;&#13;&#10;    // Enum for interaction types&#13;&#10;    public enum InteractionType {&#13;&#10;        LIKE,&#13;&#10;        SHARE,&#13;&#10;        BOOKMARK,&#13;&#10;        VIEW,&#13;&#10;        COMMENT,&#13;&#10;        REACTION&#13;&#10;    }&#13;&#10;&#13;&#10;    // Enum for reaction types&#13;&#10;    public enum ReactionType {&#13;&#10;        LIKE,&#13;&#10;        LOVE,&#13;&#10;        HAHA,&#13;&#10;        WOW,&#13;&#10;        SAD,&#13;&#10;        ANGRY,&#13;&#10;        BOOKMARK&#13;&#10;    }&#13;&#10;&#13;&#10;    // Helper methods&#13;&#10;    public boolean isReaction() {&#13;&#10;        return this.type == InteractionType.REACTION;&#13;&#10;    }&#13;&#10;&#13;&#10;    public boolean isLike() {&#13;&#10;        return this.type == InteractionType.LIKE || &#13;&#10;               (this.type == InteractionType.REACTION &amp;&amp; this.reactionType == ReactionType.LIKE);&#13;&#10;    }&#13;&#10;&#13;&#10;    public boolean isBookmark() {&#13;&#10;        return this.type == InteractionType.BOOKMARK ||&#13;&#10;               (this.type == InteractionType.REACTION &amp;&amp; this.reactionType == ReactionType.BOOKMARK);&#13;&#10;    }&#13;&#10;&#13;&#10;    public boolean isView() {&#13;&#10;        return this.type == InteractionType.VIEW;&#13;&#10;    }&#13;&#10;&#13;&#10;    public boolean isShare() {&#13;&#10;        return this.type == InteractionType.SHARE;&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/repository/CommentRepository.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/repository/CommentRepository.java" />
              <option name="originalContent" value="package com.ctuconnect.repository;&#10;&#10;import org.springframework.data.domain.Page;&#10;import org.springframework.data.domain.Pageable;&#10;import org.springframework.data.mongodb.repository.MongoRepository;&#10;import org.springframework.data.mongodb.repository.Query;&#10;import org.springframework.stereotype.Repository;&#10;import com.ctuconnect.entity.CommentEntity;&#10;&#10;import java.util.List;&#10;&#10;@Repository&#10;public interface CommentRepository extends MongoRepository&lt;CommentEntity, String&gt; {&#10;&#10;    Page&lt;CommentEntity&gt; findByPostId(String postId, Pageable pageable);&#10;&#10;    List&lt;CommentEntity&gt; findByPostIdAndParentCommentIdIsNull(String postId);&#10;&#10;    List&lt;CommentEntity&gt; findByParentCommentId(String parentCommentId);&#10;&#10;    long countByPostId(String postId);&#10;&#10;    // Fix: Use MongoDB query for nested author object&#10;    @Query(value = &quot;{ 'author.id': ?0 }&quot;, count = true)&#10;    long countByAuthor_Id(String authorId);&#10;&#10;    void deleteByPostId(String postId);&#10;&#10;    // Additional useful queries for nested author structure&#10;    @Query(&quot;{ 'author.id': ?0 }&quot;)&#10;    Page&lt;CommentEntity&gt; findByAuthor_Id(String authorId, Pageable pageable);&#10;&#10;    // Add method that AdminController is calling (without underscore)&#10;    @Query(value = &quot;{ 'author.id': ?0 }&quot;, count = true)&#10;    long countByAuthorId(String authorId);&#10;}&#10;}&#10;" />
              <option name="updatedContent" value="package com.ctuconnect.repository;&#13;&#10;&#13;&#10;import org.springframework.data.domain.Page;&#13;&#10;import org.springframework.data.domain.Pageable;&#13;&#10;import org.springframework.data.mongodb.repository.MongoRepository;&#13;&#10;import org.springframework.data.mongodb.repository.Query;&#13;&#10;import org.springframework.stereotype.Repository;&#13;&#10;import com.ctuconnect.entity.CommentEntity;&#13;&#10;&#13;&#10;import java.util.List;&#13;&#10;&#13;&#10;@Repository&#13;&#10;public interface CommentRepository extends MongoRepository&lt;CommentEntity, String&gt; {&#13;&#10;&#13;&#10;    Page&lt;CommentEntity&gt; findByPostId(String postId, Pageable pageable);&#13;&#10;&#13;&#10;    List&lt;CommentEntity&gt; findByPostIdAndParentCommentIdIsNull(String postId);&#13;&#10;&#13;&#10;    List&lt;CommentEntity&gt; findByParentCommentId(String parentCommentId);&#13;&#10;&#13;&#10;    long countByPostId(String postId);&#13;&#10;&#13;&#10;    // Fix: Use MongoDB query for nested author object&#13;&#10;    @Query(value = &quot;{ 'author.id': ?0 }&quot;, count = true)&#13;&#10;    long countByAuthor_Id(String authorId);&#13;&#10;&#13;&#10;    void deleteByPostId(String postId);&#13;&#10;&#13;&#10;    // Additional useful queries for nested author structure&#13;&#10;    @Query(&quot;{ 'author.id': ?0 }&quot;)&#13;&#10;    Page&lt;CommentEntity&gt; findByAuthor_Id(String authorId, Pageable pageable);&#13;&#10;&#13;&#10;    // Add method that AdminController is calling (without underscore)&#13;&#10;    @Query(value = &quot;{ 'author.id': ?0 }&quot;, count = true)&#13;&#10;    long countByAuthorId(String authorId);&#13;&#10;&#13;&#10;    // Method for user profile synchronization - find all comments by author ID&#13;&#10;    @Query(&quot;{ 'author.id': ?0 }&quot;)&#13;&#10;    List&lt;CommentEntity&gt; findByAuthor_Id(String authorId);&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/service/InteractionService.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/service/InteractionService.java" />
              <option name="originalContent" value="package com.ctuconnect.service;&#10;&#10;import org.springframework.beans.factory.annotation.Autowired;&#10;import org.springframework.stereotype.Service;&#10;import com.ctuconnect.client.UserServiceClient;&#10;import com.ctuconnect.dto.AuthorInfo;&#10;import com.ctuconnect.dto.request.InteractionRequest;&#10;import com.ctuconnect.dto.response.InteractionResponse;&#10;import com.ctuconnect.entity.InteractionEntity;&#10;import com.ctuconnect.entity.PostEntity;&#10;import com.ctuconnect.repository.InteractionRepository;&#10;import com.ctuconnect.repository.PostRepository;&#10;&#10;import java.util.Objects;&#10;import java.util.Optional;&#10;import java.util.List;&#10;&#10;@Service&#10;public class InteractionService {&#10;&#10;    @Autowired&#10;    private InteractionRepository interactionRepository;&#10;&#10;    @Autowired&#10;    private PostRepository postRepository;&#10;&#10;    @Autowired&#10;    private UserServiceClient userServiceClient;&#10;&#10;    @Autowired&#10;    private EventService eventService;&#10;&#10;    /**&#10;     * Create or toggle interaction (like/bookmark)&#10;     * Fixed to properly handle state persistence and prevent duplicates&#10;     */&#10;    public InteractionResponse createInteraction(String postId, InteractionRequest request, String authorId) {&#10;        AuthorInfo author = userServiceClient.getAuthorInfo(authorId);&#10;        if (author == null) {&#10;            throw new RuntimeException(&quot;Author not found with id: &quot; + authorId);&#10;        }&#10;&#10;        PostEntity post = postRepository.findById(postId)&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;Post not found with id: &quot; + postId));&#10;&#10;        // Check if user already has this type of interaction with the post&#10;        Optional&lt;InteractionEntity&gt; existingInteraction = interactionRepository&#10;                .findByPostIdAndAuthor_IdAndType(postId, authorId, request.getReaction());&#10;    }&#10;        if (existingInteraction.isPresent()) {&#10;            // User already has this interaction - remove it (toggle off)&#10;            interactionRepository.delete(existingInteraction.get());&#10;&#10;            // Update post stats&#10;            updatePostStatsOnRemove(post, request.getReaction());&#10;            postRepository.save(post);&#10;&#10;            eventService.publishInteractionEvent(postId, authorId, &quot;UN-&quot; + request.getReaction().toString());&#10;            return new InteractionResponse(false, &quot;Interaction removed&quot;); // Interaction removed&#10;" />
              <option name="updatedContent" value="package com.ctuconnect.service;&#10;&#10;import org.springframework.beans.factory.annotation.Autowired;&#10;import org.springframework.stereotype.Service;&#10;import com.ctuconnect.client.UserServiceClient;&#10;import com.ctuconnect.dto.AuthorInfo;&#10;import com.ctuconnect.dto.request.InteractionRequest;&#10;import com.ctuconnect.dto.response.InteractionResponse;&#10;import com.ctuconnect.entity.InteractionEntity;&#10;import com.ctuconnect.entity.PostEntity;&#10;import com.ctuconnect.repository.InteractionRepository;&#10;import com.ctuconnect.repository.PostRepository;&#10;&#10;import java.util.Objects;&#10;import java.util.Optional;&#10;import java.util.List;&#10;&#10;@Service&#10;public class InteractionService {&#10;&#10;    @Autowired&#10;    private InteractionRepository interactionRepository;&#10;&#10;    @Autowired&#10;    private PostRepository postRepository;&#10;&#10;    @Autowired&#10;    private UserServiceClient userServiceClient;&#10;&#10;    @Autowired&#10;    private EventService eventService;&#10;&#10;    /**&#10;     * Create or toggle interaction (like/bookmark)&#10;     * Fixed to properly handle state persistence and prevent duplicates&#10;     */&#10;    public InteractionResponse createInteraction(String postId, InteractionRequest request, String authorId) {&#10;        AuthorInfo author = userServiceClient.getAuthorInfo(authorId);&#10;        if (author == null) {&#10;            throw new RuntimeException(&quot;Author not found with id: &quot; + authorId);&#10;        }&#10;&#10;        PostEntity post = postRepository.findById(postId)&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;Post not found with id: &quot; + postId));&#10;&#10;        // For reaction-based interactions, check if user already has ANY reaction on this post&#10;        if (request.getReaction() == InteractionEntity.InteractionType.LIKE ||&#10;            request.getReaction() == InteractionEntity.InteractionType.REACTION) {&#10;&#10;            // Remove any existing reactions from this user on this post&#10;            List&lt;InteractionEntity&gt; existingReactions = interactionRepository&#10;                    .findByPostIdAndAuthor_Id(postId, authorId);&#10;&#10;            for (InteractionEntity existing : existingReactions) {&#10;                if (existing.isLike() || existing.isReaction()) {&#10;                    interactionRepository.delete(existing);&#10;                    updatePostStatsOnRemove(post, existing.getType());&#10;                }&#10;            }&#10;&#10;            // Check if this is the same reaction being toggled off&#10;            boolean sameReaction = existingReactions.stream()&#10;                    .anyMatch(existing -&gt; isSameReaction(existing, request));&#10;&#10;            if (sameReaction) {&#10;                // Same reaction clicked again - just remove it (toggle off)&#10;                postRepository.save(post);&#10;                eventService.publishInteractionEvent(postId, authorId, &quot;UN-&quot; + request.getReaction().toString());&#10;                return new InteractionResponse(false, &quot;Reaction removed&quot;);&#10;            }&#10;        } else {&#10;            // For non-reaction interactions (bookmark, share, etc.), check for exact match&#10;            Optional&lt;InteractionEntity&gt; existingInteraction = interactionRepository&#10;                    .findByPostIdAndAuthor_IdAndType(postId, authorId, request.getReaction());&#10;&#10;            if (existingInteraction.isPresent()) {&#10;                // Toggle off the exact interaction&#10;                interactionRepository.delete(existingInteraction.get());&#10;                updatePostStatsOnRemove(post, request.getReaction());&#10;                postRepository.save(post);&#10;                eventService.publishInteractionEvent(postId, authorId, &quot;UN-&quot; + request.getReaction().toString());&#10;                return new InteractionResponse(false, &quot;Interaction removed&quot;);&#10;            }&#10;        }&#10;&#10;        // Create new interaction&#10;        InteractionEntity interaction;&#10;        if (request.getReactionType() != null) {&#10;            interaction = new InteractionEntity(postId, author, request.getReaction(), request.getReactionType());&#10;        } else {&#10;            interaction = new InteractionEntity(postId, author, request.getReaction());&#10;        }&#10;&#10;        if (request.getMetadata() != null) {&#10;            interaction.setMetadata(request.getMetadata());&#10;        }&#10;&#10;        InteractionEntity saved = interactionRepository.save(interaction);&#10;&#10;        // Update post stats&#10;        updatePostStatsOnAdd(post, request.getReaction());&#10;        postRepository.save(post);&#10;&#10;        eventService.publishInteractionEvent(postId, authorId, request.getReaction().toString());&#10;        return new InteractionResponse(saved);&#10;    }&#10;&#10;    private boolean isSameReaction(InteractionEntity existing, InteractionRequest request) {&#10;        if (existing.getType() == InteractionEntity.InteractionType.LIKE &amp;&amp;&#10;            request.getReaction() == InteractionEntity.InteractionType.LIKE) {&#10;            return true;&#10;        }&#10;        if (existing.getType() == InteractionEntity.InteractionType.REACTION &amp;&amp;&#10;            request.getReaction() == InteractionEntity.InteractionType.REACTION) {&#10;            return Objects.equals(existing.getReactionType(), request.getReactionType());&#10;        }&#10;        return false;&#10;    }&#10;&#10;    /**&#10;     * Get user's interaction status for a post&#10;     */&#10;    public InteractionResponse getUserInteractionStatus(String postId, String userId) {&#10;        List&lt;InteractionEntity&gt; userInteractions = interactionRepository.findByPostIdAndAuthor_Id(postId, userId);&#10;&#10;        if (userInteractions.isEmpty()) {&#10;            return new InteractionResponse(false, &quot;No interactions found&quot;);&#10;        }&#10;&#10;        // Return the most recent interaction&#10;        InteractionEntity mostRecent = userInteractions.stream()&#10;                .max((i1, i2) -&gt; i1.getCreatedAt().compareTo(i2.getCreatedAt()))&#10;                .orElse(userInteractions.get(0));&#10;&#10;        return new InteractionResponse(mostRecent);&#10;    }&#10;&#10;    /**&#10;     * Check if user has liked a specific post&#10;     */&#10;    public boolean hasUserLikedPost(String postId, String userId) {&#10;        List&lt;InteractionEntity&gt; interactions = interactionRepository.findByPostIdAndAuthor_Id(postId, userId);&#10;        return interactions.stream().anyMatch(InteractionEntity::isLike);&#10;    }&#10;&#10;    /**&#10;     * Check if user has bookmarked a specific post&#10;     */&#10;    public boolean hasUserBookmarkedPost(String postId, String userId) {&#10;        List&lt;InteractionEntity&gt; interactions = interactionRepository.findByPostIdAndAuthor_Id(postId, userId);&#10;        return interactions.stream().anyMatch(InteractionEntity::isBookmark);&#10;    }&#10;&#10;    private void updatePostStatsOnAdd(PostEntity post, InteractionEntity.InteractionType type) {&#10;        switch (type) {&#10;            case LIKE:&#10;                post.getStats().incrementReaction(InteractionEntity.ReactionType.LIKE);&#10;                break;&#10;            case BOOKMARK:&#10;                // Handle bookmark stats if needed&#10;                break;&#10;            case SHARE:&#10;                post.getStats().incrementShares();&#10;                break;&#10;            case VIEW:&#10;                post.getStats().incrementViews();&#10;                break;&#10;            case COMMENT:&#10;                post.getStats().incrementComments();&#10;                break;&#10;            default:&#10;                break;&#10;        }&#10;    }&#10;&#10;    private void updatePostStatsOnRemove(PostEntity post, InteractionEntity.InteractionType type) {&#10;        switch (type) {&#10;            case LIKE:&#10;                post.getStats().decrementReaction(InteractionEntity.ReactionType.LIKE);&#10;                break;&#10;            case BOOKMARK:&#10;                // Handle bookmark stats if needed&#10;                break;&#10;            case SHARE:&#10;                post.getStats().decrementShares();&#10;                break;&#10;            case COMMENT:&#10;                post.getStats().decrementComments();&#10;                break;&#10;            default:&#10;                break;&#10;        }&#10;    }&#10;&#10;    public long getInteractionCount(String postId, InteractionEntity.InteractionType type) {&#10;        return interactionRepository.countByPostIdAndType(postId, type);&#10;    }&#10;&#10;    /**&#10;     * Check if user has reacted to a post (for legacy compatibility)&#10;     */&#10;    public boolean hasUserReacted(String postId, String userId) {&#10;        return hasUserLikedPost(postId, userId);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/service/PostService.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/service/PostService.java" />
              <option name="originalContent" value="package com.ctuconnect.service;&#10;&#10;import org.springframework.beans.factory.annotation.Autowired;&#10;import org.springframework.data.domain.Page;&#10;import org.springframework.data.domain.Pageable;&#10;import org.springframework.stereotype.Service;&#10;import org.springframework.web.multipart.MultipartFile;&#10;import com.ctuconnect.client.MediaServiceClient;&#10;import com.ctuconnect.client.UserServiceClient;&#10;import com.ctuconnect.dto.AuthorInfo;&#10;import com.ctuconnect.dto.request.PostRequest;&#10;import com.ctuconnect.dto.request.ScheduledPostRequest;&#10;import com.ctuconnect.dto.response.PostResponse;&#10;import com.ctuconnect.dto.response.PostAnalyticsResponse;&#10;import com.ctuconnect.entity.InteractionEntity;&#10;import com.ctuconnect.entity.PostEntity;&#10;import com.ctuconnect.entity.CommentEntity;&#10;import com.ctuconnect.repository.CommentRepository;&#10;import com.ctuconnect.repository.InteractionRepository;&#10;import com.ctuconnect.repository.PostRepository;&#10;import com.ctuconnect.security.AuthenticatedUser;&#10;&#10;import java.util.ArrayList;&#10;import java.util.HashSet;&#10;import java.util.List;&#10;import java.util.Optional;&#10;import java.util.Set;&#10;import java.util.stream.Collectors;&#10;&#10;@Service&#10;public class PostService {&#10;&#10;    @Autowired&#10;    private PostRepository postRepository;&#10;&#10;    @Autowired&#10;    private CommentRepository commentRepository;&#10;&#10;    @Autowired&#10;    private InteractionRepository interactionRepository;&#10;&#10;    @Autowired&#10;    private MediaServiceClient mediaServiceClient;&#10;&#10;    @Autowired&#10;    private UserServiceClient userServiceClient;&#10;&#10;    @Autowired&#10;    private EventService eventService;&#10;&#10;    public PostResponse createPost(PostRequest request, List&lt;MultipartFile&gt; files, String authorId) {&#10;        AuthorInfo author = userServiceClient.getAuthorInfo(authorId);&#10;        if (author == null) {&#10;            throw new RuntimeException(&quot;Author not found with id: &quot; + authorId);&#10;        }&#10;&#10;        PostEntity post = PostEntity.builder()&#10;                .title(request.getTitle())&#10;                .content(request.getContent())&#10;                .author(author)&#10;                .images(new ArrayList&lt;&gt;())&#10;                .tags(request.getTags() != null ? request.getTags() : new ArrayList&lt;&gt;())&#10;                .category(request.getCategory())&#10;                .privacy(request.getVisibility() != null ? request.getVisibility() : &quot;PUBLIC&quot;)&#10;                .stats(new PostEntity.PostStats())&#10;                .build();&#10;&#10;        // Upload files to media-service&#10;        if (files != null &amp;&amp; !files.isEmpty()) {&#10;            List&lt;String&gt; imageUrls = new ArrayList&lt;&gt;();&#10;            for (MultipartFile file : files) {&#10;                if (!file.isEmpty()) {&#10;                    try {&#10;                        MediaServiceClient.MediaUploadResponse uploadResponse =&#10;                            mediaServiceClient.uploadFile(file, getFileType(file));&#10;                        imageUrls.add(uploadResponse.getFileUrl());&#10;                    } catch (Exception e) {&#10;                        // Log error but continue processing&#10;                        System.err.println(&quot;Failed to upload file: &quot; + e.getMessage());&#10;                    }&#10;                }&#10;            }&#10;            post.setImages(imageUrls);&#10;        }&#10;&#10;        PostEntity savedPost = postRepository.save(post);&#10;&#10;        // Publish event&#10;        eventService.publishPostEvent(&quot;POST_CREATED&quot;, savedPost.getId(), savedPost.getAuthorId(), savedPost);&#10;&#10;        return new PostResponse(savedPost);&#10;    }&#10;&#10;    public Page&lt;PostResponse&gt; getAllPosts(Pageable pageable) {&#10;        Page&lt;PostEntity&gt; posts = postRepository.findAll(pageable);&#10;        &#10;        // Recalculate stats for each post before returning&#10;        posts.forEach(this::recalculatePostStats);&#10;        postRepository.saveAll(posts.getContent());&#10;        &#10;        return posts.map(PostResponse::new);&#10;    }&#10;&#10;    public Page&lt;PostResponse&gt; getPostsByAuthor(String authorId, Pageable pageable) {&#10;        if (postOpt.isPresent()) {&#10;                post.setTitle(request.getTitle());&#10;            }&#10;            if (request.getContent() != null) {&#10;                post.setContent(request.getContent());&#10;            }&#10;            if (request.getTags() != null) {&#10;                post.setTags(request.getTags());&#10;            }&#10;            if (request.getCategory() != null) {&#10;                post.setCategory(request.getCategory());&#10;            }&#10;            if (request.getVisibility() != null) {&#10;                post.setVisibility(request.getVisibility());&#10;            }&#10;&#10;            PostEntity savedPost = postRepository.save(post);&#10;&#10;            // Publish event&#10;            eventService.publishPostEvent(&quot;POST_UPDATED&quot;, savedPost.getId(), savedPost.getAuthorId(), savedPost);&#10;&#10;            return new PostResponse(savedPost);&#10;        }&#10;        throw new RuntimeException(&quot;Post not found with id: &quot; + id);&#10;    }&#10;&#10;    public void deletePost(String id, String authorId) {&#10;        Optional&lt;PostEntity&gt; postOpt = postRepository.findById(id);&#10;        if (postOpt.isPresent()) {&#10;            PostEntity post = postOpt.get();&#10;&#10;            // Check if user is the author&#10;            if (!post.getAuthorId().equals(authorId)) {&#10;                throw new RuntimeException(&quot;Only the author can delete this post&quot;);&#10;            }&#10;&#10;            // Delete associated comments and interactions&#10;            commentRepository.deleteByPostId(id);&#10;            interactionRepository.deleteByPostId(id);&#10;&#10;            // Delete the post&#10;            postRepository.deleteById(id);&#10;&#10;            // Publish event&#10;            eventService.publishPostEvent(&quot;POST_DELETED&quot;, id, authorId, post);&#10;        } else {&#10;            throw new RuntimeException(&quot;Post not found with id: &quot; + id);&#10;        }&#10;    }&#10;&#10;    private void recordViewInteraction(String postId, String userId) {&#10;        try {&#10;            AuthorInfo author = userServiceClient.getAuthorInfo(userId);&#10;            if (author == null) return;&#10;&#10;            // Check if user already viewed this post recently (within last hour)&#10;            Optional&lt;InteractionEntity&gt; existingView = interactionRepository&#10;                    .findByPostIdAndAuthor_IdAndType(postId, userId, InteractionEntity.InteractionType.VIEW);&#10;&#10;            if (existingView.isEmpty()) {&#10;                // Create view interaction&#10;                InteractionEntity viewInteraction = new InteractionEntity(postId, author, InteractionEntity.InteractionType.VIEW);&#10;                interactionRepository.save(viewInteraction);&#10;&#10;                // Update post stats&#10;                Optional&lt;PostEntity&gt; postOpt = postRepository.findById(postId);&#10;                if (postOpt.isPresent()) {&#10;                    PostEntity post = postOpt.get();&#10;                    post.getStats().incrementViews();&#10;                    postRepository.save(post);&#10;                }&#10;&#10;                // Publish interaction event&#10;                eventService.publishInteractionEvent(postId, userId, &quot;VIEW&quot;);&#10;            }&#10;        } catch (Exception e) {&#10;            // Log error but don't fail the main operation&#10;            System.err.println(&quot;Failed to record view interaction: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    private String getFileType(MultipartFile file) {&#10;        String contentType = file.getContentType();&#10;        if (contentType != null) {&#10;            if (contentType.startsWith(&quot;image/&quot;)) return &quot;IMAGE&quot;;&#10;            if (contentType.startsWith(&quot;video/&quot;)) return &quot;VIDEO&quot;;&#10;            if (contentType.startsWith(&quot;audio/&quot;)) return &quot;AUDIO&quot;;&#10;            if (contentType.equals(&quot;application/pdf&quot;)) return &quot;PDF&quot;;&#10;        }&#10;        return &quot;DOCUMENT&quot;;&#10;    }&#10;&#10;    public List&lt;PostResponse&gt; getTopViewedPosts() {&#10;        return postRepository.findTop10ByOrderByStatsViewsDesc()&#10;                .stream()&#10;                .map(PostResponse::new)&#10;                .toList();&#10;    }&#10;&#10;    public List&lt;PostResponse&gt; getTopLikedPosts() {&#10;        return postRepository.findTop10ByOrderByStatsLikesDesc()&#10;                .stream()&#10;                .map(PostResponse::new)&#10;                .toList();&#10;    }&#10;&#10;    /**&#10;     * Enhanced post creation with Facebook-like features&#10;     */&#10;    public PostResponse createEnhancedPost(PostRequest request, AuthenticatedUser user) {&#10;        AuthorInfo author = userServiceClient.getAuthorInfo(user.getId());&#10;        if (author == null) {&#10;            throw new RuntimeException(&quot;Author not found with id: &quot; + user.getId());&#10;        }&#10;&#10;        PostEntity post = PostEntity.builder()&#10;                .title(request.getTitle())&#10;                .content(request.getContent())&#10;                .author(author)&#10;                .images(request.getImages() != null ? request.getImages() : new ArrayList&lt;&gt;())&#10;                .videos(request.getVideos() != null ? request.getVideos() : new ArrayList&lt;&gt;())&#10;                .tags(request.getTags() != null ? request.getTags() : new ArrayList&lt;&gt;())&#10;                .category(request.getCategory())&#10;                .privacy(request.getVisibility() != null ? request.getVisibility() : &quot;PUBLIC&quot;)&#10;                .postType(request.getPostType() != null ? PostEntity.PostType.valueOf(request.getPostType()) : PostEntity.PostType.TEXT)&#10;                .stats(new PostEntity.PostStats())&#10;                .audienceSettings(new PostEntity.AudienceSettings())&#10;                .engagement(new PostEntity.EngagementMetrics())&#10;                .build();&#10;&#10;        // Set audience settings if provided&#10;        if (request.getAudienceSettings() != null) {&#10;            post.setAudienceSettings(request.getAudienceSettings());&#10;        }&#10;&#10;        // Handle scheduled posts&#10;        if (request.getScheduledAt() != null) {&#10;            post.setScheduledAt(request.getScheduledAt());&#10;            post.setScheduled(true);&#10;        }&#10;&#10;        PostEntity savedPost = postRepository.save(post);&#10;&#10;        // Publish event&#10;        eventService.publishPostEvent(&quot;POST_CREATED&quot;, savedPost.getId(), savedPost.getAuthorId(), savedPost);&#10;&#10;        return new PostResponse(savedPost);&#10;    }&#10;&#10;    /**&#10;     * Get users affected by a post (for cache invalidation)&#10;     */&#10;    public Set&lt;String&gt; getAffectedUserIds(String postId) {&#10;        Optional&lt;PostEntity&gt; postOpt = postRepository.findById(postId);&#10;        if (postOpt.isPresent()) {&#10;            PostEntity post = postOpt.get();&#10;            Set&lt;String&gt; affectedUsers = new HashSet&lt;&gt;();&#10;&#10;            // Add author&#10;            affectedUsers.add(post.getAuthorId());&#10;&#10;            // Add friends if post is visible to friends&#10;            if (&quot;FRIENDS&quot;.equals(post.getPrivacy()) || &quot;PUBLIC&quot;.equals(post.getPrivacy())) {&#10;                Set&lt;String&gt; authorFriends = userServiceClient.getFriendIds(post.getAuthorId());&#10;                affectedUsers.addAll(authorFriends);&#10;            }&#10;&#10;            return affectedUsers;&#10;        }&#10;        return new HashSet&lt;&gt;();&#10;    }&#10;&#10;    /**&#10;     * Handle post interactions (like, comment, share)&#10;     */&#10;    public void handlePostInteraction(String postId, String userId, String action, String reactionType) {&#10;        Optional&lt;PostEntity&gt; postOpt = postRepository.findById(postId);&#10;        if (postOpt.isEmpty()) {&#10;            throw new RuntimeException(&quot;Post not found with id: &quot; + postId);&#10;        }&#10;&#10;        PostEntity post = postOpt.get();&#10;        AuthorInfo user = userServiceClient.getAuthorInfo(userId);&#10;        if (user == null) {&#10;            throw new RuntimeException(&quot;User not found with id: &quot; + userId);&#10;        }&#10;&#10;        switch (action.toUpperCase()) {&#10;            case &quot;LIKE&quot;:&#10;                handleLikeInteraction(postId, userId, reactionType, post, user);&#10;                break;&#10;            case &quot;UNLIKE&quot;:&#10;                handleUnlikeInteraction(postId, userId, post);&#10;                break;&#10;            case &quot;SHARE&quot;:&#10;                handleShareInteraction(postId, userId, post, user);&#10;                break;&#10;            default:&#10;                throw new RuntimeException(&quot;Unsupported action: &quot; + action);&#10;        }&#10;&#10;        // Update engagement metrics&#10;        updateEngagementMetrics(post);&#10;        postRepository.save(post);&#10;    }&#10;&#10;    /**&#10;     * Get post author ID&#10;     */&#10;    public String getPostAuthorId(String postId) {&#10;        Optional&lt;PostEntity&gt; postOpt = postRepository.findById(postId);&#10;        if (postOpt.isPresent()) {&#10;            return postOpt.get().getAuthorId();&#10;        }&#10;        throw new RuntimeException(&quot;Post not found with id: &quot; + postId);&#10;    }&#10;&#10;    /**&#10;     * Add comment to post&#10;     */&#10;    public void addComment(String postId, String userId, String content) {&#10;        Optional&lt;PostEntity&gt; postOpt = postRepository.findById(postId);&#10;        if (postOpt.isEmpty()) {&#10;            throw new RuntimeException(&quot;Post not found with id: &quot; + postId);&#10;        }&#10;&#10;        AuthorInfo author = userServiceClient.getAuthorInfo(userId);&#10;        if (author == null) {&#10;            throw new RuntimeException(&quot;User not found with id: &quot; + userId);&#10;        }&#10;&#10;        CommentEntity comment = CommentEntity.builder()&#10;                .postId(postId)&#10;                .author(author)&#10;                .content(content)&#10;                .build();&#10;&#10;        commentRepository.save(comment);&#10;&#10;        // Update post comment count&#10;        PostEntity post = postOpt.get();&#10;        post.getStats().incrementComments();&#10;        updateEngagementMetrics(post);&#10;        postRepository.save(post);&#10;&#10;        // Publish event&#10;        eventService.publishPostEvent(&quot;COMMENT_ADDED&quot;, postId, userId, comment);&#10;    }&#10;&#10;    /**&#10;     * Get post analytics&#10;     */&#10;    public PostAnalyticsResponse getPostAnalytics(String postId, String userId) {&#10;        Optional&lt;PostEntity&gt; postOpt = postRepository.findById(postId);&#10;        if (postOpt.isEmpty()) {&#10;            throw new RuntimeException(&quot;Post not found with id: &quot; + postId);&#10;        }&#10;&#10;        PostEntity post = postOpt.get();&#10;&#10;        // Check if user is the post author&#10;        if (!post.getAuthorId().equals(userId)) {&#10;            throw new RuntimeException(&quot;Only post author can view analytics&quot;);&#10;        }&#10;&#10;        return PostAnalyticsResponse.builder()&#10;                .postId(postId)&#10;                .views(post.getStats().getViews())&#10;                .likes(post.getStats().getLikes())&#10;                .comments(post.getStats().getComments())&#10;                .shares(post.getStats().getShares())&#10;                .engagementRate(post.getEngagement().getEngagementRate())&#10;                .reactions(post.getStats().getReactions())&#10;                .build();&#10;    }&#10;&#10;    /**&#10;     * Schedule post for later publishing&#10;     */&#10;    public PostResponse schedulePost(ScheduledPostRequest request, AuthenticatedUser user) {&#10;        AuthorInfo author = userServiceClient.getAuthorInfo(user.getId());&#10;        if (author == null) {&#10;            throw new RuntimeException(&quot;Author not found with id: &quot; + user.getId());&#10;        }&#10;&#10;        PostEntity post = PostEntity.builder()&#10;                .title(request.getTitle())&#10;                .content(request.getContent())&#10;                .author(author)&#10;                .images(request.getImages() != null ? request.getImages() : new ArrayList&lt;&gt;())&#10;                .tags(request.getTags() != null ? request.getTags() : new ArrayList&lt;&gt;())&#10;                .category(request.getCategory())&#10;                .privacy(request.getVisibility() != null ? request.getVisibility() : &quot;PUBLIC&quot;)&#10;                .scheduledAt(request.getScheduledAt())&#10;                .isScheduled(true)&#10;                .stats(new PostEntity.PostStats())&#10;                .build();&#10;&#10;        PostEntity savedPost = postRepository.save(post);&#10;        return new PostResponse(savedPost);&#10;    }&#10;&#10;    /**&#10;     * Enhanced search with filters&#10;     */&#10;    public List&lt;PostResponse&gt; searchPosts(String query, String category, String faculty,&#10;                                        String dateRange, Pageable pageable) {&#10;        // This would need to be implemented with proper MongoDB queries&#10;        // For now, implementing basic search&#10;        Page&lt;PostEntity&gt; posts;&#10;&#10;        if (category != null &amp;&amp; !category.isEmpty()) {&#10;            posts = postRepository.findByCategoryAndTitleContainingOrContentContaining(&#10;                category, query, query, pageable);&#10;        } else {&#10;            posts = postRepository.findByTitleContainingOrContentContaining(query, query, pageable);&#10;        }&#10;&#10;        return posts.stream()&#10;                .map(PostResponse::new)&#10;                .collect(Collectors.toList());&#10;    }&#10;&#10;    /**&#10;     * Update author information in posts (for data consistency)&#10;     */&#10;    public void updateAuthorInfoInPosts(String userId, String fullName, String avatarUrl) {&#10;        List&lt;PostEntity&gt; userPosts = postRepository.findByAuthor_Id(userId);&#10;&#10;        for (PostEntity post : userPosts) {&#10;            AuthorInfo updatedAuthor = post.getAuthor();&#10;            updatedAuthor.setFullName(fullName);&#10;            updatedAuthor.setAvatarUrl(avatarUrl);&#10;            post.setAuthor(updatedAuthor);&#10;        }&#10;&#10;        if (!userPosts.isEmpty()) {&#10;            postRepository.saveAll(userPosts);&#10;        }&#10;    }&#10;&#10;    // Helper methods&#10;    private void handleLikeInteraction(String postId, String userId, String reactionType,&#10;                                     PostEntity post, AuthorInfo user) {&#10;        InteractionEntity.ReactionType reaction =&#10;            reactionType != null ?&#10;            InteractionEntity.ReactionType.valueOf(reactionType.toUpperCase()) :&#10;            InteractionEntity.ReactionType.LIKE;&#10;&#10;        // Check if user already reacted&#10;        Optional&lt;InteractionEntity&gt; existingInteraction = interactionRepository&#10;                .findByPostIdAndAuthor_IdAndType(postId, userId, InteractionEntity.InteractionType.REACTION);&#10;&#10;        if (existingInteraction.isEmpty()) {&#10;            // Create new reaction&#10;            InteractionEntity interaction = InteractionEntity.builder()&#10;                    .postId(postId)&#10;                    .author(user)&#10;                    .type(InteractionEntity.InteractionType.REACTION)&#10;                    .reactionType(reaction)&#10;                    .build();&#10;&#10;            interactionRepository.save(interaction);&#10;            post.getStats().incrementReaction(reaction);&#10;        }&#10;    }&#10;&#10;    private void handleUnlikeInteraction(String postId, String userId, PostEntity post) {&#10;        Optional&lt;InteractionEntity&gt; existingInteraction = interactionRepository&#10;                .findByPostIdAndAuthor_IdAndType(postId, userId, InteractionEntity.InteractionType.REACTION);&#10;&#10;        if (existingInteraction.isPresent()) {&#10;            InteractionEntity interaction = existingInteraction.get();&#10;            post.getStats().decrementReaction(interaction.getReactionType());&#10;            interactionRepository.delete(interaction);&#10;        }&#10;    }&#10;&#10;    private void handleShareInteraction(String postId, String userId, PostEntity post, AuthorInfo user) {&#10;        InteractionEntity interaction = InteractionEntity.builder()&#10;                .postId(postId)&#10;                .author(user)&#10;                .type(InteractionEntity.InteractionType.SHARE)&#10;                .build();&#10;&#10;        interactionRepository.save(interaction);&#10;        post.getStats().incrementShares();&#10;    }&#10;&#10;    private void updateEngagementMetrics(PostEntity post) {&#10;        PostEntity.EngagementMetrics engagement = post.getEngagement();&#10;        PostEntity.PostStats stats = post.getStats();&#10;&#10;        engagement.updateEngagement(&#10;            (int) stats.getLikes(),&#10;            (int) stats.getComments(),&#10;            (int) stats.getShares(),&#10;            (int) stats.getViews()&#10;        );&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.ctuconnect.service;&#13;&#10;&#13;&#10;import org.springframework.beans.factory.annotation.Autowired;&#13;&#10;import org.springframework.data.domain.Page;&#13;&#10;import org.springframework.data.domain.Pageable;&#13;&#10;import org.springframework.stereotype.Service;&#13;&#10;import org.springframework.web.multipart.MultipartFile;&#13;&#10;import com.ctuconnect.client.MediaServiceClient;&#13;&#10;import com.ctuconnect.client.UserServiceClient;&#13;&#10;import com.ctuconnect.dto.AuthorInfo;&#13;&#10;import com.ctuconnect.dto.request.PostRequest;&#13;&#10;import com.ctuconnect.dto.request.ScheduledPostRequest;&#13;&#10;import com.ctuconnect.dto.response.PostResponse;&#13;&#10;import com.ctuconnect.dto.response.PostAnalyticsResponse;&#13;&#10;import com.ctuconnect.entity.InteractionEntity;&#13;&#10;import com.ctuconnect.entity.PostEntity;&#13;&#10;import com.ctuconnect.entity.CommentEntity;&#13;&#10;import com.ctuconnect.repository.CommentRepository;&#13;&#10;import com.ctuconnect.repository.InteractionRepository;&#13;&#10;import com.ctuconnect.repository.PostRepository;&#13;&#10;import com.ctuconnect.security.AuthenticatedUser;&#13;&#10;&#13;&#10;import java.util.ArrayList;&#13;&#10;import java.util.HashSet;&#13;&#10;import java.util.List;&#13;&#10;import java.util.Optional;&#13;&#10;import java.util.Set;&#13;&#10;import java.util.stream.Collectors;&#13;&#10;&#13;&#10;@Service&#13;&#10;public class PostService {&#13;&#10;&#13;&#10;    @Autowired&#13;&#10;    private PostRepository postRepository;&#13;&#10;&#13;&#10;    @Autowired&#13;&#10;    private CommentRepository commentRepository;&#13;&#10;&#13;&#10;    @Autowired&#13;&#10;    private InteractionRepository interactionRepository;&#13;&#10;&#13;&#10;    @Autowired&#13;&#10;    private MediaServiceClient mediaServiceClient;&#13;&#10;&#13;&#10;    @Autowired&#13;&#10;    private UserServiceClient userServiceClient;&#13;&#10;&#13;&#10;    @Autowired&#13;&#10;    private EventService eventService;&#13;&#10;&#13;&#10;    public PostResponse createPost(PostRequest request, List&lt;MultipartFile&gt; files, String authorId) {&#13;&#10;        AuthorInfo author = userServiceClient.getAuthorInfo(authorId);&#13;&#10;        if (author == null) {&#13;&#10;            throw new RuntimeException(&quot;Author not found with id: &quot; + authorId);&#13;&#10;        }&#13;&#10;&#13;&#10;        PostEntity post = PostEntity.builder()&#13;&#10;                .title(request.getTitle())&#13;&#10;                .content(request.getContent())&#13;&#10;                .author(author)&#13;&#10;                .images(new ArrayList&lt;&gt;())&#13;&#10;                .tags(request.getTags() != null ? request.getTags() : new ArrayList&lt;&gt;())&#13;&#10;                .category(request.getCategory())&#13;&#10;                .privacy(request.getVisibility() != null ? request.getVisibility() : &quot;PUBLIC&quot;)&#13;&#10;                .stats(new PostEntity.PostStats())&#13;&#10;                .build();&#13;&#10;&#13;&#10;        // Upload files to media-service&#13;&#10;        if (files != null &amp;&amp; !files.isEmpty()) {&#13;&#10;            List&lt;String&gt; imageUrls = new ArrayList&lt;&gt;();&#13;&#10;            for (MultipartFile file : files) {&#13;&#10;                if (!file.isEmpty()) {&#13;&#10;                    try {&#13;&#10;                        MediaServiceClient.MediaUploadResponse uploadResponse =&#13;&#10;                            mediaServiceClient.uploadFile(file, getFileType(file));&#13;&#10;                        imageUrls.add(uploadResponse.getFileUrl());&#13;&#10;                    } catch (Exception e) {&#13;&#10;                        // Log error but continue processing&#13;&#10;                        System.err.println(&quot;Failed to upload file: &quot; + e.getMessage());&#13;&#10;                    }&#13;&#10;                }&#13;&#10;            }&#13;&#10;            post.setImages(imageUrls);&#13;&#10;        }&#13;&#10;&#13;&#10;        PostEntity savedPost = postRepository.save(post);&#13;&#10;&#13;&#10;        // Publish event&#13;&#10;        eventService.publishPostEvent(&quot;POST_CREATED&quot;, savedPost.getId(), savedPost.getAuthorId(), savedPost);&#13;&#10;&#13;&#10;        return new PostResponse(savedPost);&#13;&#10;    }&#13;&#10;&#13;&#10;    public Page&lt;PostResponse&gt; getAllPosts(Pageable pageable) {&#13;&#10;        Page&lt;PostEntity&gt; posts = postRepository.findAll(pageable);&#13;&#10;        &#13;&#10;        // Recalculate stats for each post before returning&#13;&#10;        posts.forEach(this::recalculatePostStats);&#13;&#10;        postRepository.saveAll(posts.getContent());&#13;&#10;        &#13;&#10;        return posts.map(PostResponse::new);&#13;&#10;    }&#13;&#10;&#13;&#10;    public Page&lt;PostResponse&gt; getPostsByAuthor(String authorId, Pageable pageable) {&#13;&#10;        System.out.println(&quot;DEBUG: PostService.getPostsByAuthor called with authorId: &quot; + authorId);&#13;&#10;        &#13;&#10;        Page&lt;PostEntity&gt; posts = postRepository.findByAuthor_Id(authorId, pageable);&#13;&#10;        System.out.println(&quot;DEBUG: Repository query returned &quot; + posts.getTotalElements() + &quot; posts&quot;);&#13;&#10;        &#13;&#10;        // Debug first few posts from repository&#13;&#10;        posts.getContent().stream().limit(3).forEach(post -&gt; {&#13;&#10;            System.out.println(&quot;DEBUG: Repository returned post ID: &quot; + post.getId() + &#13;&#10;                &quot;, Author ID: &quot; + (post.getAuthor() != null ? post.getAuthor().getId() : &quot;null&quot;) +&#13;&#10;                &quot;, Author Name: &quot; + (post.getAuthor() != null ? post.getAuthor().getName() : &quot;null&quot;));&#13;&#10;        });&#13;&#10;        &#13;&#10;        // Recalculate stats for each post before returning&#13;&#10;        posts.forEach(this::recalculatePostStats);&#13;&#10;        postRepository.saveAll(posts.getContent());&#13;&#10;        &#13;&#10;        return posts.map(PostResponse::new);&#13;&#10;    }&#13;&#10;&#13;&#10;    public Page&lt;PostResponse&gt; getPostsByCategory(String category, Pageable pageable) {&#13;&#10;        return postRepository.findByCategory(category, pageable)&#13;&#10;                .map(PostResponse::new);&#13;&#10;    }&#13;&#10;&#13;&#10;    public Page&lt;PostResponse&gt; searchPosts(String searchTerm, Pageable pageable) {&#13;&#10;        return postRepository.findByTitleContainingOrContentContaining(searchTerm, searchTerm, pageable)&#13;&#10;                .map(PostResponse::new);&#13;&#10;    }&#13;&#10;&#13;&#10;    public PostResponse getPostById(String id, String currentUserId) {&#13;&#10;        Optional&lt;PostEntity&gt; postOpt = postRepository.findById(id);&#13;&#10;        if (postOpt.isPresent()) {&#13;&#10;            PostEntity post = postOpt.get();&#13;&#10;&#13;&#10;            // Record view interaction if user is different from author&#13;&#10;            if (currentUserId != null &amp;&amp; !currentUserId.equals(post.getAuthorId())) {&#13;&#10;                recordViewInteraction(post.getId(), currentUserId);&#13;&#10;            }&#13;&#10;&#13;&#10;            // Recalculate stats from database before returning&#13;&#10;            recalculatePostStats(post);&#13;&#10;            postRepository.save(post);&#13;&#10;            &#13;&#10;            return new PostResponse(post);&#13;&#10;        }&#13;&#10;        throw new RuntimeException(&quot;Post not found with id: &quot; + id);&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Recalculate post stats from actual interactions in database&#13;&#10;     * This fixes the issue where stats show 0 even when interactions exist&#13;&#10;     */&#13;&#10;    private void recalculatePostStats(PostEntity post) {&#13;&#10;        // Count actual likes from interactions&#13;&#10;        long likeCount = interactionRepository.countByPostIdAndType(post.getId(), InteractionEntity.InteractionType.LIKE);&#13;&#10;        long bookmarkCount = interactionRepository.countByPostIdAndType(post.getId(), InteractionEntity.InteractionType.BOOKMARK);&#13;&#10;        long shareCount = interactionRepository.countByPostIdAndType(post.getId(), InteractionEntity.InteractionType.SHARE);&#13;&#10;        &#13;&#10;        // Count comments&#13;&#10;        long commentCount = commentRepository.countByPostId(post.getId());&#13;&#10;        &#13;&#10;        // Update post stats&#13;&#10;        post.getStats().setLikes(likeCount);&#13;&#10;        post.getStats().setComments(commentCount); &#13;&#10;        post.getStats().setShares(shareCount);&#13;&#10;        &#13;&#10;        // Update reactions map for LIKE type&#13;&#10;        post.getStats().getReactions().put(InteractionEntity.ReactionType.LIKE, (int) likeCount);&#13;&#10;    }&#13;&#10;&#13;&#10;    public PostResponse updatePost(String id, PostRequest request, String authorId) {&#13;&#10;        Optional&lt;PostEntity&gt; postOpt = postRepository.findById(id);&#13;&#10;        if (postOpt.isPresent()) {&#13;&#10;            PostEntity post = postOpt.get();&#13;&#10;&#13;&#10;            // Check if user is the author&#13;&#10;            if (!post.getAuthorId().equals(authorId)) {&#13;&#10;                throw new RuntimeException(&quot;Only the author can update this post&quot;);&#13;&#10;            }&#13;&#10;&#13;&#10;            if (request.getTitle() != null) {&#13;&#10;                post.setTitle(request.getTitle());&#13;&#10;            }&#13;&#10;            if (request.getContent() != null) {&#13;&#10;                post.setContent(request.getContent());&#13;&#10;            }&#13;&#10;            if (request.getTags() != null) {&#13;&#10;                post.setTags(request.getTags());&#13;&#10;            }&#13;&#10;            if (request.getCategory() != null) {&#13;&#10;                post.setCategory(request.getCategory());&#13;&#10;            }&#13;&#10;            if (request.getVisibility() != null) {&#13;&#10;                post.setVisibility(request.getVisibility());&#13;&#10;            }&#13;&#10;&#13;&#10;            PostEntity savedPost = postRepository.save(post);&#13;&#10;&#13;&#10;            // Publish event&#13;&#10;            eventService.publishPostEvent(&quot;POST_UPDATED&quot;, savedPost.getId(), savedPost.getAuthorId(), savedPost);&#13;&#10;&#13;&#10;            return new PostResponse(savedPost);&#13;&#10;        }&#13;&#10;        throw new RuntimeException(&quot;Post not found with id: &quot; + id);&#13;&#10;    }&#13;&#10;&#13;&#10;    public void deletePost(String id, String authorId) {&#13;&#10;        Optional&lt;PostEntity&gt; postOpt = postRepository.findById(id);&#13;&#10;        if (postOpt.isPresent()) {&#13;&#10;            PostEntity post = postOpt.get();&#13;&#10;&#13;&#10;            // Check if user is the author&#13;&#10;            if (!post.getAuthorId().equals(authorId)) {&#13;&#10;                throw new RuntimeException(&quot;Only the author can delete this post&quot;);&#13;&#10;            }&#13;&#10;&#13;&#10;            // Delete associated comments and interactions&#13;&#10;            commentRepository.deleteByPostId(id);&#13;&#10;            interactionRepository.deleteByPostId(id);&#13;&#10;&#13;&#10;            // Delete the post&#13;&#10;            postRepository.deleteById(id);&#13;&#10;&#13;&#10;            // Publish event&#13;&#10;            eventService.publishPostEvent(&quot;POST_DELETED&quot;, id, authorId, post);&#13;&#10;        } else {&#13;&#10;            throw new RuntimeException(&quot;Post not found with id: &quot; + id);&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    private void recordViewInteraction(String postId, String userId) {&#13;&#10;        try {&#13;&#10;            AuthorInfo author = userServiceClient.getAuthorInfo(userId);&#13;&#10;            if (author == null) return;&#13;&#10;&#13;&#10;            // Check if user already viewed this post recently (within last hour)&#13;&#10;            Optional&lt;InteractionEntity&gt; existingView = interactionRepository&#13;&#10;                    .findByPostIdAndAuthor_IdAndType(postId, userId, InteractionEntity.InteractionType.VIEW);&#13;&#10;&#13;&#10;            if (existingView.isEmpty()) {&#13;&#10;                // Create view interaction&#13;&#10;                InteractionEntity viewInteraction = new InteractionEntity(postId, author, InteractionEntity.InteractionType.VIEW);&#13;&#10;                interactionRepository.save(viewInteraction);&#13;&#10;&#13;&#10;                // Update post stats&#13;&#10;                Optional&lt;PostEntity&gt; postOpt = postRepository.findById(postId);&#13;&#10;                if (postOpt.isPresent()) {&#13;&#10;                    PostEntity post = postOpt.get();&#13;&#10;                    post.getStats().incrementViews();&#13;&#10;                    postRepository.save(post);&#13;&#10;                }&#13;&#10;&#13;&#10;                // Publish interaction event&#13;&#10;                eventService.publishInteractionEvent(postId, userId, &quot;VIEW&quot;);&#13;&#10;            }&#13;&#10;        } catch (Exception e) {&#13;&#10;            // Log error but don't fail the main operation&#13;&#10;            System.err.println(&quot;Failed to record view interaction: &quot; + e.getMessage());&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    private String getFileType(MultipartFile file) {&#13;&#10;        String contentType = file.getContentType();&#13;&#10;        if (contentType != null) {&#13;&#10;            if (contentType.startsWith(&quot;image/&quot;)) return &quot;IMAGE&quot;;&#13;&#10;            if (contentType.startsWith(&quot;video/&quot;)) return &quot;VIDEO&quot;;&#13;&#10;            if (contentType.startsWith(&quot;audio/&quot;)) return &quot;AUDIO&quot;;&#13;&#10;            if (contentType.equals(&quot;application/pdf&quot;)) return &quot;PDF&quot;;&#13;&#10;        }&#13;&#10;        return &quot;DOCUMENT&quot;;&#13;&#10;    }&#13;&#10;&#13;&#10;    public List&lt;PostResponse&gt; getTopViewedPosts() {&#13;&#10;        return postRepository.findTop10ByOrderByStatsViewsDesc()&#13;&#10;                .stream()&#13;&#10;                .map(PostResponse::new)&#13;&#10;                .toList();&#13;&#10;    }&#13;&#10;&#13;&#10;    public List&lt;PostResponse&gt; getTopLikedPosts() {&#13;&#10;        return postRepository.findTop10ByOrderByStatsLikesDesc()&#13;&#10;                .stream()&#13;&#10;                .map(PostResponse::new)&#13;&#10;                .toList();&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Enhanced post creation with Facebook-like features&#13;&#10;     */&#13;&#10;    public PostResponse createEnhancedPost(PostRequest request, AuthenticatedUser user) {&#13;&#10;        AuthorInfo author = userServiceClient.getAuthorInfo(user.getId());&#13;&#10;        if (author == null) {&#13;&#10;            throw new RuntimeException(&quot;Author not found with id: &quot; + user.getId());&#13;&#10;        }&#13;&#10;&#13;&#10;        PostEntity post = PostEntity.builder()&#13;&#10;                .title(request.getTitle())&#13;&#10;                .content(request.getContent())&#13;&#10;                .author(author)&#13;&#10;                .images(request.getImages() != null ? request.getImages() : new ArrayList&lt;&gt;())&#13;&#10;                .videos(request.getVideos() != null ? request.getVideos() : new ArrayList&lt;&gt;())&#13;&#10;                .tags(request.getTags() != null ? request.getTags() : new ArrayList&lt;&gt;())&#13;&#10;                .category(request.getCategory())&#13;&#10;                .privacy(request.getVisibility() != null ? request.getVisibility() : &quot;PUBLIC&quot;)&#13;&#10;                .postType(request.getPostType() != null ? PostEntity.PostType.valueOf(request.getPostType()) : PostEntity.PostType.TEXT)&#13;&#10;                .stats(new PostEntity.PostStats())&#13;&#10;                .audienceSettings(new PostEntity.AudienceSettings())&#13;&#10;                .engagement(new PostEntity.EngagementMetrics())&#13;&#10;                .build();&#13;&#10;&#13;&#10;        // Set audience settings if provided&#13;&#10;        if (request.getAudienceSettings() != null) {&#13;&#10;            post.setAudienceSettings(request.getAudienceSettings());&#13;&#10;        }&#13;&#10;&#13;&#10;        // Handle scheduled posts&#13;&#10;        if (request.getScheduledAt() != null) {&#13;&#10;            post.setScheduledAt(request.getScheduledAt());&#13;&#10;            post.setScheduled(true);&#13;&#10;        }&#13;&#10;&#13;&#10;        PostEntity savedPost = postRepository.save(post);&#13;&#10;&#13;&#10;        // Publish event&#13;&#10;        eventService.publishPostEvent(&quot;POST_CREATED&quot;, savedPost.getId(), savedPost.getAuthorId(), savedPost);&#13;&#10;&#13;&#10;        return new PostResponse(savedPost);&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Get users affected by a post (for cache invalidation)&#13;&#10;     */&#13;&#10;    public Set&lt;String&gt; getAffectedUserIds(String postId) {&#13;&#10;        Optional&lt;PostEntity&gt; postOpt = postRepository.findById(postId);&#13;&#10;        if (postOpt.isPresent()) {&#13;&#10;            PostEntity post = postOpt.get();&#13;&#10;            Set&lt;String&gt; affectedUsers = new HashSet&lt;&gt;();&#13;&#10;&#13;&#10;            // Add author&#13;&#10;            affectedUsers.add(post.getAuthorId());&#13;&#10;&#13;&#10;            // Add friends if post is visible to friends&#13;&#10;            if (&quot;FRIENDS&quot;.equals(post.getPrivacy()) || &quot;PUBLIC&quot;.equals(post.getPrivacy())) {&#13;&#10;                Set&lt;String&gt; authorFriends = userServiceClient.getFriendIds(post.getAuthorId());&#13;&#10;                affectedUsers.addAll(authorFriends);&#13;&#10;            }&#13;&#10;&#13;&#10;            return affectedUsers;&#13;&#10;        }&#13;&#10;        return new HashSet&lt;&gt;();&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Handle post interactions (like, comment, share)&#13;&#10;     */&#13;&#10;    public void handlePostInteraction(String postId, String userId, String action, String reactionType) {&#13;&#10;        Optional&lt;PostEntity&gt; postOpt = postRepository.findById(postId);&#13;&#10;        if (postOpt.isEmpty()) {&#13;&#10;            throw new RuntimeException(&quot;Post not found with id: &quot; + postId);&#13;&#10;        }&#13;&#10;&#13;&#10;        PostEntity post = postOpt.get();&#13;&#10;        AuthorInfo user = userServiceClient.getAuthorInfo(userId);&#13;&#10;        if (user == null) {&#13;&#10;            throw new RuntimeException(&quot;User not found with id: &quot; + userId);&#13;&#10;        }&#13;&#10;&#13;&#10;        switch (action.toUpperCase()) {&#13;&#10;            case &quot;LIKE&quot;:&#13;&#10;                handleLikeInteraction(postId, userId, reactionType, post, user);&#13;&#10;                break;&#13;&#10;            case &quot;UNLIKE&quot;:&#13;&#10;                handleUnlikeInteraction(postId, userId, post);&#13;&#10;                break;&#13;&#10;            case &quot;SHARE&quot;:&#13;&#10;                handleShareInteraction(postId, userId, post, user);&#13;&#10;                break;&#13;&#10;            default:&#13;&#10;                throw new RuntimeException(&quot;Unsupported action: &quot; + action);&#13;&#10;        }&#13;&#10;&#13;&#10;        // Update engagement metrics&#13;&#10;        updateEngagementMetrics(post);&#13;&#10;        postRepository.save(post);&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Get post author ID&#13;&#10;     */&#13;&#10;    public String getPostAuthorId(String postId) {&#13;&#10;        Optional&lt;PostEntity&gt; postOpt = postRepository.findById(postId);&#13;&#10;        if (postOpt.isPresent()) {&#13;&#10;            return postOpt.get().getAuthorId();&#13;&#10;        }&#13;&#10;        throw new RuntimeException(&quot;Post not found with id: &quot; + postId);&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Add comment to post&#13;&#10;     */&#13;&#10;    public void addComment(String postId, String userId, String content) {&#13;&#10;        Optional&lt;PostEntity&gt; postOpt = postRepository.findById(postId);&#13;&#10;        if (postOpt.isEmpty()) {&#13;&#10;            throw new RuntimeException(&quot;Post not found with id: &quot; + postId);&#13;&#10;        }&#13;&#10;&#13;&#10;        AuthorInfo author = userServiceClient.getAuthorInfo(userId);&#13;&#10;        if (author == null) {&#13;&#10;            throw new RuntimeException(&quot;User not found with id: &quot; + userId);&#13;&#10;        }&#13;&#10;&#13;&#10;        CommentEntity comment = CommentEntity.builder()&#13;&#10;                .postId(postId)&#13;&#10;                .author(author)&#13;&#10;                .content(content)&#13;&#10;                .build();&#13;&#10;&#13;&#10;        commentRepository.save(comment);&#13;&#10;&#13;&#10;        // Update post comment count&#13;&#10;        PostEntity post = postOpt.get();&#13;&#10;        post.getStats().incrementComments();&#13;&#10;        updateEngagementMetrics(post);&#13;&#10;        postRepository.save(post);&#13;&#10;&#13;&#10;        // Publish event&#13;&#10;        eventService.publishPostEvent(&quot;COMMENT_ADDED&quot;, postId, userId, comment);&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Get post analytics&#13;&#10;     */&#13;&#10;    public PostAnalyticsResponse getPostAnalytics(String postId, String userId) {&#13;&#10;        Optional&lt;PostEntity&gt; postOpt = postRepository.findById(postId);&#13;&#10;        if (postOpt.isEmpty()) {&#13;&#10;            throw new RuntimeException(&quot;Post not found with id: &quot; + postId);&#13;&#10;        }&#13;&#10;&#13;&#10;        PostEntity post = postOpt.get();&#13;&#10;&#13;&#10;        // Check if user is the post author&#13;&#10;        if (!post.getAuthorId().equals(userId)) {&#13;&#10;            throw new RuntimeException(&quot;Only post author can view analytics&quot;);&#13;&#10;        }&#13;&#10;&#13;&#10;        return PostAnalyticsResponse.builder()&#13;&#10;                .postId(postId)&#13;&#10;                .views(post.getStats().getViews())&#13;&#10;                .likes(post.getStats().getLikes())&#13;&#10;                .comments(post.getStats().getComments())&#13;&#10;                .shares(post.getStats().getShares())&#13;&#10;                .engagementRate(post.getEngagement().getEngagementRate())&#13;&#10;                .reactions(post.getStats().getReactions())&#13;&#10;                .build();&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Schedule post for later publishing&#13;&#10;     */&#13;&#10;    public PostResponse schedulePost(ScheduledPostRequest request, AuthenticatedUser user) {&#13;&#10;        AuthorInfo author = userServiceClient.getAuthorInfo(user.getId());&#13;&#10;        if (author == null) {&#13;&#10;            throw new RuntimeException(&quot;Author not found with id: &quot; + user.getId());&#13;&#10;        }&#13;&#10;&#13;&#10;        PostEntity post = PostEntity.builder()&#13;&#10;                .title(request.getTitle())&#13;&#10;                .content(request.getContent())&#13;&#10;                .author(author)&#13;&#10;                .images(request.getImages() != null ? request.getImages() : new ArrayList&lt;&gt;())&#13;&#10;                .tags(request.getTags() != null ? request.getTags() : new ArrayList&lt;&gt;())&#13;&#10;                .category(request.getCategory())&#13;&#10;                .privacy(request.getVisibility() != null ? request.getVisibility() : &quot;PUBLIC&quot;)&#13;&#10;                .scheduledAt(request.getScheduledAt())&#13;&#10;                .isScheduled(true)&#13;&#10;                .stats(new PostEntity.PostStats())&#13;&#10;                .build();&#13;&#10;&#13;&#10;        PostEntity savedPost = postRepository.save(post);&#13;&#10;        return new PostResponse(savedPost);&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Enhanced search with filters&#13;&#10;     */&#13;&#10;    public List&lt;PostResponse&gt; searchPosts(String query, String category, String faculty,&#13;&#10;                                        String dateRange, Pageable pageable) {&#13;&#10;        // This would need to be implemented with proper MongoDB queries&#13;&#10;        // For now, implementing basic search&#13;&#10;        Page&lt;PostEntity&gt; posts;&#13;&#10;&#13;&#10;        if (category != null &amp;&amp; !category.isEmpty()) {&#13;&#10;            posts = postRepository.findByCategoryAndTitleContainingOrContentContaining(&#13;&#10;                category, query, query, pageable);&#13;&#10;        } else {&#13;&#10;            posts = postRepository.findByTitleContainingOrContentContaining(query, query, pageable);&#13;&#10;        }&#13;&#10;&#13;&#10;        return posts.stream()&#13;&#10;                .map(PostResponse::new)&#13;&#10;                .collect(Collectors.toList());&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Update author information in posts (for data consistency)&#13;&#10;     */&#13;&#10;    public void updateAuthorInfoInPosts(String userId, String fullName, String avatarUrl) {&#13;&#10;        List&lt;PostEntity&gt; userPosts = postRepository.findByAuthor_Id(userId);&#13;&#10;&#13;&#10;        for (PostEntity post : userPosts) {&#13;&#10;            AuthorInfo updatedAuthor = post.getAuthor();&#13;&#10;            updatedAuthor.setFullName(fullName);&#13;&#10;            updatedAuthor.setAvatarUrl(avatarUrl);&#13;&#10;            post.setAuthor(updatedAuthor);&#13;&#10;        }&#13;&#10;&#13;&#10;        if (!userPosts.isEmpty()) {&#13;&#10;            postRepository.saveAll(userPosts);&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    // Helper methods&#13;&#10;    private void handleLikeInteraction(String postId, String userId, String reactionType,&#13;&#10;                                     PostEntity post, AuthorInfo user) {&#13;&#10;        InteractionEntity.ReactionType reaction =&#13;&#10;            reactionType != null ?&#13;&#10;            InteractionEntity.ReactionType.valueOf(reactionType.toUpperCase()) :&#13;&#10;            InteractionEntity.ReactionType.LIKE;&#13;&#10;&#13;&#10;        // Check if user already reacted&#13;&#10;        Optional&lt;InteractionEntity&gt; existingInteraction = interactionRepository&#13;&#10;                .findByPostIdAndAuthor_IdAndType(postId, userId, InteractionEntity.InteractionType.REACTION);&#13;&#10;&#13;&#10;        if (existingInteraction.isEmpty()) {&#13;&#10;            // Create new reaction&#13;&#10;            InteractionEntity interaction = InteractionEntity.builder()&#13;&#10;                    .postId(postId)&#13;&#10;                    .author(user)&#13;&#10;                    .type(InteractionEntity.InteractionType.REACTION)&#13;&#10;                    .reactionType(reaction)&#13;&#10;                    .build();&#13;&#10;&#13;&#10;            interactionRepository.save(interaction);&#13;&#10;            post.getStats().incrementReaction(reaction);&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    private void handleUnlikeInteraction(String postId, String userId, PostEntity post) {&#13;&#10;        Optional&lt;InteractionEntity&gt; existingInteraction = interactionRepository&#13;&#10;                .findByPostIdAndAuthor_IdAndType(postId, userId, InteractionEntity.InteractionType.REACTION);&#13;&#10;&#13;&#10;        if (existingInteraction.isPresent()) {&#13;&#10;            InteractionEntity interaction = existingInteraction.get();&#13;&#10;            post.getStats().decrementReaction(interaction.getReactionType());&#13;&#10;            interactionRepository.delete(interaction);&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    private void handleShareInteraction(String postId, String userId, PostEntity post, AuthorInfo user) {&#13;&#10;        InteractionEntity interaction = InteractionEntity.builder()&#13;&#10;                .postId(postId)&#13;&#10;                .author(user)&#13;&#10;                .type(InteractionEntity.InteractionType.SHARE)&#13;&#10;                .build();&#13;&#10;&#13;&#10;        interactionRepository.save(interaction);&#13;&#10;        post.getStats().incrementShares();&#13;&#10;    }&#13;&#10;&#13;&#10;    private void updateEngagementMetrics(PostEntity post) {&#13;&#10;        PostEntity.EngagementMetrics engagement = post.getEngagement();&#13;&#10;        PostEntity.PostStats stats = post.getStats();&#13;&#10;&#13;&#10;        engagement.updateEngagement(&#13;&#10;            (int) stats.getLikes(),&#13;&#10;            (int) stats.getComments(),&#13;&#10;            (int) stats.getShares(),&#13;&#10;            (int) stats.getViews()&#13;&#10;        );&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/service/UserServiceClient.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/service/UserServiceClient.java" />
              <option name="updatedContent" value="package com.ctuconnect.service;&#10;&#10;import org.springframework.cloud.openfeign.FeignClient;&#10;import org.springframework.web.bind.annotation.GetMapping;&#10;import org.springframework.web.bind.annotation.PathVariable;&#10;&#10;import java.util.Set;&#10;&#10;@FeignClient(name = &quot;user-service&quot;, url = &quot;${user-service.url:http://user-service:8081}&quot;)&#10;public interface UserServiceClient {&#10;    &#10;    @GetMapping(&quot;/api/users/{userId}/friends/ids&quot;)&#10;    Set&lt;String&gt; getFriendIds(@PathVariable String userId);&#10;    &#10;    @GetMapping(&quot;/api/users/{userId}/close-interactions&quot;)&#10;    Set&lt;String&gt; getCloseInteractionIds(@PathVariable String userId);&#10;    &#10;    @GetMapping(&quot;/api/users/{userId}/same-faculty&quot;)&#10;    Set&lt;String&gt; getSameFacultyUserIds(@PathVariable String userId);&#10;    &#10;    @GetMapping(&quot;/api/users/{userId}/same-major&quot;)&#10;    Set&lt;String&gt; getSameMajorUserIds(@PathVariable String userId);&#10;    &#10;    @GetMapping(&quot;/api/users/{userId}/interest-tags&quot;)&#10;    Set&lt;String&gt; getUserInterestTags(@PathVariable String userId);&#10;    &#10;    @GetMapping(&quot;/api/users/{userId}/preferred-categories&quot;)&#10;    Set&lt;String&gt; getUserPreferredCategories(@PathVariable String userId);&#10;    &#10;    @GetMapping(&quot;/api/users/{userId}/faculty-id&quot;)&#10;    String getUserFacultyId(@PathVariable String userId);&#10;    &#10;    @GetMapping(&quot;/api/users/{userId}/major-id&quot;)&#10;    String getUserMajorId(@PathVariable String userId);&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/post-service/src/main/resources/application-docker.properties">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/post-service/src/main/resources/application-docker.properties" />
              <option name="originalContent" value="# Docker-specific configuration for post-service&#10;spring.application.name=post-service&#10;server.port=8085&#10;&#10;# MongoDB Configuration - Docker service name&#10;spring.data.mongodb.database=post_db&#10;spring.data.mongodb.host=post_db&#10;spring.data.mongodb.port=27017&#10;&#10;# Redis Configuration - Docker service name&#10;spring.data.redis.host=redis&#10;spring.data.redis.port=6379&#10;spring.data.redis.timeout=60000ms&#10;spring.data.redis.lettuce.pool.max-active=8&#10;spring.data.redis.lettuce.pool.max-idle=8&#10;spring.data.redis.lettuce.pool.max-idle=8&#10;spring.data.redis.lettuce.pool.max-idle=8&#10;spring.data.redis.lettuce.pool.max-idle=8&#10;spring.data.redis.lettuce.pool.max-idle=8&#10;spring.data.redis.lettuce.pool.max-idle=8&#10;spring.data.redis.lettuce.pool.max-idle=8&#10;spring.data.redis.lettuce.pool.max-idle=8&#10;spring.data.redis.lettuce.pool.min-idle=0&#10;&#10;# Kafka Configuration - Docker service name&#10;spring.kafka.bootstrap-servers=kafka:9092&#10;spring.kafka.producer.key-serializer=org.apache.kafka.common.serialization.StringSerializer&#10;spring.kafka.producer.value-serializer=org.springframework.kafka.support.serializer.JsonSerializer&#10;&#10;spring.kafka.consumer.group-id=post-service-group&#10;spring.kafka.consumer.key-deserializer=org.apache.kafka.common.serialization.StringDeserializer&#10;" />
              <option name="updatedContent" value="# Docker-specific configuration for post-service&#13;&#10;spring.application.name=post-service&#13;&#10;server.port=8085&#13;&#10;&#13;&#10;# MongoDB Configuration - Docker service name&#13;&#10;spring.data.mongodb.database=post_db&#13;&#10;spring.data.mongodb.host=post_db&#13;&#10;spring.data.mongodb.port=27017&#13;&#10;&#13;&#10;# Redis Configuration - Docker service name&#13;&#10;spring.data.redis.host=redis&#13;&#10;spring.data.redis.port=6379&#13;&#10;spring.data.redis.timeout=60000ms&#13;&#10;spring.data.redis.lettuce.pool.max-active=8&#13;&#10;spring.data.redis.lettuce.pool.min-idle=0&#13;&#10;&#13;&#10;# Kafka Configuration - Docker service name&#13;&#10;spring.kafka.bootstrap-servers=kafka:9092&#13;&#10;spring.kafka.producer.key-serializer=org.apache.kafka.common.serialization.StringSerializer&#13;&#10;spring.kafka.producer.value-serializer=org.springframework.kafka.support.serializer.JsonSerializer&#13;&#10;&#13;&#10;spring.kafka.consumer.group-id=post-service-group&#13;&#10;spring.kafka.consumer.key-deserializer=org.apache.kafka.common.serialization.StringDeserializer&#13;&#10;spring.kafka.consumer.value-deserializer=org.springframework.kafka.support.serializer.JsonDeserializer&#13;&#10;spring.kafka.consumer.properties.spring.json.trusted.packages=*&#13;&#10;spring.kafka.consumer.auto-offset-reset=earliest&#13;&#10;spring.kafka.consumer.enable-auto-commit=true&#13;&#10;&#13;&#10;# Eureka Configuration - Docker service name&#13;&#10;eureka.client.service-url.defaultZone=http://eureka-server:8761/eureka/&#13;&#10;eureka.instance.prefer-ip-address=true&#13;&#10;eureka.instance.instance-id=${spring.application.name}:${server.port}&#13;&#10;&#13;&#10;# User Service Configuration - Docker service name&#13;&#10;user-service.url=http://user-service:8081&#13;&#10;&#13;&#10;# Media Service Configuration - Docker service name&#13;&#10;media-service.url=http://media-service:8084&#13;&#10;&#13;&#10;# Feign Configuration&#13;&#10;feign.client.config.default.connect-timeout=10000&#13;&#10;feign.client.config.default.read-timeout=10000&#13;&#10;feign.client.config.default.logger-level=basic&#13;&#10;&#13;&#10;# File Upload Configuration&#13;&#10;spring.servlet.multipart.max-file-size=10MB&#13;&#10;spring.servlet.multipart.max-request-size=50MB&#13;&#10;&#13;&#10;# Actuator Configuration&#13;&#10;management.endpoints.web.exposure.include=health,info,metrics&#13;&#10;management.endpoint.health.show-details=always&#13;&#10;&#13;&#10;# Logging Configuration&#13;&#10;logging.level.com.ctuconnect=DEBUG&#13;&#10;logging.level.org.springframework.kafka=INFO&#13;&#10;logging.level.org.springframework.data.mongodb=INFO" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/post-service/src/main/resources/application.properties">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/post-service/src/main/resources/application.properties" />
              <option name="originalContent" value="spring.application.name=post-service&#10;server.port=8085&#10;&#10;# MongoDB Configuration&#10;spring.data.mongodb.database=post_db&#10;spring.data.mongodb.host=localhost&#10;spring.data.mongodb.port=27018&#10;&#10;# Kafka Configuration&#10;spring.kafka.bootstrap-servers=localhost:9092&#10;spring.kafka.producer.key-serializer=org.apache.kafka.common.serialization.StringSerializer&#10;spring.kafka.producer.value-serializer=org.springframework.kafka.support.serializer.JsonSerializer&#10;&#10;# Kafka Consumer Configuration - Fix missing group-id error&#10;spring.kafka.consumer.group-id=post-service-group&#10;spring.kafka.consumer.key-deserializer=org.apache.kafka.common.serialization.StringDeserializer&#10;spring.kafka.consumer.value-deserializer=org.springframework.kafka.support.serializer.JsonDeserializer&#10;spring.kafka.consumer.properties.spring.json.trusted.packages=*&#10;spring.kafka.consumer.auto-offset-reset=earliest&#10;spring.kafka.consumer.enable-auto-commit=true&#10;&#10;# Eureka Configuration&#10;eureka.client.service-url.defaultZone=http://localhost:8761/eureka/&#10;eureka.instance.prefer-ip-address=true&#10;eureka.instance.instance-id=${spring.application.name}:${server.port}&#10;&#10;# Redis Configuration - Fix for Docker container networking&#10;spring.data.redis.host=redis&#10;spring.data.redis.port=6379&#10;spring.data.redis.timeout=60000ms&#10;spring.data.redis.lettuce.pool.max-active=8&#10;spring.data.redis.lettuce.pool.max-idle=8&#10;spring.data.redis.lettuce.pool.min-idle=0&#10;&#10;" />
              <option name="updatedContent" value="spring.application.name=post-service&#10;server.port=8085&#10;&#10;# MongoDB Configuration&#10;spring.data.mongodb.database=post_db&#10;spring.data.mongodb.host=localhost&#10;spring.data.mongodb.port=27018&#10;&#10;# Kafka Configuration&#10;spring.kafka.bootstrap-servers=localhost:9092&#10;spring.kafka.producer.key-serializer=org.apache.kafka.common.serialization.StringSerializer&#10;spring.kafka.producer.value-serializer=org.springframework.kafka.support.serializer.JsonSerializer&#10;&#10;# Kafka Consumer Configuration - Fix missing group-id error&#10;spring.kafka.consumer.group-id=post-service-group&#10;spring.kafka.consumer.key-deserializer=org.apache.kafka.common.serialization.StringDeserializer&#10;spring.kafka.consumer.value-deserializer=org.springframework.kafka.support.serializer.JsonDeserializer&#10;spring.kafka.consumer.properties.spring.json.trusted.packages=*&#10;spring.kafka.consumer.auto-offset-reset=earliest&#10;spring.kafka.consumer.enable-auto-commit=true&#10;&#10;# Eureka Configuration&#10;eureka.client.service-url.defaultZone=http://localhost:8761/eureka/&#10;eureka.instance.prefer-ip-address=true&#10;eureka.instance.instance-id=${spring.application.name}:${server.port}&#10;&#10;# Redis Configuration - Fix for Docker container networking&#10;spring.data.redis.host=redis&#10;spring.data.redis.port=6379&#10;spring.data.redis.timeout=60000ms&#10;spring.data.redis.lettuce.pool.max-active=8&#10;spring.data.redis.lettuce.pool.max-idle=8&#10;spring.data.redis.lettuce.pool.min-idle=0&#10;&#10;# User Service Configuration&#10;user-service.url=http://localhost:8081&#10;&#10;# Media Service Configuration&#10;media-service.url=http://localhost:8084&#10;&#10;# Feign Configuration&#10;feign.client.config.default.connect-timeout=5000&#10;feign.client.config.default.read-timeout=5000&#10;feign.client.config.default.logger-level=basic&#10;&#10;# File Upload Configuration&#10;spring.servlet.multipart.max-file-size=10MB&#10;spring.servlet.multipart.max-request-size=50MB&#10;&#10;# Actuator Configuration&#10;management.endpoints.web.exposure.include=health,info,metrics&#10;management.endpoint.health.show-details=always&#10;&#10;# Logging Configuration&#10;logging.level.vn.ctu.edu.postservice=DEBUG&#10;logging.level.org.springframework.kafka=INFO&#10;logging.level.org.springframework.data.mongodb=INFO" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/recommendation-service/Dockerfile">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/recommendation-service/Dockerfile" />
              <option name="originalContent" value="FROM python:3.11-slim&#10;&#10;# Set working directory&#10;WORKDIR /app&#10;&#10;# Install system dependencies&#10;RUN apt-get update &amp;&amp; apt-get install -y \&#10;    gcc \&#10;    g++ \&#10;    curl \&#10;RUN pip install --no-cache-dir -r requirements.txt&#10;RUN pip install --no-cache-dir -r requirements.txt&#10;RUN pip install --no-cache-dir -r requirements.txt&#10;RUN pip install --no-cache-dir -r requirements.txt&#10;RUN pip install --no-cache-dir -r requirements.txt&#10;RUN pip install --no-cache-dir -r requirements.txt&#10;RUN pip install --no-cache-dir -r requirements.txt&#10;" />
              <option name="updatedContent" value="FROM python:3.11-slim&#10;&#10;# Set working directory&#10;WORKDIR /app&#10;&#10;# Install system dependencies&#10;RUN apt-get update &amp;&amp; apt-get install -y \&#10;    gcc \&#10;    g++ \&#10;    curl \&#10;    wget \&#10;    &amp;&amp; rm -rf /var/lib/apt/lists/*&#10;&#10;# Copy requirements first for better caching&#10;COPY requirements.txt .&#10;&#10;# Install Python dependencies&#10;RUN pip install --no-cache-dir --upgrade pip &amp;&amp; \&#10;    pip install --no-cache-dir -r requirements.txt&#10;&#10;# Copy application code&#10;COPY . .&#10;&#10;# Create models directory&#10;RUN mkdir -p models&#10;&#10;# Create non-root user for security&#10;RUN useradd --create-home --shell /bin/bash --uid 1000 app \&#10;    &amp;&amp; chown -R app:app /app&#10;USER app&#10;&#10;# Expose port&#10;EXPOSE 8000&#10;&#10;# Health check compatible with Spring Boot actuator format&#10;HEALTHCHECK --interval=30s --timeout=30s --start-period=60s --retries=3 \&#10;    CMD curl -f http://localhost:8000/health || exit 1&#10;&#10;# Environment variables for production&#10;ENV PYTHONPATH=/app&#10;ENV PYTHONUNBUFFERED=1&#10;ENV PYTHONDONTWRITEBYTECODE=1&#10;&#10;# Run the application with gunicorn for production&#10;CMD [&quot;python&quot;, &quot;-m&quot;, &quot;uvicorn&quot;, &quot;main:app&quot;, &quot;--host&quot;, &quot;0.0.0.0&quot;, &quot;--port&quot;, &quot;8000&quot;, &quot;--workers&quot;, &quot;1&quot;]" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/recommendation-service/README.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/recommendation-service/README.md" />
              <option name="updatedContent" value="# CTU Connect Recommendation Service&#10;&#10;A comprehensive AI-powered recommendation microservice for the CTU Connect social platform, featuring deep learning models, reinforcement learning, A/B testing, and real-time personalization.&#10;&#10;## Features&#10;&#10;### Core Capabilities&#10;- **Deep Learning Personalization**: Uses PyTorch with PhoBERT for Vietnamese content understanding&#10;- **Multi-head Attention**: Advanced attention mechanisms for user-post relevance scoring&#10;- **Reinforcement Learning**: DQN-based continuous learning from user feedback&#10;- **A/B Testing**: Built-in experimentation framework with multiple model variants&#10;- **Real-time Processing**: Kafka-based streaming for instant recommendation updates&#10;- **Caching**: Redis-powered caching for sub-100ms response times&#10;- **Monitoring**: Prometheus metrics and comprehensive logging&#10;&#10;### Technical Architecture&#10;- **Framework**: FastAPI with async/await for high performance&#10;- **Database**: PostgreSQL with async SQLAlchemy&#10;- **Message Queue**: Apache Kafka for real-time data streaming&#10;- **Caching**: Redis for recommendation and feature caching&#10;- **ML Ops**: MLflow for experiment tracking and model versioning&#10;- **Deployment**: Docker and Kubernetes with auto-scaling&#10;&#10;## Quick Start&#10;&#10;### Prerequisites&#10;- Python 3.11+&#10;- PostgreSQL 12+&#10;- Redis 6+&#10;- Apache Kafka 2.8+&#10;&#10;### Installation&#10;&#10;1. **Clone and setup environment**:&#10;```bash&#10;cd recommendation-service&#10;python -m venv venv&#10;source venv/bin/activate  # Windows: venv\Scripts\activate&#10;pip install -r requirements.txt&#10;```&#10;&#10;2. **Configure environment variables**:&#10;```bash&#10;export DATABASE_URL=&quot;postgresql+asyncpg://user:pass@localhost:5432/recommendation_db&quot;&#10;export REDIS_URL=&quot;redis://localhost:6379&quot;&#10;export KAFKA_BOOTSTRAP_SERVERS=&quot;localhost:9092&quot;&#10;export SECRET_KEY=&quot;your-secret-key&quot;&#10;```&#10;&#10;3. **Initialize database**:&#10;```bash&#10;python -c &quot;&#10;import asyncio&#10;from db.models import create_tables&#10;asyncio.run(create_tables())&#10;&quot;&#10;```&#10;&#10;4. **Start the service**:&#10;```bash&#10;python main.py&#10;```&#10;&#10;The service will be available at `http://localhost:8000`&#10;&#10;## API Documentation&#10;&#10;### Authentication&#10;All endpoints require an API key in the Authorization header:&#10;```&#10;Authorization: Bearer your-api-key&#10;```&#10;&#10;### Endpoints&#10;&#10;#### GET /health&#10;Health check endpoint&#10;```json&#10;{&#10;  &quot;status&quot;: &quot;healthy&quot;,&#10;  &quot;timestamp&quot;: &quot;2025-08-05T10:30:00Z&quot;,&#10;  &quot;version&quot;: &quot;1.0.0&quot;,&#10;  &quot;services&quot;: {&#10;    &quot;redis&quot;: &quot;healthy&quot;,&#10;    &quot;recommendation_engine&quot;: &quot;healthy&quot;&#10;  }&#10;}&#10;```&#10;&#10;#### POST /recommendations&#10;Get personalized recommendations for a user&#10;&#10;**Request**:&#10;```json&#10;{&#10;  &quot;user_id&quot;: &quot;user_123&quot;,&#10;  &quot;context&quot;: {&#10;    &quot;device_type&quot;: &quot;mobile&quot;,&#10;    &quot;location&quot;: &quot;Vietnam&quot;&#10;  },&#10;  &quot;k&quot;: 10,&#10;  &quot;include_explanations&quot;: true&#10;}&#10;```&#10;&#10;**Response**:&#10;```json&#10;{&#10;  &quot;recommendations&quot;: [&#10;    {&#10;      &quot;post_id&quot;: &quot;post_456&quot;,&#10;      &quot;title&quot;: &quot;Khoa học máy tính&quot;,&#10;      &quot;content&quot;: &quot;Bài viết về AI...&quot;,&#10;      &quot;author_id&quot;: &quot;author_789&quot;,&#10;      &quot;category&quot;: &quot;Khoa Hoc&quot;,&#10;      &quot;tags&quot;: [&quot;AI&quot;, &quot;machine-learning&quot;],&#10;      &quot;engagement_rate&quot;: 0.15,&#10;      &quot;relevance_score&quot;: 0.95,&#10;      &quot;rank&quot;: 1,&#10;      &quot;reason&quot;: &quot;Recommended because you're interested in Khoa Hoc&quot;&#10;    }&#10;  ],&#10;  &quot;ab_variant&quot;: &quot;personalized_v1&quot;,&#10;  &quot;timestamp&quot;: &quot;2025-08-05T10:30:00Z&quot;,&#10;  &quot;user_id&quot;: &quot;user_123&quot;,&#10;  &quot;total_count&quot;: 10,&#10;  &quot;processing_time_ms&quot;: 45.2&#10;}&#10;```&#10;&#10;#### POST /feedback&#10;Record user interaction feedback&#10;&#10;**Request**:&#10;```json&#10;{&#10;  &quot;user_id&quot;: &quot;user_123&quot;,&#10;  &quot;post_id&quot;: &quot;post_456&quot;,&#10;  &quot;feedback_type&quot;: &quot;like&quot;,&#10;  &quot;context&quot;: {&#10;    &quot;device_type&quot;: &quot;mobile&quot;,&#10;    &quot;session_id&quot;: &quot;session_abc&quot;&#10;  }&#10;}&#10;```&#10;&#10;**Response**:&#10;```json&#10;{&#10;  &quot;success&quot;: true,&#10;  &quot;message&quot;: &quot;Feedback recorded successfully&quot;,&#10;  &quot;timestamp&quot;: &quot;2025-08-05T10:30:00Z&quot;&#10;}&#10;```&#10;&#10;#### GET /recommendations/{user_id}/history&#10;Get recommendation history for a user&#10;&#10;**Response**:&#10;```json&#10;{&#10;  &quot;user_id&quot;: &quot;user_123&quot;,&#10;  &quot;history&quot;: [&#10;    {&#10;      &quot;timestamp&quot;: &quot;2025-08-05T10:30:00Z&quot;,&#10;      &quot;post_ids&quot;: [&quot;post_1&quot;, &quot;post_2&quot;],&#10;      &quot;model_version&quot;: &quot;v1.0&quot;,&#10;      &quot;ab_test_variant&quot;: &quot;personalized_v1&quot;,&#10;      &quot;served_count&quot;: 10,&#10;      &quot;clicked_count&quot;: 3,&#10;      &quot;ctr&quot;: 0.3&#10;    }&#10;  ],&#10;  &quot;total_count&quot;: 50&#10;}&#10;```&#10;&#10;## Model Training&#10;&#10;### Training Data Preparation&#10;The system automatically collects training data from user interactions:&#10;- **Positive samples**: Likes, comments, shares (weighted by engagement strength)&#10;- **Negative samples**: Posts viewed but not interacted with&#10;- **Features**: User profile, post content, temporal context&#10;&#10;### Training Pipeline&#10;```bash&#10;# Start training&#10;python core/training.py&#10;```&#10;&#10;The training pipeline includes:&#10;1. **Data Collection**: Fetches recent interactions from database&#10;2. **Feature Engineering**: Extracts user/post embeddings and context features&#10;3. **Model Training**: Deep learning with attention mechanisms&#10;4. **Evaluation**: Precision, recall, F1-score, diversity metrics&#10;5. **Model Deployment**: Automatic model versioning and deployment&#10;&#10;### Model Architecture&#10;```&#10;User Features (Profile + Context) &#10;    ↓&#10;User Embedding (256d)&#10;    ↓&#10;Multi-Head Attention ← Post Embedding (256d)&#10;    ↓                      ↑&#10;Fusion Layer        Content Encoder (PhoBERT)&#10;    ↓                      ↑&#10;Prediction Head     Post Features + Metadata&#10;    ↓&#10;Relevance Score (0-1)&#10;```&#10;&#10;## A/B Testing&#10;&#10;The service supports multiple recommendation variants:&#10;- **personalized_v1**: Base deep learning model (40% traffic)&#10;- **personalized_v2**: Enhanced with reinforcement learning (40% traffic)  &#10;- **popularity_based**: Fallback algorithm (20% traffic)&#10;&#10;Users are consistently assigned to variants based on user ID hash.&#10;&#10;## Monitoring &amp; Analytics&#10;&#10;### Prometheus Metrics&#10;- `recommendation_requests_total`: Total API requests&#10;- `recommendations_served_total`: Recommendations served by variant&#10;- `feedback_received_total`: User feedback by type&#10;- `model_accuracy`: Current model performance&#10;- `cache_hits_total` / `cache_misses_total`: Caching performance&#10;&#10;### Dashboards&#10;Access metrics at `/metrics` endpoint for Prometheus scraping.&#10;&#10;### Logging&#10;Structured JSON logging with:&#10;- Request/response tracking&#10;- Model prediction details&#10;- Error tracking and debugging&#10;- Performance monitoring&#10;&#10;## Deployment&#10;&#10;### Docker&#10;```bash&#10;# Build image&#10;docker build -t ctu-connect/recommendation-service .&#10;&#10;# Run container&#10;docker run -p 8000:8000 \&#10;  -e DATABASE_URL=&quot;postgresql+asyncpg://...&quot; \&#10;  -e REDIS_URL=&quot;redis://...&quot; \&#10;  ctu-connect/recommendation-service&#10;```&#10;&#10;### Kubernetes&#10;```bash&#10;# Deploy to Kubernetes&#10;kubectl apply -f deployment/kubernetes.yaml&#10;&#10;# Check status&#10;kubectl get pods -l app=recommendation-service&#10;kubectl logs -f deployment/recommendation-service&#10;```&#10;&#10;The Kubernetes deployment includes:&#10;- **Auto-scaling**: 2-10 replicas based on CPU/memory usage&#10;- **Health checks**: Liveness and readiness probes&#10;- **Resource limits**: Memory and CPU constraints&#10;- **Config management**: ConfigMaps and Secrets&#10;&#10;### Production Configuration&#10;For production deployment:&#10;&#10;1. **Database**: Use managed PostgreSQL (AWS RDS, Google Cloud SQL)&#10;2. **Redis**: Use managed Redis cluster&#10;3. **Kafka**: Use managed Kafka service (Confluent, AWS MSK)&#10;4. **Monitoring**: Set up Prometheus + Grafana&#10;5. **Security**: Enable API authentication, rate limiting&#10;6. **SSL/TLS**: Configure HTTPS termination&#10;&#10;## Performance&#10;&#10;### Benchmarks&#10;- **Response Time**: &lt; 100ms for cached recommendations&#10;- **Throughput**: 1000+ RPS per instance&#10;- **Accuracy**: 85%+ precision on validation set&#10;- **Diversity**: 70%+ category diversity in recommendations&#10;&#10;### Optimization Tips&#10;1. **Caching Strategy**: Cache user features and popular recommendations&#10;2. **Batch Processing**: Group similar requests for efficient inference&#10;3. **Model Optimization**: Use TorchScript or ONNX for faster inference&#10;4. **Database**: Optimize queries with proper indexing&#10;5. **Scaling**: Use horizontal pod autoscaling in Kubernetes&#10;&#10;## Testing&#10;&#10;### Run Tests&#10;```bash&#10;# Unit tests&#10;pytest tests/ -v&#10;&#10;# Integration tests&#10;pytest tests/ -v -m integration&#10;&#10;# Load tests&#10;pytest tests/test_recommendation.py::TestPerformance -v&#10;```&#10;&#10;### Test Coverage&#10;- **API Endpoints**: Complete request/response testing&#10;- **Model Components**: Unit tests for all neural network layers&#10;- **Data Processing**: Feature extraction and transformation tests&#10;- **Integration**: End-to-end recommendation flow tests&#10;&#10;## Contributing&#10;&#10;### Development Setup&#10;1. Fork the repository&#10;2. Create feature branch: `git checkout -b feature/new-feature`&#10;3. Install dev dependencies: `pip install -r requirements.txt`&#10;4. Run tests: `pytest`&#10;5. Submit pull request&#10;&#10;### Code Standards&#10;- **Python**: Follow PEP 8, use Black formatter&#10;- **Documentation**: Add docstrings for all functions&#10;- **Testing**: Maintain &gt;90% test coverage&#10;- **Type Hints**: Use type annotations throughout&#10;&#10;## Troubleshooting&#10;&#10;### Common Issues&#10;&#10;**Service won't start**:&#10;- Check database connection string&#10;- Verify Redis is running&#10;- Ensure Kafka is accessible&#10;&#10;**Poor recommendation quality**:&#10;- Check training data quality and quantity&#10;- Verify user interaction tracking&#10;- Review model hyperparameters&#10;&#10;**High response times**:&#10;- Check Redis cache hit rates&#10;- Monitor database query performance&#10;- Review model inference time&#10;&#10;**Memory issues**:&#10;- Adjust batch sizes in training&#10;- Optimize model architecture&#10;- Configure appropriate resource limits&#10;&#10;### Debug Mode&#10;Enable debug mode for detailed logging:&#10;```bash&#10;export DEBUG=true&#10;python main.py&#10;```&#10;&#10;### Logs&#10;Check logs for debugging:&#10;```bash&#10;# Docker&#10;docker logs &lt;container-id&gt;&#10;&#10;# Kubernetes&#10;kubectl logs -f deployment/recommendation-service&#10;```&#10;&#10;## License&#10;&#10;MIT License - see LICENSE file for details.&#10;&#10;## Support&#10;&#10;For questions and support:&#10;- GitHub Issues: Create issue in repository&#10;- Documentation: Check API documentation at `/docs`&#10;- Monitoring: Check service health at `/health`" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/recommendation-service/deployment/kubernetes.yaml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/recommendation-service/deployment/kubernetes.yaml" />
              <option name="updatedContent" value="apiVersion: apps/v1&#10;kind: Deployment&#10;metadata:&#10;  name: recommendation-service&#10;  labels:&#10;    app: recommendation-service&#10;spec:&#10;  replicas: 3&#10;  selector:&#10;    matchLabels:&#10;      app: recommendation-service&#10;  template:&#10;    metadata:&#10;      labels:&#10;        app: recommendation-service&#10;    spec:&#10;      containers:&#10;      - name: recommendation-service&#10;        image: ctu-connect/recommendation-service:latest&#10;        ports:&#10;        - containerPort: 8000&#10;        env:&#10;        - name: DATABASE_URL&#10;          valueFrom:&#10;            secretKeyRef:&#10;              name: recommendation-secrets&#10;              key: database-url&#10;        - name: REDIS_URL&#10;          valueFrom:&#10;            configMapKeyRef:&#10;              name: recommendation-config&#10;              key: redis-url&#10;        - name: KAFKA_BOOTSTRAP_SERVERS&#10;          valueFrom:&#10;            configMapKeyRef:&#10;              name: recommendation-config&#10;              key: kafka-servers&#10;        - name: SECRET_KEY&#10;          valueFrom:&#10;            secretKeyRef:&#10;              name: recommendation-secrets&#10;              key: secret-key&#10;        - name: MLFLOW_TRACKING_URI&#10;          valueFrom:&#10;            configMapKeyRef:&#10;              name: recommendation-config&#10;              key: mlflow-uri&#10;        resources:&#10;          requests:&#10;            memory: &quot;512Mi&quot;&#10;            cpu: &quot;250m&quot;&#10;          limits:&#10;            memory: &quot;2Gi&quot;&#10;            cpu: &quot;1000m&quot;&#10;        livenessProbe:&#10;          httpGet:&#10;            path: /health&#10;            port: 8000&#10;          initialDelaySeconds: 30&#10;          periodSeconds: 10&#10;        readinessProbe:&#10;          httpGet:&#10;            path: /health&#10;            port: 8000&#10;          initialDelaySeconds: 5&#10;          periodSeconds: 5&#10;---&#10;apiVersion: v1&#10;kind: Service&#10;metadata:&#10;  name: recommendation-service&#10;spec:&#10;  selector:&#10;    app: recommendation-service&#10;  ports:&#10;    - protocol: TCP&#10;      port: 80&#10;      targetPort: 8000&#10;  type: ClusterIP&#10;---&#10;apiVersion: v1&#10;kind: ConfigMap&#10;metadata:&#10;  name: recommendation-config&#10;data:&#10;  redis-url: &quot;redis://redis-service:6379&quot;&#10;  kafka-servers: &quot;kafka-service:9092&quot;&#10;  mlflow-uri: &quot;http://mlflow-service:5000&quot;&#10;  debug: &quot;false&quot;&#10;---&#10;apiVersion: v1&#10;kind: Secret&#10;metadata:&#10;  name: recommendation-secrets&#10;type: Opaque&#10;data:&#10;  database-url: cG9zdGdyZXNxbCthc3luY3BnOi8vcG9zdGdyZXM6cGFzc3dvcmRAbG9jYWxob3N0OjU0MzIvcmVjb21tZW5kYXRpb25fZGI=&#10;  secret-key: eW91ci1zZWNyZXQta2V5LWhlcmU=&#10;---&#10;apiVersion: autoscaling/v2&#10;kind: HorizontalPodAutoscaler&#10;metadata:&#10;  name: recommendation-service-hpa&#10;spec:&#10;  scaleTargetRef:&#10;    apiVersion: apps/v1&#10;    kind: Deployment&#10;    name: recommendation-service&#10;  minReplicas: 2&#10;  maxReplicas: 10&#10;  metrics:&#10;  - type: Resource&#10;    resource:&#10;      name: cpu&#10;      target:&#10;        type: Utilization&#10;        averageUtilization: 70&#10;  - type: Resource&#10;    resource:&#10;      name: memory&#10;      target:&#10;        type: Utilization&#10;        averageUtilization: 80" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/user-service/src/main/java/com/ctuconnect/event/UserEventPublisher.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/user-service/src/main/java/com/ctuconnect/event/UserEventPublisher.java" />
              <option name="updatedContent" value="package com.ctuconnect.event;&#10;&#10;import org.springframework.beans.factory.annotation.Autowired;&#10;import org.springframework.kafka.core.KafkaTemplate;&#10;import org.springframework.stereotype.Service;&#10;import com.fasterxml.jackson.databind.ObjectMapper;&#10;import lombok.extern.slf4j.Slf4j;&#10;&#10;import java.util.HashMap;&#10;import java.util.Map;&#10;&#10;/**&#10; * Service to publish user profile update events to Kafka&#10; * This notifies other services (like post-service) when user profiles are updated&#10; */&#10;@Service&#10;@Slf4j&#10;public class UserEventPublisher {&#10;&#10;    @Autowired&#10;    private KafkaTemplate&lt;String, String&gt; kafkaTemplate;&#10;&#10;    @Autowired&#10;    private ObjectMapper objectMapper;&#10;&#10;    private static final String USER_PROFILE_UPDATED_TOPIC = &quot;user-profile-updated&quot;;&#10;&#10;    /**&#10;     * Publish user profile update event&#10;     */&#10;    public void publishUserProfileUpdateEvent(String userId, String fullName, String email, String avatarUrl, String role) {&#10;        try {&#10;            Map&lt;String, Object&gt; eventData = new HashMap&lt;&gt;();&#10;            eventData.put(&quot;userId&quot;, userId);&#10;            eventData.put(&quot;fullName&quot;, fullName);&#10;            eventData.put(&quot;email&quot;, email);&#10;            eventData.put(&quot;avatarUrl&quot;, avatarUrl);&#10;            eventData.put(&quot;role&quot;, role);&#10;            eventData.put(&quot;eventType&quot;, &quot;USER_PROFILE_UPDATED&quot;);&#10;            eventData.put(&quot;timestamp&quot;, System.currentTimeMillis());&#10;&#10;            String eventMessage = objectMapper.writeValueAsString(eventData);&#10;            &#10;            kafkaTemplate.send(USER_PROFILE_UPDATED_TOPIC, userId, eventMessage);&#10;            log.info(&quot;Published user profile update event for user: {}&quot;, userId);&#10;            &#10;        } catch (Exception e) {&#10;            log.error(&quot;Failed to publish user profile update event for user {}: {}&quot;, userId, e.getMessage(), e);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Publish user profile update event with user entity data&#10;     */&#10;    public void publishUserProfileUpdateEvent(String userId, Map&lt;String, Object&gt; userData) {&#10;        try {&#10;            Map&lt;String, Object&gt; eventData = new HashMap&lt;&gt;();&#10;            eventData.put(&quot;userId&quot;, userId);&#10;            eventData.put(&quot;userData&quot;, userData);&#10;            eventData.put(&quot;eventType&quot;, &quot;USER_PROFILE_UPDATED&quot;);&#10;            eventData.put(&quot;timestamp&quot;, System.currentTimeMillis());&#10;&#10;            String eventMessage = objectMapper.writeValueAsString(eventData);&#10;            &#10;            kafkaTemplate.send(USER_PROFILE_UPDATED_TOPIC, userId, eventMessage);&#10;            log.info(&quot;Published user profile update event for user: {}&quot;, userId);&#10;            &#10;        } catch (Exception e) {&#10;            log.error(&quot;Failed to publish user profile update event for user {}: {}&quot;, userId, e.getMessage(), e);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/user-service/src/main/java/com/ctuconnect/repository/UserRepository.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/user-service/src/main/java/com/ctuconnect/repository/UserRepository.java" />
              <option name="originalContent" value="package com.ctuconnect.repository;&#10;&#10;import com.ctuconnect.entity.FacultyEntity;&#10;import com.ctuconnect.entity.UserEntity;&#10;import org.springframework.data.jpa.repository.Modifying;&#10;import org.springframework.data.neo4j.repository.Neo4jRepository;&#10;import org.springframework.data.neo4j.repository.query.Query;&#10;import org.springframework.data.repository.query.Param;&#10;&#10;import java.util.List;&#10;import java.util.Optional;&#10;&#10;public interface UserRepository extends Neo4jRepository&lt;UserEntity, String&gt; {&#10;&#10; // Tìm kiếm người dùng bằng email hoặc username&#10; Optional&lt;UserEntity&gt; findByEmail(String email);&#10;&#10; Optional&lt;UserEntity&gt; findByUsername(String username);&#10;&#10; boolean existsByEmail(String email);&#10;&#10; boolean existsByUsername(String username);&#10;&#10; @Query(&quot;MATCH (u:User) WHERE u.email = $identifier OR u.username = $identifier RETURN u&quot;)&#10; Optional&lt;UserEntity&gt; findByEmailOrUsername(@Param(&quot;identifier&quot;) String identifier);&#10;&#10; // Lấy user by id&#10; @Query(&quot;MATCH (u:User {id: $userId}) RETURN u&quot;)&#10; Optional&lt;UserEntity&gt; findUserWithAllRelations(@Param(&quot;userId&quot;) String userId);&#10;&#10; // Xóa quan hệ của profile học sinh (student)&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})&#10;        OPTIONAL MATCH (u)-[r]-&gt;()&#10;        WHERE type(r) IN ['ENROLLED_IN', 'WORKS_IN', 'BELONGS_TO', 'IN_BATCH', 'HAS_GENDER']&#10;        DELETE r&#10;        &quot;&quot;&quot;)&#10; void clearStudentRelationships(@Param(&quot;userId&quot;) String userId);&#10;&#10; // Xóa quan hệ của profile giảng viên (lecturer)&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})&#10;        OPTIONAL MATCH (u)-[r]-&gt;()&#10;        WHERE type(r) IN ['HAS_DEGREE', 'HAS_ACADEMIC', 'HAS_POSITION', 'WORKS_IN', 'BELONGS_TO', 'HAS_GENDER']&#10;        DELETE r&#10;        &quot;&quot;&quot;)&#10; void clearLecturerRelationships(@Param(&quot;userId&quot;) String userId);&#10;&#10; // Xóa quan hệ cụ thể theo danh sách quan hệ truyền vào&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})&#10;        OPTIONAL MATCH (u)-[r]-&gt;()&#10;        WHERE type(r) IN $relationshipTypes&#10;        DELETE r&#10;        &quot;&quot;&quot;)&#10; void clearSpecificRelationships(@Param(&quot;userId&quot;) String userId, @Param(&quot;relationshipTypes&quot;) List&lt;String&gt; relationshipTypes);&#10;&#10; // Xóa quan hệ đơn lẻ theo loại&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})-[r]-&gt;(n)&#10;        WHERE type(r) = $relationshipType&#10;        DELETE r&#10;        &quot;&quot;&quot;)&#10; void deleteRelationship(@Param(&quot;userId&quot;) String userId, @Param(&quot;relationshipType&quot;) String relationshipType);&#10;&#10; // Cập nhật các quan hệ profile&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})&#10;        OPTIONAL MATCH (u)-[r:ENROLLED_IN]-&gt;()&#10;        DELETE r&#10;        WITH u&#10;        MATCH (newMajor:Major {id: $majorId})&#10;        MERGE (u)-[:ENROLLED_IN]-&gt;(newMajor)&#10;        &quot;&quot;&quot;)&#10; void updateUserMajor(@Param(&quot;userId&quot;) String userId, @Param(&quot;majorId&quot;) String majorId);&#10;&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})&#10;        OPTIONAL MATCH (u)-[r:IN_BATCH]-&gt;()&#10;        DELETE r&#10;        WITH u&#10;        MATCH (newBatch:Batch {id: $batchId})&#10;        MERGE (u)-[:IN_BATCH]-&gt;(newBatch)&#10;        &quot;&quot;&quot;)&#10; void updateUserBatch(@Param(&quot;userId&quot;) String userId, @Param(&quot;batchId&quot;) String batchId);&#10;&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})&#10;        OPTIONAL MATCH (u)-[r:HAS_GENDER]-&gt;()&#10;        DELETE r&#10;        WITH u&#10;        MATCH (newGender:Gender {id: $genderId})&#10;        MERGE (u)-[:HAS_GENDER]-&gt;(newGender)&#10;        &quot;&quot;&quot;)&#10; void updateUserGender(@Param(&quot;userId&quot;) String userId, @Param(&quot;genderId&quot;) String genderId);&#10;&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})&#10;        OPTIONAL MATCH (u)-[r:BELONGS_TO]-&gt;()&#10;        DELETE r&#10;        WITH u&#10;        MATCH (newFaculty:Faculty {id: $facultyId})&#10;        MERGE (u)-[:BELONGS_TO]-&gt;(newFaculty)&#10;        &quot;&quot;&quot;)&#10; void updateUserFaculty(@Param(&quot;userId&quot;) String userId, @Param(&quot;facultyId&quot;) String facultyId);&#10;&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})&#10;        OPTIONAL MATCH (u)-[r:STUDIES_AT]-&gt;()&#10;        DELETE r&#10;        WITH u&#10;        MATCH (newCollege:College {id: $collegeId})&#10;        MERGE (u)-[:STUDIES_AT]-&gt;(newCollege)&#10;        &quot;&quot;&quot;)&#10; void updateUserCollege(@Param(&quot;userId&quot;) String userId, @Param(&quot;collegeId&quot;) String collegeId);&#10;&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})&#10;        OPTIONAL MATCH (u)-[r:WORKS_IN]-&gt;()&#10;        DELETE r&#10;        WITH u&#10;        MATCH (newFaculty:Faculty {id: $facultyId})&#10;        MERGE (u)-[:WORKS_IN]-&gt;(newFaculty)&#10;        &quot;&quot;&quot;)&#10; void updateUserWorkingFaculty(@Param(&quot;userId&quot;) String userId, @Param(&quot;facultyId&quot;) String facultyId);&#10;&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})&#10;        OPTIONAL MATCH (u)-[r:EMPLOYED_AT]-&gt;()&#10;        DELETE r&#10;        WITH u&#10;        MATCH (newCollege:College {id: $collegeId})&#10;        MERGE (u)-[:EMPLOYED_AT]-&gt;(newCollege)&#10;        &quot;&quot;&quot;)&#10; void updateUserWorkingCollege(@Param(&quot;userId&quot;) String userId, @Param(&quot;collegeId&quot;) String collegeId);&#10;&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})&#10;        OPTIONAL MATCH (u)-[r:HAS_DEGREE]-&gt;()&#10;        DELETE r&#10;        WITH u&#10;        MATCH (newDegree:Degree {id: $degreeId})&#10;        MERGE (u)-[:HAS_DEGREE]-&gt;(newDegree)&#10;        &quot;&quot;&quot;)&#10; void updateUserDegree(@Param(&quot;userId&quot;) String userId, @Param(&quot;degreeId&quot;) String degreeId);&#10;&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})&#10;        OPTIONAL MATCH (u)-[r:HAS_POSITION]-&gt;()&#10;        DELETE r&#10;        WITH u&#10;        MATCH (newPosition:Position {id: $positionId})&#10;        MERGE (u)-[:HAS_POSITION]-&gt;(newPosition)&#10;        &quot;&quot;&quot;)&#10; void updateUserPosition(@Param(&quot;userId&quot;) String userId, @Param(&quot;positionId&quot;) String positionId);&#10;&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})&#10;        OPTIONAL MATCH (u)-[r:HAS_ACADEMIC]-&gt;()&#10;        DELETE r&#10;        WITH u&#10;        MATCH (newAcademic:Academic {id: $academicId})&#10;        MERGE (u)-[:HAS_ACADEMIC]-&gt;(newAcademic)&#10;        &quot;&quot;&quot;)&#10; void updateUserAcademic(@Param(&quot;userId&quot;) String userId, @Param(&quot;academicId&quot;) String academicId);&#10;&#10; // ========================= FRIEND RELATIONSHIP QUERIES =========================&#10;&#10; // Kiểm tra xem 2 user có phải bạn bè không&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u1:User {id: $userId1})-[:FRIEND_WITH]-(u2:User {id: $userId2})&#10;        RETURN COUNT(*) &gt; 0&#10;        &quot;&quot;&quot;)&#10; boolean areFriends(@Param(&quot;userId1&quot;) String userId1, @Param(&quot;userId2&quot;) String userId2);&#10;&#10; // Kiểm tra có friend request pending không&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u1:User {id: $fromUserId})-[:FRIEND_REQUEST]-&gt;(u2:User {id: $toUserId})&#10;        RETURN COUNT(*) &gt; 0&#10;        &quot;&quot;&quot;)&#10; boolean hasPendingFriendRequest(@Param(&quot;fromUserId&quot;) String fromUserId, @Param(&quot;toUserId&quot;) String toUserId);&#10;&#10; // Gửi friend request&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u1:User {id: $fromUserId}), (u2:User {id: $toUserId})&#10;        MERGE (u1)-[:FRIEND_REQUEST]-&gt;(u2)&#10;        &quot;&quot;&quot;)&#10; void sendFriendRequest(@Param(&quot;fromUserId&quot;) String fromUserId, @Param(&quot;toUserId&quot;) String toUserId);&#10;&#10; // Chấp nhận friend request&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u1:User {id: $fromUserId})-[r:FRIEND_REQUEST]-&gt;(u2:User {id: $toUserId})&#10;        DELETE r&#10;        CREATE (u1)-[:FRIEND_WITH]-&gt;(u2)&#10;        CREATE (u2)-[:FRIEND_WITH]-&gt;(u1)&#10;        &quot;&quot;&quot;)&#10; void acceptFriendRequest(@Param(&quot;fromUserId&quot;) String fromUserId, @Param(&quot;toUserId&quot;) String toUserId);&#10;&#10; // Từ chối friend request&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u1:User {id: $fromUserId})-[r:FRIEND_REQUEST]-&gt;(u2:User {id: $toUserId})&#10;        DELETE r&#10;        &quot;&quot;&quot;)&#10; void rejectFriendRequest(@Param(&quot;fromUserId&quot;) String fromUserId, @Param(&quot;toUserId&quot;) String toUserId);&#10;&#10; // Xóa friendship&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u1:User {id: $userId1})-[r:FRIEND_WITH]-(u2:User {id: $userId2})&#10;        DELETE r&#10;        &quot;&quot;&quot;)&#10; void deleteFriendship(@Param(&quot;userId1&quot;) String userId1, @Param(&quot;userId2&quot;) String userId2);&#10;&#10; // Lấy danh sách bạn bè&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})-[:FRIEND_WITH]-(friend:User)&#10;        RETURN friend&#10;        &quot;&quot;&quot;)&#10; List&lt;UserEntity&gt; findFriends(@Param(&quot;userId&quot;) String userId);&#10;&#10; // Lấy friend requests nhận được&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (requester:User)-[:FRIEND_REQUEST]-&gt;(u:User {id: $userId})&#10;        RETURN requester&#10;        &quot;&quot;&quot;)&#10; List&lt;UserEntity&gt; findIncomingFriendRequests(@Param(&quot;userId&quot;) String userId);&#10;&#10; // Lấy friend requests đã gửi&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})-[:FRIEND_REQUEST]-&gt;(receiver:User)&#10;        RETURN receiver&#10;        &quot;&quot;&quot;)&#10; List&lt;UserEntity&gt; findOutgoingFriendRequests(@Param(&quot;userId&quot;) String userId);&#10;&#10; // Lấy bạn chung giữa 2 user&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u1:User {id: $userId1})-[:FRIEND_WITH]-(mutual:User)-[:FRIEND_WITH]-(u2:User {id: $userId2})&#10;        RETURN mutual&#10;        &quot;&quot;&quot;)&#10; List&lt;UserEntity&gt; findMutualFriends(@Param(&quot;userId1&quot;) String userId1, @Param(&quot;userId2&quot;) String userId2);&#10;&#10; // Gợi ý kết bạn dựa trên bạn chung và profile tương tự&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})&#10;        MATCH (u)-[:FRIEND_WITH]-(friend)-[:FRIEND_WITH]-(suggestion:User)&#10;        WHERE NOT (u)-[:FRIEND_WITH]-(suggestion) AND u.id &lt;&gt; suggestion.id&#10;        AND NOT (u)-[:FRIEND_REQUEST]-(suggestion)&#10;        RETURN suggestion, COUNT(*) as mutualFriends&#10;        ORDER BY mutualFriends DESC&#10;        LIMIT 20&#10;        &quot;&quot;&quot;)&#10; List&lt;UserEntity&gt; findFriendSuggestions(@Param(&quot;userId&quot;) String userId);&#10;&#10; // Lọc user theo tiêu chí (cùng college, faculty, major, batch)&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})&#10;        OPTIONAL MATCH (u)-[:STUDIES_AT|EMPLOYED_AT]-&gt;(college:College)&#10;        OPTIONAL MATCH (u)-[:BELONGS_TO|WORKS_IN]-&gt;(faculty:Faculty)&#10;        OPTIONAL MATCH (u)-[:ENROLLED_IN]-&gt;(major:Major)&#10;        OPTIONAL MATCH (u)-[:IN_BATCH]-&gt;(batch:Batch)&#10;        &#10;        MATCH (candidate:User)&#10;        WHERE candidate.id &lt;&gt; $userId&#10;        AND (NOT $sameCollege OR (candidate)-[:STUDIES_AT|EMPLOYED_AT]-&gt;(college))&#10;        AND (NOT $sameFaculty OR (candidate)-[:BELONGS_TO|WORKS_IN]-&gt;(faculty))&#10;        AND (NOT $sameMajor OR (candidate)-[:ENROLLED_IN]-&gt;(major))&#10;        AND (NOT $sameBatch OR (candidate)-[:IN_BATCH]-&gt;(batch))&#10;        &#10;        RETURN candidate&#10;        &quot;&quot;&quot;)&#10; List&lt;UserEntity&gt; findUsersWithFilters(&#10;         @Param(&quot;userId&quot;) String userId,&#10;         @Param(&quot;sameCollege&quot;) boolean sameCollege,&#10;         @Param(&quot;sameFaculty&quot;) boolean sameFaculty,&#10;         @Param(&quot;sameMajor&quot;) boolean sameMajor,&#10;         @Param(&quot;sameBatch&quot;) boolean sameBatch&#10; );&#10;&#10; /**&#10;  * Find users by faculty ID (for post-service news feed algorithm)&#10;  */&#10; @Query(&quot;MATCH (u:User)-[:WORKS_IN|BELONGS_TO]-&gt;(f:Faculty {id: $facultyId}) RETURN u&quot;)&#10; List&lt;UserEntity&gt; findUsersByFacultyId(@Param(&quot;facultyId&quot;) String facultyId);&#10;&#10; /**&#10;  * Find users by major ID (for post-service news feed algorithm)&#10;  */&#10; @Query(&quot;MATCH (u:User)-[:ENROLLED_IN]-&gt;(m:Major {id: $majorId}) RETURN u&quot;)&#10; List&lt;UserEntity&gt; findUsersByMajorId(@Param(&quot;majorId&quot;) String majorId);&#10;&#10; /**&#10;  * Find users by full name containing (for search functionality)&#10;  * Uses case-insensitive search with Neo4j CONTAINS operator&#10;  */&#10; @Query(&quot;MATCH (u:User) WHERE toLower(u.fullName) CONTAINS toLower($fullName) RETURN u&quot;)&#10; List&lt;UserEntity&gt; findByFullNameContainingIgnoreCase(@Param(&quot;fullName&quot;) String fullName);&#10;&#10; /**&#10;  * Find users by faculty name (for search functionality)&#10;  */&#10; @Query(&quot;MATCH (u:User)-[:BELONGS_TO|WORKS_IN]-&gt;(f:Faculty {name: $facultyName}) RETURN u&quot;)&#10; List&lt;UserEntity&gt; findUsersByFaculty(@Param(&quot;facultyName&quot;) String facultyName);&#10;&#10; /**&#10;  * Find users by major name (for search functionality)&#10;  */&#10; @Query(&quot;MATCH (u:User)-[:ENROLLED_IN]-&gt;(m:Major {name: $majorName}) RETURN u&quot;)&#10; List&lt;UserEntity&gt; findUsersByMajor(@Param(&quot;majorName&quot;) String majorName);&#10;}&#10;" />
              <option name="updatedContent" value="package com.ctuconnect.repository;&#10;&#10;import com.ctuconnect.entity.FacultyEntity;&#10;import com.ctuconnect.entity.UserEntity;&#10;import org.springframework.data.jpa.repository.Modifying;&#10;import org.springframework.data.neo4j.repository.Neo4jRepository;&#10;import org.springframework.data.neo4j.repository.query.Query;&#10;import org.springframework.data.repository.query.Param;&#10;&#10;import java.util.List;&#10;import java.util.Optional;&#10;&#10;public interface UserRepository extends Neo4jRepository&lt;UserEntity, String&gt; {&#10;&#10; // Tìm kiếm người dùng bằng email hoặc username&#10; Optional&lt;UserEntity&gt; findByEmail(String email);&#10;&#10; Optional&lt;UserEntity&gt; findByUsername(String username);&#10;&#10; boolean existsByEmail(String email);&#10;&#10; boolean existsByUsername(String username);&#10;&#10; @Query(&quot;MATCH (u:User) WHERE u.email = $identifier OR u.username = $identifier RETURN u&quot;)&#10; Optional&lt;UserEntity&gt; findByEmailOrUsername(@Param(&quot;identifier&quot;) String identifier);&#10;&#10; // Lấy user by id&#10; @Query(&quot;MATCH (u:User {id: $userId}) RETURN u&quot;)&#10; Optional&lt;UserEntity&gt; findUserWithAllRelations(@Param(&quot;userId&quot;) String userId);&#10;&#10; // Xóa quan hệ của profile học sinh (student)&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})&#10;        OPTIONAL MATCH (u)-[r]-&gt;()&#10;        WHERE type(r) IN ['ENROLLED_IN', 'WORKS_IN', 'BELONGS_TO', 'IN_BATCH', 'HAS_GENDER']&#10;        DELETE r&#10;        &quot;&quot;&quot;)&#10; void clearStudentRelationships(@Param(&quot;userId&quot;) String userId);&#10;&#10; // Xóa quan hệ của profile giảng viên (lecturer)&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})&#10;        OPTIONAL MATCH (u)-[r]-&gt;()&#10;        WHERE type(r) IN ['HAS_DEGREE', 'HAS_ACADEMIC', 'HAS_POSITION', 'WORKS_IN', 'BELONGS_TO', 'HAS_GENDER']&#10;        DELETE r&#10;        &quot;&quot;&quot;)&#10; void clearLecturerRelationships(@Param(&quot;userId&quot;) String userId);&#10;&#10; // Xóa quan hệ cụ thể theo danh sách quan hệ truyền vào&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})&#10;        OPTIONAL MATCH (u)-[r]-&gt;()&#10;        WHERE type(r) IN $relationshipTypes&#10;        DELETE r&#10;        &quot;&quot;&quot;)&#10; void clearSpecificRelationships(@Param(&quot;userId&quot;) String userId, @Param(&quot;relationshipTypes&quot;) List&lt;String&gt; relationshipTypes);&#10;&#10; // Xóa quan hệ đơn lẻ theo loại&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})-[r]-&gt;(n)&#10;        WHERE type(r) = $relationshipType&#10;        DELETE r&#10;        &quot;&quot;&quot;)&#10; void deleteRelationship(@Param(&quot;userId&quot;) String userId, @Param(&quot;relationshipType&quot;) String relationshipType);&#10;&#10; // Cập nhật các quan hệ profile&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})&#10;        OPTIONAL MATCH (u)-[r:ENROLLED_IN]-&gt;()&#10;        DELETE r&#10;        WITH u&#10;        MATCH (newMajor:Major {id: $majorId})&#10;        MERGE (u)-[:ENROLLED_IN]-&gt;(newMajor)&#10;        &quot;&quot;&quot;)&#10; void updateUserMajor(@Param(&quot;userId&quot;) String userId, @Param(&quot;majorId&quot;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/user-service/src/main/java/com/ctuconnect/service/UserService.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/user-service/src/main/java/com/ctuconnect/service/UserService.java" />
              <option name="originalContent" value="package com.ctuconnect.service;&#10;&#10;import com.ctuconnect.dto.*;&#10;import com.ctuconnect.entity.*;&#10;import com.ctuconnect.enums.Role;&#10;import com.ctuconnect.repository.*;&#10;import com.fasterxml.jackson.databind.ObjectMapper;&#10;import jakarta.validation.constraints.NotBlank;&#10;import lombok.extern.slf4j.Slf4j;&#10;import org.springframework.beans.factory.annotation.Autowired;&#10;import org.springframework.stereotype.Service;&#10;import org.springframework.transaction.annotation.Transactional;&#10;&#10;import java.util.Map;&#10;import java.time.LocalDateTime;&#10;import java.util.ArrayList;&#10;import java.util.HashSet;&#10;import java.util.List;&#10;import java.util.Objects;&#10;import java.util.Optional;&#10;import java.util.Set;&#10;import java.util.stream.Collectors;&#10;&#10;@Slf4j&#10;@Service&#10;public class UserService {&#10;&#10;    @Autowired&#10;    private UserRepository userRepository;&#10;&#10;    @Autowired&#10;    private UserEventPublisher userEventPublisher;&#10;&#10;    @Autowired&#10;    private FacultyRepository facultyRepository;&#10;&#10;    @Autowired&#10;    private BatchRepository batchRepository;&#10;&#10;    @Autowired&#10;    private GenderRepository genderRepository;&#10;&#10;    @Autowired&#10;    private DegreeRepository degreeRepository;&#10;&#10;    @Autowired&#10;    private AcademicRepository academicRepository;&#10;&#10;    @Autowired&#10;    private PositionRepository positionRepository;&#10;&#10;    @Autowired&#10;    private CollegeRepository collegeRepository;&#10;&#10;    @Autowired&#10;    private MajorRepository majorRepository;&#10;    /**&#10;     * Create a new user&#10;     */&#10;    public UserDTO createUser(UserDTO userDTO) {&#10;        UserEntity userEntity = mapToEntity(userDTO);&#10;        userEntity.setCreatedAt(LocalDateTime.now());&#10;        userEntity.setUpdatedAt(LocalDateTime.now());&#10;&#10;        UserEntity savedUser = userRepository.save(userEntity);&#10;        return mapToDTO(savedUser);&#10;    }&#10;&#10;    /**&#10;     * Get user profile by ID or email (fallback for compatibility)&#10;     */&#10;    public UserDTO getUserProfile(String userIdOrEmail) {&#10;        Optional&lt;UserEntity&gt; userEntity;&#10;&#10;        userEntity = userRepository.findById(userIdOrEmail);&#10;&#10;        if (userEntity.isEmpty()) {&#10;            throw new RuntimeException(&quot;User not found with id or email: &quot; + userIdOrEmail);&#10;        }&#10;&#10;        return mapToDTO(userEntity.get());&#10;    }&#10;&#10;&#10;    /**&#10;     * Update user profile by ID or email (fallback for compatibility)&#10;     */&#10;    /*@Transactional&#10;    public UserDTO updateUserProfile(String userIdOrEmail, UserDTO userDTO) {&#10;        Optional&lt;UserEntity&gt; userEntityOpt = userRepository.findById(userIdOrEmail);&#10;&#10;        // If not found by ID, try to find by email (fallback for compatibility)&#10;        if (userEntityOpt.isEmpty()) {&#10;            userEntityOpt = userRepository.findByEmail(userIdOrEmail);&#10;        }&#10;&#10;        if (userEntityOpt.isEmpty()) {&#10;            throw new RuntimeException(&quot;User not found with id or email: &quot; + userIdOrEmail);&#10;        }&#10;&#10;        UserEntity userEntity = userEntityOpt.get();&#10;        String userId = userEntity.getId();&#10;&#10;        // Update basic profile fields&#10;        if (userDTO.getFullName() != null) userEntity.setFullName(userDTO.getFullName());&#10;        if (userDTO.getEmail() != null) userEntity.setEmail(userDTO.getEmail());&#10;        if (userDTO.getUsername() != null) userEntity.setUsername(userDTO.getUsername());&#10;        if (userDTO.getBio() != null) userEntity.setBio(userDTO.getBio());&#10;&#10;        // Update role safely&#10;        if (userDTO.getRole() != null) {&#10;            try {&#10;                userEntity.setRole(Role.valueOf(userDTO.getRole()));&#10;            } catch (IllegalArgumentException e) {&#10;                // Keep existing role if invalid role provided&#10;            }&#10;        }&#10;&#10;        // Update student-specific fields&#10;        if (userDTO.getStudentId() != null) userEntity.setStudentId(userDTO.getStudentId());&#10;&#10;        // Update faculty-specific fields&#10;        if (userDTO.getStaffCode() != null) userEntity.setStaffCode(userDTO.getStaffCode());&#10;&#10;        // Update media fields&#10;        if (userDTO.getAvatarUrl() != null) userEntity.setAvatarUrl(userDTO.getAvatarUrl());&#10;        if (userDTO.getBackgroundUrl() != null) userEntity.setBackgroundUrl(userDTO.getBackgroundUrl());&#10;&#10;        // Update relationships - this fixes the duplicate relationship issue&#10;        if (userDTO.getMajorId() != null) {&#10;            updateUserMajor(userId, userDTO.getMajorId());&#10;        }&#10;&#10;        if (userDTO.getBatchId() != null) {&#10;            updateUserBatch(userId, userDTO.getBatchId());&#10;        }&#10;&#10;        if (userDTO.getGenderId() != null) {&#10;            updateUserGender(userId, userDTO.getGenderId());&#10;        }&#10;&#10;        if (userDTO.getFacultyId() != null) {&#10;            if (userEntity.isStudent()) {&#10;                updateUserFaculty(userId, userDTO.getFacultyId());&#10;            } else {&#10;                updateUserWorkingFaculty(userId, userDTO.getFacultyId());&#10;            }&#10;        }&#10;&#10;        if (userDTO.getCollegeId() != null) {&#10;            if (userEntity.isStudent()) {&#10;                updateUserCollege(userId, userDTO.getCollegeId());&#10;            } else {&#10;                updateUserWorkingCollege(userId, userDTO.getCollegeId());&#10;            }&#10;        }&#10;&#10;        if (userDTO.getDegreeId() != null) {&#10;            updateUserDegree(userId, userDTO.getDegreeId());&#10;        }&#10;&#10;        if (userDTO.getPositionId() != null) {&#10;            updateUserPosition(userId, userDTO.getPositionId());&#10;        }&#10;&#10;        if (userDTO.getAcademicId() != null) {&#10;            updateUserAcademic(userId, userDTO.getAcademicId());&#10;        }&#10;&#10;        userEntity.setUpdatedAt(LocalDateTime.now());&#10;        UserEntity updatedUser = userRepository.save(userEntity);&#10;&#10;        // Publish user profile updated event&#10;        userEventPublisher.publishUserProfileUpdatedEvent(&#10;                userIdOrEmail,&#10;                updatedUser.getEmail(),&#10;                updatedUser.getFullName(),&#10;                updatedUser.getFullName(), // firstName - using fullName as we don't have separate first/last names&#10;                &quot;&quot;, // lastName - empty as we're using fullName&#10;                updatedUser.getBio(),&#10;                updatedUser.getAvatarUrl() != null ? updatedUser.getAvatarUrl() : &quot;&quot;&#10;        );&#10;&#10;        return mapToDTO(updatedUser);&#10;    }&#10;*/&#10;    // ========================= RELATIONSHIP UPDATE METHODS =========================&#10;&#10;    /**&#10;     * Update user's major relationship (for students)&#10;     */&#10;    @Transactional&#10;    public void updateUserMajor(String userId, String majorId) {&#10;        // Verify user exists&#10;        userRepository.findById(userId)&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;User not found with id: &quot; + userId));&#10;&#10;        // Verify major exists&#10;        majorRepository.findById(majorId)&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;Major not found with id: &quot; + majorId));&#10;&#10;        // Update relationship - this will delete old relationship and create new one&#10;        userRepository.updateUserMajor(userId, majorId);&#10;    }&#10;&#10;    /**&#10;     * Update user's batch relationship&#10;     */&#10;    @Transactional&#10;    public void updateUserBatch(String userId, String batchId) {&#10;        userRepository.findById(userId)&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;User not found with id: &quot; + userId));&#10;&#10;        batchRepository.findById(batchId)&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;Batch not found with id: &quot; + batchId));&#10;&#10;        userRepository.updateUserBatch(userId, batchId);&#10;    }&#10;&#10;    /**&#10;     * Update user's gender relationship&#10;     */&#10;    @Transactional&#10;    public void updateUserGender(String userId, String genderId) {&#10;        userRepository.findById(userId)&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;User not found with id: &quot; + userId));&#10;&#10;        genderRepository.findById(genderId)&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;Gender not found with id: &quot; + genderId));&#10;&#10;        userRepository.updateUserGender(userId, genderId);&#10;    }&#10;&#10;    /**&#10;     * Update user's faculty relationship (for students)&#10;     */&#10;    @Transactional&#10;    public void updateUserFaculty(String userId, String facultyId) {&#10;        userRepository.findById(userId)&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;User not found with id: &quot; + userId));&#10;&#10;        facultyRepository.findById(facultyId)&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;Faculty not found with id: &quot; + facultyId));&#10;&#10;        userRepository.updateUserFaculty(userId, facultyId);&#10;    }&#10;&#10;    /**&#10;     * Update user's college relationship (for students)&#10;     */&#10;    @Transactional&#10;    public void updateUserCollege(String userId, String collegeId) {&#10;        userRepository.findById(userId)&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;User not found with id: &quot; + userId));&#10;&#10;        collegeRepository.findById(collegeId)&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;College not found with id: &quot; + collegeId));&#10;&#10;        userRepository.updateUserCollege(userId, collegeId);&#10;    }&#10;&#10;    /**&#10;     * Update user's working faculty relationship (for staff)&#10;     */&#10;    @Transactional&#10;    public void updateUserWorkingFaculty(String userId, String facultyId) {&#10;        userRepository.findById(userId)&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;User not found with id: &quot; + userId));&#10;&#10;        facultyRepository.findById(facultyId)&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;Faculty not found with id: &quot; + facultyId));&#10;&#10;        userRepository.updateUserWorkingFaculty(userId, facultyId);&#10;    }&#10;&#10;    /**&#10;     * Update user's working college relationship (for staff)&#10;     */&#10;    @Transactional&#10;    public void updateUserWorkingCollege(String userId, String collegeId) {&#10;        userRepository.findById(userId)&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;User not found with id: &quot; + userId));&#10;&#10;        collegeRepository.findById(collegeId)&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;College not found with id: &quot; + collegeId));&#10;&#10;        userRepository.updateUserWorkingCollege(userId, collegeId);&#10;    }&#10;&#10;    /**&#10;     * Update user's degree relationship&#10;     */&#10;    @Transactional&#10;    public void updateUserDegree(String userId, String degreeId) {&#10;        userRepository.findById(userId)&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;User not found with id: &quot; + userId));&#10;&#10;        degreeRepository.findById(degreeId)&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;Degree not found with id: &quot; + degreeId));&#10;&#10;        userRepository.updateUserDegree(userId, degreeId);&#10;    }&#10;&#10;    /**&#10;     * Update user's position relationship&#10;     */&#10;    @Transactional&#10;    public void updateUserPosition(String userId, String positionId) {&#10;        userRepository.findById(userId)&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;User not found with id: &quot; + userId));&#10;&#10;        positionRepository.findById(positionId)&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;Position not found with id: &quot; + positionId));&#10;&#10;        userRepository.updateUserPosition(userId, positionId);&#10;    }&#10;&#10;    /**&#10;     * Update user's academic relationship&#10;     */&#10;    @Transactional&#10;    public void updateUserAcademic(String userId, String academicId) {&#10;        userRepository.findById(userId)&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;User not found with id: &quot; + userId));&#10;&#10;        academicRepository.findById(academicId)&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;Academic not found with id: &quot; + academicId));&#10;&#10;        userRepository.updateUserAcademic(userId, academicId);&#10;    }&#10;&#10;    /**&#10;     * Send a friend request - GỬI LỜI MỜI KẾT BẠN&#10;     */&#10;    @Transactional&#10;    public void addFriend(String userId, String friendId) {&#10;        if (userId.equals(friendId)) {&#10;            throw new IllegalArgumentException(&quot;Cannot add yourself as a friend&quot;);&#10;        }&#10;&#10;        // Kiểm tra user tồn tại&#10;        UserEntity user = userRepository.findById(userId)&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;User not found with id: &quot; + userId));&#10;&#10;        UserEntity friend = userRepository.findById(friendId)&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;Friend not found with id: &quot; + friendId));&#10;&#10;        // Kiểm tra đã là bạn bè chưa&#10;        if (userRepository.areFriends(userId, friendId)) {&#10;            throw new IllegalStateException(&quot;Users are already friends&quot;);&#10;        }&#10;&#10;        // Kiểm tra đã có friend request chưa&#10;        if (userRepository.hasPendingFriendRequest(userId, friendId)) {&#10;            throw new IllegalStateException(&quot;Friend request already sent&quot;);&#10;        }&#10;&#10;        // Kiểm tra xem có friend request ngược lại không (để auto-accept)&#10;        if (userRepository.hasPendingFriendRequest(friendId, userId)) {&#10;            // Tự động chấp nhận nếu đã có request ngược lại&#10;        // Kiểm tra xem có friend request ngược lại không (để auto-accept)&#10;&#10;            // Publish friend accepted event&#10;            userEventPublisher.publishUserRelationshipChangedEvent(&#10;                    userId,&#10;                    friendId,&#10;                    &quot;FRIEND_ACCEPTED&quot;,&#10;                    &quot;UPDATED&quot;&#10;            );&#10;        } else {&#10;            // Gửi friend request mới&#10;            userRepository.sendFriendRequest(userId, friendId);&#10;&#10;            // Publish friend request event&#10;            userEventPublisher.publishUserRelationshipChangedEvent(&#10;                    userId,&#10;                    friendId,&#10;                    &quot;FRIEND_REQUEST&quot;,&#10;                    &quot;CREATED&quot;&#10;            );&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get friend requests received by this user - LỜI MỜI KẾT BẠN NHẬN ĐƯỢC&#10;     */&#10;    public List&lt;UserDTO&gt; getFriendRequests(String userId) {&#10;        UserEntity user = userRepository.findById(userId)&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;User not found with id: &quot; + userId));&#10;&#10;        List&lt;UserEntity&gt; incomingRequests = userRepository.findIncomingFriendRequests(userId);&#10;        return incomingRequests.stream()&#10;                .map(this::mapToDTO)&#10;                .collect(Collectors.toList());&#10;    }&#10;&#10;    /**&#10;     * Get friend requests sent by this user - LỜI MỜI KẾT BẠN ĐÃ GỬI&#10;     */&#10;    public List&lt;UserDTO&gt; getFriendRequested(String userId) {&#10;        UserEntity user = userRepository.findById(userId)&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;User not found with id: &quot; + userId));&#10;&#10;        List&lt;UserEntity&gt; outgoingRequests = userRepository.findOutgoingFriendRequests(userId);&#10;        return outgoingRequests.stream()&#10;                .map(this::mapToDTO)&#10;                .collect(Collectors.toList());&#10;    }&#10;&#10;    /**&#10;     * Accept a friend request - CHẤP NHẬN LỜI MỜI KẾT BẠN&#10;     */&#10;    @Transactional&#10;    public void acceptFriendInvite(String userId, String friendId) {&#10;        UserEntity user = userRepository.findById(userId)&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;User not found with id: &quot; + userId));&#10;&#10;        UserEntity friend = userRepository.findById(friendId)&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;Friend not found with id: &quot; + friendId));&#10;&#10;        // Kiểm tra có friend request từ friendId đến userId không&#10;        if (!userRepository.hasPendingFriendRequest(friendId, userId)) {&#10;            throw new IllegalStateException(&quot;No pending friend request from &quot; + friendId);&#10;        }&#10;&#10;        // Chấp nhận friend request&#10;        userRepository.acceptFriendRequest(friendId, userId);&#10;&#10;        // Publish friend accepted event&#10;        userEventPublisher.publishUserRelationshipChangedEvent(&#10;                userId,&#10;                friendId,&#10;                &quot;FRIEND_ACCEPTED&quot;,&#10;                &quot;UPDATED&quot;&#10;        );&#10;    }&#10;&#10;    /**&#10;     * Reject a friend request - TỪ CHỐI LỜI MỜI KẾT BẠN&#10;     */&#10;    @Transactional&#10;    public void rejectFriendInvite(String userId, String friendId) {&#10;        UserEntity user = userRepository.findById(userId)&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;User not found with id: &quot; + userId));&#10;&#10;        UserEntity friend = userRepository.findById(friendId)&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;Friend not found with id: &quot; + friendId));&#10;&#10;        // Kiểm tra có friend request từ friendId đến userId không&#10;        if (!userRepository.hasPendingFriendRequest(friendId, userId)) {&#10;            throw new IllegalStateException(&quot;No pending friend request from &quot; + friendId);&#10;        }&#10;&#10;        // Từ chối friend request&#10;        userRepository.rejectFriendRequest(friendId, userId);&#10;&#10;        // Publish friend rejected event&#10;        userEventPublisher.publishUserRelationshipChangedEvent(&#10;                userId,&#10;                friendId,&#10;                &quot;FRIEND_REQUEST&quot;,&#10;                &quot;REJECTED&quot;&#10;        );&#10;    }&#10;&#10;    /**&#10;     * Remove a friend (unfriend) - HỦY KẾT BẠN&#10;     */&#10;    @Transactional&#10;    public void removeFriend(String userId, String friendId) {&#10;        UserEntity user = userRepository.findById(userId)&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;User not found with id: &quot; + userId));&#10;&#10;        UserEntity friend = userRepository.findById(friendId)&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;Friend not found with id: &quot; + friendId));&#10;&#10;        // Kiểm tra có phải bạn bè không&#10;        if (!userRepository.areFriends(userId, friendId)) {&#10;            throw new IllegalStateException(&quot;Users are not friends&quot;);&#10;        }&#10;&#10;        // Xóa friendship&#10;        userRepository.deleteFriendship(userId, friendId);&#10;&#10;        // Publish friend removed event&#10;        userEventPublisher.publishUserRelationshipChangedEvent(&#10;                userId,&#10;                friendId,&#10;                &quot;FRIEND_REMOVED&quot;,&#10;                &quot;DELETED&quot;&#10;        );&#10;    }&#10;&#10;    /**&#10;     * Get all friends of a user - LẤY DANH SÁCH BẠN BÈ&#10;     */&#10;    public FriendsDTO getFriends(String userId) {&#10;        UserEntity user = userRepository.findById(userId)&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;User not found with id: &quot; + userId));&#10;&#10;        List&lt;UserEntity&gt; friends = userRepository.findFriends(userId);&#10;        List&lt;UserDTO&gt; friendDTOs = friends.stream()&#10;                .map(this::mapToDTO)&#10;                .collect(Collectors.toList());&#10;&#10;        return new FriendsDTO(friendDTOs);&#10;    }&#10;&#10;    /**&#10;     * Get mutual friends between two users - LẤY BẠN CHUNG&#10;     */&#10;    public FriendsDTO getMutualFriends(String userId, String otherUserId) {&#10;        UserEntity user = userRepository.findById(userId)&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;User not found with id: &quot; + userId));&#10;&#10;        UserEntity otherUser = userRepository.findById(otherUserId)&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;Other user not found with id: &quot; + otherUserId));&#10;&#10;        List&lt;UserEntity&gt; mutualFriends = userRepository.findMutualFriends(userId, otherUserId);&#10;        List&lt;UserDTO&gt; mutualFriendDTOs = mutualFriends.stream()&#10;                .map(this::mapToDTO)&#10;                .collect(Collectors.toList());&#10;&#10;        return FriendsDTO.ofMutualFriends(mutualFriendDTOs);&#10;    }&#10;&#10;    /**&#10;     * Get friend suggestions - GỢI Ý KẾT BẠN&#10;     */&#10;    public FriendsDTO getFriendSuggestions(String userId) {&#10;        UserEntity user = userRepository.findById(userId)&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;User not found with id: &quot; + userId));&#10;&#10;        List&lt;UserEntity&gt; suggestions = userRepository.findFriendSuggestions(userId);&#10;        List&lt;UserDTO&gt; suggestionDTOs = suggestions.stream()&#10;                .map(u -&gt; {&#10;                    UserDTO dto = mapToDTO(u);&#10;                    // Calculate mutual friends count&#10;                    List&lt;UserEntity&gt; mutualFriends = userRepository.findMutualFriends(userId, u.getId());&#10;                    dto.setMutualFriendsCount(mutualFriends.size());&#10;&#10;                    // Calculate similarity&#10;                    calculateSimilarityScore(user, u, dto);&#10;                    return dto;&#10;                })&#10;                .collect(Collectors.toList());&#10;&#10;        return FriendsDTO.ofSuggestions(suggestionDTOs);&#10;    }&#10;&#10;    /**&#10;     * Filter users by relationship criteria - LỌC NGƯỜI DÙNG THEO TIÊU CHÍ&#10;     */&#10;    public List&lt;UserDTO&gt; getUsersByRelationshipFilters(String userId, RelationshipFilterDTO filters) {&#10;        UserEntity user = userRepository.findById(userId)&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;User not found with id: &quot; + userId));&#10;&#10;        List&lt;UserEntity&gt; filteredUsers;&#10;&#10;        // Sử dụng Neo4j query để filter hiệu quả&#10;        if (filters.getCollege() != null || filters.getFaculty() != null ||&#10;                filters.getMajor() != null || filters.getBatch() != null) {&#10;&#10;            // Convert filters to boolean flags for Neo4j query&#10;            boolean isSameCollege = filters.getCollege() != null;&#10;            boolean isSameFaculty = filters.getFaculty() != null;&#10;            boolean isSameMajor = filters.getMajor() != null;&#10;            boolean isSameBatch = filters.getBatch() != null;&#10;&#10;            filteredUsers = userRepository.findUsersWithFilters(userId, isSameCollege, isSameFaculty, isSameMajor, isSameBatch);&#10;        } else {&#10;            // If no specific filters, get all users except self&#10;            filteredUsers = userRepository.findAll().stream()&#10;                    .filter(u -&gt; !u.getId().equals(userId))&#10;                    .collect(Collectors.toList());&#10;        }&#10;&#10;        return filteredUsers.stream()&#10;                .filter(u -&gt; matchesFilters(user, u, filters))&#10;                .map(this::mapToDTO)&#10;                .collect(Collectors.toList());&#10;    }&#10;&#10;    /**&#10;     * Get all users (Admin only)&#10;     */&#10;    public List&lt;UserDTO&gt; getAllUsers() {&#10;        return userRepository.findAll().stream()&#10;                .map(this::mapToDTO)&#10;                .collect(Collectors.toList());&#10;    }&#10;&#10;    /**&#10;     * Delete user (Admin only)&#10;     */&#10;    @Transactional&#10;    public void deleteUser(String userId) {&#10;        UserEntity user = userRepository.findById(userId)&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;User not found with id: &quot; + userId));&#10;&#10;        // Xóa tất cả friend relationships và friend requests&#10;        List&lt;UserEntity&gt; friends = userRepository.findFriends(userId);&#10;        for (UserEntity friend : friends) {&#10;            userRepository.deleteFriendship(userId, friend.getId());&#10;        }&#10;&#10;        // Xóa tất cả friend requests (incoming và outgoing)&#10;        List&lt;UserEntity&gt; incomingRequests = userRepository.findIncomingFriendRequests(userId);&#10;        for (UserEntity requester : incomingRequests) {&#10;            userRepository.rejectFriendRequest(requester.getId(), userId);&#10;        }&#10;&#10;        List&lt;UserEntity&gt; outgoingRequests = userRepository.findOutgoingFriendRequests(userId);&#10;        for (UserEntity receiver : outgoingRequests) {&#10;            userRepository.rejectFriendRequest(userId, receiver.getId());&#10;        }&#10;&#10;        // Delete the user&#10;        userRepository.deleteById(userId);&#10;    }&#10;&#10;    /**&#10;     * Calculate similarity score for friend suggestions&#10;     */&#10;    private void calculateSimilarityScore(UserEntity user, UserEntity candidate, UserDTO candidateDTO) {&#10;        // Check similarity attributes using proper getter methods&#10;        candidateDTO.setSameCollege(Objects.equals(user.getCollegeName(), candidate.getCollegeName()));&#10;        candidateDTO.setSameFaculty(Objects.equals(user.getFacultyName(), candidate.getFacultyName()));&#10;        candidateDTO.setSameMajor(Objects.equals(user.getMajorName(), candidate.getMajorName()));&#10;        candidateDTO.setSameBatch(Objects.equals(user.getBatchYear(), candidate.getBatchYear()));&#10;    }&#10;&#10;    /**&#10;     * Check if user matches relationship filters&#10;     */&#10;    private boolean matchesFilters(UserEntity user, UserEntity candidate, RelationshipFilterDTO filters) {&#10;        if (filters.getCollege() != null &amp;&amp; !filters.getCollege().equals(candidate.getCollegeName())) {&#10;            return false;&#10;        }&#10;        if (filters.getFaculty() != null &amp;&amp; !filters.getFaculty().equals(candidate.getFacultyName())) {&#10;            return false;&#10;        }&#10;        if (filters.getMajor() != null &amp;&amp; !filters.getMajor().equals(candidate.getMajorName())) {&#10;            return false;&#10;        }&#10;        if (filters.getBatch() != null &amp;&amp; !filters.getBatch().equals(candidate.getBatchYear())) {&#10;            return false;&#10;        }&#10;        return filters.getGender() == null || filters.getGender().equals(candidate.getGenderName());&#10;    }&#10;&#10;    /**&#10;     * Map UserEntity to UserDTO&#10;     */&#10;    private UserDTO mapToDTO(UserEntity entity) {&#10;        UserDTO dto = new UserDTO();&#10;        dto.setId(entity.getId());&#10;        dto.setEmail(entity.getEmail());&#10;        dto.setUsername(entity.getUsername());&#10;        dto.setFullName(entity.getFullName());&#10;        dto.setRole(entity.getRole() != null ? entity.getRole().toString() : null);&#10;        dto.setBio(entity.getBio());&#10;        dto.setIsActive(entity.getIsActive());&#10;        dto.setIsProfileCompleted(entity.getIsProfileCompleted());&#10;        dto.setCreatedAt(entity.getCreatedAt());&#10;        dto.setUpdatedAt(entity.getUpdatedAt());&#10;&#10;        // Student fields&#10;        dto.setStudentId(entity.getStudentId());&#10;        dto.setMajor(entity.getMajor());&#10;        dto.setBatch(entity.getBatch());&#10;        // Lecturer fields&#10;        dto.setStaffCode(entity.getStaffCode());&#10;        dto.setAcademic(entity.getAcademic());&#10;        dto.setDegree(entity.getDegree());&#10;        dto.setPosition(entity.getPosition());&#10;&#10;        // Common fields&#10;        dto.setFaculty(entity.getFaculty());&#10;        dto.setCollege(entity.getCollege());&#10;        dto.setGender(entity.getGender());&#10;&#10;        // Media fields&#10;        dto.setAvatarUrl(entity.getAvatarUrl());&#10;        dto.setBackgroundUrl(entity.getBackgroundUrl());&#10;&#10;        // Friends mapping&#10;        if (entity.getFriends() != null) {&#10;            dto.setFriendIds(&#10;                    entity.getFriends().stream()&#10;                            .map(UserEntity::getId)&#10;                            .collect(Collectors.toSet())&#10;            );&#10;        }&#10;&#10;        return dto;&#10;    }&#10;&#10;&#10;    /**&#10;     * Map UserDTO to UserEntity&#10;     */&#10;    private UserEntity mapToEntity(UserDTO dto) {&#10;        UserEntity entity = new UserEntity();&#10;        entity.setId(dto.getId());&#10;        entity.setEmail(dto.getEmail());&#10;        entity.setUsername(dto.getUsername());&#10;        entity.setFullName(dto.getFullName());&#10;&#10;        // Handle role conversion safely&#10;        if (dto.getRole() != null) {&#10;            try {&#10;                entity.setRole(Role.valueOf(dto.getRole()));&#10;            } catch (IllegalArgumentException e) {&#10;                entity.setRole(Role.USER); // Default fallback&#10;            }&#10;        }&#10;&#10;        entity.setBio(dto.getBio());&#10;        entity.setIsActive(dto.getIsActive());&#10;&#10;        // Student fields&#10;        entity.setStudentId(dto.getStudentId());&#10;&#10;        // Faculty fields&#10;        entity.setStaffCode(dto.getStaffCode());&#10;&#10;        // Media fields&#10;        entity.setAvatarUrl(dto.getAvatarUrl());&#10;        entity.setBackgroundUrl(dto.getBackgroundUrl());&#10;&#10;        // Note: Relationship mappings (major, batch, gender, etc.) should be handled&#10;        // separately as they require database lookups to establish Neo4j relationships&#10;        // This method only handles direct field mappings&#10;&#10;        return entity;&#10;    }&#10;&#10;    public Boolean checkProfile(String currentUserId) {&#10;        UserEntity userEntity = userRepository.findById(currentUserId)&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;User not found with id: &quot; + currentUserId));&#10;&#10;        // Map to DTO&#10;        UserDTO userDTO = mapToDTO(userEntity);&#10;&#10;        return userDTO.getIsProfileCompleted();&#10;    }&#10;&#10;    // ========================= PROFILE UPDATE METHODS =========================&#10;&#10;    /**&#10;     * Update student profile with event publishing for post-service synchronization&#10;     */&#10;    @Transactional&#10;    public UserDTO updateStudentProfile(String userId, Object profileRequest) {&#10;        UserEntity userEntity = userRepository.findById(userId)&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;User not found with id: &quot; + userId));&#10;&#10;        // Convert Object to map for flexible handling&#10;        @SuppressWarnings(&quot;unchecked&quot;)&#10;        Map&lt;String, Object&gt; profileData = (Map&lt;String, Object&gt;) profileRequest;&#10;&#10;        // Update basic profile fields&#10;        if (profileData.containsKey(&quot;fullName&quot;)) {&#10;            userEntity.setFullName((String) profileData.get(&quot;fullName&quot;));&#10;        }&#10;        if (profileData.containsKey(&quot;bio&quot;)) {&#10;            userEntity.setBio((String) profileData.get(&quot;bio&quot;));&#10;        }&#10;        if (profileData.containsKey(&quot;studentId&quot;)) {&#10;            userEntity.setStudentId((String) profileData.get(&quot;studentId&quot;));&#10;        }&#10;        if (profileData.containsKey(&quot;avatarUrl&quot;)) {&#10;            userEntity.setAvatarUrl((String) profileData.get(&quot;avatarUrl&quot;));&#10;        }&#10;        if (profileData.containsKey(&quot;backgroundUrl&quot;)) {&#10;            userEntity.setBackgroundUrl((String) profileData.get(&quot;backgroundUrl&quot;));&#10;        }&#10;&#10;        // Update relationships if provided&#10;        if (profileData.containsKey(&quot;majorCode&quot;)) {&#10;            String majorCode = (String) profileData.get(&quot;majorCode&quot;);&#10;            if (majorCode != null) {&#10;                updateUserMajor(userId, majorCode);&#10;            }&#10;        }&#10;        if (profileData.containsKey(&quot;facultyCode&quot;)) {&#10;            String facultyCode = (String) profileData.get(&quot;facultyCode&quot;);&#10;            if (facultyCode != null) {&#10;                updateUserFaculty(userId, facultyCode);&#10;            }&#10;        }&#10;        if (profileData.containsKey(&quot;collegeCode&quot;)) {&#10;            String collegeCode = (String) profileData.get(&quot;collegeCode&quot;);&#10;            if (collegeCode != null) {&#10;                updateUserCollege(userId, collegeCode);&#10;            }&#10;        }&#10;        if (profileData.containsKey(&quot;batchYear&quot;)) {&#10;            String batchYear = (String) profileData.get(&quot;batchYear&quot;);&#10;            if (batchYear != null) {&#10;                updateUserBatch(userId, batchYear);&#10;            }&#10;        }&#10;        if (profileData.containsKey(&quot;genderCode&quot;)) {&#10;            String genderCode = (String) profileData.get(&quot;genderCode&quot;);&#10;            if (genderCode != null) {&#10;                updateUserGender(userId, genderCode);&#10;            }&#10;        }&#10;&#10;        userEntity.setUpdatedAt(LocalDateTime.now());&#10;        UserEntity updatedUser = userRepository.save(userEntity);&#10;&#10;        // CRITICAL FIX: Publish profile update event for post-service synchronization&#10;        publishProfileUpdateEvent(updatedUser);&#10;&#10;        return mapToDTO(updatedUser);&#10;    }&#10;&#10;    /**&#10;     * Update lecturer profile with event publishing for post-service synchronization&#10;     */&#10;    @Transactional&#10;    public UserDTO updateLecturerProfile(String userId, Object profileRequest) {&#10;        UserEntity userEntity = userRepository.findById(userId)&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;User not found with id: &quot; + userId));&#10;&#10;        // Convert Object to map for flexible handling&#10;        @SuppressWarnings(&quot;unchecked&quot;)&#10;        Map&lt;String, Object&gt; profileData = (Map&lt;String, Object&gt;) profileRequest;&#10;&#10;        // Update basic profile fields&#10;        if (profileData.containsKey(&quot;fullName&quot;)) {&#10;            userEntity.setFullName((String) profileData.get(&quot;fullName&quot;));&#10;        }&#10;        if (profileData.containsKey(&quot;bio&quot;)) {&#10;            userEntity.setBio((String) profileData.get(&quot;bio&quot;));&#10;        }&#10;        if (profileData.containsKey(&quot;staffCode&quot;)) {&#10;            userEntity.setStaffCode((String) profileData.get(&quot;staffCode&quot;));&#10;        }&#10;        if (profileData.containsKey(&quot;avatarUrl&quot;)) {&#10;            userEntity.setAvatarUrl((String) profileData.get(&quot;avatarUrl&quot;));&#10;        }&#10;        if (profileData.containsKey(&quot;backgroundUrl&quot;)) {&#10;            userEntity.setBackgroundUrl((String) profileData.get(&quot;backgroundUrl&quot;));&#10;        }&#10;&#10;        // Update relationships if provided&#10;        if (profileData.containsKey(&quot;facultyCode&quot;)) {&#10;            String facultyCode = (String) profileData.get(&quot;facultyCode&quot;);&#10;            if (facultyCode != null) {&#10;                updateUserWorkingFaculty(userId, facultyCode);&#10;            }&#10;        }&#10;        if (profileData.containsKey(&quot;positionCode&quot;)) {&#10;            String positionCode = (String) profileData.get(&quot;positionCode&quot;);&#10;            if (positionCode != null) {&#10;                updateUserPosition(userId, positionCode);&#10;            }&#10;        }&#10;        if (profileData.containsKey(&quot;academicCode&quot;)) {&#10;            String academicCode = (String) profileData.get(&quot;academicCode&quot;);&#10;            if (academicCode != null) {&#10;                updateUserAcademic(userId, academicCode);&#10;            }&#10;        }&#10;        if (profileData.containsKey(&quot;degreeCode&quot;)) {&#10;            String degreeCode = (String) profileData.get(&quot;degreeCode&quot;);&#10;            if (degreeCode != null) {&#10;                updateUserDegree(userId, degreeCode);&#10;            }&#10;        }&#10;        if (profileData.containsKey(&quot;genderCode&quot;)) {&#10;            String genderCode = (String) profileData.get(&quot;genderCode&quot;);&#10;            if (genderCode != null) {&#10;                updateUserGender(userId, genderCode);&#10;            }&#10;        }&#10;&#10;        userEntity.setUpdatedAt(LocalDateTime.now());&#10;        UserEntity updatedUser = userRepository.save(userEntity);&#10;&#10;        // CRITICAL FIX: Publish profile update event for post-service synchronization&#10;        publishProfileUpdateEvent(updatedUser);&#10;&#10;        return mapToDTO(updatedUser);&#10;    }&#10;&#10;    /**&#10;     * Update general user profile with event publishing&#10;     */&#10;    @Transactional&#10;    public UserDTO updateUserProfile(String userId, UserDTO userDTO) {&#10;        UserEntity userEntity = userRepository.findById(userId)&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;User not found with id: &quot; + userId));&#10;&#10;        // Update basic profile fields&#10;        if (userDTO.getFullName() != null) userEntity.setFullName(userDTO.getFullName());&#10;        if (userDTO.getEmail() != null) userEntity.setEmail(userDTO.getEmail());&#10;        if (userDTO.getUsername() != null) userEntity.setUsername(userDTO.getUsername());&#10;        if (userDTO.getBio() != null) userEntity.setBio(userDTO.getBio());&#10;        if (userDTO.getAvatarUrl() != null) userEntity.setAvatarUrl(userDTO.getAvatarUrl());&#10;        if (userDTO.getBackgroundUrl() != null) userEntity.setBackgroundUrl(userDTO.getBackgroundUrl());&#10;&#10;        userEntity.setUpdatedAt(LocalDateTime.now());&#10;        UserEntity updatedUser = userRepository.save(userEntity);&#10;&#10;        // CRITICAL FIX: Publish profile update event for post-service synchronization&#10;        publishProfileUpdateEvent(updatedUser);&#10;&#10;        return mapToDTO(updatedUser);&#10;    }&#10;&#10;    /**&#10;     * Publish profile update event to notify post-service&#10;     * This is the CRITICAL method that fixes AuthorInfo synchronization&#10;     */&#10;    private void publishProfileUpdateEvent(UserEntity user) {&#10;        try {&#10;            userEventPublisher.publishUserProfileUpdatedEventForPostService(&#10;                user.getId(),&#10;                user.getFullName() != null ? user.getFullName() : &quot;&quot;,&#10;                user.getEmail() != null ? user.getEmail() : &quot;&quot;,&#10;                user.getUsername() != null ? user.getUsername() : &quot;&quot;,&#10;                user.getAvatarUrl() != null ? user.getAvatarUrl() : &quot;&quot;,&#10;                user.getRole() != null ? user.getRole().name() : &quot;USER&quot;&#10;            );&#10;            log.info(&quot;Published profile update event for user: {} ({})&quot;, user.getId(), user.getFullName());&#10;        } catch (Exception e) {&#10;            log.error(&quot;Failed to publish profile update event for user {}: {}&quot;, user.getId(), e.getMessage(), e);&#10;            // Don't throw exception to avoid breaking the profile update&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get friend IDs for a user (for internal service communication)&#10;     */&#10;    public Set&lt;String&gt; getFriendIds(String userId) {&#10;        Optional&lt;UserEntity&gt; userOpt = userRepository.findById(userId);&#10;        if (userOpt.isPresent()) {&#10;            return userOpt.get().getFriendIds();&#10;        }&#10;        return new HashSet&lt;&gt;();&#10;    }&#10;&#10;    /**&#10;     * Get users with close interactions (for feed ranking)&#10;     */&#10;    public Set&lt;String&gt; getCloseInteractionIds(String userId) {&#10;        // This would typically analyze interaction patterns&#10;        // For now, returning a subset of friends with high interaction&#10;        Set&lt;String&gt; friendIds = getFriendIds(userId);&#10;        return friendIds.stream()&#10;                .limit(10) // Top 10 close interactions&#10;                .collect(Collectors.toSet());&#10;    }&#10;&#10;    /**&#10;     * Get users from same faculty (for post-service news feed algorithm)&#10;     */&#10;    public Set&lt;String&gt; getSameFacultyUserIds(String userId) {&#10;        Optional&lt;UserEntity&gt; userOpt = userRepository.findById(userId);&#10;        if (userOpt.isEmpty()) {&#10;            return new HashSet&lt;&gt;();&#10;        }&#10;&#10;        UserEntity user = userOpt.get();&#10;        if (user.getFaculty() == null) {&#10;            return new HashSet&lt;&gt;();&#10;        }&#10;&#10;        // Find all users in the same faculty&#10;        List&lt;UserEntity&gt; sameFacultyUsers = userRepository.findUsersByFaculty(user.getFaculty().getId());&#10;        return sameFacultyUsers.stream()&#10;                .map(UserEntity::getId)&#10;                .filter(id -&gt; !id.equals(userId)) // Exclude self&#10;                .collect(Collectors.toSet());&#10;    }&#10;&#10;    /**&#10;     * Get users from same major (for post-service news feed algorithm)&#10;     */&#10;    public Set&lt;String&gt; getSameMajorUserIds(String userId) {&#10;        Optional&lt;UserEntity&gt; userOpt = userRepository.findById(userId);&#10;        if (userOpt.isEmpty()) {&#10;            return new HashSet&lt;&gt;();&#10;        }&#10;&#10;        UserEntity user = userOpt.get();&#10;        if (user.getMajor() == null) {&#10;            return new HashSet&lt;&gt;();&#10;        }&#10;&#10;        // Find all users in the same major&#10;        List&lt;UserEntity&gt; sameMajorUsers = userRepository.findUsersByMajor(user.getMajor().getId());&#10;        return sameMajorUsers.stream()&#10;                .map(UserEntity::getId)&#10;                .filter(id -&gt; !id.equals(userId)) // Exclude self&#10;                .collect(Collectors.toSet());&#10;    }&#10;&#10;    /**&#10;     * Get user interest tags (for post-service content recommendation)&#10;     */&#10;    public Set&lt;String&gt; getUserInterestTags(String userId) {&#10;        Optional&lt;UserEntity&gt; userOpt = userRepository.findById(userId);&#10;        if (userOpt.isEmpty()) {&#10;            return new HashSet&lt;&gt;();&#10;        }&#10;&#10;        UserEntity user = userOpt.get();&#10;        Set&lt;String&gt; interestTags = new HashSet&lt;&gt;();&#10;&#10;        // Add tags based on user's major and faculty&#10;        if (user.getMajor() != null) {&#10;            interestTags.add(user.getMajor().getName().toLowerCase());&#10;            interestTags.add(user.getMajor().getId().toLowerCase());&#10;        }&#10;&#10;        if (user.getFaculty() != null) {&#10;            interestTags.add(user.getFaculty().getName().toLowerCase());&#10;        }&#10;&#10;        // Add role-based tags&#10;        if (user.getRole() != null) {&#10;            interestTags.add(user.getRole().toString().toLowerCase());&#10;        }&#10;&#10;        return interestTags;&#10;    }&#10;&#10;    /**&#10;     * Get user preferred categories (for post-service content filtering)&#10;     */&#10;    public Set&lt;String&gt; getUserPreferredCategories(String userId) {&#10;        Optional&lt;UserEntity&gt; userOpt = userRepository.findById(userId);&#10;        if (userOpt.isEmpty()) {&#10;            return new HashSet&lt;&gt;();&#10;        }&#10;&#10;        UserEntity user = userOpt.get();&#10;        Set&lt;String&gt; preferredCategories = new HashSet&lt;&gt;();&#10;&#10;        // Add categories based on user profile&#10;        if (user.isStudent()) {&#10;            preferredCategories.add(&quot;academic&quot;);&#10;            preferredCategories.add(&quot;student_life&quot;);&#10;            if (user.getMajor() != null) {&#10;                preferredCategories.add(user.getMajor().getName().toLowerCase().replace(&quot; &quot;, &quot;_&quot;));&#10;            }&#10;        } else if (user.isFaculty()) {&#10;            preferredCategories.add(&quot;academic&quot;);&#10;            preferredCategories.add(&quot;research&quot;);&#10;            preferredCategories.add(&quot;teaching&quot;);&#10;        }&#10;&#10;        // Add general categories&#10;        preferredCategories.add(&quot;general&quot;);&#10;        preferredCategories.add(&quot;announcements&quot;);&#10;&#10;        return preferredCategories;&#10;    }&#10;&#10;    /**&#10;     * Get user's faculty ID (for post-service group filtering)&#10;     */&#10;    public String getUserFacultyId(String userId) {&#10;        Optional&lt;UserEntity&gt; userOpt = userRepository.findById(userId);&#10;        if (userOpt.isPresent() &amp;&amp; userOpt.get().getFaculty() != null) {&#10;            return userOpt.get().getFaculty().getId();&#10;        }&#10;        return null;&#10;    }&#10;&#10;    /**&#10;     * Get user's major ID (for post-service group filtering)&#10;     */&#10;    public String getUserMajorId(String userId) {&#10;        Optional&lt;UserEntity&gt; userOpt = userRepository.findById(userId);&#10;        if (userOpt.isPresent() &amp;&amp; userOpt.get().getMajor() != null) {&#10;            return userOpt.get().getMajor().getId();&#10;        }&#10;        return null;&#10;    }&#10;&#10;    /**&#10;     * Enhanced user search with academic context&#10;     */&#10;    public List&lt;UserDTO&gt; searchUsersWithContext(String query, String faculty, String major,&#10;                                               String batch, String currentUserId, int page, int size) {&#10;        // This would implement complex search with Neo4j queries&#10;        // For now, implementing basic search&#10;        List&lt;UserEntity&gt; users = userRepository.findByFullNameContainingIgnoreCase(query);&#10;&#10;        // Apply filters&#10;        if (faculty != null &amp;&amp; !faculty.isEmpty()) {&#10;            users = users.stream()&#10;                    .filter(user -&gt; faculty.equals(user.getFacultyId()))&#10;                    .collect(Collectors.toList());&#10;        }&#10;&#10;        if (major != null &amp;&amp; !major.isEmpty()) {&#10;            users = users.stream()&#10;                    .filter(user -&gt; major.equals(user.getMajorId()))&#10;                    .collect(Collectors.toList());&#10;        }&#10;&#10;        if (batch != null &amp;&amp; !batch.isEmpty()) {&#10;            users = users.stream()&#10;                    .filter(user -&gt; batch.equals(user.getBatchId()))&#10;                    .collect(Collectors.toList());&#10;        }&#10;&#10;        // Apply pagination and convert to DTOs&#10;        return users.stream()&#10;                .skip(page * size)&#10;                .limit(size)&#10;                .map(this::mapToDTO)&#10;                .collect(Collectors.toList());&#10;    }&#10;&#10;    /**&#10;     * Send friend request&#10;     */&#10;    /*@Transactional&#10;    public void sendFriendRequest(String fromUserId, String toUserId) {&#10;        // This would typically create a friend request relationship in Neo4j&#10;        // For now, just publishing an event&#10;        userEventPublisher.publishUserRelationshipChangedEvent(&#10;                fromUserId, toUserId, &quot;FRIEND_REQUEST_SENT&quot;);&#10;&#10;        log.info(&quot;Friend request sent from {} to {}&quot;, fromUserId, toUserId);&#10;    }&#10;*/&#10;    /**&#10;     * Accept friend request&#10;     */&#10;    /*@Transactional&#10;    public void acceptFriendRequest(String fromUserId, String toUserId) {&#10;        // This would typically update the relationship in Neo4j&#10;        // For now, just publishing an event&#10;        userEventPublisher.publishUserRelationshipChangedEvent(&#10;                toUserId, fromUserId, &quot;FRIEND_REQUEST_ACCEPTED&quot;);&#10;&#10;        log.info(&quot;Friend request accepted: {} and {} are now friends&quot;, fromUserId, toUserId);&#10;    }&#10;*/&#10;    /**&#10;     * Get user activity feed (for profile timeline)&#10;     */&#10;    public List&lt;ActivityDTO&gt; getUserActivity(String userId, String viewerId, int page, int size) {&#10;        // This would typically query activity logs or events&#10;        // For now, returning mock activity data&#10;        List&lt;ActivityDTO&gt; activities = new ArrayList&lt;&gt;();&#10;&#10;        activities.add(ActivityDTO.builder()&#10;                .id(&quot;activity_1&quot;)&#10;                .userId(userId)&#10;                .activityType(&quot;POST_CREATED&quot;)&#10;                .entityType(&quot;POST&quot;)&#10;                .entityId(&quot;post_123&quot;)&#10;                .description(&quot;Created a new post&quot;)&#10;                .timestamp(LocalDateTime.now().minusDays(1))&#10;                .build());&#10;&#10;        activities.add(ActivityDTO.builder()&#10;                .id(&quot;activity_2&quot;)&#10;                .userId(userId)&#10;                .activityType(&quot;FRIEND_ADDED&quot;)&#10;                .entityType(&quot;USER&quot;)&#10;                .entityId(&quot;user_456&quot;)&#10;                .description(&quot;Added a new friend&quot;)&#10;                .timestamp(LocalDateTime.now().minusDays(2))&#10;                .build());&#10;&#10;        return activities.stream()&#10;                .skip(page * size)&#10;                .limit(size)&#10;                .collect(Collectors.toList());&#10;    }&#10;&#10;}&#10;" />
              <option name="updatedContent" value="package com.ctuconnect.service;&#13;&#10;&#13;&#10;import com.ctuconnect.dto.*;&#13;&#10;import com.ctuconnect.entity.*;&#13;&#10;import com.ctuconnect.enums.Role;&#13;&#10;import com.ctuconnect.repository.*;&#13;&#10;import com.fasterxml.jackson.databind.ObjectMapper;&#13;&#10;import jakarta.validation.constraints.NotBlank;&#13;&#10;import lombok.extern.slf4j.Slf4j;&#13;&#10;import org.springframework.beans.factory.annotation.Autowired;&#13;&#10;import org.springframework.stereotype.Service;&#13;&#10;import org.springframework.transaction.annotation.Transactional;&#13;&#10;&#13;&#10;import java.util.Map;&#13;&#10;import java.time.LocalDateTime;&#13;&#10;import java.util.ArrayList;&#13;&#10;import java.util.HashSet;&#13;&#10;import java.util.List;&#13;&#10;import java.util.Objects;&#13;&#10;import java.util.Optional;&#13;&#10;import java.util.Set;&#13;&#10;import java.util.stream.Collectors;&#13;&#10;&#13;&#10;@Slf4j&#13;&#10;@Service&#13;&#10;public class UserService {&#13;&#10;&#13;&#10;    @Autowired&#13;&#10;    private UserRepository userRepository;&#13;&#10;&#13;&#10;    @Autowired&#13;&#10;    private UserEventPublisher userEventPublisher;&#13;&#10;&#13;&#10;    @Autowired&#13;&#10;    private FacultyRepository facultyRepository;&#13;&#10;&#13;&#10;    @Autowired&#13;&#10;    private BatchRepository batchRepository;&#13;&#10;&#13;&#10;    @Autowired&#13;&#10;    private GenderRepository genderRepository;&#13;&#10;&#13;&#10;    @Autowired&#13;&#10;    private DegreeRepository degreeRepository;&#13;&#10;&#13;&#10;    @Autowired&#13;&#10;    private AcademicRepository academicRepository;&#13;&#10;&#13;&#10;    @Autowired&#13;&#10;    private PositionRepository positionRepository;&#13;&#10;&#13;&#10;    @Autowired&#13;&#10;    private CollegeRepository collegeRepository;&#13;&#10;&#13;&#10;    @Autowired&#13;&#10;    private MajorRepository majorRepository;&#13;&#10;    /**&#13;&#10;     * Create a new user&#13;&#10;     */&#13;&#10;    public UserDTO createUser(UserDTO userDTO) {&#13;&#10;        UserEntity userEntity = mapToEntity(userDTO);&#13;&#10;        userEntity.setCreatedAt(LocalDateTime.now());&#13;&#10;        userEntity.setUpdatedAt(LocalDateTime.now());&#13;&#10;&#13;&#10;        UserEntity savedUser = userRepository.save(userEntity);&#13;&#10;        return mapToDTO(savedUser);&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Get user profile by ID or email (fallback for compatibility)&#13;&#10;     */&#13;&#10;    public UserDTO getUserProfile(String userIdOrEmail) {&#13;&#10;        Optional&lt;UserEntity&gt; userEntity;&#13;&#10;&#13;&#10;        userEntity = userRepository.findById(userIdOrEmail);&#13;&#10;&#13;&#10;        if (userEntity.isEmpty()) {&#13;&#10;            throw new RuntimeException(&quot;User not found with id or email: &quot; + userIdOrEmail);&#13;&#10;        }&#13;&#10;&#13;&#10;        return mapToDTO(userEntity.get());&#13;&#10;    }&#13;&#10;&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Update user profile by ID or email (fallback for compatibility)&#13;&#10;     */&#13;&#10;    /*@Transactional&#13;&#10;    public UserDTO updateUserProfile(String userIdOrEmail, UserDTO userDTO) {&#13;&#10;        Optional&lt;UserEntity&gt; userEntityOpt = userRepository.findById(userIdOrEmail);&#13;&#10;&#13;&#10;        // If not found by ID, try to find by email (fallback for compatibility)&#13;&#10;        if (userEntityOpt.isEmpty()) {&#13;&#10;            userEntityOpt = userRepository.findByEmail(userIdOrEmail);&#13;&#10;        }&#13;&#10;&#13;&#10;        if (userEntityOpt.isEmpty()) {&#13;&#10;            throw new RuntimeException(&quot;User not found with id or email: &quot; + userIdOrEmail);&#13;&#10;        }&#13;&#10;&#13;&#10;        UserEntity userEntity = userEntityOpt.get();&#13;&#10;        String userId = userEntity.getId();&#13;&#10;&#13;&#10;        // Update basic profile fields&#13;&#10;        if (userDTO.getFullName() != null) userEntity.setFullName(userDTO.getFullName());&#13;&#10;        if (userDTO.getEmail() != null) userEntity.setEmail(userDTO.getEmail());&#13;&#10;        if (userDTO.getUsername() != null) userEntity.setUsername(userDTO.getUsername());&#13;&#10;        if (userDTO.getBio() != null) userEntity.setBio(userDTO.getBio());&#13;&#10;&#13;&#10;        // Update role safely&#13;&#10;        if (userDTO.getRole() != null) {&#13;&#10;            try {&#13;&#10;                userEntity.setRole(Role.valueOf(userDTO.getRole()));&#13;&#10;            } catch (IllegalArgumentException e) {&#13;&#10;                // Keep existing role if invalid role provided&#13;&#10;            }&#13;&#10;        }&#13;&#10;&#13;&#10;        // Update student-specific fields&#13;&#10;        if (userDTO.getStudentId() != null) userEntity.setStudentId(userDTO.getStudentId());&#13;&#10;&#13;&#10;        // Update faculty-specific fields&#13;&#10;        if (userDTO.getStaffCode() != null) userEntity.setStaffCode(userDTO.getStaffCode());&#13;&#10;&#13;&#10;        // Update media fields&#13;&#10;        if (userDTO.getAvatarUrl() != null) userEntity.setAvatarUrl(userDTO.getAvatarUrl());&#13;&#10;        if (userDTO.getBackgroundUrl() != null) userEntity.setBackgroundUrl(userDTO.getBackgroundUrl());&#13;&#10;&#13;&#10;        // Update relationships - this fixes the duplicate relationship issue&#13;&#10;        if (userDTO.getMajorId() != null) {&#13;&#10;            updateUserMajor(userId, userDTO.getMajorId());&#13;&#10;        }&#13;&#10;&#13;&#10;        if (userDTO.getBatchId() != null) {&#13;&#10;            updateUserBatch(userId, userDTO.getBatchId());&#13;&#10;        }&#13;&#10;&#13;&#10;        if (userDTO.getGenderId() != null) {&#13;&#10;            updateUserGender(userId, userDTO.getGenderId());&#13;&#10;        }&#13;&#10;&#13;&#10;        if (userDTO.getFacultyId() != null) {&#13;&#10;            if (userEntity.isStudent()) {&#13;&#10;                updateUserFaculty(userId, userDTO.getFacultyId());&#13;&#10;            } else {&#13;&#10;                updateUserWorkingFaculty(userId, userDTO.getFacultyId());&#13;&#10;            }&#13;&#10;        }&#13;&#10;&#13;&#10;        if (userDTO.getCollegeId() != null) {&#13;&#10;            if (userEntity.isStudent()) {&#13;&#10;                updateUserCollege(userId, userDTO.getCollegeId());&#13;&#10;            } else {&#13;&#10;                updateUserWorkingCollege(userId, userDTO.getCollegeId());&#13;&#10;            }&#13;&#10;        }&#13;&#10;&#13;&#10;        if (userDTO.getDegreeId() != null) {&#13;&#10;            updateUserDegree(userId, userDTO.getDegreeId());&#13;&#10;        }&#13;&#10;&#13;&#10;        if (userDTO.getPositionId() != null) {&#13;&#10;            updateUserPosition(userId, userDTO.getPositionId());&#13;&#10;        }&#13;&#10;&#13;&#10;        if (userDTO.getAcademicId() != null) {&#13;&#10;            updateUserAcademic(userId, userDTO.getAcademicId());&#13;&#10;        }&#13;&#10;&#13;&#10;        userEntity.setUpdatedAt(LocalDateTime.now());&#13;&#10;        UserEntity updatedUser = userRepository.save(userEntity);&#13;&#10;&#13;&#10;        // Publish user profile updated event&#13;&#10;        userEventPublisher.publishUserProfileUpdatedEvent(&#13;&#10;                userIdOrEmail,&#13;&#10;                updatedUser.getEmail(),&#13;&#10;                updatedUser.getFullName(),&#13;&#10;                updatedUser.getFullName(), // firstName - using fullName as we don't have separate first/last names&#13;&#10;                &quot;&quot;, // lastName - empty as we're using fullName&#13;&#10;                updatedUser.getBio(),&#13;&#10;                updatedUser.getAvatarUrl() != null ? updatedUser.getAvatarUrl() : &quot;&quot;&#13;&#10;        );&#13;&#10;&#13;&#10;        return mapToDTO(updatedUser);&#13;&#10;    }&#13;&#10;*/&#13;&#10;    // ========================= RELATIONSHIP UPDATE METHODS =========================&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Update user's major relationship (for students)&#13;&#10;     */&#13;&#10;    @Transactional&#13;&#10;    public void updateUserMajor(String userId, String majorId) {&#13;&#10;        // Verify user exists&#13;&#10;        userRepository.findById(userId)&#13;&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;User not found with id: &quot; + userId));&#13;&#10;&#13;&#10;        // Verify major exists&#13;&#10;        majorRepository.findById(majorId)&#13;&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;Major not found with id: &quot; + majorId));&#13;&#10;&#13;&#10;        // Update relationship - this will delete old relationship and create new one&#13;&#10;        userRepository.updateUserMajor(userId, majorId);&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Update user's batch relationship&#13;&#10;     */&#13;&#10;    @Transactional&#13;&#10;    public void updateUserBatch(String userId, String batchId) {&#13;&#10;        userRepository.findById(userId)&#13;&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;User not found with id: &quot; + userId));&#13;&#10;&#13;&#10;        batchRepository.findById(batchId)&#13;&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;Batch not found with id: &quot; + batchId));&#13;&#10;&#13;&#10;        userRepository.updateUserBatch(userId, batchId);&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Update user's gender relationship&#13;&#10;     */&#13;&#10;    @Transactional&#13;&#10;    public void updateUserGender(String userId, String genderId) {&#13;&#10;        userRepository.findById(userId)&#13;&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;User not found with id: &quot; + userId));&#13;&#10;&#13;&#10;        genderRepository.findById(genderId)&#13;&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;Gender not found with id: &quot; + genderId));&#13;&#10;&#13;&#10;        userRepository.updateUserGender(userId, genderId);&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Update user's faculty relationship (for students)&#13;&#10;     */&#13;&#10;    @Transactional&#13;&#10;    public void updateUserFaculty(String userId, String facultyId) {&#13;&#10;        userRepository.findById(userId)&#13;&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;User not found with id: &quot; + userId));&#13;&#10;&#13;&#10;        facultyRepository.findById(facultyId)&#13;&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;Faculty not found with id: &quot; + facultyId));&#13;&#10;&#13;&#10;        userRepository.updateUserFaculty(userId, facultyId);&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Update user's college relationship (for students)&#13;&#10;     */&#13;&#10;    @Transactional&#13;&#10;    public void updateUserCollege(String userId, String collegeId) {&#13;&#10;        userRepository.findById(userId)&#13;&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;User not found with id: &quot; + userId));&#13;&#10;&#13;&#10;        collegeRepository.findById(collegeId)&#13;&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;College not found with id: &quot; + collegeId));&#13;&#10;&#13;&#10;        userRepository.updateUserCollege(userId, collegeId);&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Update user's working faculty relationship (for staff)&#13;&#10;     */&#13;&#10;    @Transactional&#13;&#10;    public void updateUserWorkingFaculty(String userId, String facultyId) {&#13;&#10;        userRepository.findById(userId)&#13;&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;User not found with id: &quot; + userId));&#13;&#10;&#13;&#10;        facultyRepository.findById(facultyId)&#13;&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;Faculty not found with id: &quot; + facultyId));&#13;&#10;&#13;&#10;        userRepository.updateUserWorkingFaculty(userId, facultyId);&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Update user's working college relationship (for staff)&#13;&#10;     */&#13;&#10;    @Transactional&#13;&#10;    public void updateUserWorkingCollege(String userId, String collegeId) {&#13;&#10;        userRepository.findById(userId)&#13;&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;User not found with id: &quot; + userId));&#13;&#10;&#13;&#10;        collegeRepository.findById(collegeId)&#13;&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;College not found with id: &quot; + collegeId));&#13;&#10;&#13;&#10;        userRepository.updateUserWorkingCollege(userId, collegeId);&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Update user's degree relationship&#13;&#10;     */&#13;&#10;    @Transactional&#13;&#10;    public void updateUserDegree(String userId, String degreeId) {&#13;&#10;        userRepository.findById(userId)&#13;&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;User not found with id: &quot; + userId));&#13;&#10;&#13;&#10;        degreeRepository.findById(degreeId)&#13;&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;Degree not found with id: &quot; + degreeId));&#13;&#10;&#13;&#10;        userRepository.updateUserDegree(userId, degreeId);&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Update user's position relationship&#13;&#10;     */&#13;&#10;    @Transactional&#13;&#10;    public void updateUserPosition(String userId, String positionId) {&#13;&#10;        userRepository.findById(userId)&#13;&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;User not found with id: &quot; + userId));&#13;&#10;&#13;&#10;        positionRepository.findById(positionId)&#13;&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;Position not found with id: &quot; + positionId));&#13;&#10;&#13;&#10;        userRepository.updateUserPosition(userId, positionId);&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Update user's academic relationship&#13;&#10;     */&#13;&#10;    @Transactional&#13;&#10;    public void updateUserAcademic(String userId, String academicId) {&#13;&#10;        userRepository.findById(userId)&#13;&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;User not found with id: &quot; + userId));&#13;&#10;&#13;&#10;        academicRepository.findById(academicId)&#13;&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;Academic not found with id: &quot; + academicId));&#13;&#10;&#13;&#10;        userRepository.updateUserAcademic(userId, academicId);&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Send a friend request - GỬI LỜI MỜI KẾT BẠN&#13;&#10;     */&#13;&#10;    @Transactional&#13;&#10;    public void addFriend(String userId, String friendId) {&#13;&#10;        if (userId.equals(friendId)) {&#13;&#10;            throw new IllegalArgumentException(&quot;Cannot add yourself as a friend&quot;);&#13;&#10;        }&#13;&#10;&#13;&#10;        // Kiểm tra user tồn tại&#13;&#10;        UserEntity user = userRepository.findById(userId)&#13;&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;User not found with id: &quot; + userId));&#13;&#10;&#13;&#10;        UserEntity friend = userRepository.findById(friendId)&#13;&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;Friend not found with id: &quot; + friendId));&#13;&#10;&#13;&#10;        // Kiểm tra đã là bạn bè chưa&#13;&#10;        if (userRepository.areFriends(userId, friendId)) {&#13;&#10;            throw new IllegalStateException(&quot;Users are already friends&quot;);&#13;&#10;        }&#13;&#10;&#13;&#10;        // Kiểm tra đã có friend request chưa&#13;&#10;        if (userRepository.hasPendingFriendRequest(userId, friendId)) {&#13;&#10;            throw new IllegalStateException(&quot;Friend request already sent&quot;);&#13;&#10;        }&#13;&#10;&#13;&#10;        // Kiểm tra xem có friend request ngược lại không (để auto-accept)&#13;&#10;        if (userRepository.hasPendingFriendRequest(friendId, userId)) {&#13;&#10;            // Tự động chấp nhận nếu đã có request ngược lại&#13;&#10;        // Kiểm tra xem có friend request ngược lại không (để auto-accept)&#13;&#10;&#13;&#10;            // Publish friend accepted event&#13;&#10;            userEventPublisher.publishUserRelationshipChangedEvent(&#13;&#10;                    userId,&#13;&#10;                    friendId,&#13;&#10;                    &quot;FRIEND_ACCEPTED&quot;,&#13;&#10;                    &quot;UPDATED&quot;&#13;&#10;            );&#13;&#10;        } else {&#13;&#10;            // Gửi friend request mới&#13;&#10;            userRepository.sendFriendRequest(userId, friendId);&#13;&#10;&#13;&#10;            // Publish friend request event&#13;&#10;            userEventPublisher.publishUserRelationshipChangedEvent(&#13;&#10;                    userId,&#13;&#10;                    friendId,&#13;&#10;                    &quot;FRIEND_REQUEST&quot;,&#13;&#10;                    &quot;CREATED&quot;&#13;&#10;            );&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Get incoming friend requests - LẤY LỜI MỜI KẾT BẠN NHẬN ĐƯỢC&#13;&#10;     */&#13;&#10;    public List&lt;UserDTO&gt; getFriendRequests(String userId) {&#13;&#10;        UserEntity user = userRepository.findById(userId)&#13;&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;User not found with id: &quot; + userId));&#13;&#10;&#13;&#10;        List&lt;UserEntity&gt; incomingRequests = userRepository.findIncomingFriendRequests(userId);&#13;&#10;        return incomingRequests.stream()&#13;&#10;                .map(this::mapToDTO)&#13;&#10;                .collect(Collectors.toList());&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Get outgoing friend requests - LẤY LỜI MỜI KẾT BẠN ĐÃ GỬI&#13;&#10;     */&#13;&#10;    public List&lt;UserDTO&gt; getFriendRequested(String userId) {&#13;&#10;        UserEntity user = userRepository.findById(userId)&#13;&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;User not found with id: &quot; + userId));&#13;&#10;&#13;&#10;        List&lt;UserEntity&gt; outgoingRequests = userRepository.findOutgoingFriendRequests(userId);&#13;&#10;        return outgoingRequests.stream()&#13;&#10;                .map(this::mapToDTO)&#13;&#10;                .collect(Collectors.toList());&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Accept a friend request - CHẤP NHẬN LỜI MỜI KẾT BẠN&#13;&#10;     */&#13;&#10;    @Transactional&#13;&#10;    public void acceptFriendInvite(String userId, String friendId) {&#13;&#10;        UserEntity user = userRepository.findById(userId)&#13;&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;User not found with id: &quot; + userId));&#13;&#10;&#13;&#10;        UserEntity friend = userRepository.findById(friendId)&#13;&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;Friend not found with id: &quot; + friendId));&#13;&#10;&#13;&#10;        // Kiểm tra có friend request từ friendId đến userId không&#13;&#10;        if (!userRepository.hasPendingFriendRequest(friendId, userId)) {&#13;&#10;            throw new IllegalStateException(&quot;No pending friend request from &quot; + friendId);&#13;&#10;        }&#13;&#10;&#13;&#10;        // Chấp nhận friend request&#13;&#10;        userRepository.acceptFriendRequest(friendId, userId);&#13;&#10;&#13;&#10;        // Publish friend accepted event&#13;&#10;        userEventPublisher.publishUserRelationshipChangedEvent(&#13;&#10;                userId,&#13;&#10;                friendId,&#13;&#10;                &quot;FRIEND_ACCEPTED&quot;,&#13;&#10;                &quot;UPDATED&quot;&#13;&#10;        );&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Reject a friend request - TỪ CHỐI LỜI MỜI KẾT BẠN&#13;&#10;     */&#13;&#10;    @Transactional&#13;&#10;    public void rejectFriendInvite(String userId, String friendId) {&#13;&#10;        UserEntity user = userRepository.findById(userId)&#13;&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;User not found with id: &quot; + userId));&#13;&#10;&#13;&#10;        UserEntity friend = userRepository.findById(friendId)&#13;&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;Friend not found with id: &quot; + friendId));&#13;&#10;&#13;&#10;        // Kiểm tra có friend request từ friendId đến userId không&#13;&#10;        if (!userRepository.hasPendingFriendRequest(friendId, userId)) {&#13;&#10;            throw new IllegalStateException(&quot;No pending friend request from &quot; + friendId);&#13;&#10;        }&#13;&#10;&#13;&#10;        // Từ chối friend request&#13;&#10;        userRepository.rejectFriendRequest(friendId, userId);&#13;&#10;&#13;&#10;        // Publish friend rejected event&#13;&#10;        userEventPublisher.publishUserRelationshipChangedEvent(&#13;&#10;                userId,&#13;&#10;                friendId,&#13;&#10;                &quot;FRIEND_REQUEST&quot;,&#13;&#10;                &quot;REJECTED&quot;&#13;&#10;        );&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Remove a friend (unfriend) - HỦY KẾT BẠN&#13;&#10;     */&#13;&#10;    @Transactional&#13;&#10;    public void removeFriend(String userId, String friendId) {&#13;&#10;        UserEntity user = userRepository.findById(userId)&#13;&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;User not found with id: &quot; + userId));&#13;&#10;&#13;&#10;        UserEntity friend = userRepository.findById(friendId)&#13;&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;Friend not found with id: &quot; + friendId));&#13;&#10;&#13;&#10;        // Kiểm tra có phải bạn bè không&#13;&#10;        if (!userRepository.areFriends(userId, friendId)) {&#13;&#10;            throw new IllegalStateException(&quot;Users are not friends&quot;);&#13;&#10;        }&#13;&#10;&#13;&#10;        // Xóa friendship&#13;&#10;        userRepository.deleteFriendship(userId, friendId);&#13;&#10;&#13;&#10;        // Publish friend removed event&#13;&#10;        userEventPublisher.publishUserRelationshipChangedEvent(&#13;&#10;                userId,&#13;&#10;                friendId,&#13;&#10;                &quot;FRIEND_REMOVED&quot;,&#13;&#10;                &quot;DELETED&quot;&#13;&#10;        );&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Get all friends of a user - LẤY DANH SÁCH BẠN BÈ&#13;&#10;     */&#13;&#10;    public FriendsDTO getFriends(String userId) {&#13;&#10;        UserEntity user = userRepository.findById(userId)&#13;&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;User not found with id: &quot; + userId));&#13;&#10;&#13;&#10;        List&lt;UserEntity&gt; friends = userRepository.findFriends(userId);&#13;&#10;        List&lt;UserDTO&gt; friendDTOs = friends.stream()&#13;&#10;                .map(this::mapToDTO)&#13;&#10;                .collect(Collectors.toList());&#13;&#10;&#13;&#10;        return new FriendsDTO(friendDTOs);&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Get mutual friends between two users - LẤY BẠN CHUNG&#13;&#10;     */&#13;&#10;    public FriendsDTO getMutualFriends(String userId, String otherUserId) {&#13;&#10;        UserEntity user = userRepository.findById(userId)&#13;&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;User not found with id: &quot; + userId));&#13;&#10;&#13;&#10;        UserEntity otherUser = userRepository.findById(otherUserId)&#13;&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;Other user not found with id: &quot; + otherUserId));&#13;&#10;&#13;&#10;        List&lt;UserEntity&gt; mutualFriends = userRepository.findMutualFriends(userId, otherUserId);&#13;&#10;        List&lt;UserDTO&gt; mutualFriendDTOs = mutualFriends.stream()&#13;&#10;                .map(this::mapToDTO)&#13;&#10;                .collect(Collectors.toList());&#13;&#10;&#13;&#10;        return FriendsDTO.ofMutualFriends(mutualFriendDTOs);&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Get friend suggestions - GỢI Ý KẾT BẠN&#13;&#10;     */&#13;&#10;    public FriendsDTO getFriendSuggestions(String userId) {&#13;&#10;        UserEntity user = userRepository.findById(userId)&#13;&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;User not found with id: &quot; + userId));&#13;&#10;&#13;&#10;        List&lt;UserEntity&gt; suggestions = userRepository.findFriendSuggestions(userId);&#13;&#10;        List&lt;UserDTO&gt; suggestionDTOs = suggestions.stream()&#13;&#10;                .map(u -&gt; {&#13;&#10;                    UserDTO dto = mapToDTO(u);&#13;&#10;                    // Calculate mutual friends count&#13;&#10;                    List&lt;UserEntity&gt; mutualFriends = userRepository.findMutualFriends(userId, u.getId());&#13;&#10;                    dto.setMutualFriendsCount(mutualFriends.size());&#13;&#10;&#13;&#10;                    // Calculate similarity&#13;&#10;                    calculateSimilarityScore(user, u, dto);&#13;&#10;                    return dto;&#13;&#10;                })&#13;&#10;                .collect(Collectors.toList());&#13;&#10;&#13;&#10;        return FriendsDTO.ofSuggestions(suggestionDTOs);&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Filter users by relationship criteria - LỌC NGƯỜI DÙNG THEO TIÊU CHÍ&#13;&#10;     */&#13;&#10;    public List&lt;UserDTO&gt; getUsersByRelationshipFilters(String userId, RelationshipFilterDTO filters) {&#13;&#10;        UserEntity user = userRepository.findById(userId)&#13;&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;User not found with id: &quot; + userId));&#13;&#10;&#13;&#10;        List&lt;UserEntity&gt; filteredUsers = userRepository.findUsersWithFilters(&#13;&#10;                userId,&#13;&#10;                filters.isSameCollege(),&#13;&#10;                filters.isSameFaculty(),&#13;&#10;                filters.isSameMajor(),&#13;&#10;                filters.isSameBatch()&#13;&#10;        );&#13;&#10;&#13;&#10;        return filteredUsers.stream()&#13;&#10;                .map(this::mapToDTO)&#13;&#10;                .collect(Collectors.toList());&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Get all users (Admin only)&#13;&#10;     */&#13;&#10;    public List&lt;UserDTO&gt; getAllUsers() {&#13;&#10;        return userRepository.findAll().stream()&#13;&#10;                .map(this::mapToDTO)&#13;&#10;                .collect(Collectors.toList());&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Delete user (Admin only)&#13;&#10;     */&#13;&#10;    @Transactional&#13;&#10;    public void deleteUser(String userId) {&#13;&#10;        UserEntity user = userRepository.findById(userId)&#13;&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;User not found with id: &quot; + userId));&#13;&#10;&#13;&#10;        // Xóa tất cả friend relationships và friend requests&#13;&#10;        List&lt;UserEntity&gt; friends = userRepository.findFriends(userId);&#13;&#10;        for (UserEntity friend : friends) {&#13;&#10;            userRepository.deleteFriendship(userId, friend.getId());&#13;&#10;        }&#13;&#10;&#13;&#10;        // Xóa tất cả friend requests (incoming và outgoing)&#13;&#10;        List&lt;UserEntity&gt; incomingRequests = userRepository.findIncomingFriendRequests(userId);&#13;&#10;        for (UserEntity requester : incomingRequests) {&#13;&#10;            userRepository.rejectFriendRequest(requester.getId(), userId);&#13;&#10;        }&#13;&#10;&#13;&#10;        List&lt;UserEntity&gt; outgoingRequests = userRepository.findOutgoingFriendRequests(userId);&#13;&#10;        for (UserEntity receiver : outgoingRequests) {&#13;&#10;            userRepository.rejectFriendRequest(userId, receiver.getId());&#13;&#10;        }&#13;&#10;&#13;&#10;        // Delete the user&#13;&#10;        userRepository.deleteById(userId);&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Calculate similarity score for friend suggestions&#13;&#10;     */&#13;&#10;    private void calculateSimilarityScore(UserEntity user, UserEntity candidate, UserDTO candidateDTO) {&#13;&#10;        // Check similarity attributes using proper getter methods&#13;&#10;        candidateDTO.setSameCollege(Objects.equals(user.getCollegeName(), candidate.getCollegeName()));&#13;&#10;        candidateDTO.setSameFaculty(Objects.equals(user.getFacultyName(), candidate.getFacultyName()));&#13;&#10;        candidateDTO.setSameMajor(Objects.equals(user.getMajorName(), candidate.getMajorName()));&#13;&#10;        candidateDTO.setSameBatch(Objects.equals(user.getBatchYear(), candidate.getBatchYear()));&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Check if user matches relationship filters&#13;&#10;     */&#13;&#10;    private boolean matchesFilters(UserEntity user, UserEntity candidate, RelationshipFilterDTO filters) {&#13;&#10;        if (filters.getCollege() != null &amp;&amp; !filters.getCollege().equals(candidate.getCollegeName())) {&#13;&#10;            return false;&#13;&#10;        }&#13;&#10;        if (filters.getFaculty() != null &amp;&amp; !filters.getFaculty().equals(candidate.getFacultyName())) {&#13;&#10;            return false;&#13;&#10;        }&#13;&#10;        if (filters.getMajor() != null &amp;&amp; !filters.getMajor().equals(candidate.getMajorName())) {&#13;&#10;            return false;&#13;&#10;        }&#13;&#10;        if (filters.getBatch() != null &amp;&amp; !filters.getBatch().equals(candidate.getBatchYear())) {&#13;&#10;            return false;&#13;&#10;        }&#13;&#10;        return filters.getGender() == null || filters.getGender().equals(candidate.getGenderName());&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Map UserEntity to UserDTO&#13;&#10;     */&#13;&#10;    private UserDTO mapToDTO(UserEntity entity) {&#13;&#10;        UserDTO dto = new UserDTO();&#13;&#10;        dto.setId(entity.getId());&#13;&#10;        dto.setEmail(entity.getEmail());&#13;&#10;        dto.setUsername(entity.getUsername());&#13;&#10;        dto.setFullName(entity.getFullName());&#13;&#10;        dto.setRole(entity.getRole() != null ? entity.getRole().toString() : null);&#13;&#10;        dto.setBio(entity.getBio());&#13;&#10;        dto.setIsActive(entity.getIsActive());&#13;&#10;        dto.setIsProfileCompleted(entity.getIsProfileCompleted());&#13;&#10;        dto.setCreatedAt(entity.getCreatedAt());&#13;&#10;        dto.setUpdatedAt(entity.getUpdatedAt());&#13;&#10;&#13;&#10;        // Student fields&#13;&#10;        dto.setStudentId(entity.getStudentId());&#13;&#10;        dto.setMajor(entity.getMajor());&#13;&#10;        dto.setBatch(entity.getBatch());&#13;&#10;        // Lecturer fields&#13;&#10;        dto.setStaffCode(entity.getStaffCode());&#13;&#10;        dto.setAcademic(entity.getAcademic());&#13;&#10;        dto.setDegree(entity.getDegree());&#13;&#10;        dto.setPosition(entity.getPosition());&#13;&#10;&#13;&#10;        // Common fields&#13;&#10;        dto.setFaculty(entity.getFaculty());&#13;&#10;        dto.setCollege(entity.getCollege());&#13;&#10;        dto.setGender(entity.getGender());&#13;&#10;&#13;&#10;        // Media fields&#13;&#10;        dto.setAvatarUrl(entity.getAvatarUrl());&#13;&#10;        dto.setBackgroundUrl(entity.getBackgroundUrl());&#13;&#10;&#13;&#10;        // Friends mapping&#13;&#10;        if (entity.getFriends() != null) {&#13;&#10;            dto.setFriendIds(&#13;&#10;                    entity.getFriends().stream()&#13;&#10;                            .map(UserEntity::getId)&#13;&#10;                            .collect(Collectors.toSet())&#13;&#10;            );&#13;&#10;        }&#13;&#10;&#13;&#10;        return dto;&#13;&#10;    }&#13;&#10;&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Map UserDTO to UserEntity&#13;&#10;     */&#13;&#10;    private UserEntity mapToEntity(UserDTO dto) {&#13;&#10;        UserEntity entity = new UserEntity();&#13;&#10;        entity.setId(dto.getId());&#13;&#10;        entity.setEmail(dto.getEmail());&#13;&#10;        entity.setUsername(dto.getUsername());&#13;&#10;        entity.setFullName(dto.getFullName());&#13;&#10;&#13;&#10;        // Handle role conversion safely&#13;&#10;        if (dto.getRole() != null) {&#13;&#10;            try {&#13;&#10;                entity.setRole(Role.valueOf(dto.getRole()));&#13;&#10;            } catch (IllegalArgumentException e) {&#13;&#10;                entity.setRole(Role.USER); // Default fallback&#13;&#10;            }&#13;&#10;        }&#13;&#10;&#13;&#10;        entity.setBio(dto.getBio());&#13;&#10;        entity.setIsActive(dto.getIsActive());&#13;&#10;&#13;&#10;        // Student fields&#13;&#10;        entity.setStudentId(dto.getStudentId());&#13;&#10;&#13;&#10;        // Faculty fields&#13;&#10;        entity.setStaffCode(dto.getStaffCode());&#13;&#10;&#13;&#10;        // Media fields&#13;&#10;        entity.setAvatarUrl(dto.getAvatarUrl());&#13;&#10;        entity.setBackgroundUrl(dto.getBackgroundUrl());&#13;&#10;&#13;&#10;        // Note: Relationship mappings (major, batch, gender, etc.) should be handled&#13;&#10;        // separately as they require database lookups to establish Neo4j relationships&#13;&#10;        // This method only handles direct field mappings&#13;&#10;&#13;&#10;        return entity;&#13;&#10;    }&#13;&#10;&#13;&#10;    public Boolean checkProfile(String currentUserId) {&#13;&#10;        UserEntity userEntity = userRepository.findById(currentUserId)&#13;&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;User not found with id: &quot; + currentUserId));&#13;&#10;&#13;&#10;        // Map to DTO&#13;&#10;        UserDTO userDTO = mapToDTO(userEntity);&#13;&#10;&#13;&#10;        return userDTO.getIsProfileCompleted();&#13;&#10;    }&#13;&#10;&#13;&#10;    // ========================= PROFILE UPDATE METHODS =========================&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Update student profile with event publishing for post-service synchronization&#13;&#10;     */&#13;&#10;    @Transactional&#13;&#10;    public UserDTO updateStudentProfile(String userId, Object profileRequest) {&#13;&#10;        UserEntity userEntity = userRepository.findById(userId)&#13;&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;User not found with id: &quot; + userId));&#13;&#10;&#13;&#10;        // Convert Object to map for flexible handling&#13;&#10;        @SuppressWarnings(&quot;unchecked&quot;)&#13;&#10;        Map&lt;String, Object&gt; profileData = (Map&lt;String, Object&gt;) profileRequest;&#13;&#10;&#13;&#10;        // Update basic profile fields&#13;&#10;        if (profileData.containsKey(&quot;fullName&quot;)) {&#13;&#10;            userEntity.setFullName((String) profileData.get(&quot;fullName&quot;));&#13;&#10;        }&#13;&#10;        if (profileData.containsKey(&quot;bio&quot;)) {&#13;&#10;            userEntity.setBio((String) profileData.get(&quot;bio&quot;));&#13;&#10;        }&#13;&#10;        if (profileData.containsKey(&quot;studentId&quot;)) {&#13;&#10;            userEntity.setStudentId((String) profileData.get(&quot;studentId&quot;));&#13;&#10;        }&#13;&#10;        if (profileData.containsKey(&quot;avatarUrl&quot;)) {&#13;&#10;            userEntity.setAvatarUrl((String) profileData.get(&quot;avatarUrl&quot;));&#13;&#10;        }&#13;&#10;        if (profileData.containsKey(&quot;backgroundUrl&quot;)) {&#13;&#10;            userEntity.setBackgroundUrl((String) profileData.get(&quot;backgroundUrl&quot;));&#13;&#10;        }&#13;&#10;&#13;&#10;        // Update relationships if provided&#13;&#10;        if (profileData.containsKey(&quot;majorCode&quot;)) {&#13;&#10;            String majorCode = (String) profileData.get(&quot;majorCode&quot;);&#13;&#10;            if (majorCode != null) {&#13;&#10;                updateUserMajor(userId, majorCode);&#13;&#10;            }&#13;&#10;        }&#13;&#10;        if (profileData.containsKey(&quot;facultyCode&quot;)) {&#13;&#10;            String facultyCode = (String) profileData.get(&quot;facultyCode&quot;);&#13;&#10;            if (facultyCode != null) {&#13;&#10;                updateUserFaculty(userId, facultyCode);&#13;&#10;            }&#13;&#10;        }&#13;&#10;        if (profileData.containsKey(&quot;collegeCode&quot;)) {&#13;&#10;            String collegeCode = (String) profileData.get(&quot;collegeCode&quot;);&#13;&#10;            if (collegeCode != null) {&#13;&#10;                updateUserCollege(userId, collegeCode);&#13;&#10;            }&#13;&#10;        }&#13;&#10;        if (profileData.containsKey(&quot;batchYear&quot;)) {&#13;&#10;            String batchYear = (String) profileData.get(&quot;batchYear&quot;);&#13;&#10;            if (batchYear != null) {&#13;&#10;                updateUserBatch(userId, batchYear);&#13;&#10;            }&#13;&#10;        }&#13;&#10;        if (profileData.containsKey(&quot;genderCode&quot;)) {&#13;&#10;            String genderCode = (String) profileData.get(&quot;genderCode&quot;);&#13;&#10;            if (genderCode != null) {&#13;&#10;                updateUserGender(userId, genderCode);&#13;&#10;            }&#13;&#10;        }&#13;&#10;&#13;&#10;        userEntity.setUpdatedAt(LocalDateTime.now());&#13;&#10;        UserEntity updatedUser = userRepository.save(userEntity);&#13;&#10;&#13;&#10;        // CRITICAL FIX: Publish profile update event for post-service synchronization&#13;&#10;        publishProfileUpdateEvent(updatedUser);&#13;&#10;&#13;&#10;        return mapToDTO(updatedUser);&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Update lecturer profile with event publishing for post-service synchronization&#13;&#10;     */&#13;&#10;    @Transactional&#13;&#10;    public UserDTO updateLecturerProfile(String userId, Object profileRequest) {&#13;&#10;        UserEntity userEntity = userRepository.findById(userId)&#13;&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;User not found with id: &quot; + userId));&#13;&#10;&#13;&#10;        // Convert Object to map for flexible handling&#13;&#10;        @SuppressWarnings(&quot;unchecked&quot;)&#13;&#10;        Map&lt;String, Object&gt; profileData = (Map&lt;String, Object&gt;) profileRequest;&#13;&#10;&#13;&#10;        // Update basic profile fields&#13;&#10;        if (profileData.containsKey(&quot;fullName&quot;)) {&#13;&#10;            userEntity.setFullName((String) profileData.get(&quot;fullName&quot;));&#13;&#10;        }&#13;&#10;        if (profileData.containsKey(&quot;bio&quot;)) {&#13;&#10;            userEntity.setBio((String) profileData.get(&quot;bio&quot;));&#13;&#10;        }&#13;&#10;        if (profileData.containsKey(&quot;staffCode&quot;)) {&#13;&#10;            userEntity.setStaffCode((String) profileData.get(&quot;staffCode&quot;));&#13;&#10;        }&#13;&#10;        if (profileData.containsKey(&quot;avatarUrl&quot;)) {&#13;&#10;            userEntity.setAvatarUrl((String) profileData.get(&quot;avatarUrl&quot;));&#13;&#10;        }&#13;&#10;        if (profileData.containsKey(&quot;backgroundUrl&quot;)) {&#13;&#10;            userEntity.setBackgroundUrl((String) profileData.get(&quot;backgroundUrl&quot;));&#13;&#10;        }&#13;&#10;&#13;&#10;        // Update relationships if provided&#13;&#10;        if (profileData.containsKey(&quot;facultyCode&quot;)) {&#13;&#10;            String facultyCode = (String) profileData.get(&quot;facultyCode&quot;);&#13;&#10;            if (facultyCode != null) {&#13;&#10;                updateUserWorkingFaculty(userId, facultyCode);&#13;&#10;            }&#13;&#10;        }&#13;&#10;        if (profileData.containsKey(&quot;positionCode&quot;)) {&#13;&#10;            String positionCode = (String) profileData.get(&quot;positionCode&quot;);&#13;&#10;            if (positionCode != null) {&#13;&#10;                updateUserPosition(userId, positionCode);&#13;&#10;            }&#13;&#10;        }&#13;&#10;        if (profileData.containsKey(&quot;academicCode&quot;)) {&#13;&#10;            String academicCode = (String) profileData.get(&quot;academicCode&quot;);&#13;&#10;            if (academicCode != null) {&#13;&#10;                updateUserAcademic(userId, academicCode);&#13;&#10;            }&#13;&#10;        }&#13;&#10;        if (profileData.containsKey(&quot;degreeCode&quot;)) {&#13;&#10;            String degreeCode = (String) profileData.get(&quot;degreeCode&quot;);&#13;&#10;            if (degreeCode != null) {&#13;&#10;                updateUserDegree(userId, degreeCode);&#13;&#10;            }&#13;&#10;        }&#13;&#10;        if (profileData.containsKey(&quot;genderCode&quot;)) {&#13;&#10;            String genderCode = (String) profileData.get(&quot;genderCode&quot;);&#13;&#10;            if (genderCode != null) {&#13;&#10;                updateUserGender(userId, genderCode);&#13;&#10;            }&#13;&#10;        }&#13;&#10;&#13;&#10;        userEntity.setUpdatedAt(LocalDateTime.now());&#13;&#10;        UserEntity updatedUser = userRepository.save(userEntity);&#13;&#10;&#13;&#10;        // CRITICAL FIX: Publish profile update event for post-service synchronization&#13;&#10;        publishProfileUpdateEvent(updatedUser);&#13;&#10;&#13;&#10;        return mapToDTO(updatedUser);&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Update general user profile with event publishing&#13;&#10;     */&#13;&#10;    @Transactional&#13;&#10;    public UserDTO updateUserProfile(String userId, UserDTO userDTO) {&#13;&#10;        UserEntity userEntity = userRepository.findById(userId)&#13;&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;User not found with id: &quot; + userId));&#13;&#10;&#13;&#10;        // Update basic profile fields&#13;&#10;        if (userDTO.getFullName() != null) userEntity.setFullName(userDTO.getFullName());&#13;&#10;        if (userDTO.getEmail() != null) userEntity.setEmail(userDTO.getEmail());&#13;&#10;        if (userDTO.getUsername() != null) userEntity.setUsername(userDTO.getUsername());&#13;&#10;        if (userDTO.getBio() != null) userEntity.setBio(userDTO.getBio());&#13;&#10;        if (userDTO.getAvatarUrl() != null) userEntity.setAvatarUrl(userDTO.getAvatarUrl());&#13;&#10;        if (userDTO.getBackgroundUrl() != null) userEntity.setBackgroundUrl(userDTO.getBackgroundUrl());&#13;&#10;&#13;&#10;        userEntity.setUpdatedAt(LocalDateTime.now());&#13;&#10;        UserEntity updatedUser = userRepository.save(userEntity);&#13;&#10;&#13;&#10;        // CRITICAL FIX: Publish profile update event for post-service synchronization&#13;&#10;        publishProfileUpdateEvent(updatedUser);&#13;&#10;&#13;&#10;        return mapToDTO(updatedUser);&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Publish profile update event to notify post-service&#13;&#10;     * This is the CRITICAL method that fixes AuthorInfo synchronization&#13;&#10;     */&#13;&#10;    private void publishProfileUpdateEvent(UserEntity user) {&#13;&#10;        try {&#13;&#10;            userEventPublisher.publishUserProfileUpdatedEventForPostService(&#13;&#10;                user.getId(),&#13;&#10;                user.getFullName() != null ? user.getFullName() : &quot;&quot;,&#13;&#10;                user.getEmail() != null ? user.getEmail() : &quot;&quot;,&#13;&#10;                user.getUsername() != null ? user.getUsername() : &quot;&quot;,&#13;&#10;                user.getAvatarUrl() != null ? user.getAvatarUrl() : &quot;&quot;,&#13;&#10;                user.getRole() != null ? user.getRole().name() : &quot;USER&quot;&#13;&#10;            );&#13;&#10;            log.info(&quot;Published profile update event for user: {} ({})&quot;, user.getId(), user.getFullName());&#13;&#10;        } catch (Exception e) {&#13;&#10;            log.error(&quot;Failed to publish profile update event for user {}: {}&quot;, user.getId(), e.getMessage(), e);&#13;&#10;            // Don't throw exception to avoid breaking the profile update&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Get friend IDs for a user (for internal service communication)&#13;&#10;     */&#13;&#10;    public Set&lt;String&gt; getFriendIds(String userId) {&#13;&#10;        Optional&lt;UserEntity&gt; userOpt = userRepository.findById(userId);&#13;&#10;        if (userOpt.isPresent()) {&#13;&#10;            return userOpt.get().getFriendIds();&#13;&#10;        }&#13;&#10;        return new HashSet&lt;&gt;();&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Get users with close interactions (for feed ranking)&#13;&#10;     */&#13;&#10;    public Set&lt;String&gt; getCloseInteractionIds(String userId) {&#13;&#10;        // This would typically analyze interaction patterns&#13;&#10;        // For now, returning a subset of friends with high interaction&#13;&#10;        Set&lt;String&gt; friendIds = getFriendIds(userId);&#13;&#10;        return friendIds.stream()&#13;&#10;                .limit(10) // Top 10 close interactions&#13;&#10;                .collect(Collectors.toSet());&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Get users from same faculty (for post-service news feed algorithm)&#13;&#10;     */&#13;&#10;    public Set&lt;String&gt; getSameFacultyUserIds(String userId) {&#13;&#10;        Optional&lt;UserEntity&gt; userOpt = userRepository.findById(userId);&#13;&#10;        if (userOpt.isEmpty()) {&#13;&#10;            return new HashSet&lt;&gt;();&#13;&#10;        }&#13;&#10;&#13;&#10;        UserEntity user = userOpt.get();&#13;&#10;        if (user.getFaculty() == null) {&#13;&#10;            return new HashSet&lt;&gt;();&#13;&#10;        }&#13;&#10;&#13;&#10;        // Find all users in the same faculty&#13;&#10;        List&lt;UserEntity&gt; sameFacultyUsers = userRepository.findUsersByFaculty(user.getFaculty().getId());&#13;&#10;        return sameFacultyUsers.stream()&#13;&#10;                .map(UserEntity::getId)&#13;&#10;                .filter(id -&gt; !id.equals(userId)) // Exclude self&#13;&#10;                .collect(Collectors.toSet());&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Get users from same major (for post-service news feed algorithm)&#13;&#10;     */&#13;&#10;    public Set&lt;String&gt; getSameMajorUserIds(String userId) {&#13;&#10;        Optional&lt;UserEntity&gt; userOpt = userRepository.findById(userId);&#13;&#10;        if (userOpt.isEmpty()) {&#13;&#10;            return new HashSet&lt;&gt;();&#13;&#10;        }&#13;&#10;&#13;&#10;        UserEntity user = userOpt.get();&#13;&#10;        if (user.getMajor() == null) {&#13;&#10;            return new HashSet&lt;&gt;();&#13;&#10;        }&#13;&#10;&#13;&#10;        // Find all users in the same major&#13;&#10;        List&lt;UserEntity&gt; sameMajorUsers = userRepository.findUsersByMajor(user.getMajor().getId());&#13;&#10;        return sameMajorUsers.stream()&#13;&#10;                .map(UserEntity::getId)&#13;&#10;                .filter(id -&gt; !id.equals(userId)) // Exclude self&#13;&#10;                .collect(Collectors.toSet());&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Get user interest tags (for post-service content recommendation)&#13;&#10;     */&#13;&#10;    public Set&lt;String&gt; getUserInterestTags(String userId) {&#13;&#10;        Optional&lt;UserEntity&gt; userOpt = userRepository.findById(userId);&#13;&#10;        if (userOpt.isEmpty()) {&#13;&#10;            return new HashSet&lt;&gt;();&#13;&#10;        }&#13;&#10;&#13;&#10;        UserEntity user = userOpt.get();&#13;&#10;        Set&lt;String&gt; interestTags = new HashSet&lt;&gt;();&#13;&#10;&#13;&#10;        // Add tags based on user's major and faculty&#13;&#10;        if (user.getMajor() != null) {&#13;&#10;            interestTags.add(user.getMajor().getName().toLowerCase());&#13;&#10;            interestTags.add(user.getMajor().getId().toLowerCase());&#13;&#10;        }&#13;&#10;&#13;&#10;        if (user.getFaculty() != null) {&#13;&#10;            interestTags.add(user.getFaculty().getName().toLowerCase());&#13;&#10;        }&#13;&#10;&#13;&#10;        // Add role-based tags&#13;&#10;        if (user.getRole() != null) {&#13;&#10;            interestTags.add(user.getRole().toString().toLowerCase());&#13;&#10;        }&#13;&#10;&#13;&#10;        return interestTags;&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Get user preferred categories (for post-service content filtering)&#13;&#10;     */&#13;&#10;    public Set&lt;String&gt; getUserPreferredCategories(String userId) {&#13;&#10;        Optional&lt;UserEntity&gt; userOpt = userRepository.findById(userId);&#13;&#10;        if (userOpt.isEmpty()) {&#13;&#10;            return new HashSet&lt;&gt;();&#13;&#10;        }&#13;&#10;&#13;&#10;        UserEntity user = userOpt.get();&#13;&#10;        Set&lt;String&gt; preferredCategories = new HashSet&lt;&gt;();&#13;&#10;&#13;&#10;        // Add categories based on user profile&#13;&#10;        if (user.isStudent()) {&#13;&#10;            preferredCategories.add(&quot;academic&quot;);&#13;&#10;            preferredCategories.add(&quot;student_life&quot;);&#13;&#10;            if (user.getMajor() != null) {&#13;&#10;                preferredCategories.add(user.getMajor().getName().toLowerCase().replace(&quot; &quot;, &quot;_&quot;));&#13;&#10;            }&#13;&#10;        } else if (user.isFaculty()) {&#13;&#10;            preferredCategories.add(&quot;academic&quot;);&#13;&#10;            preferredCategories.add(&quot;research&quot;);&#13;&#10;            preferredCategories.add(&quot;teaching&quot;);&#13;&#10;        }&#13;&#10;&#13;&#10;        // Add general categories&#13;&#10;        preferredCategories.add(&quot;general&quot;);&#13;&#10;        preferredCategories.add(&quot;announcements&quot;);&#13;&#10;&#13;&#10;        return preferredCategories;&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Get user's faculty ID (for post-service group filtering)&#13;&#10;     */&#13;&#10;    public String getUserFacultyId(String userId) {&#13;&#10;        Optional&lt;UserEntity&gt; userOpt = userRepository.findById(userId);&#13;&#10;        if (userOpt.isPresent() &amp;&amp; userOpt.get().getFaculty() != null) {&#13;&#10;            return userOpt.get().getFaculty().getId();&#13;&#10;        }&#13;&#10;        return null;&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Get user's major ID (for post-service group filtering)&#13;&#10;     */&#13;&#10;    public String getUserMajorId(String userId) {&#13;&#10;        Optional&lt;UserEntity&gt; userOpt = userRepository.findById(userId);&#13;&#10;        if (userOpt.isPresent() &amp;&amp; userOpt.get().getMajor() != null) {&#13;&#10;            return userOpt.get().getMajor().getId();&#13;&#10;        }&#13;&#10;        return null;&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Enhanced user search with academic context&#13;&#10;     */&#13;&#10;    public List&lt;UserDTO&gt; searchUsersWithContext(String query, String faculty, String major,&#13;&#10;                                               String batch, String currentUserId, int page, int size) {&#13;&#10;        // This would implement complex search with Neo4j queries&#13;&#10;        // For now, implementing basic search&#13;&#10;        List&lt;UserEntity&gt; users = userRepository.findByFullNameContainingIgnoreCase(query);&#13;&#10;&#13;&#10;        // Apply filters&#13;&#10;        if (faculty != null &amp;&amp; !faculty.isEmpty()) {&#13;&#10;            users = users.stream()&#13;&#10;                    .filter(user -&gt; faculty.equals(user.getFacultyId()))&#13;&#10;                    .collect(Collectors.toList());&#13;&#10;        }&#13;&#10;&#13;&#10;        if (major != null &amp;&amp; !major.isEmpty()) {&#13;&#10;            users = users.stream()&#13;&#10;                    .filter(user -&gt; major.equals(user.getMajorId()))&#13;&#10;                    .collect(Collectors.toList());&#13;&#10;        }&#13;&#10;&#13;&#10;        if (batch != null &amp;&amp; !batch.isEmpty()) {&#13;&#10;            users = users.stream()&#13;&#10;                    .filter(user -&gt; batch.equals(user.getBatchId()))&#13;&#10;                    .collect(Collectors.toList());&#13;&#10;        }&#13;&#10;&#13;&#10;        // Apply pagination and convert to DTOs&#13;&#10;        return users.stream()&#13;&#10;                .skip(page * size)&#13;&#10;                .limit(size)&#13;&#10;                .map(this::mapToDTO)&#13;&#10;                .collect(Collectors.toList());&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Send friend request&#13;&#10;     */&#13;&#10;    /*@Transactional&#13;&#10;    public void sendFriendRequest(String fromUserId, String toUserId) {&#13;&#10;        // This would typically create a friend request relationship in Neo4j&#13;&#10;        // For now, just publishing an event&#13;&#10;        userEventPublisher.publishUserRelationshipChangedEvent(&#13;&#10;                fromUserId, toUserId, &quot;FRIEND_REQUEST_SENT&quot;);&#13;&#10;&#13;&#10;        log.info(&quot;Friend request sent from {} to {}&quot;, fromUserId, toUserId);&#13;&#10;    }&#13;&#10;*/&#13;&#10;    /**&#13;&#10;     * Accept friend request&#13;&#10;     */&#13;&#10;    /*@Transactional&#13;&#10;    public void acceptFriendRequest(String fromUserId, String toUserId) {&#13;&#10;        // This would typically update the relationship in Neo4j&#13;&#10;        // For now, just publishing an event&#13;&#10;        userEventPublisher.publishUserRelationshipChangedEvent(&#13;&#10;                toUserId, fromUserId, &quot;FRIEND_REQUEST_ACCEPTED&quot;);&#13;&#10;&#13;&#10;        log.info(&quot;Friend request accepted: {} and {} are now friends&quot;, fromUserId, toUserId);&#13;&#10;    }&#13;&#10;*/&#13;&#10;    /**&#13;&#10;     * Get user activity feed (for profile timeline)&#13;&#10;     */&#13;&#10;    public List&lt;ActivityDTO&gt; getUserActivity(String userId, String viewerId, int page, int size) {&#13;&#10;        // This would typically query activity logs or events&#13;&#10;        // For now, returning mock activity data&#13;&#10;        List&lt;ActivityDTO&gt; activities = new ArrayList&lt;&gt;();&#13;&#10;&#13;&#10;        activities.add(ActivityDTO.builder()&#13;&#10;                .id(&quot;activity_1&quot;)&#13;&#10;                .userId(userId)&#13;&#10;                .activityType(&quot;POST_CREATED&quot;)&#13;&#10;                .entityType(&quot;POST&quot;)&#13;&#10;                .entityId(&quot;post_123&quot;)&#13;&#10;                .description(&quot;Created a new post&quot;)&#13;&#10;                .timestamp(LocalDateTime.now().minusDays(1))&#13;&#10;                .build());&#13;&#10;&#13;&#10;        activities.add(ActivityDTO.builder()&#13;&#10;                .id(&quot;activity_2&quot;)&#13;&#10;                .userId(userId)&#13;&#10;                .activityType(&quot;FRIEND_ADDED&quot;)&#13;&#10;                .entityType(&quot;USER&quot;)&#13;&#10;                .entityId(&quot;user_456&quot;)&#13;&#10;                .description(&quot;Added a new friend&quot;)&#13;&#10;                .timestamp(LocalDateTime.now().minusDays(2))&#13;&#10;                .build());&#13;&#10;&#13;&#10;        return activities.stream()&#13;&#10;                .skip(page * size)&#13;&#10;                .limit(size)&#13;&#10;                .collect(Collectors.toList());&#13;&#10;    }&#13;&#10;&#13;&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>