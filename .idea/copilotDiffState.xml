<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/ARCHITECTURE_OPTIMIZATION.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ARCHITECTURE_OPTIMIZATION.md" />
              <option name="originalContent" value="# CTU-Connect Architecture Optimization Plan&#10;## Based on Facebook's Social Network Model&#10;&#10;### Current Architecture Analysis&#10;- ✅ Microservices architecture with proper service separation&#10;- ✅ Event-driven communication via Kafka&#10;- ✅ Multiple database technologies (PostgreSQL, MongoDB, Neo4j, Redis)&#10;- ✅ API Gateway for centralized routing&#10;- ✅ Service discovery with Eureka&#10;&#10;### Key Optimizations Required&#10;- Implement eventual consistency patterns&#10;#### 1. Data Consistency &amp; Flow Optimization&#10;- Implement eventual consistency patterns&#10;- Add distributed transaction management&#10;- Optimize cross-service data synchronization&#10;&#10;#### 3. Social Graph Optimization&#10;- Friend suggestion algorithms&#10;#### 2. Enhanced Post System (Facebook-like)&#10;- Timeline generation algorithms&#10;- News feed ranking and personalization&#10;- Real-time updates and notifications&#10;- Database optimization and indexing&#10;- Load balancing and horizontal scaling&#10;&#10;#### 5. Real-time Features&#10;#### 3. Social Graph Optimization&#10;- Friend suggestion algorithms&#10;- Privacy controls and audience targeting&#10;- Activity feed generation&#10;- Real-time chat and comments&#10;- Activity status tracking&#10;#### 4. Performance &amp; Scalability&#10;- Caching strategies at multiple levels&#10;#### 5. Real-time Features&#10;- Live notifications&#10;- Real-time chat and comments&#10;- Activity status tracking&#10;" />
              <option name="updatedContent" value="# CTU-Connect Architecture Optimization Plan&#10;## Based on Facebook's Social Network Model&#10;&#10;### Current Architecture Analysis&#10;- ✅ Microservices architecture with proper service separation&#10;- ✅ Event-driven communication via Kafka&#10;- ✅ Multiple database technologies (PostgreSQL, MongoDB, Neo4j, Redis)&#10;- ✅ API Gateway for centralized routing&#10;- ✅ Service discovery with Eureka&#10;&#10;## COMPLETED OPTIMIZATIONS&#10;&#10;### 1. Enhanced Data Models (Facebook-like)&#10;&#10;#### Enhanced PostEntity&#10;- **Audience Targeting**: Similar to Facebook's privacy controls with granular audience settings&#10;- **Engagement Metrics**: Real-time engagement scoring for feed ranking algorithms&#10;- **Post Types**: Support for TEXT, IMAGE, VIDEO, LINK, POLL, EVENT, SHARED&#10;- **Location Support**: Geographic tagging capabilities&#10;- **Scheduled Posts**: Ability to schedule posts for future publishing&#10;- **Edit History**: Track post modifications with timestamps&#10;&#10;#### Advanced Social Graph (Neo4j)&#10;- **Friend Suggestions**: Multi-signal algorithm using mutual friends, academic connections, profile viewers&#10;- **Relationship Types**: FRIENDS_WITH, FRIEND_REQUEST_SENT, VIEWED_PROFILE, BLOCKED&#10;- **Academic Context**: Faculty, major, and batch-based connections&#10;- **Interaction History**: Track user interactions for personalization&#10;&#10;### 2. Facebook-like News Feed Algorithm&#10;&#10;#### NewsFeedService Implementation&#10;- **Personalized Ranking**: Multi-factor scoring system&#10;  - Friend relationship weight (1.0)&#10;  - Engagement score weight (0.8)&#10;  - Recency weight (0.6)&#10;  - Content relevance weight (0.7)&#10;- **Cache Strategy**: 30-minute feed cache with intelligent invalidation&#10;- **Over-fetching**: Retrieve 3x posts for optimal ranking&#10;- **Diversity Control**: Prevent feed domination by single authors&#10;&#10;#### Feed Types&#10;- **Personalized Feed**: User-specific content based on social graph&#10;- **Trending Posts**: Engagement-based trending algorithm&#10;- **User Timeline**: Profile-specific post timeline with privacy filtering&#10;&#10;### 3. Real-time Notification System&#10;&#10;#### NotificationService Features&#10;- **Real-time WebSocket**: Instant notifications via SimpMessagingTemplate&#10;- **Event-driven**: Kafka integration for scalable notification processing&#10;- **Notification Types**: POST_LIKED, COMMENTED, SHARED, FRIEND_REQUEST, etc.&#10;- **Bulk Notifications**: Efficient handling of viral content notifications&#10;- **Unread Counters**: Redis-cached unread notification counts&#10;&#10;### 4. Data Consistency Management&#10;&#10;#### DataConsistencyService&#10;- **Eventual Consistency**: Cross-service data synchronization&#10;- **Cache Invalidation**: Smart cache invalidation on data changes&#10;- **Compensation Logic**: Failure handling and retry mechanisms&#10;- **Event Sourcing**: Kafka-based event propagation&#10;&#10;### 5. Advanced Caching Strategy&#10;&#10;#### Multi-level Caching&#10;- **Redis Caching**: &#10;  - User data (24 hours TTL)&#10;  - Posts (6 hours TTL)&#10;  - Friend suggestions (6 hours TTL)&#10;  - News feed (30 minutes TTL)&#10;- **Application-level**: In-memory caching for frequently accessed data&#10;- **Database-level**: Optimized queries and indexing&#10;&#10;### 6. Social Graph Optimization&#10;&#10;#### SocialGraphService Features&#10;- **Friend Suggestions Algorithm**:&#10;  - Mutual friends (highest priority)&#10;  - Academic connections (faculty/major/batch)&#10;  - Friends of friends&#10;  - Profile viewers&#10;  - Similar interests&#10;- **Relevance Scoring**: Multi-factor relevance calculation&#10;- **Cache Management**: 6-hour TTL with smart invalidation&#10;&#10;### 7. Performance Enhancements&#10;&#10;#### Database Optimizations&#10;- **MongoDB**: Compound indexes for posts, engagement-based sorting&#10;- **Neo4j**: Optimized Cypher queries for relationship traversal&#10;- **PostgreSQL**: Proper indexing for auth and media services&#10;- **Redis**: Strategic caching and session management&#10;&#10;#### API Optimizations&#10;- **Pagination**: Consistent pagination across all endpoints&#10;- **Bulk Operations**: Efficient batch processing for notifications&#10;- **Async Processing**: CompletableFuture for non-blocking operations&#10;&#10;### 8. Enhanced Security &amp; Privacy&#10;&#10;#### Privacy Controls&#10;- **Audience Settings**: PUBLIC, FRIENDS, CUSTOM, ONLY_ME&#10;- **Academic Targeting**: Faculty/major/batch-specific visibility&#10;- **Block Lists**: User blocking functionality&#10;- **Profile Privacy**: Granular profile visibility controls&#10;&#10;### 9. Real-time Features&#10;&#10;#### WebSocket Integration&#10;- **Live Notifications**: Real-time notification delivery&#10;- **Activity Status**: User online/offline status tracking&#10;- **Real-time Comments**: Live comment updates on posts&#10;&#10;### 10. Monitoring &amp; Health Checks&#10;&#10;#### System Monitoring&#10;- **Health Indicators**: Redis, MongoDB, Neo4j health checks&#10;- **Performance Metrics**: Engagement rates, cache hit ratios&#10;- **Error Tracking**: Comprehensive logging and error handling&#10;&#10;## IMPLEMENTATION SUMMARY&#10;&#10;### New Services Created&#10;1. **NewsFeedService** - Facebook-like feed generation&#10;2. **NotificationService** - Real-time notification system&#10;3. **SocialGraphService** - Advanced friend suggestions&#10;4. **DataConsistencyService** - Cross-service data synchronization&#10;&#10;### Enhanced Controllers&#10;1. **EnhancedPostController** - Advanced post management&#10;2. **EnhancedUserController** - Social graph operations&#10;&#10;### Data Models Enhanced&#10;- **PostEntity** - Facebook-like post features&#10;- **NotificationEntity** - Rich notification system&#10;- **FriendSuggestionDTO** - Comprehensive suggestion data&#10;&#10;### Configuration Added&#10;- **CacheConfig** - Multi-level caching strategy&#10;- **HealthCheckConfig** - System health monitoring&#10;&#10;## FACEBOOK-INSPIRED FEATURES IMPLEMENTED&#10;&#10;### Content &amp; Engagement&#10;✅ **News Feed Algorithm** - Personalized content ranking&#10;✅ **Post Types** - Text, image, video, link, poll support&#10;✅ **Reactions System** - Like, love, laugh, etc.&#10;✅ **Comments &amp; Replies** - Threaded comment system&#10;✅ **Share Functionality** - Post sharing with attribution&#10;✅ **Trending Posts** - Viral content discovery&#10;&#10;### Social Features&#10;✅ **Friend Suggestions** - Multi-signal recommendation engine&#10;✅ **Mutual Friends** - Connection discovery&#10;✅ **Academic Networks** - University-specific connections&#10;✅ **People You May Know** - Profile viewer suggestions&#10;✅ **Friend Requests** - Connection management&#10;&#10;### Privacy &amp; Security&#10;✅ **Audience Controls** - Granular post visibility&#10;✅ **Academic Targeting** - Faculty/major-based sharing&#10;✅ **Block/Unblock** - User blocking system&#10;✅ **Profile Privacy** - Customizable profile visibility&#10;&#10;### Real-time Features&#10;✅ **Live Notifications** - Instant activity updates  &#10;✅ **Real-time Comments** - Live comment updates&#10;✅ **Activity Status** - Online presence tracking&#10;✅ **WebSocket Integration** - Real-time communication&#10;&#10;### Performance &amp; Scale&#10;✅ **Multi-level Caching** - Redis + application caching&#10;✅ **Event-driven Architecture** - Kafka message streaming&#10;✅ **Database Optimization** - Proper indexing and queries&#10;✅ **Load Balancing Ready** - Horizontal scaling support&#10;&#10;## DEPLOYMENT RECOMMENDATIONS&#10;&#10;### 1. Database Scaling&#10;- **MongoDB Sharding** for post data&#10;- **Neo4j Clustering** for social graph&#10;- **Redis Clustering** for caching layer&#10;&#10;### 2. Performance Monitoring&#10;- Implement APM tools (New Relic, DataDog)&#10;- Set up alerts for cache hit ratios&#10;- Monitor database query performance&#10;&#10;### 3. Content Delivery&#10;- Integrate CDN for media files&#10;- Implement image/video optimization&#10;- Add progressive loading for feeds&#10;&#10;### 4. Security Enhancements&#10;- Rate limiting on API endpoints&#10;- Content moderation system&#10;- Spam detection algorithms&#10;&#10;This comprehensive optimization transforms your CTU-Connect platform into a robust, scalable social network with Facebook-like capabilities while maintaining the academic focus of your original vision." />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/client-frontend/src/app/posts/page.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/client-frontend/src/app/posts/page.tsx" />
              <option name="updatedContent" value="'use client';&#10;&#10;import React, { useState, useEffect } from 'react';&#10;import { Post, PaginatedResponse } from '@/types';&#10;import { postService } from '@/services/postService';&#10;import { CreatePost } from '@/components/post/CreatePost';&#10;import { PostCard } from '@/components/post/PostCard';&#10;import { LoadingSpinner } from '@/components/ui/LoadingSpinner';&#10;import { ErrorAlert } from '@/components/ui/ErrorAlert';&#10;import { Button } from '@/components/ui/Button';&#10;import { Plus, RefreshCw } from 'lucide-react';&#10;&#10;export default function PostsPage() {&#10;  const [posts, setPosts] = useState&lt;Post[]&gt;([]);&#10;  const [isLoading, setIsLoading] = useState(true);&#10;  const [error, setError] = useState&lt;string | null&gt;(null);&#10;  const [showCreatePost, setShowCreatePost] = useState(false);&#10;&#10;  const loadPosts = async () =&gt; {&#10;    try {&#10;      setIsLoading(true);&#10;      setError(null);&#10;      const response: PaginatedResponse&lt;Post&gt; = await postService.getPosts();&#10;      setPosts(response.content);&#10;    } catch (err: any) {&#10;      console.error('Failed to load posts:', err);&#10;      setError(err.response?.data?.message || err.message || 'Failed to load posts');&#10;    } finally {&#10;      setIsLoading(false);&#10;    }&#10;  };&#10;&#10;  useEffect(() =&gt; {&#10;    loadPosts();&#10;  }, []);&#10;&#10;  const handlePostCreated = (newPost: Post) =&gt; {&#10;    setPosts(prev =&gt; [newPost, ...prev]);&#10;    setShowCreatePost(false);&#10;  };&#10;&#10;  const handlePostUpdate = (updatedPost: Post) =&gt; {&#10;    setPosts(prev =&gt; prev.map(post =&gt; &#10;      post.id === updatedPost.id ? updatedPost : post&#10;    ));&#10;  };&#10;&#10;  const handlePostDelete = (postId: string) =&gt; {&#10;    setPosts(prev =&gt; prev.filter(post =&gt; post.id !== postId));&#10;  };&#10;&#10;  if (isLoading) {&#10;    return (&#10;      &lt;div className=&quot;min-h-screen bg-gray-50 flex items-center justify-center&quot;&gt;&#10;        &lt;LoadingSpinner size=&quot;lg&quot; /&gt;&#10;      &lt;/div&gt;&#10;    );&#10;  }&#10;&#10;  return (&#10;    &lt;div className=&quot;min-h-screen bg-gray-50&quot;&gt;&#10;      &lt;div className=&quot;max-w-2xl mx-auto py-8 px-4&quot;&gt;&#10;        {/* Header */}&#10;        &lt;div className=&quot;flex items-center justify-between mb-6&quot;&gt;&#10;          &lt;h1 className=&quot;text-2xl font-bold text-gray-900&quot;&gt;Posts&lt;/h1&gt;&#10;          &lt;div className=&quot;flex gap-2&quot;&gt;&#10;            &lt;Button&#10;              variant=&quot;secondary&quot;&#10;              onClick={loadPosts}&#10;              disabled={isLoading}&#10;              className=&quot;flex items-center gap-2&quot;&#10;            &gt;&#10;              &lt;RefreshCw className={`w-4 h-4 ${isLoading ? 'animate-spin' : ''}`} /&gt;&#10;              Refresh&#10;            &lt;/Button&gt;&#10;            &lt;Button&#10;              onClick={() =&gt; setShowCreatePost(true)}&#10;              className=&quot;flex items-center gap-2&quot;&#10;            &gt;&#10;              &lt;Plus className=&quot;w-4 h-4&quot; /&gt;&#10;              Create Post&#10;            &lt;/Button&gt;&#10;          &lt;/div&gt;&#10;        &lt;/div&gt;&#10;&#10;        {/* Create Post Form */}&#10;        {showCreatePost &amp;&amp; (&#10;          &lt;div className=&quot;mb-6&quot;&gt;&#10;            &lt;CreatePost&#10;              onPostCreated={handlePostCreated}&#10;              onCancel={() =&gt; setShowCreatePost(false)}&#10;            /&gt;&#10;          &lt;/div&gt;&#10;        )}&#10;&#10;        {/* Error Display */}&#10;        {error &amp;&amp; (&#10;          &lt;div className=&quot;mb-6&quot;&gt;&#10;            &lt;ErrorAlert message={error} /&gt;&#10;          &lt;/div&gt;&#10;        )}&#10;&#10;        {/* Posts List */}&#10;        {posts.length === 0 ? (&#10;          &lt;div className=&quot;text-center py-12&quot;&gt;&#10;            &lt;div className=&quot;text-gray-400 mb-4&quot;&gt;&#10;              &lt;Plus className=&quot;w-16 h-16 mx-auto&quot; /&gt;&#10;            &lt;/div&gt;&#10;            &lt;h3 className=&quot;text-lg font-medium text-gray-900 mb-2&quot;&gt;No posts yet&lt;/h3&gt;&#10;            &lt;p className=&quot;text-gray-500 mb-4&quot;&gt;Be the first to create a post!&lt;/p&gt;&#10;            &lt;Button onClick={() =&gt; setShowCreatePost(true)}&gt;&#10;              Create First Post&#10;            &lt;/Button&gt;&#10;          &lt;/div&gt;&#10;        ) : (&#10;          &lt;div className=&quot;space-y-6&quot;&gt;&#10;            {posts.map((post) =&gt; (&#10;              &lt;PostCard&#10;                key={post.id}&#10;                post={post}&#10;                onPostUpdate={handlePostUpdate}&#10;                onPostDelete={handlePostDelete}&#10;              /&gt;&#10;            ))}&#10;          &lt;/div&gt;&#10;        )}&#10;      &lt;/div&gt;&#10;    &lt;/div&gt;&#10;  );&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/client-frontend/src/components/post/PostCard.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/client-frontend/src/components/post/PostCard.tsx" />
              <option name="originalContent" value="'use client';&#10;&#10;import React, { useState, useEffect } from 'react';&#10;import { Post, CreateCommentRequest } from '@/types';&#10;import { postService } from '@/services/postService';&#10;import { Button } from '@/components/ui/Button';&#10;import { Card } from '@/components/ui/Card';&#10;import { Textarea } from '@/components/ui/Textarea';&#10;import { LoadingSpinner } from '@/components/ui/LoadingSpinner';&#10;import {&#10;  Heart,&#10;  MessageCircle,&#10;  Share,&#10;  Bookmark,&#10;  MoreHorizontal,&#10;  Send,&#10;  Eye&#10;} from 'lucide-react';&#10;import { formatDistanceToNow } from 'date-fns';&#10;&#10;&#10;interface PostCardProps {&#10;  post: Post;&#10;  onPostUpdate?: (updatedPost: Post) =&gt; void;&#10;  onPostDelete?: (postId: string) =&gt; void;&#10;  className?: string;&#10;}&#10;&#10;export const PostCard: React.FC&lt;PostCardProps&gt; = ({&#10;  post,&#10;  onPostUpdate,&#10;  onPostDelete,&#10;  className = ''&#10;}) =&gt; {&#10;  const [isLiked, setIsLiked] = useState(false);&#10;  const [isBookmarked, setIsBookmarked] = useState(false);&#10;  const [showComments, setShowComments] = useState(false);&#10;  const [commentText, setCommentText] = useState('');&#10;  const [comments, setComments] = useState&lt;any[]&gt;([]);&#10;  const [isLoadingComments, setIsLoadingComments] = useState(false);&#10;  const [isSubmittingComment, setIsSubmittingComment] = useState(false);&#10;  const [isLoadingInteraction, setIsLoadingInteraction] = useState(false);&#10;&#10;  // Load interaction status on component mount to fix state persistence&#10;  useEffect(() =&gt; {&#10;    const loadInteractionStatus = async () =&gt; {&#10;      try {&#10;        const status = await postService.getInteractionStatus(post.id);&#10;        setIsLiked(status.hasLiked);&#10;        setIsBookmarked(status.hasBookmarked);&#10;      } catch (error) {&#10;        // Silently fail - user might not be authenticated&#10;        // This prevents errors when viewing posts without login&#10;        console.debug('Could not load interaction status:', error);&#10;      }&#10;    };&#10;&#10;    loadInteractionStatus();&#10;  }, [post.id]);&#10;&#10;  const handleShowComments = async () =&gt; {&#10;    if (!showComments &amp;&amp; comments.length === 0) {&#10;      setIsLoadingComments(true);&#10;      try {&#10;        const response = await postService.getComments(post.id);&#10;        setComments(response.content);&#10;      } catch (error) {&#10;        console.error('Failed to load comments:', error);&#10;      } finally {&#10;        setIsLoadingComments(false);&#10;      }&#10;    }&#10;    setShowComments(!showComments);&#10;  };&#10;&#10;  const handleLike = async () =&gt; {&#10;    if (isLoadingInteraction) return;&#10;&#10;    setIsLoadingInteraction(true);&#10;    try {&#10;      await postService.toggleLike(post.id);&#10;      setIsLiked(!isLiked);&#10;&#10;      const updatedPost = {&#10;        ...post,&#10;        stats: {&#10;          ...post.stats,&#10;          likes: isLiked ? post.stats.likes - 1 : post.stats.likes + 1&#10;        }&#10;      };&#10;      onPostUpdate?.(updatedPost);&#10;    } catch (error) {&#10;      console.error('Failed to toggle like:', error);&#10;    } finally {&#10;      setIsLoadingInteraction(false);&#10;    }&#10;  };&#10;&#10;  const handleBookmark = async () =&gt; {&#10;    if (isLoadingInteraction) return;&#10;&#10;    setIsLoadingInteraction(true);&#10;    try {&#10;      await postService.toggleBookmark(post.id);&#10;      setIsBookmarked(!isBookmarked);&#10;&#10;      const updatedPost = {&#10;        ...post,&#10;        stats: {&#10;          ...post.stats,&#10;          bookmarks: isBookmarked ? post.stats.bookmarks - 1 : post.stats.bookmarks + 1&#10;        }&#10;      };&#10;      onPostUpdate?.(updatedPost);&#10;    } catch (error) {&#10;      console.error('Failed to toggle bookmark:', error);&#10;    } finally {&#10;      setIsLoadingInteraction(false);&#10;    }&#10;  };&#10;&#10;  const handleShare = async () =&gt; {&#10;    if (isLoadingInteraction) return;&#10;&#10;    setIsLoadingInteraction(true);&#10;    try {&#10;      await postService.sharePost(post.id);&#10;&#10;      const updatedPost = {&#10;        ...post,&#10;        stats: {&#10;          ...post.stats,&#10;          shares: post.stats.shares + 1&#10;        }&#10;      };&#10;      onPostUpdate?.(updatedPost);&#10;&#10;      // Copy link to clipboard&#10;      await navigator.clipboard.writeText(`${window.location.origin}/posts/${post.id}`);&#10;      alert('Post link copied to clipboard!');&#10;    } catch (error) {&#10;      console.error('Failed to share post:', error);&#10;    } finally {&#10;      setIsLoadingInteraction(false);&#10;    }&#10;  };&#10;&#10;  const handleSubmitComment = async (e: React.FormEvent) =&gt; {&#10;    e.preventDefault();&#10;    if (!commentText.trim() || isSubmittingComment) return;&#10;&#10;    setIsSubmittingComment(true);&#10;    try {&#10;      const commentData: CreateCommentRequest = {&#10;        content: commentText.trim()&#10;      };&#10;&#10;      const newComment = await postService.createComment(post.id, commentData);&#10;      setComments(prev =&gt; [...prev, newComment]);&#10;      setCommentText('');&#10;&#10;      const updatedPost = {&#10;        ...post,&#10;        stats: {&#10;          ...post.stats,&#10;          comments: post.stats.comments + 1&#10;        }&#10;      };&#10;      onPostUpdate?.(updatedPost);&#10;    } catch (error) {&#10;      console.error('Failed to create comment:', error);&#10;    } finally {&#10;      setIsSubmittingComment(false);&#10;    }&#10;  };&#10;&#10;  const formatStats = (count: number): string =&gt; {&#10;    if (count &gt;= 1000000) return `${(count / 1000000).toFixed(1)}M`;&#10;    if (count &gt;= 1000) return `${(count / 1000).toFixed(1)}K`;&#10;    return count.toString();&#10;  };&#10;&#10;&#10;&#10;  return (&#10;    &lt;Card className={`post-card bg-white rounded-lg shadow ${className}`}&gt;&#10;      {/* Post Header */}&#10;      &lt;div className=&quot;flex items-start justify-between p-4&quot;&gt;&#10;        &lt;div className=&quot;flex items-center space-x-3&quot;&gt;&#10;          &lt;div className=&quot;w-10 h-10 bg-gray-300 rounded-full flex items-center justify-center&quot;&gt;&#10;            {post.authorAvatar ? (&#10;              &lt;img&#10;                src={post.authorAvatar}&#10;                alt={post.authorName || 'Author'}&#10;                className=&quot;w-full h-full rounded-full object-cover&quot;&#10;              /&gt;&#10;            ) : (&#10;              &lt;span className=&quot;text-sm font-medium text-gray-600&quot;&gt;&#10;                {(post.authorName || 'Anonymous').charAt(0).toUpperCase()}&#10;              &lt;/span&gt;&#10;            )}&#10;          &lt;/div&gt;&#10;          &lt;div&gt;&#10;            &lt;h3 className=&quot;font-semibold text-gray-900&quot;&gt;&#10;              {post.authorName || 'Anonymous'}&#10;            &lt;/h3&gt;&#10;            &lt;p className=&quot;text-sm text-gray-500&quot;&gt;&#10;              {formatDistanceToNow(new Date(post.createdAt), { addSuffix: true })}&#10;              {post.visibility &amp;&amp; post.visibility !== 'PUBLIC' &amp;&amp; (&#10;                &lt;span className=&quot;ml-2 px-2 py-0.5 bg-gray-100 rounded text-xs&quot;&gt;&#10;                  {post.visibility.toLowerCase()}&#10;                &lt;/span&gt;&#10;              )}&#10;            &lt;/p&gt;&#10;          &lt;/div&gt;&#10;        &lt;/div&gt;&#10;        &lt;Button variant=&quot;ghost&quot; size=&quot;sm&quot;&gt;&#10;          &lt;MoreHorizontal className=&quot;w-4 h-4&quot; /&gt;&#10;        &lt;/Button&gt;&#10;      &lt;/div&gt;&#10;&#10;      {/* Post Content */}&#10;      &lt;div className=&quot;px-4 pb-3&quot;&gt;&#10;        {post.title &amp;&amp; (&#10;          &lt;h2 className=&quot;text-lg font-semibold mb-2&quot;&gt;{post.title}&lt;/h2&gt;&#10;        )}&#10;        &lt;p className=&quot;text-gray-900 whitespace-pre-wrap&quot;&gt;{post.content}&lt;/p&gt;&#10;&#10;        {/* Tags */}&#10;        {post.tags &amp;&amp; post.tags.length &gt; 0 &amp;&amp; (&#10;          &lt;div className=&quot;flex flex-wrap gap-2 mt-3&quot;&gt;&#10;            {post.tags.map((tag, index) =&gt; (&#10;              &lt;span&#10;                key={index}&#10;                className=&quot;inline-block px-2 py-1 bg-blue-100 text-blue-800 rounded-full text-sm&quot;&#10;              &gt;&#10;                #{tag}&#10;              &lt;/span&gt;&#10;            ))}&#10;          &lt;/div&gt;&#10;        )}&#10;&#10;        {/* Category */}&#10;        {post.category &amp;&amp; (&#10;          &lt;div className=&quot;mt-2&quot;&gt;&#10;            &lt;span className=&quot;inline-block px-2 py-1 bg-green-100 text-green-800 rounded text-sm&quot;&gt;&#10;              {post.category}&#10;            &lt;/span&gt;&#10;          &lt;/div&gt;&#10;        )}&#10;      &lt;/div&gt;&#10;&#10;      {/* Post Images */}&#10;      {post.images &amp;&amp; post.images.length &gt; 0 &amp;&amp; (&#10;        &lt;div className=&quot;px-4 pb-3&quot;&gt;&#10;          &lt;div className={`grid gap-2 ${&#10;            post.images.length === 1 ? 'grid-cols-1' : &#10;            post.images.length === 2 ? 'grid-cols-2' : &#10;            'grid-cols-2'&#10;          }`}&gt;&#10;            {post.images.slice(0, 4).map((image, index) =&gt; (&#10;              &lt;div key={index} className=&quot;relative&quot;&gt;&#10;                &lt;img&#10;                  src={image}&#10;                  alt={`Post image ${index + 1}`}&#10;                  className=&quot;w-full h-48 object-cover rounded-lg&quot;&#10;                /&gt;&#10;                {index === 3 &amp;&amp;  post.images &amp;&amp; post.images.length &gt; 4 &amp;&amp; (&#10;                  &lt;div className=&quot;absolute inset-0 bg-black bg-opacity-50 rounded-lg flex items-center justify-center&quot;&gt;&#10;                    &lt;span className=&quot;text-white text-lg font-semibold&quot;&gt;&#10;                      +{post.images.length - 4} more&#10;                    &lt;/span&gt;&#10;                  &lt;/div&gt;&#10;                )}&#10;              &lt;/div&gt;&#10;            ))}&#10;          &lt;/div&gt;&#10;        &lt;/div&gt;&#10;      )}&#10;&#10;      {/* Post Stats */}&#10;      &lt;div className=&quot;px-4 py-2 border-t border-gray-100&quot;&gt;&#10;        &lt;div className=&quot;flex items-center justify-between text-sm text-gray-500&quot;&gt;&#10;          &lt;div className=&quot;flex items-center space-x-4&quot;&gt;&#10;            &lt;span className=&quot;flex items-center space-x-1&quot;&gt;&#10;              &lt;Eye className=&quot;w-4 h-4&quot; /&gt;&#10;              &lt;span&gt;{formatStats(post.stats.views)}&lt;/span&gt;&#10;            &lt;/span&gt;&#10;            &lt;span className=&quot;flex items-center space-x-1&quot;&gt;&#10;              &lt;Heart className=&quot;w-4 h-4&quot; /&gt;&#10;              &lt;span&gt;{formatStats(post.stats.likes)}&lt;/span&gt;&#10;            &lt;/span&gt;&#10;          &lt;/div&gt;&#10;          &lt;div className=&quot;flex items-center space-x-4&quot;&gt;&#10;            &lt;span&gt;{formatStats(post.stats.comments)} comments&lt;/span&gt;&#10;            &lt;span&gt;{formatStats(post.stats.shares)} shares&lt;/span&gt;&#10;          &lt;/div&gt;&#10;        &lt;/div&gt;&#10;      &lt;/div&gt;&#10;&#10;      {/* Post Actions */}&#10;      &lt;div className=&quot;px-4 py-2 border-t border-gray-100&quot;&gt;&#10;        &lt;div className=&quot;flex items-center justify-between&quot;&gt;&#10;          &lt;Button&#10;            variant=&quot;ghost&quot;&#10;            size=&quot;sm&quot;&#10;            onClick={handleLike}&#10;            disabled={isLoadingInteraction}&#10;            className={`flex items-center space-x-2 ${isLiked ? 'text-red-500' : 'text-gray-500'}`}&#10;          &gt;&#10;            &lt;Heart className={`w-5 h-5 ${isLiked ? 'fill-current' : ''}`} /&gt;&#10;            &lt;span&gt;Like&lt;/span&gt;&#10;          &lt;/Button&gt;&#10;&#10;          &lt;Button&#10;            variant=&quot;ghost&quot;&#10;            size=&quot;sm&quot;&#10;            onClick={handleShowComments}&#10;            className=&quot;flex items-center space-x-2 text-gray-500&quot;&#10;          &gt;&#10;            &lt;MessageCircle className=&quot;w-5 h-5&quot; /&gt;&#10;            &lt;span&gt;Comment&lt;/span&gt;&#10;          &lt;/Button&gt;&#10;&#10;          &lt;Button&#10;            variant=&quot;ghost&quot;&#10;            size=&quot;sm&quot;&#10;            onClick={handleShare}&#10;            disabled={isLoadingInteraction}&#10;            className=&quot;flex items-center space-x-2 text-gray-500&quot;&#10;          &gt;&#10;            &lt;Share className=&quot;w-5 h-5&quot; /&gt;&#10;            &lt;span&gt;Share&lt;/span&gt;&#10;          &lt;/Button&gt;&#10;&#10;          &lt;Button&#10;            variant=&quot;ghost&quot;&#10;            size=&quot;sm&quot;&#10;            onClick={handleBookmark}&#10;            disabled={isLoadingInteraction}&#10;            className={`flex items-center space-x-2 ${isBookmarked ? 'text-blue-500' : 'text-gray-500'}`}&#10;          &gt;&#10;            &lt;Bookmark className={`w-5 h-5 ${isBookmarked ? 'fill-current' : ''}`} /&gt;&#10;            &lt;span&gt;Save&lt;/span&gt;&#10;          &lt;/Button&gt;&#10;        &lt;/div&gt;&#10;      &lt;/div&gt;&#10;&#10;      {/* Comments Section */}&#10;      {showComments &amp;&amp; (&#10;        &lt;div className=&quot;border-t border-gray-100&quot;&gt;&#10;          {/* Comment Form */}&#10;          &lt;form onSubmit={handleSubmitComment} className=&quot;p-4 border-b border-gray-100&quot;&gt;&#10;            &lt;div className=&quot;flex space-x-3&quot;&gt;&#10;              &lt;div className=&quot;w-8 h-8 bg-gray-300 rounded-full flex-shrink-0&quot;&gt;&lt;/div&gt;&#10;              &lt;div className=&quot;flex-1&quot;&gt;&#10;                &lt;Textarea&#10;                  placeholder=&quot;Write a comment...&quot;&#10;                  value={commentText}&#10;                  onChange={(e) =&gt; setCommentText(e.target.value)}&#10;                  className=&quot;w-full resize-none min-h-[60px]&quot;&#10;                /&gt;&#10;                &lt;div className=&quot;flex justify-end mt-2&quot;&gt;&#10;                  &lt;Button&#10;                    type=&quot;submit&quot;&#10;                    size=&quot;sm&quot;&#10;                    disabled={!commentText.trim() || isSubmittingComment}&#10;                    className=&quot;flex items-center space-x-2&quot;&#10;                  &gt;&#10;                    {isSubmittingComment ? (&#10;                      &lt;LoadingSpinner /&gt;&#10;                    ) : (&#10;                      &lt;Send className=&quot;w-4 h-4&quot; /&gt;&#10;                    )}&#10;                    &lt;span&gt;Post&lt;/span&gt;&#10;                  &lt;/Button&gt;&#10;                &lt;/div&gt;&#10;              &lt;/div&gt;&#10;            &lt;/div&gt;&#10;          &lt;/form&gt;&#10;&#10;          {/* Comments List */}&#10;          &lt;div className=&quot;p-4&quot;&gt;&#10;            {isLoadingComments ? (&#10;              &lt;div className=&quot;flex justify-center py-4&quot;&gt;&#10;                &lt;LoadingSpinner /&gt;&#10;              &lt;/div&gt;&#10;            ) : comments.length === 0 ? (&#10;              &lt;p className=&quot;text-gray-500 text-center py-4&quot;&gt;No comments yet&lt;/p&gt;&#10;            ) : (&#10;              &lt;div className=&quot;space-y-4&quot;&gt;&#10;                {comments.map((comment) =&gt; (&#10;                  &lt;div key={comment.author.id} className=&quot;flex space-x-3&quot;&gt;&#10;                    &lt;div className=&quot;w-8 h-8 bg-gray-300 rounded-full flex-shrink-0&quot;&gt;&#10;                      {comment.author.avatar ? (&#10;                        &lt;img&#10;                          src={comment.author.avatar}&#10;                          alt={comment.author.name}&#10;                          className=&quot;w-full h-full rounded-full object-cover&quot;&#10;                        /&gt;&#10;                      ) : (&#10;                        &lt;span className=&quot;text-xs font-medium text-gray-600 flex items-center justify-center w-full h-full&quot;&gt;&#10;                          {(comment.author.name || 'A').charAt(0).toUpperCase()}&#10;                        &lt;/span&gt;&#10;                      )}&#10;                    &lt;/div&gt;&#10;                    &lt;div className=&quot;flex-1&quot;&gt;&#10;                      &lt;div className=&quot;bg-gray-100 rounded-lg px-3 py-2&quot;&gt;&#10;                        &lt;p className=&quot;font-semibold text-sm&quot;&gt;{comment.author.name || 'Anonymous'}&lt;/p&gt;&#10;                        &lt;p className=&quot;text-gray-900&quot;&gt;{comment.content}&lt;/p&gt;&#10;                      &lt;/div&gt;&#10;                      &lt;p className=&quot;text-xs text-gray-500 mt-1&quot;&gt;&#10;                        {formatDistanceToNow(new Date(comment.createdAt), { addSuffix: true })}&#10;                      &lt;/p&gt;&#10;                    &lt;/div&gt;&#10;                  &lt;/div&gt;&#10;                ))}&#10;              &lt;/div&gt;&#10;            )}&#10;          &lt;/div&gt;&#10;        &lt;/div&gt;&#10;      )}&#10;    &lt;/Card&gt;&#10;  );&#10;};&#10;" />
              <option name="updatedContent" value="'use client';&#10;&#10;import React, { useState, useEffect } from 'react';&#10;import { Post, CreateCommentRequest } from '@/types';&#10;import { postService } from '@/services/postService';&#10;import { Button } from '@/components/ui/Button';&#10;import { Card } from '@/components/ui/Card';&#10;import { Textarea } from '@/components/ui/Textarea';&#10;import { LoadingSpinner } from '@/components/ui/LoadingSpinner';&#10;import {&#10;  Heart,&#10;  MessageCircle,&#10;  Share,&#10;  Bookmark,&#10;  MoreHorizontal,&#10;  Send,&#10;  Eye&#10;} from 'lucide-react';&#10;import { formatDistanceToNow } from 'date-fns';&#10;&#10;&#10;interface PostCardProps {&#10;  post: Post;&#10;  onPostUpdate?: (updatedPost: Post) =&gt; void;&#10;  onPostDelete?: (postId: string) =&gt; void;&#10;  className?: string;&#10;}&#10;&#10;export const PostCard: React.FC&lt;PostCardProps&gt; = ({&#10;  post,&#10;  onPostUpdate,&#10;  onPostDelete,&#10;  className = ''&#10;}) =&gt; {&#10;  const [isLiked, setIsLiked] = useState(false);&#10;  const [isBookmarked, setIsBookmarked] = useState(false);&#10;  const [showComments, setShowComments] = useState(false);&#10;  const [commentText, setCommentText] = useState('');&#10;  const [comments, setComments] = useState&lt;any[]&gt;([]);&#10;  const [isLoadingComments, setIsLoadingComments] = useState(false);&#10;  const [isSubmittingComment, setIsSubmittingComment] = useState(false);&#10;  const [isLoadingInteraction, setIsLoadingInteraction] = useState(false);&#10;&#10;  // Load interaction status on component mount to fix state persistence&#10;  useEffect(() =&gt; {&#10;    const loadInteractionStatus = async () =&gt; {&#10;      try {&#10;        const status = await postService.getInteractionStatus(post.id);&#10;        setIsLiked(status.hasLiked);&#10;        setIsBookmarked(status.hasBookmarked);&#10;      } catch (error) {&#10;        // Silently fail - user might not be authenticated&#10;        // This prevents errors when viewing posts without login&#10;        console.debug('Could not load interaction status:', error);&#10;      }&#10;    };&#10;&#10;    loadInteractionStatus();&#10;  }, [post.id]);&#10;&#10;  const handleShowComments = async () =&gt; {&#10;    if (!showComments &amp;&amp; comments.length === 0) {&#10;      setIsLoadingComments(true);&#10;      try {&#10;        const response = await postService.getComments(post.id);&#10;        setComments(response.content);&#10;      } catch (error) {&#10;        console.error('Failed to load comments:', error);&#10;      } finally {&#10;        setIsLoadingComments(false);&#10;      }&#10;    }&#10;    setShowComments(!showComments);&#10;  };&#10;&#10;  const handleLike = async () =&gt; {&#10;    if (isLoadingInteraction) return;&#10;&#10;    setIsLoadingInteraction(true);&#10;    try {&#10;      await postService.toggleLike(post.id);&#10;      setIsLiked(!isLiked);&#10;&#10;      const updatedPost = {&#10;        ...post,&#10;        stats: {&#10;          ...post.stats,&#10;          likes: isLiked ? post.stats.likes - 1 : post.stats.likes + 1&#10;        }&#10;      };&#10;      onPostUpdate?.(updatedPost);&#10;    } catch (error) {&#10;      console.error('Failed to toggle like:', error);&#10;    } finally {&#10;      setIsLoadingInteraction(false);&#10;    }&#10;  };&#10;&#10;  const handleBookmark = async () =&gt; {&#10;    if (isLoadingInteraction) return;&#10;&#10;    setIsLoadingInteraction(true);&#10;    try {&#10;      await postService.toggleBookmark(post.id);&#10;      setIsBookmarked(!isBookmarked);&#10;&#10;      const updatedPost = {&#10;        ...post,&#10;        stats: {&#10;          ...post.stats,&#10;          bookmarks: isBookmarked ? post.stats.bookmarks - 1 : post.stats.bookmarks + 1&#10;        }&#10;      };&#10;      onPostUpdate?.(updatedPost);&#10;    } catch (error) {&#10;      console.error('Failed to toggle bookmark:', error);&#10;    } finally {&#10;      setIsLoadingInteraction(false);&#10;    }&#10;  };&#10;&#10;  const handleShare = async () =&gt; {&#10;    if (isLoadingInteraction) return;&#10;&#10;    setIsLoadingInteraction(true);&#10;    try {&#10;      await postService.sharePost(post.id);&#10;&#10;      const updatedPost = {&#10;        ...post,&#10;        stats: {&#10;          ...post.stats,&#10;          shares: post.stats.shares + 1&#10;        }&#10;      };&#10;      onPostUpdate?.(updatedPost);&#10;&#10;      // Copy link to clipboard&#10;      await navigator.clipboard.writeText(`${window.location.origin}/posts/${post.id}`);&#10;      alert('Post link copied to clipboard!');&#10;    } catch (error) {&#10;      console.error('Failed to share post:', error);&#10;    } finally {&#10;      setIsLoadingInteraction(false);&#10;    }&#10;  };&#10;&#10;  const handleSubmitComment = async (e: React.FormEvent) =&gt; {&#10;    e.preventDefault();&#10;    if (!commentText.trim() || isSubmittingComment) return;&#10;&#10;    setIsSubmittingComment(true);&#10;    try {&#10;      const commentData: CreateCommentRequest = {&#10;        content: commentText.trim()&#10;      };&#10;&#10;      const newComment = await postService.createComment(post.id, commentData);&#10;      setComments(prev =&gt; [...prev, newComment]);&#10;      setCommentText('');&#10;&#10;      const updatedPost = {&#10;        ...post,&#10;        stats: {&#10;          ...post.stats,&#10;          comments: post.stats.comments + 1&#10;        }&#10;      };&#10;      onPostUpdate?.(updatedPost);&#10;    } catch (error) {&#10;      console.error('Failed to create comment:', error);&#10;    } finally {&#10;      setIsSubmittingComment(false);&#10;    }&#10;  };&#10;&#10;  const formatStats = (count: number): string =&gt; {&#10;    if (count &gt;= 1000000) return `${(count / 1000000).toFixed(1)}M`;&#10;    if (count &gt;= 1000) return `${(count / 1000).toFixed(1)}K`;&#10;    return count.toString();&#10;  };&#10;&#10;&#10;&#10;  return (&#10;    &lt;Card className={`post-card bg-white rounded-lg shadow ${className}`}&gt;&#10;      {/* Post Header */}&#10;      &lt;div className=&quot;flex items-start justify-between p-4&quot;&gt;&#10;        &lt;div className=&quot;flex items-center space-x-3&quot;&gt;&#10;          &lt;div className=&quot;w-10 h-10 bg-gray-300 rounded-full flex items-center justify-center&quot;&gt;&#10;            {post.authorAvatar ? (&#10;              &lt;img&#10;                src={post.authorAvatar}&#10;                alt={post.authorName || 'Author'}&#10;                className=&quot;w-full h-full rounded-full object-cover&quot;&#10;              /&gt;&#10;            ) : (&#10;              &lt;span className=&quot;text-sm font-medium text-gray-600&quot;&gt;&#10;                {(post.authorName || 'Anonymous').charAt(0).toUpperCase()}&#10;              &lt;/span&gt;&#10;            )}&#10;          &lt;/div&gt;&#10;          &lt;div&gt;&#10;            &lt;h3 className=&quot;font-semibold text-gray-900&quot;&gt;&#10;              {post.authorName || 'Anonymous'}&#10;            &lt;/h3&gt;&#10;            &lt;p className=&quot;text-sm text-gray-500&quot;&gt;&#10;              {formatDistanceToNow(new Date(post.createdAt), { addSuffix: true })}&#10;              {post.visibility &amp;&amp; post.visibility !== 'PUBLIC' &amp;&amp; (&#10;                &lt;span className=&quot;ml-2 px-2 py-0.5 bg-gray-100 rounded text-xs&quot;&gt;&#10;                  {post.visibility.toLowerCase()}&#10;                &lt;/span&gt;&#10;              )}&#10;            &lt;/p&gt;&#10;          &lt;/div&gt;&#10;        &lt;/div&gt;&#10;        &lt;Button variant=&quot;ghost&quot; size=&quot;sm&quot;&gt;&#10;          &lt;MoreHorizontal className=&quot;w-4 h-4&quot; /&gt;&#10;        &lt;/Button&gt;&#10;      &lt;/div&gt;&#10;&#10;      {/* Post Content */}&#10;      &lt;div className=&quot;px-4 pb-3&quot;&gt;&#10;        {post.title &amp;&amp; (&#10;          &lt;h2 className=&quot;text-lg font-semibold mb-2&quot;&gt;{post.title}&lt;/h2&gt;&#10;        )}&#10;        &lt;p className=&quot;text-gray-900 whitespace-pre-wrap&quot;&gt;{post.content}&lt;/p&gt;&#10;&#10;        {/* Tags */}&#10;        {post.tags &amp;&amp; post.tags.length &gt; 0 &amp;&amp; (&#10;          &lt;div className=&quot;flex flex-wrap gap-2 mt-3&quot;&gt;&#10;            {post.tags.map((tag, index) =&gt; (&#10;              &lt;span&#10;                key={index}&#10;                className=&quot;inline-block px-2 py-1 bg-blue-100 text-blue-800 rounded-full text-sm&quot;&#10;              &gt;&#10;                #{tag}&#10;              &lt;/span&gt;&#10;            ))}&#10;          &lt;/div&gt;&#10;        )}&#10;&#10;        {/* Category */}&#10;        {post.category &amp;&amp; (&#10;          &lt;div className=&quot;mt-2&quot;&gt;&#10;            &lt;span className=&quot;inline-block px-2 py-1 bg-green-100 text-green-800 rounded text-sm&quot;&gt;&#10;              {post.category}&#10;            &lt;/span&gt;&#10;          &lt;/div&gt;&#10;        )}&#10;      &lt;/div&gt;&#10;&#10;      {/* Post Images */}&#10;      {post.images &amp;&amp; post.images.length &gt; 0 &amp;&amp; (&#10;        &lt;div className=&quot;px-4 pb-3&quot;&gt;&#10;          &lt;div className={`grid gap-2 ${&#10;            post.images.length === 1 ? 'grid-cols-1' : &#10;            post.images.length === 2 ? 'grid-cols-2' : &#10;            'grid-cols-2'&#10;          }`}&gt;&#10;            {post.images.slice(0, 4).map((image, index) =&gt; (&#10;              &lt;div key={index} className=&quot;relative&quot;&gt;&#10;                &lt;img&#10;                  src={image}&#10;                  alt={`Post image ${index + 1}`}&#10;                  className=&quot;w-full h-48 object-cover rounded-lg&quot;&#10;                /&gt;&#10;                {index === 3 &amp;&amp;  post.images &amp;&amp; post.images.length &gt; 4 &amp;&amp; (&#10;                  &lt;div className=&quot;absolute inset-0 bg-black bg-opacity-50 rounded-lg flex items-center justify-center&quot;&gt;&#10;                    &lt;span className=&quot;text-white text-lg font-semibold&quot;&gt;&#10;                      +{post.images.length - 4} more&#10;                    &lt;/span&gt;&#10;                  &lt;/div&gt;&#10;                )}&#10;              &lt;/div&gt;&#10;            ))}&#10;          &lt;/div&gt;&#10;        &lt;/div&gt;&#10;      )}&#10;&#10;      {/* Post Stats */}&#10;      &lt;div className=&quot;px-4 py-2 border-t border-gray-100&quot;&gt;&#10;        &lt;div className=&quot;flex items-center justify-between text-sm text-gray-500&quot;&gt;&#10;          &lt;div className=&quot;flex items-center space-x-4&quot;&gt;&#10;            &lt;span className=&quot;flex items-center space-x-1&quot;&gt;&#10;              &lt;Eye className=&quot;w-4 h-4&quot; /&gt;&#10;              &lt;span&gt;{formatStats(post.stats.views)}&lt;/span&gt;&#10;            &lt;/span&gt;&#10;            &lt;span className=&quot;flex items-center space-x-1&quot;&gt;&#10;              &lt;Heart className=&quot;w-4 h-4&quot; /&gt;&#10;              &lt;span&gt;{formatStats(post.stats.likes)}&lt;/span&gt;&#10;            &lt;/span&gt;&#10;          &lt;/div&gt;&#10;          &lt;div className=&quot;flex items-center space-x-4&quot;&gt;&#10;            &lt;span&gt;{formatStats(post.stats.comments)} comments&lt;/span&gt;&#10;            &lt;span&gt;{formatStats(post.stats.shares)} shares&lt;/span&gt;&#10;          &lt;/div&gt;&#10;        &lt;/div&gt;&#10;      &lt;/div&gt;&#10;&#10;      {/* Post Actions */}&#10;      &lt;div className=&quot;px-4 py-2 border-t border-gray-100&quot;&gt;&#10;        &lt;div className=&quot;flex items-center justify-between&quot;&gt;&#10;          &lt;Button&#10;            variant=&quot;ghost&quot;&#10;            size=&quot;sm&quot;&#10;            onClick={handleLike}&#10;            disabled={isLoadingInteraction}&#10;            className={`flex items-center space-x-2 ${isLiked ? 'text-red-500' : 'text-gray-500'}`}&#10;          &gt;&#10;            &lt;Heart className={`w-5 h-5 ${isLiked ? 'fill-current' : ''}`} /&gt;&#10;            &lt;span&gt;Like&lt;/span&gt;&#10;          &lt;/Button&gt;&#10;&#10;          &lt;Button&#10;            variant=&quot;ghost&quot;&#10;            size=&quot;sm&quot;&#10;            onClick={handleShowComments}&#10;            className=&quot;flex items-center space-x-2 text-gray-500&quot;&#10;          &gt;&#10;            &lt;MessageCircle className=&quot;w-5 h-5&quot; /&gt;&#10;            &lt;span&gt;Comment&lt;/span&gt;&#10;          &lt;/Button&gt;&#10;&#10;          &lt;Button&#10;            variant=&quot;ghost&quot;&#10;            size=&quot;sm&quot;&#10;            onClick={handleShare}&#10;            disabled={isLoadingInteraction}&#10;            className=&quot;flex items-center space-x-2 text-gray-500&quot;&#10;          &gt;&#10;            &lt;Share className=&quot;w-5 h-5&quot; /&gt;&#10;            &lt;span&gt;Share&lt;/span&gt;&#10;          &lt;/Button&gt;&#10;&#10;          &lt;Button&#10;            variant=&quot;ghost&quot;&#10;            size=&quot;sm&quot;&#10;            onClick={handleBookmark}&#10;            disabled={isLoadingInteraction}&#10;            className={`flex items-center space-x-2 ${isBookmarked ? 'text-blue-500' : 'text-gray-500'}`}&#10;          &gt;&#10;            &lt;Bookmark className={`w-5 h-5 ${isBookmarked ? 'fill-current' : ''}`} /&gt;&#10;            &lt;span&gt;Save&lt;/span&gt;&#10;          &lt;/Button&gt;&#10;        &lt;/div&gt;&#10;      &lt;/div&gt;&#10;&#10;      {/* Comments Section */}&#10;      {showComments &amp;&amp; (&#10;        &lt;div className=&quot;border-t border-gray-100&quot;&gt;&#10;          {/* Comment Form */}&#10;          &lt;form onSubmit={handleSubmitComment} className=&quot;p-4 border-b border-gray-100&quot;&gt;&#10;            &lt;div className=&quot;flex space-x-3&quot;&gt;&#10;              &lt;div className=&quot;w-8 h-8 bg-gray-300 rounded-full flex-shrink-0&quot;&gt;&lt;/div&gt;&#10;              &lt;div className=&quot;flex-1&quot;&gt;&#10;                &lt;Textarea&#10;                  placeholder=&quot;Write a comment...&quot;&#10;                  value={commentText}&#10;                  onChange={(e) =&gt; setCommentText(e.target.value)}&#10;                  className=&quot;w-full resize-none min-h-[60px]&quot;&#10;                /&gt;&#10;                &lt;div className=&quot;flex justify-end mt-2&quot;&gt;&#10;                  &lt;Button&#10;                    type=&quot;submit&quot;&#10;                    size=&quot;sm&quot;&#10;                    disabled={!commentText.trim() || isSubmittingComment}&#10;                    className=&quot;flex items-center space-x-2&quot;&#10;                  &gt;&#10;                    {isSubmittingComment ? (&#10;                      &lt;LoadingSpinner /&gt;&#10;                    ) : (&#10;                      &lt;Send className=&quot;w-4 h-4&quot; /&gt;&#10;                    )}&#10;                    &lt;span&gt;Post&lt;/span&gt;&#10;                  &lt;/Button&gt;&#10;                &lt;/div&gt;&#10;              &lt;/div&gt;&#10;            &lt;/div&gt;&#10;          &lt;/form&gt;&#10;&#10;          {/* Comments List */}&#10;          &lt;div className=&quot;p-4&quot;&gt;&#10;            {isLoadingComments ? (&#10;              &lt;div className=&quot;flex justify-center py-4&quot;&gt;&#10;                &lt;LoadingSpinner /&gt;&#10;              &lt;/div&gt;&#10;            ) : comments.length === 0 ? (&#10;              &lt;p className=&quot;text-gray-500 text-center py-4&quot;&gt;No comments yet&lt;/p&gt;&#10;            ) : (&#10;              &lt;div className=&quot;space-y-4&quot;&gt;&#10;                {comments.map((comment) =&gt; (&#10;                  &lt;div key={comment.author.id} className=&quot;flex space-x-3&quot;&gt;&#10;                    &lt;div className=&quot;w-8 h-8 bg-gray-300 rounded-full flex-shrink-0&quot;&gt;&#10;                      {comment.author.avatar ? (&#10;                        &lt;img&#10;                          src={comment.author.avatar}&#10;                          alt={comment.author.name}&#10;                          className=&quot;w-full h-full rounded-full object-cover&quot;&#10;                        /&gt;&#10;                      ) : (&#10;                        &lt;span className=&quot;text-xs font-medium text-gray-600 flex items-center justify-center w-full h-full&quot;&gt;&#10;                          {(comment.author.name || 'A').charAt(0).toUpperCase()}&#10;                        &lt;/span&gt;&#10;                      )}&#10;                    &lt;/div&gt;&#10;                    &lt;div className=&quot;flex-1&quot;&gt;&#10;                      &lt;div className=&quot;bg-gray-100 rounded-lg px-3 py-2&quot;&gt;&#10;                        &lt;p className=&quot;font-semibold text-sm&quot;&gt;{comment.author.name || 'Anonymous'}&lt;/p&gt;&#10;                        &lt;p className=&quot;text-gray-900&quot;&gt;{comment.content}&lt;/p&gt;&#10;                      &lt;/div&gt;&#10;                      &lt;p className=&quot;text-xs text-gray-500 mt-1&quot;&gt;&#10;                        {formatDistanceToNow(new Date(comment.createdAt), { addSuffix: true })}&#10;                      &lt;/p&gt;&#10;                    &lt;/div&gt;&#10;                  &lt;/div&gt;&#10;                ))}&#10;              &lt;/div&gt;&#10;            )}&#10;          &lt;/div&gt;&#10;        &lt;/div&gt;&#10;      )}&#10;    &lt;/Card&gt;&#10;  );&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/client-frontend/src/services/postService.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/client-frontend/src/services/postService.ts" />
              <option name="originalContent" value="import api from '@/lib/api';&#10;import { mediaService, MediaResponse } from './mediaService';&#10;import {&#10;  Post,&#10;  Comment,&#10;  CreatePostRequest,&#10;  UpdatePostRequest,&#10;  CreateCommentRequest,&#10;  CreateInteractionRequest,&#10;  Interaction,&#10;  PaginatedResponse,&#10;  InteractionType,&#10;  ReactionType&#10;} from '@/types';&#10;&#10;export const postService = {&#10;  // Create post with proper structure matching backend&#10;  async createPost(postData: CreatePostRequest, files?: File[]): Promise&lt;Post&gt; {&#10;    try {&#10;      let mediaUrls: string[] = [];&#10;&#10;      // Step 1: Upload files to media service first if files exist&#10;      if (files &amp;&amp; files.length &gt; 0) {&#10;        console.log('Uploading files to media service...');&#10;        const mediaResponses: MediaResponse[] = await mediaService.uploadFiles(&#10;          files,&#10;          'Post media files'&#10;        );&#10;&#10;        // Extract cloudinary URLs from media responses&#10;        mediaUrls = mediaResponses.map(media =&gt; media.cloudinaryUrl);&#10;        console.log('Files uploaded successfully:', mediaUrls);&#10;      }&#10;&#10;      // Step 2: Create post data with media URLs&#10;      const postRequestData = {&#10;        ...postData,&#10;        images: mediaUrls.length &gt; 0 ? mediaUrls : undefined&#10;      };&#10;      console.log('Uploading post request...', postRequestData);&#10;      // Step 3: Create post via post service&#10;      const response = await api.post('/posts', postRequestData, {&#10;        headers: {&#10;          'Content-Type': 'application/json',&#10;        },&#10;      });&#10;&#10;      return response.data;&#10;    } catch (error) {&#10;      console.error('Error creating post:', error);&#10;      throw error;&#10;    }&#10;  },&#10;&#10;  // Get paginated posts&#10;  async getPosts(&#10;    page = 0,&#10;    size = 10,&#10;    sortBy = 'createdAt',&#10;    sortDir = 'desc',&#10;    authorId?: string,&#10;    category?: string,&#10;    search?: string&#10;  ): Promise&lt;PaginatedResponse&lt;Post&gt;&gt; {&#10;    const params = new URLSearchParams({&#10;      page: page.toString(),&#10;      size: size.toString(),&#10;      sortBy,&#10;      sortDir,&#10;    });&#10;&#10;    if (authorId) params.append('authorId', authorId);&#10;    if (category) params.append('category', category);&#10;    if (search) params.append('search', search);&#10;&#10;    const response = await api.get(`/posts?${params.toString()}`);&#10;    console.log(&quot;Fetched posts:&quot;, response.data);&#10;    return response.data;&#10;  },&#10;&#10;  // Get single post by ID&#10;  async getPost(postId: string): Promise&lt;Post&gt; {&#10;    const response = await api.get(`/posts/${postId}`);&#10;    return response.data;&#10;  },&#10;&#10;  // Get posts by author&#10;  async getUserPosts(authorId: string, page = 0, size = 10): Promise&lt;PaginatedResponse&lt;Post&gt;&gt; {&#10;    return this.getPosts(page, size, 'createdAt', 'desc', authorId);&#10;  },&#10;&#10;  // Update post&#10;  async updatePost(postId: string, updateData: UpdatePostRequest): Promise&lt;Post&gt; {&#10;    const response = await api.put(`/posts/${postId}`, updateData);&#10;    return response.data;&#10;  },&#10;&#10;  // Delete post&#10;  async deletePost(postId: string): Promise&lt;void&gt; {&#10;    await api.delete(`/posts/${postId}`);&#10;  },&#10;&#10;  // Search posts&#10;  async searchPosts(query: string, page = 0, size = 10): Promise&lt;PaginatedResponse&lt;Post&gt;&gt; {&#10;    return this.getPosts(page, size, 'createdAt', 'desc', undefined, undefined, query);&#10;  },&#10;&#10;  // Get posts by category&#10;  async getPostsByCategory(category: string, page = 0, size = 10): Promise&lt;PaginatedResponse&lt;Post&gt;&gt; {&#10;    return this.getPosts(page, size, 'createdAt', 'desc', undefined, category);&#10;  },&#10;&#10;  // INTERACTION METHODS&#10;&#10;  // Create interaction (like, share, bookmark)&#10;  async createInteraction(postId: string, interactionData: CreateInteractionRequest): Promise&lt;Interaction | null&gt; {&#10;    const response = await api.post(`/posts/${postId}/interactions`, interactionData);&#10;    console.log(&quot;Created interaction:&quot;, response.data);&#10;    return response.data;&#10;  },&#10;&#10;  // Like/Unlike post&#10;  async toggleLike(postId: string): Promise&lt;Interaction | null&gt; {&#10;    return this.createInteraction(postId, {&#10;      type: InteractionType.LIKE,&#10;      reactionType: ReactionType.LIKE&#10;    });&#10;  },&#10;&#10;  // Share post&#10;  async sharePost(postId: string): Promise&lt;Interaction | null&gt; {&#10;    return this.createInteraction(postId, {&#10;      type: InteractionType.SHARE&#10;    });&#10;  },&#10;&#10;  // Bookmark post&#10;  async toggleBookmark(postId: string): Promise&lt;Interaction | null&gt; {&#10;    return this.createInteraction(postId, {&#10;      type: InteractionType.BOOKMARK,&#10;      reactionType: ReactionType.BOOKMARK&#10;    });&#10;  },&#10;&#10;  // Check if user has liked post&#10;  async hasUserLikedPost(postId: string): Promise&lt;boolean&gt; {&#10;    const response = await api.get(`/posts/${postId}/likes/check`);&#10;    return response.data;&#10;  },&#10;&#10;  // Get top viewed posts&#10;  async getTopViewedPosts(): Promise&lt;Post[]&gt; {&#10;    const response = await api.get('/posts/top-viewed');&#10;    return response.data;&#10;  },&#10;&#10;  // Get top liked posts&#10;  async getTopLikedPosts(): Promise&lt;Post[]&gt; {&#10;    const response = await api.get('/posts/top-liked');&#10;    return response.data;&#10;  },&#10;&#10;  // INTERACTION STATUS METHODS (New - for persistent state)&#10;&#10;  // Check interaction status for a post&#10;  async getInteractionStatus(postId: string): Promise&lt;{&#10;    postId: string;&#10;    userId: string;&#10;    hasLiked: boolean;&#10;    hasBookmarked: boolean;&#10;    interactions: { LIKE: boolean; BOOKMARK: boolean };&#10;  }&gt; {&#10;    const response = await api.get(`/posts/${postId}/interactions/status`);&#10;    return response.data;&#10;  },&#10;&#10;  // Check like status specifically&#10;  async checkLikeStatus(postId: string): Promise&lt;{&#10;    postId: string;&#10;    hasLiked: boolean;&#10;    userId: string;&#10;  }&gt; {&#10;    const response = await api.get(`/posts/${postId}/interactions/like/status`);&#10;    return response.data;&#10;  },&#10;&#10;  // Check bookmark status specifically&#10;  async checkBookmarkStatus(postId: string): Promise&lt;{&#10;    postId: string;&#10;    hasBookmarked: boolean;&#10;    userId: string;&#10;  }&gt; {&#10;    const response = await api.get(`/posts/${postId}/interactions/bookmark/status`);&#10;    return response.data;&#10;  },&#10;&#10;  // COMMENT METHODS (Missing)&#10;&#10;  // Get comments for a post&#10;  async getComments(postId: string, page = 0, size = 10): Promise&lt;PaginatedResponse&lt;Comment&gt;&gt; {&#10;    const params = new URLSearchParams({&#10;      page: page.toString(),&#10;      size: size.toString(),&#10;    });&#10;&#10;    const response = await api.get(`/posts/${postId}/comments?${params.toString()}`);&#10;    return response.data;&#10;  },&#10;&#10;  // Create a comment&#10;  async createComment(postId: string, commentData: CreateCommentRequest): Promise&lt;Comment&gt; {&#10;    const response = await api.post(`/posts/${postId}/comments`, commentData);&#10;    return response.data;&#10;  }&#10;};&#10;" />
              <option name="updatedContent" value="import api from '@/lib/api';&#10;import { mediaService, MediaResponse } from './mediaService';&#10;import {&#10;  Post,&#10;  Comment,&#10;  CreatePostRequest,&#10;  UpdatePostRequest,&#10;  CreateCommentRequest,&#10;  CreateInteractionRequest,&#10;  Interaction,&#10;  PaginatedResponse,&#10;  InteractionType,&#10;  ReactionType&#10;} from '@/types';&#10;&#10;export const postService = {&#10;  // Create post with proper structure matching backend&#10;  async createPost(postData: CreatePostRequest, files?: File[]): Promise&lt;Post&gt; {&#10;    try {&#10;      let mediaUrls: string[] = [];&#10;&#10;      // Step 1: Upload files to media service first if files exist&#10;      if (files &amp;&amp; files.length &gt; 0) {&#10;        console.log('Uploading files to media service...');&#10;        const mediaResponses: MediaResponse[] = await mediaService.uploadFiles(&#10;          files,&#10;          'Post media files'&#10;        );&#10;&#10;        // Extract cloudinary URLs from media responses&#10;        mediaUrls = mediaResponses.map(media =&gt; media.cloudinaryUrl);&#10;        console.log('Files uploaded successfully:', mediaUrls);&#10;      }&#10;&#10;      // Step 2: Create post data with media URLs&#10;      const postRequestData = {&#10;        ...postData,&#10;        images: mediaUrls.length &gt; 0 ? mediaUrls : undefined&#10;      };&#10;      console.log('Uploading post request...', postRequestData);&#10;      // Step 3: Create post via post service&#10;      const response = await api.post('/posts', postRequestData, {&#10;        headers: {&#10;          'Content-Type': 'application/json',&#10;        },&#10;      });&#10;&#10;      return response.data;&#10;    } catch (error) {&#10;      console.error('Error creating post:', error);&#10;      throw error;&#10;    }&#10;  },&#10;&#10;  // Get paginated posts&#10;  async getPosts(&#10;    page = 0,&#10;    size = 10,&#10;    sortBy = 'createdAt',&#10;    sortDir = 'desc',&#10;    authorId?: string,&#10;    category?: string,&#10;    search?: string&#10;  ): Promise&lt;PaginatedResponse&lt;Post&gt;&gt; {&#10;    const params = new URLSearchParams({&#10;      page: page.toString(),&#10;      size: size.toString(),&#10;      sortBy,&#10;      sortDir,&#10;    });&#10;&#10;    if (authorId) params.append('authorId', authorId);&#10;    if (category) params.append('category', category);&#10;    if (search) params.append('search', search);&#10;&#10;    const response = await api.get(`/posts?${params.toString()}`);&#10;    console.log(&quot;Fetched posts:&quot;, response.data);&#10;    return response.data;&#10;  },&#10;&#10;  // Get single post by ID&#10;  async getPost(postId: string): Promise&lt;Post&gt; {&#10;    const response = await api.get(`/posts/${postId}`);&#10;    return response.data;&#10;  },&#10;&#10;  // Get posts by author&#10;  async getUserPosts(authorId: string, page = 0, size = 10): Promise&lt;PaginatedResponse&lt;Post&gt;&gt; {&#10;    return this.getPosts(page, size, 'createdAt', 'desc', authorId);&#10;  },&#10;&#10;  // Update post&#10;  async updatePost(postId: string, updateData: UpdatePostRequest): Promise&lt;Post&gt; {&#10;    const response = await api.put(`/posts/${postId}`, updateData);&#10;    return response.data;&#10;  },&#10;&#10;  // Delete post&#10;  async deletePost(postId: string): Promise&lt;void&gt; {&#10;    await api.delete(`/posts/${postId}`);&#10;  },&#10;&#10;  // Search posts&#10;  async searchPosts(query: string, page = 0, size = 10): Promise&lt;PaginatedResponse&lt;Post&gt;&gt; {&#10;    return this.getPosts(page, size, 'createdAt', 'desc', undefined, undefined, query);&#10;  },&#10;&#10;  // Get posts by category&#10;  async getPostsByCategory(category: string, page = 0, size = 10): Promise&lt;PaginatedResponse&lt;Post&gt;&gt; {&#10;    return this.getPosts(page, size, 'createdAt', 'desc', undefined, category);&#10;  },&#10;&#10;  // INTERACTION METHODS&#10;&#10;  // Create interaction (like, share, bookmark)&#10;  async createInteraction(postId: string, interactionData: CreateInteractionRequest): Promise&lt;Interaction | null&gt; {&#10;    const response = await api.post(`/posts/${postId}/interactions`, interactionData);&#10;    console.log(&quot;Created interaction:&quot;, response.data);&#10;    return response.data;&#10;  },&#10;&#10;  // Like/Unlike post&#10;  async toggleLike(postId: string): Promise&lt;Interaction | null&gt; {&#10;    return this.createInteraction(postId, {&#10;      type: InteractionType.LIKE,&#10;      reactionType: ReactionType.LIKE&#10;    });&#10;  },&#10;&#10;  // Share post&#10;  async sharePost(postId: string): Promise&lt;Interaction | null&gt; {&#10;    return this.createInteraction(postId, {&#10;      type: InteractionType.SHARE&#10;    });&#10;  },&#10;&#10;  // Bookmark post&#10;  async toggleBookmark(postId: string): Promise&lt;Interaction | null&gt; {&#10;    return this.createInteraction(postId, {&#10;      type: InteractionType.BOOKMARK,&#10;      reactionType: ReactionType.BOOKMARK&#10;    });&#10;  },&#10;&#10;  // Check if user has liked post&#10;  async hasUserLikedPost(postId: string): Promise&lt;boolean&gt; {&#10;    const response = await api.get(`/posts/${postId}/likes/check`);&#10;    return response.data;&#10;  },&#10;&#10;  // Get top viewed posts&#10;  async getTopViewedPosts(): Promise&lt;Post[]&gt; {&#10;    const response = await api.get('/posts/top-viewed');&#10;    return response.data;&#10;  },&#10;&#10;  // Get top liked posts&#10;  async getTopLikedPosts(): Promise&lt;Post[]&gt; {&#10;    const response = await api.get('/posts/top-liked');&#10;    return response.data;&#10;  },&#10;&#10;  // INTERACTION STATUS METHODS (New - for persistent state)&#10;&#10;  // Check interaction status for a post&#10;  async getInteractionStatus(postId: string): Promise&lt;{&#10;    postId: string;&#10;    userId: string;&#10;    hasLiked: boolean;&#10;    hasBookmarked: boolean;&#10;    interactions: { LIKE: boolean; BOOKMARK: boolean };&#10;  }&gt; {&#10;    const response = await api.get(`/posts/${postId}/interactions/status`);&#10;    return response.data;&#10;  },&#10;&#10;  // Check like status specifically&#10;  async checkLikeStatus(postId: string): Promise&lt;{&#10;    postId: string;&#10;    hasLiked: boolean;&#10;    userId: string;&#10;  }&gt; {&#10;    const response = await api.get(`/posts/${postId}/interactions/like/status`);&#10;    return response.data;&#10;  },&#10;&#10;  // Check bookmark status specifically&#10;  async checkBookmarkStatus(postId: string): Promise&lt;{&#10;    postId: string;&#10;    hasBookmarked: boolean;&#10;    userId: string;&#10;  }&gt; {&#10;    const response = await api.get(`/posts/${postId}/interactions/bookmark/status`);&#10;    return response.data;&#10;  },&#10;&#10;  // COMMENT METHODS (Missing)&#10;&#10;  // Get comments for a post&#10;  async getComments(postId: string, page = 0, size = 10): Promise&lt;PaginatedResponse&lt;Comment&gt;&gt; {&#10;    const params = new URLSearchParams({&#10;      page: page.toString(),&#10;      size: size.toString(),&#10;    });&#10;&#10;    const response = await api.get(`/posts/${postId}/comments?${params.toString()}`);&#10;    return response.data;&#10;  },&#10;&#10;  // Create a comment&#10;  async createComment(postId: string, commentData: CreateCommentRequest): Promise&lt;Comment&gt; {&#10;    const response = await api.post(`/posts/${postId}/comments`, commentData);&#10;    return response.data;&#10;  }&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/client-frontend/src/shared/config/api-client.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/client-frontend/src/shared/config/api-client.ts" />
              <option name="updatedContent" value="import axios, { AxiosInstance, AxiosRequestConfig, AxiosResponse } from 'axios';&#10;import { API_ENDPOINTS } from '../constants';&#10;&#10;// API Client Configuration&#10;export class ApiClient {&#10;  private instance: AxiosInstance;&#10;&#10;  constructor() {&#10;    this.instance = axios.create({&#10;      baseURL: API_ENDPOINTS.BASE_URL,&#10;      timeout: 10000,&#10;      headers: {&#10;        'Content-Type': 'application/json',&#10;      },&#10;    });&#10;&#10;    this.setupInterceptors();&#10;  }&#10;&#10;  private setupInterceptors() {&#10;    // Request interceptor to add auth token&#10;    this.instance.interceptors.request.use(&#10;      (config) =&gt; {&#10;        const token = this.getAuthToken();&#10;        if (token) {&#10;          config.headers.Authorization = `Bearer ${token}`;&#10;        }&#10;        return config;&#10;      },&#10;      (error) =&gt; Promise.reject(error)&#10;    );&#10;&#10;    // Response interceptor for error handling&#10;    this.instance.interceptors.response.use(&#10;      (response) =&gt; response.data,&#10;      (error) =&gt; {&#10;        if (error.response?.status === 401) {&#10;          this.handleUnauthorized();&#10;        }&#10;        return Promise.reject(error);&#10;      }&#10;    );&#10;  }&#10;&#10;  private getAuthToken(): string | null {&#10;    if (typeof window !== 'undefined') {&#10;      return localStorage.getItem('auth_token');&#10;    }&#10;    return null;&#10;  }&#10;&#10;  private handleUnauthorized() {&#10;    if (typeof window !== 'undefined') {&#10;      localStorage.removeItem('auth_token');&#10;      window.location.href = '/auth/login';&#10;    }&#10;  }&#10;&#10;  // HTTP Methods&#10;  async get&lt;T = any&gt;(url: string, config?: AxiosRequestConfig): Promise&lt;T&gt; {&#10;    return this.instance.get(url, config);&#10;  }&#10;&#10;  async post&lt;T = any&gt;(url: string, data?: any, config?: AxiosRequestConfig): Promise&lt;T&gt; {&#10;    return this.instance.post(url, data, config);&#10;  }&#10;&#10;  async put&lt;T = any&gt;(url: string, data?: any, config?: AxiosRequestConfig): Promise&lt;T&gt; {&#10;    return this.instance.put(url, data, config);&#10;  }&#10;&#10;  async patch&lt;T = any&gt;(url: string, data?: any, config?: AxiosRequestConfig): Promise&lt;T&gt; {&#10;    return this.instance.patch(url, data, config);&#10;  }&#10;&#10;  async delete&lt;T = any&gt;(url: string, config?: AxiosRequestConfig): Promise&lt;T&gt; {&#10;    return this.instance.delete(url, config);&#10;  }&#10;}&#10;&#10;// Export singleton instance&#10;export const apiClient = new ApiClient();" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/client-frontend/src/shared/constants/api-endpoints.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/client-frontend/src/shared/constants/api-endpoints.ts" />
              <option name="updatedContent" value="// API Endpoints Constants for Client-Frontend&#10;export const API_ENDPOINTS = {&#10;  // Base URLs for services&#10;  BASE_URL: process.env.NEXT_PUBLIC_API_URL || 'http://localhost:8080',&#10;  &#10;  // Authentication endpoints&#10;  AUTH: {&#10;    BASE: '/api/auth',&#10;    LOGIN: '/api/auth/login',&#10;    REGISTER: '/api/auth/register',&#10;    REFRESH: '/api/auth/refresh',&#10;    LOGOUT: '/api/auth/logout',&#10;    VERIFY_EMAIL: '/api/auth/verify-email',&#10;    FORGOT_PASSWORD: '/api/auth/forgot-password',&#10;    RESET_PASSWORD: '/api/auth/reset-password',&#10;    PROFILE: '/api/auth/profile'&#10;  },&#10;&#10;  // User management endpoints&#10;  USERS: {&#10;    BASE: '/api/users',&#10;    PROFILE: '/api/users/profile',&#10;    BY_ID: '/api/users/:id',&#10;    UPDATE_PROFILE: '/api/users/profile',&#10;    SEARCH: '/api/users/search',&#10;    FRIENDS: '/api/users/:id/friends',&#10;    FRIEND_SUGGESTIONS: '/api/users/friend-suggestions',&#10;    SEND_FRIEND_REQUEST: '/api/users/:id/friend-request',&#10;    ACCEPT_FRIEND_REQUEST: '/api/users/:id/accept-friend',&#10;    MUTUAL_FRIENDS: '/api/users/:id/mutual-friends-count',&#10;    TIMELINE: '/api/users/:id/timeline',&#10;    ACTIVITIES: '/api/users/:id/activities'&#10;  },&#10;&#10;  // Post management endpoints&#10;  POSTS: {&#10;    BASE: '/api/posts',&#10;    BY_ID: '/api/posts/:id',&#10;    BY_USER: '/api/posts/user/:userId',&#10;    FEED: '/api/posts/feed',&#10;    TRENDING: '/api/posts/trending',&#10;    TIMELINE: '/api/posts/timeline/:userId',&#10;    SEARCH: '/api/posts/search',&#10;    LIKE: '/api/posts/:id/interact',&#10;    COMMENTS: '/api/posts/:id/comments',&#10;    COMMENT_LIKE: '/api/posts/comments/:id/like',&#10;    SCHEDULE: '/api/posts/schedule',&#10;    ANALYTICS: '/api/posts/:id/analytics'&#10;  },&#10;&#10;  // Chat endpoints&#10;  CHAT: {&#10;    BASE: '/api/chat',&#10;    ROOMS: '/api/chat/rooms',&#10;    MESSAGES: '/api/chat/rooms/:roomId/messages',&#10;    SEND_MESSAGE: '/api/chat/rooms/:roomId/messages'&#10;  },&#10;&#10;  // Media endpoints&#10;  MEDIA: {&#10;    BASE: '/api/media',&#10;    UPLOAD: '/api/media/upload',&#10;    BY_ID: '/api/media/:id'&#10;  },&#10;&#10;  // Notification endpoints&#10;  NOTIFICATIONS: {&#10;    BASE: '/api/notifications',&#10;    UNREAD_COUNT: '/api/notifications/unread-count',&#10;    MARK_READ: '/api/notifications/:id/read',&#10;    MARK_ALL_READ: '/api/notifications/mark-all-read'&#10;  },&#10;&#10;  // Analytics endpoints&#10;  ANALYTICS: {&#10;    BASE: '/api/analytics',&#10;    USER_STATS: '/api/analytics/users/:id/stats',&#10;    POST_STATS: '/api/analytics/posts/:id/stats'&#10;  }&#10;};&#10;&#10;// API Response types&#10;export interface ApiResponse&lt;T = any&gt; {&#10;  success: boolean;&#10;  data?: T;&#10;  message?: string;&#10;  errors?: string[];&#10;}&#10;&#10;export interface PaginatedResponse&lt;T = any&gt; {&#10;  content: T[];&#10;  totalElements: number;&#10;  totalPages: number;&#10;  size: number;&#10;  number: number;&#10;  first: boolean;&#10;  last: boolean;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/client-frontend/src/shared/constants/index.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/client-frontend/src/shared/constants/index.ts" />
              <option name="updatedContent" value="export * from './api-endpoints';&#10;&#10;// Re-export for backward compatibility&#10;export { API_ENDPOINTS } from './api-endpoints';" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/client-frontend/src/shared/services/post.service.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/client-frontend/src/shared/services/post.service.ts" />
              <option name="originalContent" value="import { apiClient } from '@/shared/config/api-client';&#10;import { API_ENDPOINTS } from '@/shared/constants';&#10;import { createApiUrl } from '@/shared/utils';&#10;import {&#10;  Post,&#10;  Comment,&#10;  CreatePostRequest,&#10;  UpdatePostRequest,&#10;  CreateCommentRequest,&#10;  UpdateCommentRequest,&#10;  PaginatedResponse,&#10;  ApiResponse,&#10;  PostVisibility,&#10;} from '@/shared/types';&#10;&#10;/**&#10; * Post Service&#10; * Handles all post-related API calls&#10; * Handles all post-related API calls&#10; */&#10;export class PostService {&#10;   * Create new post&#10;   * Create new post&#10;    const formData = new FormData();&#10;    formData.append('content', postData.content);&#10;&#10;    if (postData.visibility) {&#10;      formData.append('visibility', postData.visibility);&#10;    }&#10;    formData.append('content', postData.content);&#10;    if (postData.tags) {&#10;      postData.tags.forEach(tag =&gt; formData.append('tags', tag));&#10;    }&#10;&#10;    if (postData.images) {&#10;      postData.images.forEach(image =&gt; formData.append('images', image));&#10;    }&#10;&#10;    return apiClient.post&lt;Post&gt;(API_ENDPOINTS.POSTS.BASE, formData, {&#10;      headers: {&#10;        'Content-Type': 'multipart/form-data',&#10;      },&#10;    });&#10;      postData.tags.forEach(tag =&gt; formData.append('tags', tag));&#10;    }&#10;&#10;    if (postData.images) {&#10;      postData.images.forEach(image =&gt; formData.append('images', image));&#10;    }&#10;&#10;    return apiClient.post&lt;Post&gt;(API_ENDPOINTS.POSTS.BASE, formData, {&#10;      headers: {&#10;        'Content-Type': 'multipart/form-data',&#10;      },&#10;    });&#10;  }&#10;&#10;  /**&#10;   * Get posts feed&#10;   */&#10;  async getPosts(page = 0, size = 10): Promise&lt;PaginatedResponse&lt;Post&gt;&gt; {&#10;    const url = createApiUrl(API_ENDPOINTS.POSTS.BASE, undefined, { page, size });&#10;    return apiClient.get&lt;PaginatedResponse&lt;Post&gt;&gt;(url);&#10;  }&#10;&#10;  /**&#10;   * Get single post by ID&#10;   */&#10;  async getPost(postId: string): Promise&lt;Post&gt; {&#10;    const url = createApiUrl(API_ENDPOINTS.POSTS.BASE + '/:id', { id: postId });&#10;    return apiClient.get&lt;Post&gt;(url);&#10;  }&#10;&#10;  /**&#10;   * Get posts by user&#10;   */&#10;  async getUserPosts(&#10;    userId: string,&#10;    page = 0,&#10;    size = 10&#10;  ): Promise&lt;PaginatedResponse&lt;Post&gt;&gt; {&#10;    const url = createApiUrl(&#10;      API_ENDPOINTS.POSTS.BY_USER,&#10;      { id: userId },&#10;      { page, size }&#10;    );&#10;    return apiClient.get&lt;PaginatedResponse&lt;Post&gt;&gt;(url);&#10;  }&#10;&#10;  /**&#10;   * Update post&#10;   */&#10;  async updatePost(postId: string, updateData: UpdatePostRequest): Promise&lt;Post&gt; {&#10;    const url = createApiUrl(API_ENDPOINTS.POSTS.BASE + '/:id', { id: postId });&#10;    return apiClient.put&lt;Post&gt;(url, updateData);&#10;  }&#10;&#10;  /**&#10;   * Delete post&#10;   */&#10;  async deletePost(postId: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#10;    const url = createApiUrl(API_ENDPOINTS.POSTS.BASE + '/:id', { id: postId });&#10;    return apiClient.delete&lt;ApiResponse&lt;null&gt;&gt;(url);&#10;  }&#10;&#10;  /**&#10;   * Like post&#10;   */&#10;  async likePost(postId: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#10;    const url = createApiUrl(API_ENDPOINTS.POSTS.LIKE, { id: postId });&#10;    return apiClient.post&lt;ApiResponse&lt;null&gt;&gt;(url);&#10;  }&#10;&#10;  /**&#10;   * Unlike post&#10;   */&#10;  async unlikePost(postId: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#10;    const url = createApiUrl(API_ENDPOINTS.POSTS.LIKE, { id: postId });&#10;    return apiClient.delete&lt;ApiResponse&lt;null&gt;&gt;(url);&#10;  }&#10;&#10;  /**&#10;   * Get post comments&#10;   */&#10;  async getComments(&#10;    postId: string,&#10;    page = 0,&#10;    size = 10&#10;  ): Promise&lt;PaginatedResponse&lt;Comment&gt;&gt; {&#10;    const url = createApiUrl(&#10;      API_ENDPOINTS.POSTS.COMMENTS,&#10;      { id: postId },&#10;      { page, size }&#10;    );&#10;    return apiClient.get&lt;PaginatedResponse&lt;Comment&gt;&gt;(url);&#10;  }&#10;&#10;  /**&#10;   * Create comment&#10;   */&#10;  async createComment(commentData: CreateCommentRequest): Promise&lt;Comment&gt; {&#10;    const url = createApiUrl(API_ENDPOINTS.POSTS.COMMENTS, { id: commentData.postId });&#10;    return apiClient.post&lt;Comment&gt;(url, {&#10;      content: commentData.content,&#10;      parentId: commentData.parentId,&#10;    });&#10;  }&#10;&#10;  /**&#10;   * Update comment&#10;   */&#10;  async updateComment(&#10;    commentId: string,&#10;    updateData: UpdateCommentRequest&#10;  ): Promise&lt;Comment&gt; {&#10;    const url = createApiUrl('/comments/:id', { id: commentId });&#10;    return apiClient.put&lt;Comment&gt;(url, updateData);&#10;  }&#10;&#10;  /**&#10;   * Delete comment&#10;   */&#10;  async deleteComment(commentId: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#10;    const url = createApiUrl('/comments/:id', { id: commentId });&#10;    return apiClient.delete&lt;ApiResponse&lt;null&gt;&gt;(url);&#10;  }&#10;&#10;  /**&#10;   * Like comment&#10;   */&#10;  async likeComment(commentId: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#10;    const url = createApiUrl(API_ENDPOINTS.POSTS.COMMENT_LIKE, { id: commentId });&#10;    return apiClient.post&lt;ApiResponse&lt;null&gt;&gt;(url);&#10;  }&#10;&#10;  /**&#10;   * Unlike comment&#10;   */&#10;  async unlikeComment(commentId: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#10;    const url = createApiUrl(API_ENDPOINTS.POSTS.COMMENT_LIKE, { id: commentId });&#10;    return apiClient.delete&lt;ApiResponse&lt;null&gt;&gt;(url);&#10;  }&#10;&#10;  /**&#10;   * Share post&#10;   */&#10;  async sharePost(postId: string, content?: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#10;    const url = createApiUrl('/posts/:id/share', { id: postId });&#10;    return apiClient.post&lt;ApiResponse&lt;null&gt;&gt;(url, { content });&#10;  }&#10;&#10;  /**&#10;   * Bookmark post&#10;   */&#10;  async bookmarkPost(postId: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#10;    const url = createApiUrl('/posts/:id/bookmark', { id: postId });&#10;    return apiClient.post&lt;ApiResponse&lt;null&gt;&gt;(url);&#10;  }&#10;&#10;  /**&#10;   * Remove bookmark&#10;   */&#10;  async removeBookmark(postId: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#10;    const url = createApiUrl('/posts/:id/bookmark', { id: postId });&#10;    return apiClient.delete&lt;ApiResponse&lt;null&gt;&gt;(url);&#10;  }&#10;}&#10;&#10;// Export singleton instance&#10;export const postService = new PostService();&#10;" />
              <option name="updatedContent" value="import { apiClient } from '@/shared/config/api-client';&#13;&#10;import { API_ENDPOINTS } from '@/shared/constants';&#13;&#10;import { createApiUrl } from '@/shared/utils';&#13;&#10;import {&#13;&#10;  Post,&#13;&#10;  Comment,&#13;&#10;  CreatePostRequest,&#13;&#10;  UpdatePostRequest,&#13;&#10;  CreateCommentRequest,&#13;&#10;  UpdateCommentRequest,&#13;&#10;  PaginatedResponse,&#13;&#10;  ApiResponse,&#13;&#10;  PostVisibility,&#13;&#10;} from '@/shared/types';&#13;&#10;&#13;&#10;/**&#13;&#10; * Post Service - Updated to sync with backend APIs&#13;&#10; */&#13;&#10;export class PostService {&#13;&#10;  /**&#13;&#10;   * Create new post - Updated to match EnhancedPostController&#13;&#10;   */&#13;&#10;  async createPost(postData: CreatePostRequest): Promise&lt;Post&gt; {&#13;&#10;    // Use JSON instead of FormData to match EnhancedPostController&#13;&#10;    return apiClient.post&lt;Post&gt;(API_ENDPOINTS.POSTS.BASE, postData);&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Get personalized feed - Updated to match backend&#13;&#10;   */&#13;&#10;  async getPersonalizedFeed(page = 0, size = 10): Promise&lt;Post[]&gt; {&#13;&#10;    const url = createApiUrl(API_ENDPOINTS.POSTS.FEED, undefined, { page, size });&#13;&#10;    return apiClient.get&lt;Post[]&gt;(url);&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Get posts feed&#13;&#10;   */&#13;&#10;  async getPosts(page = 0, size = 10): Promise&lt;PaginatedResponse&lt;Post&gt;&gt; {&#13;&#10;    const url = createApiUrl(API_ENDPOINTS.POSTS.BASE, undefined, { page, size });&#13;&#10;    return apiClient.get&lt;PaginatedResponse&lt;Post&gt;&gt;(url);&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Get single post by ID&#13;&#10;   */&#13;&#10;  async getPost(postId: string): Promise&lt;Post&gt; {&#13;&#10;    const url = createApiUrl(API_ENDPOINTS.POSTS.BASE + '/:id', { id: postId });&#13;&#10;    return apiClient.get&lt;Post&gt;(url);&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Get posts by user&#13;&#10;   */&#13;&#10;  async getUserPosts(&#13;&#10;    userId: string,&#13;&#10;    page = 0,&#13;&#10;    size = 10&#13;&#10;  ): Promise&lt;PaginatedResponse&lt;Post&gt;&gt; {&#13;&#10;    const url = createApiUrl(&#13;&#10;      API_ENDPOINTS.POSTS.BY_USER,&#13;&#10;      { id: userId },&#13;&#10;      { page, size }&#13;&#10;    );&#13;&#10;    return apiClient.get&lt;PaginatedResponse&lt;Post&gt;&gt;(url);&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Update post&#13;&#10;   */&#13;&#10;  async updatePost(postId: string, updateData: UpdatePostRequest): Promise&lt;Post&gt; {&#13;&#10;    const url = createApiUrl(API_ENDPOINTS.POSTS.BASE + '/:id', { id: postId });&#13;&#10;    return apiClient.put&lt;Post&gt;(url, updateData);&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Delete post&#13;&#10;   */&#13;&#10;  async deletePost(postId: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#13;&#10;    const url = createApiUrl(API_ENDPOINTS.POSTS.BASE + '/:id', { id: postId });&#13;&#10;    return apiClient.delete&lt;ApiResponse&lt;null&gt;&gt;(url);&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Like post&#13;&#10;   */&#13;&#10;  async likePost(postId: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#13;&#10;    const url = createApiUrl(API_ENDPOINTS.POSTS.LIKE, { id: postId });&#13;&#10;    return apiClient.post&lt;ApiResponse&lt;null&gt;&gt;(url);&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Unlike post&#13;&#10;   */&#13;&#10;  async unlikePost(postId: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#13;&#10;    const url = createApiUrl(API_ENDPOINTS.POSTS.LIKE, { id: postId });&#13;&#10;    return apiClient.delete&lt;ApiResponse&lt;null&gt;&gt;(url);&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Get post comments&#13;&#10;   */&#13;&#10;  async getComments(&#13;&#10;    postId: string,&#13;&#10;    page = 0,&#13;&#10;    size = 10&#13;&#10;  ): Promise&lt;PaginatedResponse&lt;Comment&gt;&gt; {&#13;&#10;    const url = createApiUrl(&#13;&#10;      API_ENDPOINTS.POSTS.COMMENTS,&#13;&#10;      { id: postId },&#13;&#10;      { page, size }&#13;&#10;    );&#13;&#10;    return apiClient.get&lt;PaginatedResponse&lt;Comment&gt;&gt;(url);&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Create comment&#13;&#10;   */&#13;&#10;  async createComment(commentData: CreateCommentRequest): Promise&lt;Comment&gt; {&#13;&#10;    const url = createApiUrl(API_ENDPOINTS.POSTS.COMMENTS, { id: commentData.postId });&#13;&#10;    return apiClient.post&lt;Comment&gt;(url, {&#13;&#10;      content: commentData.content,&#13;&#10;      parentId: commentData.parentId,&#13;&#10;    });&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Update comment&#13;&#10;   */&#13;&#10;  async updateComment(&#13;&#10;    commentId: string,&#13;&#10;    updateData: UpdateCommentRequest&#13;&#10;  ): Promise&lt;Comment&gt; {&#13;&#10;    const url = createApiUrl('/comments/:id', { id: commentId });&#13;&#10;    return apiClient.put&lt;Comment&gt;(url, updateData);&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Delete comment&#13;&#10;   */&#13;&#10;  async deleteComment(commentId: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#13;&#10;    const url = createApiUrl('/comments/:id', { id: commentId });&#13;&#10;    return apiClient.delete&lt;ApiResponse&lt;null&gt;&gt;(url);&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Like comment&#13;&#10;   */&#13;&#10;  async likeComment(commentId: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#13;&#10;    const url = createApiUrl(API_ENDPOINTS.POSTS.COMMENT_LIKE, { id: commentId });&#13;&#10;    return apiClient.post&lt;ApiResponse&lt;null&gt;&gt;(url);&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Unlike comment&#13;&#10;   */&#13;&#10;  async unlikeComment(commentId: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#13;&#10;    const url = createApiUrl(API_ENDPOINTS.POSTS.COMMENT_LIKE, { id: commentId });&#13;&#10;    return apiClient.delete&lt;ApiResponse&lt;null&gt;&gt;(url);&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Share post&#13;&#10;   */&#13;&#10;  async sharePost(postId: string, content?: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#13;&#10;    const url = createApiUrl('/posts/:id/share', { id: postId });&#13;&#10;    return apiClient.post&lt;ApiResponse&lt;null&gt;&gt;(url, { content });&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Bookmark post&#13;&#10;   */&#13;&#10;  async bookmarkPost(postId: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#13;&#10;    const url = createApiUrl('/posts/:id/bookmark', { id: postId });&#13;&#10;    return apiClient.post&lt;ApiResponse&lt;null&gt;&gt;(url);&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Remove bookmark&#13;&#10;   */&#13;&#10;  async removeBookmark(postId: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#13;&#10;    const url = createApiUrl('/posts/:id/bookmark', { id: postId });&#13;&#10;    return apiClient.delete&lt;ApiResponse&lt;null&gt;&gt;(url);&#13;&#10;  }&#13;&#10;}&#13;&#10;&#13;&#10;// Export singleton instance&#13;&#10;export const postService = new PostService();" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/client-frontend/src/shared/services/user.service.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/client-frontend/src/shared/services/user.service.ts" />
              <option name="originalContent" value="import { apiClient } from '@/shared/config/api-client';&#10;import { API_ENDPOINTS } from '@/shared/constants';&#10;import { createApiUrl } from '@/shared/utils';&#10;import {&#10;  User,&#10;  UpdateUserRequest,&#10;  ApiResponse,&#10;  UserStats,&#10;  UserStats,&#10;  FileUploadResponse,&#10;  FileUploadResponse,&#10;} from '@/shared/types';&#10;&#10;/**&#10; * User Service&#10; * Handles all user-related API calls&#10; * Handles all user-related API calls&#10;   * Get user profile by ID&#10;  async getUserProfile(userId: string): Promise&lt;User&gt; {&#10;    const url = createApiUrl(API_ENDPOINTS.USERS.PROFILE, { id: userId });&#10;  /**&#10;   * Update current user profile&#10;   */&#10;  async updateProfile(userData: UpdateUserRequest): Promise&lt;User&gt; {&#10;   * Update current user profile&#10;   */&#10;  async updateProfile(userData: UpdateUserRequest): Promise&lt;User&gt; {&#10;    return apiClient.put&lt;User&gt;(API_ENDPOINTS.USERS.PROFILE, userData);&#10;  }&#10;&#10;  /**&#10;   * Upload user avatar&#10;  }&#10;&#10;  /**&#10;   * Upload user avatar&#10;   */&#10;  async uploadAvatar(&#10;   * Search users&#10;    onProgress?: (progress: number) =&gt; void&#10;  async uploadAvatar(&#10;    file: File,&#10;    onProgress?: (progress: number) =&gt; void&#10;  ): Promise&lt;FileUploadResponse&gt; {&#10;    return apiClient.uploadFile&lt;FileUploadResponse&gt;(&#10;      API_ENDPOINTS.USERS.AVATAR,&#10;    size = 10&#10;  ): Promise&lt;PaginatedResponse&lt;User&gt;&gt; {&#10;    );&#10;      q: query,&#10;    return apiClient.get&lt;PaginatedResponse&lt;User&gt;&gt;(url);&#10;      page,&#10;      size,&#10;    });&#10;    return apiClient.get&lt;PaginatedResponse&lt;User&gt;&gt;(url);&#10;  }&#10;&#10;  /**&#10;   * Follow user&#10;   */&#10;   * Follow user&#10;    const url = createApiUrl(API_ENDPOINTS.USERS.FOLLOW, { id: userId });&#10;    return apiClient.post&lt;ApiResponse&lt;null&gt;&gt;(url);&#10;  }&#10;&#10;  /**&#10;   * Unfollow user&#10;   */&#10;  async unfollowUser(userId: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#10;    const url = createApiUrl(API_ENDPOINTS.USERS.FOLLOW, { id: userId });&#10;  async followUser(userId: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#10;    const url = createApiUrl(API_ENDPOINTS.USERS.FOLLOW, { id: userId });&#10;&#10;  /**&#10;   * Get user followers&#10;   */&#10;   * Unfollow user&#10;   */&#10;  async unfollowUser(userId: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#10;    const url = createApiUrl(API_ENDPOINTS.USERS.FOLLOW, { id: userId });&#10;    return apiClient.delete&lt;ApiResponse&lt;null&gt;&gt;(url);&#10;  }&#10;&#10;  /**&#10;   * Get users that user is following&#10;    userId: string,&#10;  async getFollowing(&#10;    userId: string,&#10;    page = 0,&#10;    size = 10&#10;  ): Promise&lt;PaginatedResponse&lt;User&gt;&gt; {&#10;    const url = createApiUrl(&#10;      API_ENDPOINTS.USERS.FOLLOWING,&#10;      { id: userId },&#10;  async getFriends(&#10;    userId: string,&#10;    page = 0,&#10;    size = 10&#10;  ): Promise&lt;PaginatedResponse&lt;User&gt;&gt; {&#10;    const url = createApiUrl(&#10;      API_ENDPOINTS.USERS.FRIENDS,&#10;      { id: userId },&#10;  async getUserStats(userId: string): Promise&lt;UserStats&gt; {&#10;    const url = createApiUrl('/users/:id/stats', { id: userId });&#10;    return apiClient.get&lt;UserStats&gt;(url);&#10;    size = 10&#10;  ): Promise&lt;PaginatedResponse&lt;User&gt;&gt; {&#10;    const url = createApiUrl(&#10;   * Check if user is following another user&#10;      { id: userId },&#10;  async isFollowing(userId: string): Promise&lt;boolean&gt; {&#10;    const url = createApiUrl('/users/:id/following/check', { id: userId });&#10;    const response = await apiClient.get&lt;{ isFollowing: boolean }&gt;(url);&#10;    return response.isFollowing;&#10;    const url = createApiUrl(&#10;      API_ENDPOINTS.USERS.FOLLOWERS,&#10;      { id: userId },&#10;   * Get user friends&#10;    );&#10;    return apiClient.get&lt;PaginatedResponse&lt;User&gt;&gt;(url);&#10;  }&#10;&#10;  /**&#10;   * Get users that user is following&#10;   */&#10;  async getFollowing(&#10;    userId: string,&#10;    page = 0,&#10;    size = 10&#10;  ): Promise&lt;PaginatedResponse&lt;User&gt;&gt; {&#10;    const url = createApiUrl(&#10;      API_ENDPOINTS.USERS.FOLLOWING,&#10;      { id: userId },&#10;      { page, size }&#10;    );&#10;    return apiClient.get&lt;PaginatedResponse&lt;User&gt;&gt;(url);&#10;  }&#10;&#10;  /**&#10;   * Get user friends&#10;   */&#10;  async getFriends(&#10;    userId: string,&#10;    page = 0,&#10;    size = 10&#10;  ): Promise&lt;PaginatedResponse&lt;User&gt;&gt; {&#10;    const url = createApiUrl(&#10;      API_ENDPOINTS.USERS.FRIENDS,&#10;      { id: userId },&#10;      { page, size }&#10;    );&#10;    return apiClient.get&lt;PaginatedResponse&lt;User&gt;&gt;(url);&#10;  }&#10;&#10;  /**&#10;   * Get user statistics&#10;   */&#10;  async getUserStats(userId: string): Promise&lt;UserStats&gt; {&#10;    const url = createApiUrl('/users/:id/stats', { id: userId });&#10;    return apiClient.get&lt;UserStats&gt;(url);&#10;  }&#10;&#10;  /**&#10;   * Check if user is following another user&#10;   */&#10;  async isFollowing(userId: string): Promise&lt;boolean&gt; {&#10;    const url = createApiUrl('/users/:id/following/check', { id: userId });&#10;    const response = await apiClient.get&lt;{ isFollowing: boolean }&gt;(url);&#10;    return response.isFollowing;&#10;  }&#10;}&#10;&#10;// Export singleton instance&#10;export const userService = new UserService();&#10;" />
              <option name="updatedContent" value="import { apiClient } from '@/shared/config/api-client';&#13;&#10;import { API_ENDPOINTS } from '@/shared/constants';&#13;&#10;import { createApiUrl } from '@/shared/utils';&#13;&#10;import {&#13;&#10;  User,&#13;&#10;  UserProfile,&#13;&#10;  UpdateProfileRequest,&#13;&#10;  PaginatedResponse,&#13;&#10;  ApiResponse,&#13;&#10;} from '@/shared/types';&#13;&#10;&#13;&#10;/**&#13;&#10; * User Service - Updated to sync with backend APIs&#13;&#10; */&#13;&#10;export class UserService {&#13;&#10;  /**&#13;&#10;   * Get current user profile&#13;&#10;   */&#13;&#10;  async getCurrentUser(): Promise&lt;User&gt; {&#13;&#10;    return apiClient.get&lt;User&gt;(API_ENDPOINTS.USERS.PROFILE);&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Get user by ID&#13;&#10;   */&#13;&#10;  async getUser(userId: string): Promise&lt;User&gt; {&#13;&#10;    const url = createApiUrl(API_ENDPOINTS.USERS.BY_ID, { id: userId });&#13;&#10;    return apiClient.get&lt;User&gt;(url);&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Update user profile&#13;&#10;   */&#13;&#10;  async updateProfile(updateData: UpdateProfileRequest): Promise&lt;User&gt; {&#13;&#10;    return apiClient.put&lt;User&gt;(API_ENDPOINTS.USERS.UPDATE_PROFILE, updateData);&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Search users - Updated to match EnhancedUserController&#13;&#10;   */&#13;&#10;  async searchUsers(&#13;&#10;    query: string,&#13;&#10;    faculty?: string,&#13;&#10;    major?: string,&#13;&#10;    batch?: string,&#13;&#10;    page = 0,&#13;&#10;    size = 20&#13;&#10;  ): Promise&lt;User[]&gt; {&#13;&#10;    const url = createApiUrl(API_ENDPOINTS.USERS.SEARCH, undefined, {&#13;&#10;      query,&#13;&#10;      faculty,&#13;&#10;      major,&#13;&#10;      batch,&#13;&#10;      page,&#13;&#10;      size,&#13;&#10;    });&#13;&#10;    return apiClient.get&lt;User[]&gt;(url);&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Get friend suggestions - Updated to match backend&#13;&#10;   */&#13;&#10;  async getFriendSuggestions(limit = 10): Promise&lt;any[]&gt; {&#13;&#10;    const url = createApiUrl(API_ENDPOINTS.USERS.FRIEND_SUGGESTIONS, undefined, { limit });&#13;&#10;    return apiClient.get&lt;any[]&gt;(url);&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Send friend request - Updated to match backend&#13;&#10;   */&#13;&#10;  async sendFriendRequest(targetUserId: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#13;&#10;    const url = createApiUrl(API_ENDPOINTS.USERS.SEND_FRIEND_REQUEST, { id: targetUserId });&#13;&#10;    return apiClient.post&lt;ApiResponse&lt;null&gt;&gt;(url);&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Accept friend request - Updated to match backend&#13;&#10;   */&#13;&#10;  async acceptFriendRequest(requesterId: string): Promise&lt;ApiResponse&lt;null&gt;&gt; {&#13;&#10;    const url = createApiUrl(API_ENDPOINTS.USERS.ACCEPT_FRIEND_REQUEST, { id: requesterId });&#13;&#10;    return apiClient.post&lt;ApiResponse&lt;null&gt;&gt;(url);&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Get user's friends&#13;&#10;   */&#13;&#10;  async getFriends(userId: string): Promise&lt;User[]&gt; {&#13;&#10;    const url = createApiUrl(API_ENDPOINTS.USERS.FRIENDS, { id: userId });&#13;&#10;    return apiClient.get&lt;User[]&gt;(url);&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Get mutual friends count - Updated to match backend&#13;&#10;   */&#13;&#10;  async getMutualFriendsCount(targetUserId: string): Promise&lt;number&gt; {&#13;&#10;    const url = createApiUrl(API_ENDPOINTS.USERS.MUTUAL_FRIENDS, { id: targetUserId });&#13;&#10;    return apiClient.get&lt;number&gt;(url);&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Get user timeline - Updated to match backend&#13;&#10;   */&#13;&#10;  async getUserTimeline(userId: string, page = 0, size = 10): Promise&lt;any[]&gt; {&#13;&#10;    const url = createApiUrl(API_ENDPOINTS.USERS.TIMELINE, { id: userId }, { page, size });&#13;&#10;    return apiClient.get&lt;any[]&gt;(url);&#13;&#10;  }&#13;&#10;&#13;&#10;  /**&#13;&#10;   * Get user activities - Updated to match backend&#13;&#10;   */&#13;&#10;  async getUserActivities(userId: string, page = 0, size = 10): Promise&lt;any[]&gt; {&#13;&#10;    const url = createApiUrl(API_ENDPOINTS.USERS.ACTIVITIES, { id: userId }, { page, size });&#13;&#10;    return apiClient.get&lt;any[]&gt;(url);&#13;&#10;  }&#13;&#10;}&#13;&#10;&#13;&#10;// Export singleton instance&#13;&#10;export const userService = new UserService();" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/client/MediaServiceClient.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/client/MediaServiceClient.java" />
              <option name="originalContent" value="package com.ctuconnect.client;&#10;&#10;import lombok.Data;&#10;import org.springframework.cloud.openfeign.FeignClient;&#10;import org.springframework.http.MediaType;&#10;import org.springframework.web.bind.annotation.*;&#10;import org.springframework.web.multipart.MultipartFile;&#10;&#10;&#10;@FeignClient(name = &quot;media-service&quot;, url = &quot;${media-service.url:http://localhost:8080}&quot;)&#10;public interface MediaServiceClient {&#10;&#10;    @PostMapping(value = &quot;/api/media/upload&quot;, consumes = MediaType.MULTIPART_FORM_DATA_VALUE)&#10;    MediaUploadResponse uploadFile(@RequestPart(&quot;file&quot;) MultipartFile file,&#10;                                  @RequestParam(&quot;type&quot;) String type);&#10;&#10;    @DeleteMapping(&quot;/api/media/{id}&quot;)&#10;    void deleteFile(@PathVariable(&quot;id&quot;) String fileId);&#10;&#10;    @GetMapping(&quot;/api/media/{id}&quot;)&#10;    MediaResponse getFileInfo(@PathVariable(&quot;id&quot;) String fileId);&#10;&#10;    // Response DTOs for media service&#10;    class MediaUploadResponse {&#10;        private String id;&#10;        private String fileName;&#10;        private String fileUrl;&#10;        private String fileType;&#10;        private long fileSize;&#10;&#10;        // Getters and Setters&#10;        public String getId() {&#10;            return id;&#10;        }&#10;&#10;        public void setId(String id) {&#10;            this.id = id;&#10;        }&#10;&#10;        public String getFileName() {&#10;            return fileName;&#10;        }&#10;&#10;        public void setFileName(String fileName) {&#10;            this.fileName = fileName;&#10;        }&#10;&#10;        public String getFileUrl() {&#10;            return fileUrl;&#10;        }&#10;&#10;        public void setFileUrl(String fileUrl) {&#10;            this.fileUrl = fileUrl;&#10;        }&#10;&#10;        public String getFileType() {&#10;            return fileType;&#10;        }&#10;&#10;        public void setFileType(String fileType) {&#10;            this.fileType = fileType;&#10;        }&#10;&#10;        public long getFileSize() {&#10;            return fileSize;&#10;        }&#10;&#10;        public void setFileSize(long fileSize) {&#10;            this.fileSize = fileSize;&#10;        }&#10;    }&#10;&#10;    @Data&#10;    class MediaResponse {&#10;        private String id;&#10;        private String fileName;&#10;        private String fileUrl;&#10;        private String fileType;&#10;        private long fileSize;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.ctuconnect.client;&#13;&#10;&#13;&#10;import lombok.Data;&#13;&#10;import org.springframework.cloud.openfeign.FeignClient;&#13;&#10;import org.springframework.http.MediaType;&#13;&#10;import org.springframework.web.bind.annotation.*;&#13;&#10;import org.springframework.web.multipart.MultipartFile;&#13;&#10;import com.ctuconnect.config.FeignConfig;&#13;&#10;&#13;&#10;@FeignClient(&#13;&#10;    name = &quot;media-service&quot;, &#13;&#10;    url = &quot;${media-service.url}&quot;, &#13;&#10;    configuration = FeignConfig.class&#13;&#10;)&#13;&#10;public interface MediaServiceClient {&#13;&#10;&#13;&#10;    @PostMapping(value = &quot;/api/media/upload&quot;, consumes = MediaType.MULTIPART_FORM_DATA_VALUE)&#13;&#10;    MediaUploadResponse uploadFile(@RequestPart(&quot;file&quot;) MultipartFile file,&#13;&#10;                                  @RequestParam(&quot;type&quot;) String type);&#13;&#10;&#13;&#10;    @DeleteMapping(&quot;/api/media/{id}&quot;)&#13;&#10;    void deleteFile(@PathVariable(&quot;id&quot;) String fileId);&#13;&#10;&#13;&#10;    @GetMapping(&quot;/api/media/{id}&quot;)&#13;&#10;    MediaResponse getFileInfo(@PathVariable(&quot;id&quot;) String fileId);&#13;&#10;&#13;&#10;    // Response DTOs for media service&#13;&#10;    class MediaUploadResponse {&#13;&#10;        private String id;&#13;&#10;        private String fileName;&#13;&#10;        private String fileUrl;&#13;&#10;        private String fileType;&#13;&#10;        private long fileSize;&#13;&#10;&#13;&#10;        // Getters and Setters&#13;&#10;        public String getId() {&#13;&#10;            return id;&#13;&#10;        }&#13;&#10;&#13;&#10;        public void setId(String id) {&#13;&#10;            this.id = id;&#13;&#10;        }&#13;&#10;&#13;&#10;        public String getFileName() {&#13;&#10;            return fileName;&#13;&#10;        }&#13;&#10;&#13;&#10;        public void setFileName(String fileName) {&#13;&#10;            this.fileName = fileName;&#13;&#10;        }&#13;&#10;&#13;&#10;        public String getFileUrl() {&#13;&#10;            return fileUrl;&#13;&#10;        }&#13;&#10;&#13;&#10;        public void setFileUrl(String fileUrl) {&#13;&#10;            this.fileUrl = fileUrl;&#13;&#10;        }&#13;&#10;&#13;&#10;        public String getFileType() {&#13;&#10;            return fileType;&#13;&#10;        }&#13;&#10;&#13;&#10;        public void setFileType(String fileType) {&#13;&#10;            this.fileType = fileType;&#13;&#10;        }&#13;&#10;&#13;&#10;        public long getFileSize() {&#13;&#10;            return fileSize;&#13;&#10;        }&#13;&#10;&#13;&#10;        public void setFileSize(long fileSize) {&#13;&#10;            this.fileSize = fileSize;&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    @Data&#13;&#10;    class MediaResponse {&#13;&#10;        private String id;&#13;&#10;        private String fileName;&#13;&#10;        private String fileUrl;&#13;&#10;        private String fileType;&#13;&#10;        private long fileSize;&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/client/UserServiceClientFallback.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/client/UserServiceClientFallback.java" />
              <option name="updatedContent" value="package com.ctuconnect.client;&#10;&#10;import com.ctuconnect.dto.AuthorInfo;&#10;import lombok.extern.slf4j.Slf4j;&#10;import org.springframework.stereotype.Component;&#10;&#10;import java.util.HashSet;&#10;import java.util.Set;&#10;&#10;/**&#10; * Fallback implementation for UserServiceClient when user-service is unavailable&#10; * Provides default values to prevent service failures&#10; */&#10;@Component&#10;@Slf4j&#10;public class UserServiceClientFallback implements UserServiceClient {&#10;&#10;    @Override&#10;    public AuthorInfo getAuthorInfo(String authorId) {&#10;        log.warn(&quot;User service unavailable, returning fallback author info for user: {}&quot;, authorId);&#10;        return AuthorInfo.builder()&#10;                .userId(authorId)&#10;                .username(&quot;Unknown User&quot;)&#10;                .fullName(&quot;Unknown User&quot;)&#10;                .avatarUrl(null)&#10;                .isVerified(false)&#10;                .build();&#10;    }&#10;&#10;    @Override&#10;    public Set&lt;String&gt; getFriendIds(String userId) {&#10;        log.warn(&quot;User service unavailable, returning empty friend list for user: {}&quot;, userId);&#10;        return new HashSet&lt;&gt;();&#10;    }&#10;&#10;    @Override&#10;    public Set&lt;String&gt; getCloseInteractionIds(String userId) {&#10;        log.warn(&quot;User service unavailable, returning empty close interactions for user: {}&quot;, userId);&#10;        return new HashSet&lt;&gt;();&#10;    }&#10;&#10;    @Override&#10;    public Set&lt;String&gt; getSameFacultyUserIds(String userId) {&#10;        log.warn(&quot;User service unavailable, returning empty same faculty users for user: {}&quot;, userId);&#10;        return new HashSet&lt;&gt;();&#10;    }&#10;&#10;    @Override&#10;    public Set&lt;String&gt; getSameMajorUserIds(String userId) {&#10;        log.warn(&quot;User service unavailable, returning empty same major users for user: {}&quot;, userId);&#10;        return new HashSet&lt;&gt;();&#10;    }&#10;&#10;    @Override&#10;    public Set&lt;String&gt; getUserInterestTags(String userId) {&#10;        log.warn(&quot;User service unavailable, returning empty interest tags for user: {}&quot;, userId);&#10;        return new HashSet&lt;&gt;();&#10;    }&#10;&#10;    @Override&#10;    public Set&lt;String&gt; getUserPreferredCategories(String userId) {&#10;        log.warn(&quot;User service unavailable, returning empty preferred categories for user: {}&quot;, userId);&#10;        return new HashSet&lt;&gt;();&#10;    }&#10;&#10;    @Override&#10;    public String getUserFacultyId(String userId) {&#10;        log.warn(&quot;User service unavailable, returning null faculty ID for user: {}&quot;, userId);&#10;        return null;&#10;    }&#10;&#10;    @Override&#10;    public String getUserMajorId(String userId) {&#10;        log.warn(&quot;User service unavailable, returning null major ID for user: {}&quot;, userId);&#10;        return null;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/config/CacheConfig.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/config/CacheConfig.java" />
              <option name="updatedContent" value="package com.ctuconnect.config;&#10;&#10;import org.springframework.beans.factory.annotation.Value;&#10;import org.springframework.context.annotation.Bean;&#10;import org.springframework.context.annotation.Configuration;&#10;import org.springframework.data.redis.connection.RedisConnectionFactory;&#10;import org.springframework.data.redis.connection.lettuce.LettuceConnectionFactory;&#10;import org.springframework.data.redis.core.RedisTemplate;&#10;import org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer;&#10;import org.springframework.data.redis.serializer.StringRedisSerializer;&#10;&#10;@Configuration&#10;public class CacheConfig {&#10;&#10;    @Value(&quot;${spring.data.redis.host:localhost}&quot;)&#10;    private String redisHost;&#10;&#10;    @Value(&quot;${spring.data.redis.port:6379}&quot;)&#10;    private int redisPort;&#10;&#10;    @Bean&#10;    public RedisConnectionFactory redisConnectionFactory() {&#10;        return new LettuceConnectionFactory(redisHost, redisPort);&#10;    }&#10;&#10;    @Bean&#10;    public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory connectionFactory) {&#10;        RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;();&#10;        template.setConnectionFactory(connectionFactory);&#10;        &#10;        // Use String serializer for keys&#10;        template.setKeySerializer(new StringRedisSerializer());&#10;        template.setHashKeySerializer(new StringRedisSerializer());&#10;        &#10;        // Use JSON serializer for values&#10;        template.setValueSerializer(new GenericJackson2JsonRedisSerializer());&#10;        template.setHashValueSerializer(new GenericJackson2JsonRedisSerializer());&#10;        &#10;        template.afterPropertiesSet();&#10;        return template;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/config/FeignConfig.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/config/FeignConfig.java" />
              <option name="updatedContent" value="package com.ctuconnect.config;&#10;&#10;import feign.Logger;&#10;import feign.Request;&#10;import feign.Retryer;&#10;import feign.codec.ErrorDecoder;&#10;import org.springframework.context.annotation.Bean;&#10;import org.springframework.context.annotation.Configuration;&#10;&#10;import java.util.concurrent.TimeUnit;&#10;&#10;/**&#10; * Feign client configuration for better error handling and retry mechanism&#10; */&#10;@Configuration&#10;public class FeignConfig {&#10;&#10;    @Bean&#10;    Logger.Level feignLoggerLevel() {&#10;        return Logger.Level.BASIC;&#10;    }&#10;&#10;    @Bean&#10;    public Request.Options requestOptions() {&#10;        return new Request.Options(&#10;                10, TimeUnit.SECONDS, // connect timeout&#10;                60, TimeUnit.SECONDS, // read timeout&#10;                true // follow redirects&#10;        );&#10;    }&#10;&#10;    @Bean&#10;    public Retryer retryer() {&#10;        return new Retryer.Default(&#10;                1000, // initial interval&#10;                3000, // max interval&#10;                3     // max attempts&#10;        );&#10;    }&#10;&#10;    @Bean&#10;    public ErrorDecoder errorDecoder() {&#10;        return new CustomFeignErrorDecoder();&#10;    }&#10;&#10;    /**&#10;     * Custom error decoder to handle service communication errors gracefully&#10;     */&#10;    public static class CustomFeignErrorDecoder implements ErrorDecoder {&#10;        &#10;        @Override&#10;        public Exception decode(String methodKey, feign.Response response) {&#10;            switch (response.status()) {&#10;                case 400:&#10;                    return new IllegalArgumentException(&quot;Bad Request: &quot; + methodKey);&#10;                case 404:&#10;                    return new RuntimeException(&quot;Service not found: &quot; + methodKey);&#10;                case 500:&#10;                    return new RuntimeException(&quot;Internal Server Error in &quot; + methodKey);&#10;                case 503:&#10;                    return new RuntimeException(&quot;Service Unavailable: &quot; + methodKey);&#10;                default:&#10;                    return new RuntimeException(&quot;Unknown error occurred in &quot; + methodKey + &quot;: &quot; + response.status());&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/config/HealthCheckConfig.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/config/HealthCheckConfig.java" />
              <option name="updatedContent" value="package com.ctuconnect.config;&#10;&#10;import org.springframework.boot.actuator.health.Health;&#10;import org.springframework.boot.actuator.health.HealthIndicator;&#10;import org.springframework.context.annotation.Bean;&#10;import org.springframework.context.annotation.Configuration;&#10;import org.springframework.data.redis.connection.RedisConnectionFactory;&#10;import org.springframework.data.mongodb.core.MongoTemplate;&#10;&#10;@Configuration&#10;public class HealthCheckConfig {&#10;    &#10;    @Bean&#10;    public HealthIndicator redisHealthIndicator(RedisConnectionFactory redisConnectionFactory) {&#10;        return () -&gt; {&#10;            try {&#10;                redisConnectionFactory.getConnection().ping();&#10;                return Health.up()&#10;                    .withDetail(&quot;redis&quot;, &quot;Available&quot;)&#10;                    .build();&#10;            } catch (Exception e) {&#10;                return Health.down()&#10;                    .withDetail(&quot;redis&quot;, &quot;Unavailable&quot;)&#10;                    .withDetail(&quot;error&quot;, e.getMessage())&#10;                    .build();&#10;            }&#10;        };&#10;    }&#10;    &#10;    @Bean&#10;    public HealthIndicator mongoHealthIndicator(MongoTemplate mongoTemplate) {&#10;        return () -&gt; {&#10;            try {&#10;                mongoTemplate.getCollection(&quot;health_check&quot;).countDocuments();&#10;                return Health.up()&#10;                    .withDetail(&quot;mongodb&quot;, &quot;Available&quot;)&#10;                    .build();&#10;            } catch (Exception e) {&#10;                return Health.down()&#10;                    .withDetail(&quot;mongodb&quot;, &quot;Unavailable&quot;)&#10;                    .withDetail(&quot;error&quot;, e.getMessage())&#10;                    .build();&#10;            }&#10;        };&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/config/WebConfig.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/config/WebConfig.java" />
              <option name="updatedContent" value="package com.ctuconnect.config;&#10;&#10;import com.ctuconnect.security.AuthenticationInterceptor;&#10;import lombok.RequiredArgsConstructor;&#10;import org.springframework.context.annotation.Configuration;&#10;import org.springframework.web.servlet.config.annotation.InterceptorRegistry;&#10;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;&#10;&#10;/**&#10; * Web configuration to register security interceptors&#10; */&#10;@Configuration&#10;@RequiredArgsConstructor&#10;public class WebConfig implements WebMvcConfigurer {&#10;&#10;    private final AuthenticationInterceptor authenticationInterceptor;&#10;&#10;    @Override&#10;    public void addInterceptors(InterceptorRegistry registry) {&#10;        registry.addInterceptor(authenticationInterceptor)&#10;                .addPathPatterns(&quot;/api/**&quot;) // Apply to all API endpoints&#10;                .excludePathPatterns(&#10;                        &quot;/api/posts/health&quot;,&#10;                        &quot;/api/posts/actuator/**&quot;,&#10;                        &quot;/api/posts/swagger-ui/**&quot;,&#10;                        &quot;/api/posts/v3/api-docs/**&quot;&#10;                );&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/config/WebSocketConfig.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/config/WebSocketConfig.java" />
              <option name="updatedContent" value="package com.ctuconnect.config;&#10;&#10;import org.springframework.context.annotation.Configuration;&#10;import org.springframework.messaging.simp.config.MessageBrokerRegistry;&#10;import org.springframework.web.socket.config.annotation.EnableWebSocketMessageBroker;&#10;import org.springframework.web.socket.config.annotation.StompEndpointRegistry;&#10;import org.springframework.web.socket.config.annotation.WebSocketMessageBrokerConfigurer;&#10;&#10;@Configuration&#10;@EnableWebSocketMessageBroker&#10;public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {&#10;&#10;    @Override&#10;    public void configureMessageBroker(MessageBrokerRegistry config) {&#10;        // Enable simple message broker for in-memory message handling&#10;        config.enableSimpleBroker(&quot;/topic&quot;, &quot;/queue&quot;);&#10;        config.setApplicationDestinationPrefixes(&quot;/app&quot;);&#10;        config.setUserDestinationPrefix(&quot;/user&quot;);&#10;    }&#10;&#10;    @Override&#10;    public void registerStompEndpoints(StompEndpointRegistry registry) {&#10;        // Register STOMP endpoints for WebSocket connections&#10;        registry.addEndpoint(&quot;/ws&quot;)&#10;                .setAllowedOriginPatterns(&quot;*&quot;)&#10;                .withSockJS();&#10;        &#10;        registry.addEndpoint(&quot;/ws-notifications&quot;)&#10;                .setAllowedOriginPatterns(&quot;*&quot;)&#10;                .withSockJS();&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/controller/EnhancedPostController.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/controller/EnhancedPostController.java" />
              <option name="updatedContent" value="// This file has been merged into PostController.java&#10;// Delete this file to avoid conflicts" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/controller/PostController.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/controller/PostController.java" />
              <option name="originalContent" value="package com.ctuconnect.controller;&#10;&#10;import jakarta.validation.Valid;&#10;import org.springframework.beans.factory.annotation.Autowired;&#10;import org.springframework.data.domain.Page;&#10;import org.springframework.data.domain.PageRequest;&#10;import org.springframework.data.domain.Pageable;&#10;import org.springframework.data.domain.Sort;&#10;import org.springframework.http.HttpStatus;&#10;import org.springframework.http.ResponseEntity;&#10;import org.springframework.web.bind.annotation.*;&#10;import org.springframework.web.multipart.MultipartFile;&#10;import com.ctuconnect.dto.request.CommentRequest;&#10;import com.ctuconnect.dto.request.InteractionRequest;&#10;import com.ctuconnect.dto.request.PostRequest;&#10;import com.ctuconnect.dto.request.ScheduledPostRequest;&#10;import com.ctuconnect.dto.response.CommentResponse;&#10;import com.ctuconnect.dto.response.InteractionResponse;&#10;import com.ctuconnect.dto.response.PostResponse;&#10;import com.ctuconnect.dto.response.PostAnalyticsResponse;&#10;import com.ctuconnect.security.SecurityContextHolder;&#10;import com.ctuconnect.security.annotation.RequireAuth;&#10;import com.ctuconnect.security.AuthenticatedUser;&#10;import com.ctuconnect.service.CommentService;&#10;import com.ctuconnect.service.InteractionService;&#10;import com.ctuconnect.service.PostService;&#10;import com.ctuconnect.service.NewsFeedService;&#10;import com.ctuconnect.service.NotificationService;&#10;&#10;import java.util.List;&#10;import java.util.Map;&#10;&#10;@RestController&#10;@RequestMapping(&quot;/api/posts&quot;)&#10;public class PostController {&#10;&#10;    @Autowired&#10;    private PostService postService;&#10;&#10;    @Autowired&#10;    private CommentService commentService;&#10;&#10;    @Autowired&#10;    private InteractionService interactionService;&#10;&#10;    @Autowired(required = false)&#10;    private NewsFeedService newsFeedService;&#10;&#10;    @Autowired(required = false)&#10;    private NotificationService notificationService;&#10;&#10;    // ========== ENHANCED ENDPOINTS (Primary) ==========&#10;&#10;    /**&#10;     * Create post - Primary endpoint (Enhanced)&#10;     */&#10;    @PostMapping&#10;    @RequireAuth&#10;    public ResponseEntity&lt;?&gt; createPost(@Valid @RequestBody PostRequest request) {&#10;        try {&#10;            String currentUserId = SecurityContextHolder.getCurrentUserIdOrThrow();&#10;            &#10;            // Try enhanced service first, fallback to regular service&#10;            PostResponse response;&#10;            try {&#10;                AuthenticatedUser user = new AuthenticatedUser(currentUserId, null, null);&#10;                response = postService.createEnhancedPost(request, user);&#10;            } catch (Exception e) {&#10;                // Fallback to regular post creation&#10;                response = postService.createPost(request, null, currentUserId);&#10;            }&#10;            &#10;            // Invalidate caches if newsFeedService is available&#10;            if (newsFeedService != null) {&#10;                try {&#10;                    newsFeedService.invalidateFeedCacheForUsers(&#10;                        postService.getAffectedUserIds(response.getId()));&#10;                } catch (Exception e) {&#10;                    // Log error but don't fail the request&#10;                    System.err.println(&quot;Failed to invalidate cache: &quot; + e.getMessage());&#10;                }&#10;            }&#10;            &#10;            return ResponseEntity.status(HttpStatus.CREATED).body(response);&#10;        } catch (SecurityException e) {&#10;            return ResponseEntity.status(HttpStatus.UNAUTHORIZED)&#10;                    .body(Map.of(&quot;error&quot;, &quot;Authentication required&quot;, &quot;message&quot;, e.getMessage()));&#10;        } catch (RuntimeException e) {&#10;            return ResponseEntity.status(HttpStatus.BAD_REQUEST)&#10;                    .body(Map.of(&quot;error&quot;, &quot;Failed to create post&quot;, &quot;message&quot;, e.getMessage()));&#10;        } catch (Exception e) {&#10;            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)&#10;                    .body(Map.of(&quot;error&quot;, &quot;Internal server error&quot;, &quot;message&quot;, &quot;Failed to create post&quot;));&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Facebook-like personalized news feed&#10;     */&#10;    @GetMapping(&quot;/feed&quot;)&#10;    @RequireAuth&#10;    public ResponseEntity&lt;?&gt; getPersonalizedFeed(&#10;            @RequestParam(defaultValue = &quot;0&quot;) int page,&#10;            @RequestParam(defaultValue = &quot;10&quot;) int size) {&#10;        &#10;        try {&#10;            String currentUserId = SecurityContextHolder.getCurrentUserIdOrThrow();&#10;            &#10;            if (newsFeedService != null) {&#10;                List&lt;PostResponse&gt; feed = newsFeedService.generatePersonalizedFeed(&#10;                    currentUserId, page, size);&#10;                return ResponseEntity.ok(feed);&#10;            } else {&#10;                // Fallback to regular posts&#10;                Pageable pageable = PageRequest.of(page, size, Sort.by(&quot;createdAt&quot;).descending());&#10;                Page&lt;PostResponse&gt; posts = postService.getAllPosts(pageable);&#10;                return ResponseEntity.ok(posts.getContent());&#10;            }&#10;        } catch (Exception e) {&#10;            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)&#10;                    .body(Map.of(&quot;error&quot;, &quot;Failed to retrieve feed&quot;, &quot;message&quot;, e.getMessage()));&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get trending posts - Unified endpoint&#10;     */&#10;    @GetMapping(&quot;/trending&quot;)&#10;    public ResponseEntity&lt;?&gt; getTrendingPosts(&#10;            @RequestParam(defaultValue = &quot;0&quot;) int page,&#10;            @RequestParam(defaultValue = &quot;20&quot;) int size) {&#10;        &#10;        try {&#10;            List&lt;PostResponse&gt; posts;&#10;            &#10;            if (newsFeedService != null) {&#10;                posts = newsFeedService.getTrendingPosts(page, size);&#10;            } else {&#10;                // Fallback to top viewed posts&#10;                posts = postService.getTopViewedPosts();&#10;            }&#10;            &#10;            return ResponseEntity.ok(posts);&#10;        } catch (Exception e) {&#10;            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)&#10;                    .body(Map.of(&quot;error&quot;, &quot;Failed to retrieve trending posts&quot;, &quot;message&quot;, e.getMessage()));&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get user timeline (profile posts)&#10;     */&#10;    @GetMapping(&quot;/timeline/{userId}&quot;)&#10;    @RequireAuth&#10;    public ResponseEntity&lt;?&gt; getUserTimeline(&#10;            @PathVariable String userId,&#10;            @RequestParam(defaultValue = &quot;0&quot;) int page,&#10;            @RequestParam(defaultValue = &quot;10&quot;) int size) {&#10;        &#10;        try {&#10;            String currentUserId = SecurityContextHolder.getCurrentUserIdOrThrow();&#10;            &#10;            if (newsFeedService != null) {&#10;                List&lt;PostResponse&gt; timeline = newsFeedService.generateUserTimeline(&#10;                    userId, currentUserId, page, size);&#10;                return ResponseEntity.ok(timeline);&#10;            } else {&#10;                // Fallback to posts by author&#10;                Pageable pageable = PageRequest.of(page, size, Sort.by(&quot;createdAt&quot;).descending());&#10;                Page&lt;PostResponse&gt; posts = postService.getPostsByAuthor(userId, pageable);&#10;                return ResponseEntity.ok(posts.getContent());&#10;            }&#10;        } catch (Exception e) {&#10;            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)&#10;                    .body(Map.of(&quot;error&quot;, &quot;Failed to retrieve timeline&quot;, &quot;message&quot;, e.getMessage()));&#10;        }&#10;    }&#10;&#10;    // ========== LEGACY ENDPOINTS (Maintained for compatibility) ==========&#10;&#10;    /**&#10;     * Create post with file upload support&#10;     */&#10;    @PostMapping(&quot;/upload&quot;)&#10;    @RequireAuth&#10;    public ResponseEntity&lt;?&gt; createPostWithFiles(&#10;            @Valid @RequestPart(&quot;post&quot;) PostRequest request,&#10;            @RequestPart(value = &quot;files&quot;, required = false) List&lt;MultipartFile&gt; files) {&#10;        &#10;        try {&#10;            String currentUserId = SecurityContextHolder.getCurrentUserIdOrThrow();&#10;            PostResponse response = postService.createPost(request, files, currentUserId);&#10;            return ResponseEntity.status(HttpStatus.CREATED).body(response);&#10;        } catch (SecurityException e) {&#10;            return ResponseEntity.status(HttpStatus.UNAUTHORIZED)&#10;                    .body(Map.of(&quot;error&quot;, &quot;Authentication required&quot;, &quot;message&quot;, e.getMessage()));&#10;        } catch (RuntimeException e) {&#10;            return ResponseEntity.status(HttpStatus.BAD_REQUEST)&#10;                    .body(Map.of(&quot;error&quot;, &quot;Failed to create post&quot;, &quot;message&quot;, e.getMessage()));&#10;        } catch (Exception e) {&#10;            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)&#10;                    .body(Map.of(&quot;error&quot;, &quot;Internal server error&quot;, &quot;message&quot;, &quot;Failed to create post&quot;));&#10;        }&#10;    }&#10;&#10;    // ========== COMMON ENDPOINTS ==========&#10;&#10;    /**&#10;     * Get all posts with pagination and filters&#10;     */&#10;    @GetMapping&#10;    public ResponseEntity&lt;?&gt; getAllPosts(&#10;            @RequestParam(defaultValue = &quot;0&quot;) int page,&#10;            @RequestParam(defaultValue = &quot;10&quot;) int size,&#10;            @RequestParam(defaultValue = &quot;createdAt&quot;) String sortBy,&#10;            @RequestParam(defaultValue = &quot;desc&quot;) String sortDir,&#10;            @RequestParam(required = false) String authorId,&#10;            @RequestParam(required = false) String category,&#10;            @RequestParam(required = false) String search) {&#10;&#10;        try {&#10;            Sort sort = sortDir.equalsIgnoreCase(&quot;desc&quot;) ?&#10;                Sort.by(sortBy).descending() : Sort.by(sortBy).ascending();&#10;            Pageable pageable = PageRequest.of(page, size, sort);&#10;&#10;            Page&lt;PostResponse&gt; posts;&#10;&#10;            if (search != null &amp;&amp; !search.trim().isEmpty()) {&#10;                posts = postService.searchPosts(search.trim(), pageable);&#10;            } else if (authorId != null &amp;&amp; !authorId.trim().isEmpty()) {&#10;                posts = postService.getPostsByAuthor(authorId.trim(), pageable);&#10;            } else if (category != null &amp;&amp; !category.trim().isEmpty()) {&#10;                posts = postService.getPostsByCategory(category.trim(), pageable);&#10;            } else {&#10;                posts = postService.getAllPosts(pageable);&#10;            }&#10;&#10;            return ResponseEntity.ok(posts);&#10;        } catch (Exception e) {&#10;            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)&#10;                    .body(Map.of(&quot;error&quot;, &quot;Failed to retrieve posts&quot;, &quot;message&quot;, e.getMessage()));&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get post by ID (auto-record VIEW interaction)&#10;     */&#10;    @GetMapping(&quot;/{id}&quot;)&#10;    public ResponseEntity&lt;?&gt; getPostById(@PathVariable String id) {&#10;        try {&#10;            String currentUserId = SecurityContextHolder.getCurrentUserId();&#10;            PostResponse post = postService.getPostById(id, currentUserId);&#10;            return ResponseEntity.ok(post);&#10;        } catch (RuntimeException e) {&#10;            return ResponseEntity.status(HttpStatus.NOT_FOUND)&#10;                    .body(Map.of(&quot;error&quot;, &quot;Post not found&quot;, &quot;message&quot;, e.getMessage()));&#10;        } catch (Exception e) {&#10;            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)&#10;                    .body(Map.of(&quot;error&quot;, &quot;Failed to retrieve post&quot;, &quot;message&quot;, e.getMessage()));&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Update post (author only)&#10;     */&#10;    @PutMapping(&quot;/{id}&quot;)&#10;    @RequireAuth&#10;    public ResponseEntity&lt;?&gt; updatePost(&#10;            @PathVariable String id,&#10;            @Valid @RequestBody PostRequest request) {&#10;        try {&#10;            String authorId = SecurityContextHolder.getCurrentUserIdOrThrow();&#10;            PostResponse updatedPost = postService.updatePost(id, request, authorId);&#10;            return ResponseEntity.ok(updatedPost);&#10;        } catch (SecurityException e) {&#10;            return ResponseEntity.status(HttpStatus.UNAUTHORIZED)&#10;                    .body(Map.of(&quot;error&quot;, &quot;Authentication required&quot;, &quot;message&quot;, e.getMessage()));&#10;        } catch (RuntimeException e) {&#10;            String message = e.getMessage();&#10;            if (message.contains(&quot;Only the author&quot;)) {&#10;                return ResponseEntity.status(HttpStatus.FORBIDDEN)&#10;                        .body(Map.of(&quot;error&quot;, &quot;Access denied&quot;, &quot;message&quot;, message));&#10;            }&#10;            return ResponseEntity.status(HttpStatus.NOT_FOUND)&#10;                    .body(Map.of(&quot;error&quot;, &quot;Post not found&quot;, &quot;message&quot;, message));&#10;        } catch (Exception e) {&#10;            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)&#10;                    .body(Map.of(&quot;error&quot;, &quot;Failed to update post&quot;, &quot;message&quot;, e.getMessage()));&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Delete post (author only)&#10;     */&#10;    @DeleteMapping(&quot;/{id}&quot;)&#10;    @RequireAuth&#10;    public ResponseEntity&lt;?&gt; deletePost(@PathVariable String id) {&#10;        try {&#10;            String authorId = SecurityContextHolder.getCurrentUserIdOrThrow();&#10;            postService.deletePost(id, authorId);&#10;            return ResponseEntity.noContent().build();&#10;        } catch (SecurityException e) {&#10;            return ResponseEntity.status(HttpStatus.UNAUTHORIZED)&#10;                    .body(Map.of(&quot;error&quot;, &quot;Authentication required&quot;, &quot;message&quot;, e.getMessage()));&#10;        } catch (RuntimeException e) {&#10;            String message = e.getMessage();&#10;            if (message.contains(&quot;Only the author&quot;)) {&#10;                return ResponseEntity.status(HttpStatus.FORBIDDEN)&#10;                        .body(Map.of(&quot;error&quot;, &quot;Access denied&quot;, &quot;message&quot;, message));&#10;            }&#10;            return ResponseEntity.status(HttpStatus.NOT_FOUND)&#10;                    .body(Map.of(&quot;error&quot;, &quot;Post not found&quot;, &quot;message&quot;, message));&#10;        } catch (Exception e) {&#10;            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)&#10;                    .body(Map.of(&quot;error&quot;, &quot;Failed to delete post&quot;, &quot;message&quot;, e.getMessage()));&#10;        }&#10;    }&#10;&#10;    // ========== INTERACTION ENDPOINTS ==========&#10;&#10;    /**&#10;     * Enhanced post interaction (like, comment, share)&#10;     */&#10;    @PostMapping(&quot;/{postId}/interact&quot;)&#10;    @RequireAuth&#10;    public ResponseEntity&lt;?&gt; interactWithPost(&#10;            @PathVariable String postId,&#10;            @RequestParam String action, // LIKE, UNLIKE, SHARE&#10;            @RequestParam(required = false) String reactionType) {&#10;        &#10;        try {&#10;            String userId = SecurityContextHolder.getCurrentUserIdOrThrow();&#10;            &#10;            // Try enhanced interaction first&#10;            try {&#10;                postService.handlePostInteraction(postId, userId, action, reactionType);&#10;                &#10;                // Create notification for post author if services are available&#10;                if (!&quot;UNLIKE&quot;.equals(action) &amp;&amp; notificationService != null) {&#10;                    try {&#10;                        String authorId = postService.getPostAuthorId(postId);&#10;                        notificationService.createNotification(&#10;                            authorId,&#10;                            userId,&#10;                            &quot;POST_&quot; + action,&#10;                            &quot;POST&quot;,&#10;                            postId,&#10;                            &quot;User &quot; + action.toLowerCase() + &quot;d your post&quot;&#10;                        );&#10;                    } catch (Exception e) {&#10;                        // Log error but don't fail the request&#10;                        System.err.println(&quot;Failed to create notification: &quot; + e.getMessage());&#10;                    }&#10;                }&#10;                &#10;                return ResponseEntity.ok().build();&#10;            } catch (Exception e) {&#10;                // Fallback to legacy interaction handling&#10;                InteractionRequest request = new InteractionRequest();&#10;                // Set appropriate interaction type based on action&#10;                request.setType(mapActionToInteractionType(action));&#10;                &#10;                InteractionResponse interaction = interactionService.createInteraction(postId, request, userId);&#10;                if (interaction == null) {&#10;                    return ResponseEntity.noContent().build();&#10;                }&#10;                return ResponseEntity.status(HttpStatus.CREATED).body(interaction);&#10;            }&#10;        } catch (Exception e) {&#10;            return ResponseEntity.status(HttpStatus.BAD_REQUEST)&#10;                    .body(Map.of(&quot;error&quot;, &quot;Failed to process interaction&quot;, &quot;message&quot;, e.getMessage()));&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Add comment to post - Legacy endpoint&#10;     */&#10;    @PostMapping(&quot;/{id}/comments&quot;)&#10;    @RequireAuth&#10;    public ResponseEntity&lt;?&gt; addComment(&#10;            @PathVariable String id,&#10;            @Valid @RequestBody CommentRequest request) {&#10;        &#10;        try {&#10;            String currentUserId = SecurityContextHolder.getCurrentUserIdOrThrow();&#10;            CommentResponse comment = commentService.createComment(id, request, currentUserId);&#10;            &#10;            // Create notification if service is available&#10;            if (notificationService != null) {&#10;                try {&#10;                    String authorId = postService.getPostAuthorId(id);&#10;                    notificationService.createNotification(&#10;                        authorId,&#10;                        currentUserId,&#10;                        &quot;POST_COMMENTED&quot;,&#10;                        &quot;POST&quot;,&#10;                        id,&#10;                        &quot;User commented on your post&quot;&#10;                    );&#10;                } catch (Exception e) {&#10;                    // Log error but don't fail the request&#10;                    System.err.println(&quot;Failed to create notification: &quot; + e.getMessage());&#10;                }&#10;            }&#10;            &#10;            return ResponseEntity.status(HttpStatus.CREATED).body(comment);&#10;        } catch (RuntimeException e) {&#10;            return ResponseEntity.badRequest()&#10;                    .body(Map.of(&quot;error&quot;, &quot;Failed to add comment&quot;, &quot;message&quot;, e.getMessage()));&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Add comment with string content - Enhanced endpoint&#10;     */&#10;    @PostMapping(&quot;/{postId}/comments/simple&quot;)&#10;    @RequireAuth&#10;    public ResponseEntity&lt;?&gt; addSimpleComment(&#10;            @PathVariable String postId,&#10;            @RequestBody String content) {&#10;        &#10;        try {&#10;            String userId = SecurityContextHolder.getCurrentUserIdOrThrow();&#10;            &#10;            // Try enhanced comment service first&#10;            try {&#10;                postService.addComment(postId, userId, content);&#10;                &#10;                // Create notification&#10;                if (notificationService != null) {&#10;                    try {&#10;                        String authorId = postService.getPostAuthorId(postId);&#10;                        notificationService.createNotification(&#10;                            authorId,&#10;                            userId,&#10;                            &quot;POST_COMMENTED&quot;,&#10;                            &quot;POST&quot;,&#10;                            postId,&#10;                            &quot;User commented on your post&quot;&#10;                        );&#10;                    } catch (Exception e) {&#10;                        System.err.println(&quot;Failed to create notification: &quot; + e.getMessage());&#10;                    }&#10;                }&#10;                &#10;                return ResponseEntity.ok().build();&#10;            } catch (Exception e) {&#10;                // Fallback to legacy comment service&#10;                CommentRequest request = new CommentRequest();&#10;                request.setContent(content);&#10;                CommentResponse comment = commentService.createComment(postId, request, userId);&#10;                return ResponseEntity.status(HttpStatus.CREATED).body(comment);&#10;            }&#10;        } catch (Exception e) {&#10;            return ResponseEntity.status(HttpStatus.BAD_REQUEST)&#10;                    .body(Map.of(&quot;error&quot;, &quot;Failed to add comment&quot;, &quot;message&quot;, e.getMessage()));&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get comments for post&#10;     */&#10;    @GetMapping(&quot;/{id}/comments&quot;)&#10;    public ResponseEntity&lt;Page&lt;CommentResponse&gt;&gt; getComments(&#10;            @PathVariable String id,&#10;            @RequestParam(defaultValue = &quot;0&quot;) int page,&#10;            @RequestParam(defaultValue = &quot;10&quot;) int size) {&#10;&#10;        Pageable pageable = PageRequest.of(page, size, Sort.by(&quot;createdAt&quot;).ascending());&#10;        Page&lt;CommentResponse&gt; comments = commentService.getCommentsByPost(id, pageable);&#10;        return ResponseEntity.ok(comments);&#10;    }&#10;&#10;    /**&#10;     * Record interaction (LIKE/SHARE/BOOKMARK) - Legacy endpoint&#10;     */&#10;    @PostMapping(&quot;/{id}/interactions&quot;)&#10;    @RequireAuth&#10;    public ResponseEntity&lt;InteractionResponse&gt; recordInteraction(&#10;            @PathVariable String id,&#10;            @Valid @RequestBody InteractionRequest request) {&#10;        String userId = SecurityContextHolder.getCurrentUserIdOrThrow();&#10;        try {&#10;            InteractionResponse interaction = interactionService.createInteraction(id, request, userId);&#10;            if (interaction == null) {&#10;                // Interaction was removed (e.g., unlike)&#10;                return ResponseEntity.noContent().build();&#10;            }&#10;            return ResponseEntity.status(HttpStatus.CREATED).body(interaction);&#10;        } catch (RuntimeException e) {&#10;            return ResponseEntity.badRequest().build();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Check if user has liked post&#10;     */&#10;    @GetMapping(&quot;/{id}/likes/check&quot;)&#10;    @RequireAuth&#10;    public ResponseEntity&lt;Boolean&gt; hasUserLikedPost(@PathVariable String id) {&#10;        String userId = SecurityContextHolder.getCurrentUserIdOrThrow();&#10;        boolean hasLiked = interactionService.hasUserReacted(id, userId);&#10;        return ResponseEntity.ok(hasLiked);&#10;    }&#10;&#10;    }&#10;&#10;    /**&#10;     * Search posts with advanced filters&#10;     */&#10;    @GetMapping(&quot;/search&quot;)&#10;    public ResponseEntity&lt;?&gt; searchPosts(&#10;            @RequestParam String query,&#10;            @RequestParam(required = false) String category,&#10;            @RequestParam(required = false) String faculty,&#10;            @RequestParam(required = false) String dateRange,&#10;            @RequestParam(defaultValue = &quot;0&quot;) int page,&#10;            @RequestParam(defaultValue = &quot;10&quot;) int size) {&#10;&#10;        try {&#10;            // Try enhanced search first&#10;            try {&#10;                List&lt;PostResponse&gt; results = postService.searchPosts(&#10;                    query, category, faculty, dateRange, PageRequest.of(page, size));&#10;                return ResponseEntity.ok(results);&#10;            } catch (Exception e) {&#10;                // Fallback to simple search&#10;                Pageable pageable = PageRequest.of(page, size, Sort.by(&quot;createdAt&quot;).descending());&#10;                Page&lt;PostResponse&gt; results = postService.searchPosts(query, pageable);&#10;                return ResponseEntity.ok(results.getContent());&#10;            }&#10;        } catch (Exception e) {&#10;            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)&#10;                    .body(Map.of(&quot;error&quot;, &quot;Failed to search posts&quot;, &quot;message&quot;, e.getMessage()));&#10;        }&#10;    }&#10;&#10;    // ========== ADDITIONAL ENDPOINTS ==========&#10;&#10;    /**&#10;     * Get top viewed posts&#10;     */&#10;    @GetMapping(&quot;/top-viewed&quot;)&#10;    public ResponseEntity&lt;?&gt; getTopViewedPosts() {&#10;        try {&#10;            List&lt;PostResponse&gt; posts = postService.getTopViewedPosts();&#10;            return ResponseEntity.ok(posts);&#10;        } catch (Exception e) {&#10;            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)&#10;                    .body(Map.of(&quot;error&quot;, &quot;Failed to retrieve top viewed posts&quot;, &quot;message&quot;, e.getMessage()));&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get top liked posts&#10;     */&#10;    @GetMapping(&quot;/top-liked&quot;)&#10;    public ResponseEntity&lt;?&gt; getTopLikedPosts() {&#10;        try {&#10;            List&lt;PostResponse&gt; posts = postService.getTopLikedPosts();&#10;            return ResponseEntity.ok(posts);&#10;        } catch (Exception e) {&#10;            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)&#10;                    .body(Map.of(&quot;error&quot;, &quot;Failed to retrieve top liked posts&quot;, &quot;message&quot;, e.getMessage()));&#10;        }&#10;    }&#10;&#10;    // ========== HELPER METHODS ==========&#10;&#10;    private String mapActionToInteractionType(String action) {&#10;        switch (action.toUpperCase()) {&#10;            case &quot;LIKE&quot;:&#10;                return &quot;LIKE&quot;;&#10;            case &quot;SHARE&quot;:&#10;                return &quot;SHARE&quot;;&#10;            case &quot;BOOKMARK&quot;:&#10;                return &quot;BOOKMARK&quot;;&#10;            default:&#10;                return &quot;LIKE&quot;;&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.ctuconnect.controller;&#10;&#10;import jakarta.validation.Valid;&#10;import org.springframework.beans.factory.annotation.Autowired;&#10;import org.springframework.data.domain.Page;&#10;import org.springframework.data.domain.PageRequest;&#10;import org.springframework.data.domain.Pageable;&#10;import org.springframework.data.domain.Sort;&#10;import org.springframework.http.HttpStatus;&#10;import org.springframework.http.ResponseEntity;&#10;import org.springframework.web.bind.annotation.*;&#10;import org.springframework.web.multipart.MultipartFile;&#10;import com.ctuconnect.dto.request.CommentRequest;&#10;import com.ctuconnect.dto.request.InteractionRequest;&#10;import com.ctuconnect.dto.request.PostRequest;&#10;import com.ctuconnect.dto.request.ScheduledPostRequest;&#10;import com.ctuconnect.dto.response.CommentResponse;&#10;import com.ctuconnect.dto.response.InteractionResponse;&#10;import com.ctuconnect.dto.response.PostResponse;&#10;import com.ctuconnect.dto.response.PostAnalyticsResponse;&#10;import com.ctuconnect.security.SecurityContextHolder;&#10;import com.ctuconnect.security.annotation.RequireAuth;&#10;import com.ctuconnect.security.AuthenticatedUser;&#10;import com.ctuconnect.service.CommentService;&#10;import com.ctuconnect.service.InteractionService;&#10;import com.ctuconnect.service.PostService;&#10;import com.ctuconnect.service.NewsFeedService;&#10;import com.ctuconnect.service.NotificationService;&#10;import com.ctuconnect.service.UserSyncService;&#10;&#10;import java.util.List;&#10;import java.util.Map;&#10;&#10;@RestController&#10;@RequestMapping(&quot;/api/posts&quot;)&#10;public class PostController {&#10;&#10;    @Autowired&#10;    private PostService postService;&#10;&#10;    @Autowired&#10;    private CommentService commentService;&#10;&#10;    @Autowired&#10;    private InteractionService interactionService;&#10;&#10;    @Autowired(required = false)&#10;    private NewsFeedService newsFeedService;&#10;&#10;    @Autowired(required = false)&#10;    private NotificationService notificationService;&#10;&#10;    @Autowired&#10;    private UserSyncService userSyncService;&#10;&#10;    // ========== ENHANCED ENDPOINTS (Primary) ==========&#10;&#10;    /**&#10;     * Create post - Primary endpoint (Enhanced)&#10;     */&#10;    @PostMapping&#10;    @RequireAuth&#10;    public ResponseEntity&lt;?&gt; createPost(@Valid @RequestBody PostRequest request) {&#10;        try {&#10;            String currentUserId = SecurityContextHolder.getCurrentUserIdOrThrow();&#10;            &#10;            // Try enhanced service first, fallback to regular service&#10;            PostResponse response;&#10;            try {&#10;                AuthenticatedUser user = new AuthenticatedUser(currentUserId, null, null);&#10;                response = postService.createEnhancedPost(request, user);&#10;            } catch (Exception e) {&#10;                // Fallback to regular post creation&#10;                response = postService.createPost(request, null, currentUserId);&#10;            }&#10;            &#10;            // Invalidate caches if newsFeedService is available&#10;            if (newsFeedService != null) {&#10;                try {&#10;                    newsFeedService.invalidateFeedCacheForUsers(&#10;                        postService.getAffectedUserIds(response.getId()));&#10;                } catch (Exception e) {&#10;                    // Log error but don't fail the request&#10;                    System.err.println(&quot;Failed to invalidate cache: &quot; + e.getMessage());&#10;                }&#10;            }&#10;            &#10;            return ResponseEntity.status(HttpStatus.CREATED).body(response);&#10;        } catch (SecurityException e) {&#10;            return ResponseEntity.status(HttpStatus.UNAUTHORIZED)&#10;                    .body(Map.of(&quot;error&quot;, &quot;Authentication required&quot;, &quot;message&quot;, e.getMessage()));&#10;        } catch (RuntimeException e) {&#10;            return ResponseEntity.status(HttpStatus.BAD_REQUEST)&#10;                    .body(Map.of(&quot;error&quot;, &quot;Failed to create post&quot;, &quot;message&quot;, e.getMessage()));&#10;        } catch (Exception e) {&#10;            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)&#10;                    .body(Map.of(&quot;error&quot;, &quot;Internal server error&quot;, &quot;message&quot;, &quot;Failed to create post&quot;));&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Facebook-like personalized news feed&#10;     */&#10;    @GetMapping(&quot;/feed&quot;)&#10;    @RequireAuth&#10;    public ResponseEntity&lt;?&gt; getPersonalizedFeed(&#10;            @RequestParam(defaultValue = &quot;0&quot;) int page,&#10;            @RequestParam(defaultValue = &quot;10&quot;) int size) {&#10;        &#10;        try {&#10;            String currentUserId = SecurityContextHolder.getCurrentUserIdOrThrow();&#10;            &#10;            if (newsFeedService != null) {&#10;                List&lt;PostResponse&gt; feed = newsFeedService.generatePersonalizedFeed(&#10;                    currentUserId, page, size);&#10;                return ResponseEntity.ok(feed);&#10;            } else {&#10;                // Fallback to regular posts&#10;                Pageable pageable = PageRequest.of(page, size, Sort.by(&quot;createdAt&quot;).descending());&#10;                Page&lt;PostResponse&gt; posts = postService.getAllPosts(pageable);&#10;                return ResponseEntity.ok(posts.getContent());&#10;            }&#10;        } catch (Exception e) {&#10;            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)&#10;                    .body(Map.of(&quot;error&quot;, &quot;Failed to retrieve feed&quot;, &quot;message&quot;, e.getMessage()));&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get trending posts - Unified endpoint&#10;     */&#10;    @GetMapping(&quot;/trending&quot;)&#10;    public ResponseEntity&lt;?&gt; getTrendingPosts(&#10;            @RequestParam(defaultValue = &quot;0&quot;) int page,&#10;            @RequestParam(defaultValue = &quot;20&quot;) int size) {&#10;        &#10;        try {&#10;            List&lt;PostResponse&gt; posts;&#10;            &#10;            if (newsFeedService != null) {&#10;                posts = newsFeedService.getTrendingPosts(page, size);&#10;            } else {&#10;                // Fallback to top viewed posts&#10;                posts = postService.getTopViewedPosts();&#10;            }&#10;            &#10;            return ResponseEntity.ok(posts);&#10;        } catch (Exception e) {&#10;            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)&#10;                    .body(Map.of(&quot;error&quot;, &quot;Failed to retrieve trending posts&quot;, &quot;message&quot;, e.getMessage()));&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get user timeline (profile posts)&#10;     */&#10;    @GetMapping(&quot;/timeline/{userId}&quot;)&#10;    @RequireAuth&#10;    public ResponseEntity&lt;?&gt; getUserTimeline(&#10;            @PathVariable String userId,&#10;            @RequestParam(defaultValue = &quot;0&quot;) int page,&#10;            @RequestParam(defaultValue = &quot;10&quot;) int size) {&#10;        &#10;        try {&#10;            String currentUserId = SecurityContextHolder.getCurrentUserIdOrThrow();&#10;            &#10;            if (newsFeedService != null) {&#10;                List&lt;PostResponse&gt; timeline = newsFeedService.generateUserTimeline(&#10;                    userId, currentUserId, page, size);&#10;                return ResponseEntity.ok(timeline);&#10;            } else {&#10;                // Fallback to posts by author&#10;                Pageable pageable = PageRequest.of(page, size, Sort.by(&quot;createdAt&quot;).descending());&#10;                Page&lt;PostResponse&gt; posts = postService.getPostsByAuthor(userId, pageable);&#10;                return ResponseEntity.ok(posts.getContent());&#10;            }&#10;        } catch (Exception e) {&#10;            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)&#10;                    .body(Map.of(&quot;error&quot;, &quot;Failed to retrieve timeline&quot;, &quot;message&quot;, e.getMessage()));&#10;        }&#10;    }&#10;&#10;    // ========== LEGACY ENDPOINTS (Maintained for compatibility) ==========&#10;&#10;    /**&#10;     * Create post with file upload support&#10;     */&#10;    @PostMapping(&quot;/upload&quot;)&#10;    @RequireAuth&#10;    public ResponseEntity&lt;?&gt; createPostWithFiles(&#10;            @Valid @RequestPart(&quot;post&quot;) PostRequest request,&#10;            @RequestPart(value = &quot;files&quot;, required = false) List&lt;MultipartFile&gt; files) {&#10;        &#10;        try {&#10;            String currentUserId = SecurityContextHolder.getCurrentUserIdOrThrow();&#10;            PostResponse response = postService.createPost(request, files, currentUserId);&#10;            return ResponseEntity.status(HttpStatus.CREATED).body(response);&#10;        } catch (SecurityException e) {&#10;            return ResponseEntity.status(HttpStatus.UNAUTHORIZED)&#10;                    .body(Map.of(&quot;error&quot;, &quot;Authentication required&quot;, &quot;message&quot;, e.getMessage()));&#10;        } catch (RuntimeException e) {&#10;            return ResponseEntity.status(HttpStatus.BAD_REQUEST)&#10;                    .body(Map.of(&quot;error&quot;, &quot;Failed to create post&quot;, &quot;message&quot;, e.getMessage()));&#10;        } catch (Exception e) {&#10;            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)&#10;                    .body(Map.of(&quot;error&quot;, &quot;Internal server error&quot;, &quot;message&quot;, &quot;Failed to create post&quot;));&#10;        }&#10;    }&#10;&#10;    // ========== COMMON ENDPOINTS ==========&#10;&#10;    /**&#10;     * Get all posts with pagination and filters&#10;     */&#10;    @GetMapping&#10;    public ResponseEntity&lt;?&gt; getAllPosts(&#10;            @RequestParam(defaultValue = &quot;0&quot;) int page,&#10;            @RequestParam(defaultValue = &quot;10&quot;) int size,&#10;            @RequestParam(defaultValue = &quot;createdAt&quot;) String sortBy,&#10;            @RequestParam(defaultValue = &quot;desc&quot;) String sortDir,&#10;            @RequestParam(required = false) String authorId,&#10;            @RequestParam(required = false) String category,&#10;            @RequestParam(required = false) String search) {&#10;&#10;        try {&#10;            Sort sort = sortDir.equalsIgnoreCase(&quot;desc&quot;) ?&#10;                Sort.by(sortBy).descending() : Sort.by(sortBy).ascending();&#10;            Pageable pageable = PageRequest.of(page, size, sort);&#10;&#10;            Page&lt;PostResponse&gt; posts;&#10;&#10;            if (search != null &amp;&amp; !search.trim().isEmpty()) {&#10;                posts = postService.searchPosts(search.trim(), pageable);&#10;            } else if (authorId != null &amp;&amp; !authorId.trim().isEmpty()) {&#10;                posts = postService.getPostsByAuthor(authorId.trim(), pageable);&#10;            } else if (category != null &amp;&amp; !category.trim().isEmpty()) {&#10;                posts = postService.getPostsByCategory(category.trim(), pageable);&#10;            } else {&#10;                posts = postService.getAllPosts(pageable);&#10;            }&#10;&#10;            return ResponseEntity.ok(posts);&#10;        } catch (Exception e) {&#10;            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)&#10;                    .body(Map.of(&quot;error&quot;, &quot;Failed to retrieve posts&quot;, &quot;message&quot;, e.getMessage()));&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get post by ID (auto-record VIEW interaction)&#10;     */&#10;    @GetMapping(&quot;/{id}&quot;)&#10;    public ResponseEntity&lt;?&gt; getPostById(@PathVariable String id) {&#10;        try {&#10;            String currentUserId = SecurityContextHolder.getCurrentUserId();&#10;            PostResponse post = postService.getPostById(id, currentUserId);&#10;            return ResponseEntity.ok(post);&#10;        } catch (RuntimeException e) {&#10;            return ResponseEntity.status(HttpStatus.NOT_FOUND)&#10;                    .body(Map.of(&quot;error&quot;, &quot;Post not found&quot;, &quot;message&quot;, e.getMessage()));&#10;        } catch (Exception e) {&#10;            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)&#10;                    .body(Map.of(&quot;error&quot;, &quot;Failed to retrieve post&quot;, &quot;message&quot;, e.getMessage()));&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Update post (author only)&#10;     */&#10;    @PutMapping(&quot;/{id}&quot;)&#10;    @RequireAuth&#10;    public ResponseEntity&lt;?&gt; updatePost(&#10;            @PathVariable String id,&#10;            @Valid @RequestBody PostRequest request) {&#10;        try {&#10;            String authorId = SecurityContextHolder.getCurrentUserIdOrThrow();&#10;            PostResponse updatedPost = postService.updatePost(id, request, authorId);&#10;            return ResponseEntity.ok(updatedPost);&#10;        } catch (SecurityException e) {&#10;            return ResponseEntity.status(HttpStatus.UNAUTHORIZED)&#10;                    .body(Map.of(&quot;error&quot;, &quot;Authentication required&quot;, &quot;message&quot;, e.getMessage()));&#10;        } catch (RuntimeException e) {&#10;            String message = e.getMessage();&#10;            if (message.contains(&quot;Only the author&quot;)) {&#10;                return ResponseEntity.status(HttpStatus.FORBIDDEN)&#10;                        .body(Map.of(&quot;error&quot;, &quot;Access denied&quot;, &quot;message&quot;, message));&#10;            }&#10;            return ResponseEntity.status(HttpStatus.NOT_FOUND)&#10;                    .body(Map.of(&quot;error&quot;, &quot;Post not found&quot;, &quot;message&quot;, message));&#10;        } catch (Exception e) {&#10;            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)&#10;                    .body(Map.of(&quot;error&quot;, &quot;Failed to update post&quot;, &quot;message&quot;, e.getMessage()));&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Delete post (author only)&#10;     */&#10;    @DeleteMapping(&quot;/{id}&quot;)&#10;    @RequireAuth&#10;    public ResponseEntity&lt;?&gt; deletePost(@PathVariable String id) {&#10;        try {&#10;            String authorId = SecurityContextHolder.getCurrentUserIdOrThrow();&#10;            postService.deletePost(id, authorId);&#10;            return ResponseEntity.noContent().build();&#10;        } catch (SecurityException e) {&#10;            return ResponseEntity.status(HttpStatus.UNAUTHORIZED)&#10;                    .body(Map.of(&quot;error&quot;, &quot;Authentication required&quot;, &quot;message&quot;, e.getMessage()));&#10;        } catch (RuntimeException e) {&#10;            String message = e.getMessage();&#10;            if (message.contains(&quot;Only the author&quot;)) {&#10;                return ResponseEntity.status(HttpStatus.FORBIDDEN)&#10;                        .body(Map.of(&quot;error&quot;, &quot;Access denied&quot;, &quot;message&quot;, message));&#10;            }&#10;            return ResponseEntity.status(HttpStatus.NOT_FOUND)&#10;                    .body(Map.of(&quot;error&quot;, &quot;Post not found&quot;, &quot;message&quot;, message));&#10;        } catch (Exception e) {&#10;            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)&#10;                    .body(Map.of(&quot;error&quot;, &quot;Failed to delete post&quot;, &quot;message&quot;, e.getMessage()));&#10;        }&#10;    }&#10;&#10;    // ========== INTERACTION ENDPOINTS ==========&#10;&#10;    /**&#10;     * Enhanced post interaction (like, comment, share)&#10;     */&#10;    @PostMapping(&quot;/{postId}/interact&quot;)&#10;    @RequireAuth&#10;    public ResponseEntity&lt;?&gt; interactWithPost(&#10;            @PathVariable String postId,&#10;            @RequestParam String action, // LIKE, UNLIKE, SHARE&#10;            @RequestParam(required = false) String reactionType) {&#10;        &#10;        try {&#10;            String userId = SecurityContextHolder.getCurrentUserIdOrThrow();&#10;            &#10;            // Try enhanced interaction first&#10;            try {&#10;                postService.handlePostInteraction(postId, userId, action, reactionType);&#10;                &#10;                // Create notification for post author if services are available&#10;                if (!&quot;UNLIKE&quot;.equals(action) &amp;&amp; notificationService != null) {&#10;                    try {&#10;                        String authorId = postService.getPostAuthorId(postId);&#10;                        notificationService.createNotification(&#10;                            authorId,&#10;                            userId,&#10;                            &quot;POST_&quot; + action,&#10;                            &quot;POST&quot;,&#10;                            postId,&#10;                            &quot;User &quot; + action.toLowerCase() + &quot;d your post&quot;&#10;                        );&#10;                    } catch (Exception e) {&#10;                        // Log error but don't fail the request&#10;                        System.err.println(&quot;Failed to create notification: &quot; + e.getMessage());&#10;                    }&#10;                }&#10;                &#10;                return ResponseEntity.ok().build();&#10;            } catch (Exception e) {&#10;                // Fallback to legacy interaction handling&#10;                InteractionRequest request = new InteractionRequest();&#10;                // Set appropriate interaction type based on action&#10;                request.setType(mapActionToInteractionType(action));&#10;                &#10;                InteractionResponse interaction = interactionService.createInteraction(postId, request, userId);&#10;                if (interaction == null) {&#10;                    return ResponseEntity.noContent().build();&#10;                }&#10;                return ResponseEntity.status(HttpStatus.CREATED).body(interaction);&#10;            }&#10;        } catch (Exception e) {&#10;            return ResponseEntity.status(HttpStatus.BAD_REQUEST)&#10;                    .body(Map.of(&quot;error&quot;, &quot;Failed to process interaction&quot;, &quot;message&quot;, e.getMessage()));&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Add comment to post - Legacy endpoint&#10;     */&#10;    @PostMapping(&quot;/{id}/comments&quot;)&#10;    @RequireAuth&#10;    public ResponseEntity&lt;?&gt; addComment(&#10;            @PathVariable String id,&#10;            @Valid @RequestBody CommentRequest request) {&#10;        &#10;        try {&#10;            String currentUserId = SecurityContextHolder.getCurrentUserIdOrThrow();&#10;            CommentResponse comment = commentService.createComment(id, request, currentUserId);&#10;            &#10;            // Create notification if service is available&#10;            if (notificationService != null) {&#10;                try {&#10;                    String authorId = postService.getPostAuthorId(id);&#10;                    notificationService.createNotification(&#10;                        authorId,&#10;                        currentUserId,&#10;                        &quot;POST_COMMENTED&quot;,&#10;                        &quot;POST&quot;,&#10;                        id,&#10;                        &quot;User commented on your post&quot;&#10;                    );&#10;                } catch (Exception e) {&#10;                    // Log error but don't fail the request&#10;                    System.err.println(&quot;Failed to create notification: &quot; + e.getMessage());&#10;                }&#10;            }&#10;            &#10;            return ResponseEntity.status(HttpStatus.CREATED).body(comment);&#10;        } catch (RuntimeException e) {&#10;            return ResponseEntity.badRequest()&#10;                    .body(Map.of(&quot;error&quot;, &quot;Failed to add comment&quot;, &quot;message&quot;, e.getMessage()));&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Add comment with string content - Enhanced endpoint&#10;     */&#10;    @PostMapping(&quot;/{postId}/comments/simple&quot;)&#10;    @RequireAuth&#10;    public ResponseEntity&lt;?&gt; addSimpleComment(&#10;            @PathVariable String postId,&#10;            @RequestBody String content) {&#10;        &#10;        try {&#10;            String userId = SecurityContextHolder.getCurrentUserIdOrThrow();&#10;            &#10;            // Try enhanced comment service first&#10;            try {&#10;                postService.addComment(postId, userId, content);&#10;                &#10;                // Create notification&#10;                if (notificationService != null) {&#10;                    try {&#10;                        String authorId = postService.getPostAuthorId(postId);&#10;                        notificationService.createNotification(&#10;                            authorId,&#10;                            userId,&#10;                            &quot;POST_COMMENTED&quot;,&#10;                            &quot;POST&quot;,&#10;                            postId,&#10;                            &quot;User commented on your post&quot;&#10;                        );&#10;                    } catch (Exception e) {&#10;                        System.err.println(&quot;Failed to create notification: &quot; + e.getMessage());&#10;                    }&#10;                }&#10;                &#10;                return ResponseEntity.ok().build();&#10;            } catch (Exception e) {&#10;                // Fallback to legacy comment service&#10;                CommentRequest request = new CommentRequest();&#10;                request.setContent(content);&#10;                CommentResponse comment = commentService.createComment(postId, request, userId);&#10;                return ResponseEntity.status(HttpStatus.CREATED).body(comment);&#10;            }&#10;        } catch (Exception e) {&#10;            return ResponseEntity.status(HttpStatus.BAD_REQUEST)&#10;                    .body(Map.of(&quot;error&quot;, &quot;Failed to add comment&quot;, &quot;message&quot;, e.getMessage()));&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get comments for post&#10;     */&#10;    @GetMapping(&quot;/{id}/comments&quot;)&#10;    public ResponseEntity&lt;Page&lt;CommentResponse&gt;&gt; getComments(&#10;            @PathVariable String id,&#10;            @RequestParam(defaultValue = &quot;0&quot;) int page,&#10;            @RequestParam(defaultValue = &quot;10&quot;) int size) {&#10;&#10;        Pageable pageable = PageRequest.of(page, size, Sort.by(&quot;createdAt&quot;).ascending());&#10;        Page&lt;CommentResponse&gt; comments = commentService.getCommentsByPost(id, pageable);&#10;        return ResponseEntity.ok(comments);&#10;    }&#10;&#10;    /**&#10;     * Record interaction (LIKE/SHARE/BOOKMARK) - Legacy endpoint&#10;     */&#10;    @PostMapping(&quot;/{id}/interactions&quot;)&#10;    @RequireAuth&#10;    public ResponseEntity&lt;InteractionResponse&gt; recordInteraction(&#10;            @PathVariable String id,&#10;            @Valid @RequestBody InteractionRequest request) {&#10;        String userId = SecurityContextHolder.getCurrentUserIdOrThrow();&#10;        try {&#10;            InteractionResponse interaction = interactionService.createInteraction(id, request, userId);&#10;            if (interaction == null) {&#10;                // Interaction was removed (e.g., unlike)&#10;                return ResponseEntity.noContent().build();&#10;            }&#10;            return ResponseEntity.status(HttpStatus.CREATED).body(interaction);&#10;        } catch (RuntimeException e) {&#10;            return ResponseEntity.badRequest().build();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Check if user has liked post&#10;     */&#10;    @GetMapping(&quot;/{id}/likes/check&quot;)&#10;    @RequireAuth&#10;    public ResponseEntity&lt;Boolean&gt; hasUserLikedPost(@PathVariable String id) {&#10;        String userId = SecurityContextHolder.getCurrentUserIdOrThrow();&#10;        boolean hasLiked = interactionService.hasUserReacted(id, userId);&#10;        return ResponseEntity.ok(hasLiked);&#10;    }&#10;&#10;    // ========== INTERACTION STATUS ENDPOINTS ==========&#10;&#10;    /**&#10;     * Check if user has liked a post&#10;     * This endpoint helps frontend maintain like state after page refresh&#10;     */&#10;    @GetMapping(&quot;/{postId}/interactions/like/status&quot;)&#10;    @RequireAuth&#10;    public ResponseEntity&lt;?&gt; checkLikeStatus(@PathVariable String postId) {&#10;        try {&#10;            String currentUserId = SecurityContextHolder.getCurrentUserIdOrThrow();&#10;            boolean hasLiked = interactionService.hasUserLikedPost(postId, currentUserId);&#10;            return ResponseEntity.ok(Map.of(&#10;                &quot;postId&quot;, postId,&#10;                &quot;hasLiked&quot;, hasLiked,&#10;                &quot;userId&quot;, currentUserId&#10;            ));&#10;        } catch (SecurityException e) {&#10;            return ResponseEntity.status(HttpStatus.UNAUTHORIZED)&#10;                    .body(Map.of(&quot;error&quot;, &quot;Authentication required&quot;));&#10;        } catch (Exception e) {&#10;            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)&#10;                    .body(Map.of(&quot;error&quot;, &quot;Failed to check like status&quot;));&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Check if user has bookmarked a post&#10;     * This endpoint helps frontend maintain bookmark state after page refresh&#10;     */&#10;    @GetMapping(&quot;/{postId}/interactions/bookmark/status&quot;)&#10;    @RequireAuth&#10;    public ResponseEntity&lt;?&gt; checkBookmarkStatus(@PathVariable String postId) {&#10;        try {&#10;            String currentUserId = SecurityContextHolder.getCurrentUserIdOrThrow();&#10;            boolean hasBookmarked = interactionService.hasUserBookmarkedPost(postId, currentUserId);&#10;            return ResponseEntity.ok(Map.of(&#10;                &quot;postId&quot;, postId,&#10;                &quot;hasBookmarked&quot;, hasBookmarked,&#10;                &quot;userId&quot;, currentUserId&#10;            ));&#10;        } catch (SecurityException e) {&#10;            return ResponseEntity.status(HttpStatus.UNAUTHORIZED)&#10;                    .body(Map.of(&quot;error&quot;, &quot;Authentication required&quot;));&#10;        } catch (Exception e) {&#10;            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)&#10;                    .body(Map.of(&quot;error&quot;, &quot;Failed to check bookmark status&quot;));&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get all user interactions for a post&#10;     * This endpoint provides complete interaction state for frontend&#10;     */&#10;    @GetMapping(&quot;/{postId}/interactions/status&quot;)&#10;    @RequireAuth&#10;    public ResponseEntity&lt;?&gt; getUserInteractionStatus(@PathVariable String postId) {&#10;        try {&#10;            String currentUserId = SecurityContextHolder.getCurrentUserIdOrThrow();&#10;            boolean hasLiked = interactionService.hasUserLikedPost(postId, currentUserId);&#10;            boolean hasBookmarked = interactionService.hasUserBookmarkedPost(postId, currentUserId);&#10;&#10;            return ResponseEntity.ok(Map.of(&#10;                &quot;postId&quot;, postId,&#10;                &quot;userId&quot;, currentUserId,&#10;                &quot;hasLiked&quot;, hasLiked,&#10;                &quot;hasBookmarked&quot;, hasBookmarked,&#10;                &quot;interactions&quot;, Map.of(&#10;                    &quot;LIKE&quot;, hasLiked,&#10;                    &quot;BOOKMARK&quot;, hasBookmarked&#10;                )&#10;            ));&#10;        } catch (SecurityException e) {&#10;            return ResponseEntity.status(HttpStatus.UNAUTHORIZED)&#10;                    .body(Map.of(&quot;error&quot;, &quot;Authentication required&quot;));&#10;        } catch (Exception e) {&#10;            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)&#10;                    .body(Map.of(&quot;error&quot;, &quot;Failed to get interaction status&quot;));&#10;        }&#10;    }&#10;&#10;    // ========== USER PROFILE SYNCHRONIZATION ENDPOINTS ==========&#10;&#10;    /**&#10;     * Manual user profile synchronization endpoint&#10;     * This endpoint allows manual synchronization of user profile data across post-service&#10;     */&#10;    @PostMapping(&quot;/admin/sync-user-profile/{userId}&quot;)&#10;    @RequireAuth(roles = {&quot;ADMIN&quot;})&#10;    public ResponseEntity&lt;?&gt; syncUserProfile(@PathVariable String userId) {&#10;        try {&#10;            // Get updated user info from user-service&#10;            AuthorInfo updatedAuthor = userServiceClient.getAuthorInfo(userId);&#10;            if (updatedAuthor == null) {&#10;                return ResponseEntity.status(HttpStatus.NOT_FOUND)&#10;                        .body(Map.of(&quot;error&quot;, &quot;User not found&quot;, &quot;userId&quot;, userId));&#10;            }&#10;            &#10;            // Perform manual sync&#10;            userSyncService.manualSyncUserProfile(userId, updatedAuthor);&#10;            &#10;            return ResponseEntity.ok(Map.of(&#10;                &quot;message&quot;, &quot;User profile synchronized successfully&quot;,&#10;                &quot;userId&quot;, userId,&#10;                &quot;updatedAuthor&quot;, updatedAuthor&#10;            ));&#10;        } catch (SecurityException e) {&#10;            return ResponseEntity.status(HttpStatus.UNAUTHORIZED)&#10;                    .body(Map.of(&quot;error&quot;, &quot;Admin access required&quot;));&#10;        } catch (Exception e) {&#10;            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)&#10;                    .body(Map.of(&quot;error&quot;, &quot;Failed to sync user profile&quot;, &quot;message&quot;, e.getMessage()));&#10;        }&#10;    }&#10;&#10;    // ========== HELPER METHODS ==========&#10;&#10;    private String mapActionToInteractionType(String action) {&#10;        switch (action.toUpperCase()) {&#10;            case &quot;LIKE&quot;:&#10;                return &quot;LIKE&quot;;&#10;            case &quot;SHARE&quot;:&#10;                return &quot;SHARE&quot;;&#10;            case &quot;BOOKMARK&quot;:&#10;                return &quot;BOOKMARK&quot;;&#10;            default:&#10;                return &quot;LIKE&quot;;&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/dto/response/InteractionResponse.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/dto/response/InteractionResponse.java" />
              <option name="originalContent" value="package com.ctuconnect.dto.response;&#10;&#10;import com.ctuconnect.entity.InteractionEntity;&#10;import lombok.Data;&#10;import lombok.Getter;&#10;import lombok.Setter;&#10;&#10;import java.time.LocalDateTime;&#10;import java.util.Map;&#10;&#10;@Data&#10;public class InteractionResponse {&#10;&#10;    // Getters and Setters&#10;    private String id;&#10;    private String postId;&#10;    private String userId;&#10;    private InteractionEntity.InteractionType type;&#10;    private Map&lt;String, Object&gt; metadata;&#10;    private LocalDateTime createdAt;&#10;&#10;    // Constructors&#10;    public InteractionResponse() {}&#10;&#10;    public InteractionResponse(InteractionEntity interaction) {&#10;        this.id = interaction.getId();&#10;        this.postId = interaction.getPostId();&#10;        this.userId = interaction.getUserId();&#10;        this.type = interaction.getType();&#10;        this.metadata = interaction.getMetadata();&#10;        this.createdAt = interaction.getCreatedAt();&#10;    }&#10;&#10;}&#10;" />
              <option name="updatedContent" value="package com.ctuconnect.dto.response;&#13;&#10;&#13;&#10;import com.ctuconnect.entity.InteractionEntity;&#13;&#10;import lombok.Data;&#13;&#10;import lombok.Getter;&#13;&#10;import lombok.Setter;&#13;&#10;&#13;&#10;import java.time.LocalDateTime;&#13;&#10;import java.util.Map;&#13;&#10;&#13;&#10;@Data&#13;&#10;public class InteractionResponse {&#13;&#10;&#13;&#10;    // Getters and Setters&#13;&#10;    private String id;&#13;&#10;    private String postId;&#13;&#10;    private String userId;&#13;&#10;    private InteractionEntity.InteractionType type;&#13;&#10;    private Map&lt;String, Object&gt; metadata;&#13;&#10;    private LocalDateTime createdAt;&#13;&#10;    &#13;&#10;    // New fields for status responses&#13;&#10;    private boolean hasInteraction;&#13;&#10;    private String message;&#13;&#10;&#13;&#10;    // Constructors&#13;&#10;    public InteractionResponse() {}&#13;&#10;&#13;&#10;    public InteractionResponse(InteractionEntity interaction) {&#13;&#10;        this.id = interaction.getId();&#13;&#10;        this.postId = interaction.getPostId();&#13;&#10;        this.userId = interaction.getUserId();&#13;&#10;        this.type = interaction.getType();&#13;&#10;        this.metadata = interaction.getMetadata();&#13;&#10;        this.createdAt = interaction.getCreatedAt();&#13;&#10;        this.hasInteraction = true;&#13;&#10;    }&#13;&#10;    &#13;&#10;    // Constructor for status responses&#13;&#10;    public InteractionResponse(boolean hasInteraction, String message) {&#13;&#10;        this.hasInteraction = hasInteraction;&#13;&#10;        this.message = message;&#13;&#10;    }&#13;&#10;&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/repository/CommentRepository.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/repository/CommentRepository.java" />
              <option name="originalContent" value="package com.ctuconnect.repository;&#10;&#10;import org.springframework.data.domain.Page;&#10;import org.springframework.data.domain.Pageable;&#10;import org.springframework.data.mongodb.repository.MongoRepository;&#10;import org.springframework.data.mongodb.repository.Query;&#10;import org.springframework.stereotype.Repository;&#10;import com.ctuconnect.entity.CommentEntity;&#10;&#10;import java.util.List;&#10;&#10;@Repository&#10;public interface CommentRepository extends MongoRepository&lt;CommentEntity, String&gt; {&#10;&#10;    Page&lt;CommentEntity&gt; findByPostId(String postId, Pageable pageable);&#10;&#10;    List&lt;CommentEntity&gt; findByPostIdAndParentCommentIdIsNull(String postId);&#10;&#10;    List&lt;CommentEntity&gt; findByParentCommentId(String parentCommentId);&#10;&#10;    long countByPostId(String postId);&#10;&#10;    // Fix: Use MongoDB query for nested author object&#10;    @Query(value = &quot;{ 'author.id': ?0 }&quot;, count = true)&#10;    long countByAuthor_Id(String authorId);&#10;&#10;    void deleteByPostId(String postId);&#10;&#10;    // Additional useful queries for nested author structure&#10;    @Query(&quot;{ 'author.id': ?0 }&quot;)&#10;    Page&lt;CommentEntity&gt; findByAuthor_Id(String authorId, Pageable pageable);&#10;&#10;    // Add method that AdminController is calling (without underscore)&#10;    @Query(value = &quot;{ 'author.id': ?0 }&quot;, count = true)&#10;    long countByAuthorId(String authorId);&#10;}&#10;" />
              <option name="updatedContent" value="package com.ctuconnect.repository;&#13;&#10;&#13;&#10;import org.springframework.data.domain.Page;&#13;&#10;import org.springframework.data.domain.Pageable;&#13;&#10;import org.springframework.data.mongodb.repository.MongoRepository;&#13;&#10;import org.springframework.data.mongodb.repository.Query;&#13;&#10;import org.springframework.stereotype.Repository;&#13;&#10;import com.ctuconnect.entity.CommentEntity;&#13;&#10;&#13;&#10;import java.util.List;&#13;&#10;&#13;&#10;@Repository&#13;&#10;public interface CommentRepository extends MongoRepository&lt;CommentEntity, String&gt; {&#13;&#10;&#13;&#10;    Page&lt;CommentEntity&gt; findByPostId(String postId, Pageable pageable);&#13;&#10;&#13;&#10;    List&lt;CommentEntity&gt; findByPostIdAndParentCommentIdIsNull(String postId);&#13;&#10;&#13;&#10;    List&lt;CommentEntity&gt; findByParentCommentId(String parentCommentId);&#13;&#10;&#13;&#10;    long countByPostId(String postId);&#13;&#10;&#13;&#10;    // Fix: Use MongoDB query for nested author object&#13;&#10;    @Query(value = &quot;{ 'author.id': ?0 }&quot;, count = true)&#13;&#10;    long countByAuthor_Id(String authorId);&#13;&#10;&#13;&#10;    void deleteByPostId(String postId);&#13;&#10;&#13;&#10;    // Additional useful queries for nested author structure&#13;&#10;    @Query(&quot;{ 'author.id': ?0 }&quot;)&#13;&#10;    Page&lt;CommentEntity&gt; findByAuthor_Id(String authorId, Pageable pageable);&#13;&#10;&#13;&#10;    // Add method that AdminController is calling (without underscore)&#13;&#10;    @Query(value = &quot;{ 'author.id': ?0 }&quot;, count = true)&#13;&#10;    long countByAuthorId(String authorId);&#13;&#10;&#13;&#10;    // Method for user profile synchronization - find all comments by author ID&#13;&#10;    @Query(&quot;{ 'author.id': ?0 }&quot;)&#13;&#10;    List&lt;CommentEntity&gt; findByAuthor_Id(String authorId);&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/repository/InteractionRepository.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/repository/InteractionRepository.java" />
              <option name="originalContent" value="package com.ctuconnect.repository;&#10;&#10;import org.springframework.data.domain.Page;&#10;import org.springframework.data.domain.Pageable;&#10;import org.springframework.data.mongodb.repository.MongoRepository;&#10;import org.springframework.data.mongodb.repository.Query;&#10;import org.springframework.stereotype.Repository;&#10;import com.ctuconnect.dto.AuthorInfo;&#10;import com.ctuconnect.entity.InteractionEntity;&#10;&#10;import java.util.List;&#10;import java.util.Optional;&#10;&#10;@Repository&#10;public interface InteractionRepository extends MongoRepository&lt;InteractionEntity, String&gt; {&#10;&#10;    // Find by postId and author.id and type&#10;    @Query(&quot;{ 'postId': ?0, 'author.id': ?1, 'type': ?2 }&quot;)&#10;    Optional&lt;InteractionEntity&gt; findByPostIdAndAuthor_IdAndType(String postId, String authorId, InteractionEntity.InteractionType type);&#10;&#10;    // Find by postId and author object and type&#10;    Optional&lt;InteractionEntity&gt; findByPostIdAndAuthorAndType(String postId, AuthorInfo author, InteractionEntity.InteractionType type);&#10;&#10;    List&lt;InteractionEntity&gt; findByPostId(String postId);&#10;&#10;    @Query(&quot;{ 'author.id': ?0 }&quot;)&#10;    List&lt;InteractionEntity&gt; findByAuthor_Id(String authorId);&#10;&#10;    Page&lt;InteractionEntity&gt; findByPostIdAndType(String postId, InteractionEntity.InteractionType type, Pageable pageable);&#10;&#10;    long countByPostIdAndType(String postId, InteractionEntity.InteractionType type);&#10;&#10;    @Query(value = &quot;{ 'author.id': ?0, 'type': ?1 }&quot;, count = true)&#10;    long countByAuthor_IdAndType(String authorId, InteractionEntity.InteractionType type);&#10;&#10;    void deleteByPostId(String postId);&#10;&#10;    // Additional useful queries&#10;    @Query(&quot;{ 'postId': ?0, 'type': 'LIKE' }&quot;)&#10;    List&lt;InteractionEntity&gt; findLikesByPostId(String postId);&#10;&#10;    @Query(&quot;{ 'author.id': ?0, 'type': 'LIKE' }&quot;)&#10;    List&lt;InteractionEntity&gt; findLikesByAuthor_Id(String authorId);&#10;&#10;    @Query(&quot;{ 'postId': ?0, 'author.id': ?1 }&quot;)&#10;    List&lt;InteractionEntity&gt; findByPostIdAndAuthor_Id(String postId, String authorId);&#10;&#10;    Optional&lt;Object&gt; findByPostIdAndUserIdAndType(String postId, String userId, InteractionEntity.InteractionType interactionType);&#10;&#10;    // Add method that AdminController is calling (using userId instead of authorId)&#10;    @Query(value = &quot;{ 'author.id': ?0, 'type': ?1 }&quot;, count = true)&#10;    long countByUserIdAndType(String userId, InteractionEntity.InteractionType type);&#10;}&#10;" />
              <option name="updatedContent" value="package com.ctuconnect.repository;&#13;&#10;&#13;&#10;import org.springframework.data.domain.Page;&#13;&#10;import org.springframework.data.domain.Pageable;&#13;&#10;import org.springframework.data.mongodb.repository.MongoRepository;&#13;&#10;import org.springframework.data.mongodb.repository.Query;&#13;&#10;import org.springframework.stereotype.Repository;&#13;&#10;import com.ctuconnect.dto.AuthorInfo;&#13;&#10;import com.ctuconnect.entity.InteractionEntity;&#13;&#10;&#13;&#10;import java.util.List;&#13;&#10;import java.util.Optional;&#13;&#10;&#13;&#10;@Repository&#13;&#10;public interface InteractionRepository extends MongoRepository&lt;InteractionEntity, String&gt; {&#13;&#10;&#13;&#10;    // Find by postId and author.id and type&#13;&#10;    @Query(&quot;{ 'postId': ?0, 'author.id': ?1, 'type': ?2 }&quot;)&#13;&#10;    Optional&lt;InteractionEntity&gt; findByPostIdAndAuthor_IdAndType(String postId, String authorId, InteractionEntity.InteractionType type);&#13;&#10;&#13;&#10;    // Find by postId and author object and type&#13;&#10;    Optional&lt;InteractionEntity&gt; findByPostIdAndAuthorAndType(String postId, AuthorInfo author, InteractionEntity.InteractionType type);&#13;&#10;&#13;&#10;    List&lt;InteractionEntity&gt; findByPostId(String postId);&#13;&#10;&#13;&#10;    @Query(&quot;{ 'author.id': ?0 }&quot;)&#13;&#10;    List&lt;InteractionEntity&gt; findByAuthor_Id(String authorId);&#13;&#10;&#13;&#10;    Page&lt;InteractionEntity&gt; findByPostIdAndType(String postId, InteractionEntity.InteractionType type, Pageable pageable);&#13;&#10;&#13;&#10;    long countByPostIdAndType(String postId, InteractionEntity.InteractionType type);&#13;&#10;&#13;&#10;    @Query(value = &quot;{ 'author.id': ?0, 'type': ?1 }&quot;, count = true)&#13;&#10;    long countByAuthor_IdAndType(String authorId, InteractionEntity.InteractionType type);&#13;&#10;&#13;&#10;    void deleteByPostId(String postId);&#13;&#10;&#13;&#10;    // Additional useful queries&#13;&#10;    @Query(&quot;{ 'postId': ?0, 'type': 'LIKE' }&quot;)&#13;&#10;    List&lt;InteractionEntity&gt; findLikesByPostId(String postId);&#13;&#10;&#13;&#10;    @Query(&quot;{ 'author.id': ?0, 'type': 'LIKE' }&quot;)&#13;&#10;    List&lt;InteractionEntity&gt; findLikesByAuthor_Id(String authorId);&#13;&#10;&#13;&#10;    @Query(&quot;{ 'postId': ?0, 'author.id': ?1 }&quot;)&#13;&#10;    List&lt;InteractionEntity&gt; findByPostIdAndAuthor_Id(String postId, String authorId);&#13;&#10;&#13;&#10;    // Find existing interaction by postId and userId (using author.id field)&#13;&#10;    @Query(&quot;{ 'postId': ?0, 'author.id': ?1, 'type': ?2 }&quot;)&#13;&#10;    Optional&lt;InteractionEntity&gt; findByPostIdAndUserIdAndType(String postId, String userId, InteractionEntity.InteractionType type);&#13;&#10;&#13;&#10;    // Additional methods for user profile synchronization&#13;&#10;    @Query(&quot;{ 'author.id': ?0 }&quot;)&#13;&#10;    List&lt;InteractionEntity&gt; findByAuthor_Id(String authorId);&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/service/InteractionService.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/service/InteractionService.java" />
              <option name="originalContent" value="package com.ctuconnect.service;&#10;&#10;import org.springframework.beans.factory.annotation.Autowired;&#10;import org.springframework.stereotype.Service;&#10;import com.ctuconnect.client.UserServiceClient;&#10;import com.ctuconnect.dto.AuthorInfo;&#10;import com.ctuconnect.dto.request.InteractionRequest;&#10;import com.ctuconnect.dto.response.InteractionResponse;&#10;import com.ctuconnect.entity.InteractionEntity;&#10;import com.ctuconnect.entity.PostEntity;&#10;import com.ctuconnect.repository.InteractionRepository;&#10;import com.ctuconnect.repository.PostRepository;&#10;&#10;@Service&#10;public class InteractionService {&#10;&#10;    @Autowired&#10;    private InteractionRepository interactionRepository;&#10;&#10;    @Autowired&#10;    private PostRepository postRepository;&#10;&#10;    @Autowired&#10;    private UserServiceClient userServiceClient;&#10;&#10;    @Autowired&#10;    private EventService eventService;&#10;&#10;    public InteractionResponse createInteraction(String postId, InteractionRequest request, String authorId) {&#10;        AuthorInfo author = userServiceClient.getAuthorInfo(authorId);&#10;        PostEntity post = postRepository.findById(postId)&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;Post not found with id: &quot; + postId));&#10;&#10;        // Check if user already has this type of interaction with the post&#10;        Optional&lt;InteractionEntity&gt; existingInteraction = interactionRepository&#10;                .findByPostIdAndUserIdAndType(postId, authorId, request.getReaction());&#10;&#10;        if (existingInteraction.isPresent()) {&#10;            // User already has this interaction - remove it (toggle off)&#10;            interactionRepository.delete(existingInteraction.get());&#10;&#10;            // Update post stats&#10;            if (request.getReaction() == InteractionEntity.InteractionType.LIKE) {&#10;                post.getStats().decrementReaction(InteractionEntity.ReactionType.LIKE);&#10;            } else if (request.getReaction() == InteractionEntity.InteractionType.BOOKMARK) {&#10;                // Handle bookmark decrement if needed&#10;            }&#10;&#10;            postRepository.save(post);&#10;            eventService.publishInteractionEvent(postId, authorId, &quot;UN-&quot; + request.getReaction().toString());&#10;            return null; // Interaction removed&#10;        } else {&#10;            // Create new interaction&#10;            InteractionEntity interaction = new InteractionEntity(postId, author, request.getReaction());&#10;            interaction.setMetadata(request.getMetadata());&#10;            InteractionEntity saved = interactionRepository.save(interaction);&#10;&#10;            // Update post stats&#10;            if (request.getReaction() == InteractionEntity.InteractionType.LIKE) {&#10;                post.getStats().incrementReaction(InteractionEntity.ReactionType.LIKE);&#10;            } else if (request.getReaction() == InteractionEntity.InteractionType.BOOKMARK) {&#10;                // Handle bookmark increment if needed&#10;            }&#10;&#10;            postRepository.save(post);&#10;            eventService.publishInteractionEvent(postId, authorId, request.getReaction().toString());&#10;            return new InteractionResponse(saved);&#10;        }&#10;    }&#10;&#10;    private InteractionResponse handleReaction(PostEntity post, AuthorInfo author, InteractionRequest request) {&#10;        InteractionEntity.InteractionType newReaction = request.getReaction();&#10;&#10;        Optional&lt;InteractionEntity&gt; existing = interactionRepository.findByPostIdAndAuthorAndType(&#10;                post.getId(), author, InteractionEntity.InteractionType.LIKE);&#10;&#10;        if (existing.isPresent()) {&#10;            InteractionEntity current = existing.get();&#10;            InteractionEntity.InteractionType oldReaction = new InteractionEntity().getType();&#10;&#10;&#10;            if (oldReaction == newReaction) {&#10;                interactionRepository.delete(current);&#10;                post.getStats().decrementReaction(oldReaction.getReactionType());&#10;                postRepository.save(post);&#10;&#10;                eventService.publishInteractionEvent(post.getId(), author.getId(), &quot;UN-&quot; + newReaction.name());&#10;                return null;&#10;            } else {&#10;                current.setReaction(newReaction);&#10;                InteractionEntity saved = interactionRepository.save(current);&#10;&#10;                post.getStats().decrementReaction(oldReaction.getReactionType());&#10;                post.getStats().incrementReaction(newReaction.getReactionType());&#10;                postRepository.save(post);&#10;&#10;                eventService.publishInteractionEvent(post.getId(), author.getId(), newReaction.name());&#10;                return new InteractionResponse(saved);&#10;            }&#10;        } else {&#10;            InteractionEntity newInteraction = new InteractionEntity(post.getId(), author, InteractionEntity.InteractionType.LIKE);&#10;            newInteraction.setReaction(newReaction);&#10;            newInteraction.setMetadata(request.getMetadata());&#10;            InteractionEntity saved = interactionRepository.save(newInteraction);&#10;&#10;            post.getStats().incrementReaction(newReaction.getReactionType());&#10;            postRepository.save(post);&#10;&#10;            eventService.publishInteractionEvent(post.getId(), author.getId(), newReaction.name());&#10;            return new InteractionResponse(saved);&#10;        }&#10;    }&#10;&#10;    private void updatePostStats(PostEntity post, InteractionEntity.InteractionType type) {&#10;        if (Objects.requireNonNull(type) == InteractionEntity.InteractionType.SHARE) {&#10;            post.getStats().incrementShares();&#10;        }&#10;    }&#10;&#10;    public boolean hasUserReacted(String postId, String userId) {&#10;        return interactionRepository.findByPostIdAndUserIdAndType(&#10;                postId, userId, InteractionEntity.InteractionType.LIKE).isPresent();&#10;    }&#10;&#10;    public long getInteractionCount(String postId, InteractionEntity.InteractionType type) {&#10;        return interactionRepository.countByPostIdAndType(postId, type);&#10;    }&#10;&#10;" />
              <option name="updatedContent" value="package com.ctuconnect.service;&#10;&#10;import org.springframework.beans.factory.annotation.Autowired;&#10;import org.springframework.stereotype.Service;&#10;import com.ctuconnect.client.UserServiceClient;&#10;import com.ctuconnect.dto.AuthorInfo;&#10;import com.ctuconnect.dto.request.InteractionRequest;&#10;import com.ctuconnect.dto.response.InteractionResponse;&#10;import com.ctuconnect.entity.InteractionEntity;&#10;import com.ctuconnect.entity.PostEntity;&#10;import com.ctuconnect.repository.InteractionRepository;&#10;import com.ctuconnect.repository.PostRepository;&#10;&#10;import java.util.Objects;&#10;import java.util.Optional;&#10;import java.util.List;&#10;&#10;@Service&#10;public class InteractionService {&#10;&#10;    @Autowired&#10;    private InteractionRepository interactionRepository;&#10;&#10;    @Autowired&#10;    private PostRepository postRepository;&#10;&#10;    @Autowired&#10;    private UserServiceClient userServiceClient;&#10;&#10;    @Autowired&#10;    private EventService eventService;&#10;&#10;    /**&#10;     * Create or toggle interaction (like/bookmark)&#10;     * Fixed to properly handle state persistence and prevent duplicates&#10;     */&#10;    public InteractionResponse createInteraction(String postId, InteractionRequest request, String authorId) {&#10;        AuthorInfo author = userServiceClient.getAuthorInfo(authorId);&#10;        if (author == null) {&#10;            throw new RuntimeException(&quot;Author not found with id: &quot; + authorId);&#10;        }&#10;&#10;        PostEntity post = postRepository.findById(postId)&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;Post not found with id: &quot; + postId));&#10;&#10;        // Check if user already has this type of interaction with the post&#10;        Optional&lt;InteractionEntity&gt; existingInteraction = interactionRepository&#10;                .findByPostIdAndAuthor_IdAndType(postId, authorId, request.getReaction());&#10;&#10;        if (existingInteraction.isPresent()) {&#10;            // User already has this interaction - remove it (toggle off)&#10;            interactionRepository.delete(existingInteraction.get());&#10;&#10;            // Update post stats&#10;            updatePostStatsOnRemove(post, request.getReaction());&#10;            postRepository.save(post);&#10;&#10;            eventService.publishInteractionEvent(postId, authorId, &quot;UN-&quot; + request.getReaction().toString());&#10;            return new InteractionResponse(false, &quot;Interaction removed&quot;); // Interaction removed&#10;        } else {&#10;            // Create new interaction&#10;            InteractionEntity interaction = new InteractionEntity(postId, author, request.getReaction());&#10;            if (request.getMetadata() != null) {&#10;                interaction.setMetadata(request.getMetadata());&#10;            }&#10;            InteractionEntity saved = interactionRepository.save(interaction);&#10;&#10;            // Update post stats&#10;            updatePostStatsOnAdd(post, request.getReaction());&#10;            postRepository.save(post);&#10;&#10;            eventService.publishInteractionEvent(postId, authorId, request.getReaction().toString());&#10;            return new InteractionResponse(saved);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get user's interaction status for a post&#10;     * This method helps frontend determine current interaction state&#10;     */&#10;    public InteractionResponse getUserInteractionStatus(String postId, String userId) {&#10;        List&lt;InteractionEntity&gt; userInteractions = interactionRepository.findByPostIdAndAuthor_Id(postId, userId);&#10;&#10;        if (userInteractions.isEmpty()) {&#10;            return new InteractionResponse(false, &quot;No interactions found&quot;);&#10;        }&#10;&#10;        // Return the first interaction (in case of multiple, though there shouldn't be)&#10;        return new InteractionResponse(userInteractions.get(0));&#10;    }&#10;&#10;    /**&#10;     * Check if user has liked a specific post&#10;     */&#10;    public boolean hasUserLikedPost(String postId, String userId) {&#10;        return interactionRepository.findByPostIdAndAuthor_IdAndType(&#10;            postId, userId, InteractionEntity.InteractionType.LIKE).isPresent();&#10;    }&#10;&#10;    /**&#10;     * Check if user has bookmarked a specific post&#10;     */&#10;    public boolean hasUserBookmarkedPost(String postId, String userId) {&#10;        return interactionRepository.findByPostIdAndAuthor_IdAndType(&#10;            postId, userId, InteractionEntity.InteractionType.BOOKMARK).isPresent();&#10;    }&#10;&#10;    private void updatePostStatsOnAdd(PostEntity post, InteractionEntity.InteractionType type) {&#10;        switch (type) {&#10;            case LIKE:&#10;                post.getStats().incrementLikes();&#10;                post.getStats().incrementReaction(InteractionEntity.ReactionType.LIKE);&#10;                break;&#10;            case BOOKMARK:&#10;                // Handle bookmark stats if needed&#10;                break;&#10;            case SHARE:&#10;                post.getStats().incrementShares();&#10;                break;&#10;            default:&#10;                break;&#10;        }&#10;    }&#10;&#10;    private void updatePostStatsOnRemove(PostEntity post, InteractionEntity.InteractionType type) {&#10;        switch (type) {&#10;            case LIKE:&#10;                post.getStats().decrementLikes();&#10;                post.getStats().decrementReaction(InteractionEntity.ReactionType.LIKE);&#10;                break;&#10;            case BOOKMARK:&#10;                // Handle bookmark stats if needed&#10;                break;&#10;            case SHARE:&#10;                post.getStats().decrementShares();&#10;                break;&#10;            default:&#10;                break;&#10;        }&#10;    }&#10;&#10;    public long getInteractionCount(String postId, InteractionEntity.InteractionType type) {&#10;        return interactionRepository.countByPostIdAndType(postId, type);&#10;    }&#10;&#10;    /**&#10;     * Check if user has reacted to a post (for legacy compatibility)&#10;     */&#10;    public boolean hasUserReacted(String postId, String userId) {&#10;        return hasUserLikedPost(postId, userId);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/service/UserServiceClient.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/service/UserServiceClient.java" />
              <option name="updatedContent" value="package com.ctuconnect.service;&#10;&#10;import org.springframework.cloud.openfeign.FeignClient;&#10;import org.springframework.web.bind.annotation.GetMapping;&#10;import org.springframework.web.bind.annotation.PathVariable;&#10;&#10;import java.util.Set;&#10;&#10;@FeignClient(name = &quot;user-service&quot;, url = &quot;${user-service.url:http://user-service:8081}&quot;)&#10;public interface UserServiceClient {&#10;    &#10;    @GetMapping(&quot;/api/users/{userId}/friends/ids&quot;)&#10;    Set&lt;String&gt; getFriendIds(@PathVariable String userId);&#10;    &#10;    @GetMapping(&quot;/api/users/{userId}/close-interactions&quot;)&#10;    Set&lt;String&gt; getCloseInteractionIds(@PathVariable String userId);&#10;    &#10;    @GetMapping(&quot;/api/users/{userId}/same-faculty&quot;)&#10;    Set&lt;String&gt; getSameFacultyUserIds(@PathVariable String userId);&#10;    &#10;    @GetMapping(&quot;/api/users/{userId}/same-major&quot;)&#10;    Set&lt;String&gt; getSameMajorUserIds(@PathVariable String userId);&#10;    &#10;    @GetMapping(&quot;/api/users/{userId}/interest-tags&quot;)&#10;    Set&lt;String&gt; getUserInterestTags(@PathVariable String userId);&#10;    &#10;    @GetMapping(&quot;/api/users/{userId}/preferred-categories&quot;)&#10;    Set&lt;String&gt; getUserPreferredCategories(@PathVariable String userId);&#10;    &#10;    @GetMapping(&quot;/api/users/{userId}/faculty-id&quot;)&#10;    String getUserFacultyId(@PathVariable String userId);&#10;    &#10;    @GetMapping(&quot;/api/users/{userId}/major-id&quot;)&#10;    String getUserMajorId(@PathVariable String userId);&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/service/UserSyncService.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/post-service/src/main/java/com/ctuconnect/service/UserSyncService.java" />
              <option name="updatedContent" value="package com.ctuconnect.service;&#10;&#10;import org.springframework.beans.factory.annotation.Autowired;&#10;import org.springframework.kafka.annotation.KafkaListener;&#10;import org.springframework.stereotype.Service;&#10;import com.ctuconnect.dto.AuthorInfo;&#10;import com.ctuconnect.entity.PostEntity;&#10;import com.ctuconnect.entity.CommentEntity;&#10;import com.ctuconnect.entity.InteractionEntity;&#10;import com.ctuconnect.repository.PostRepository;&#10;import com.ctuconnect.repository.CommentRepository;&#10;import com.ctuconnect.repository.InteractionRepository;&#10;import com.fasterxml.jackson.databind.ObjectMapper;&#10;&#10;import lombok.extern.slf4j.Slf4j;&#10;import java.util.List;&#10;import java.util.Map;&#10;&#10;/**&#10; * Service to handle user profile synchronization across post-service&#10; * When user updates profile in user-service, this updates author info in posts, comments, interactions&#10; */&#10;@Service&#10;@Slf4j&#10;public class UserSyncService {&#10;&#10;    @Autowired&#10;    private PostRepository postRepository;&#10;&#10;    @Autowired&#10;    private CommentRepository commentRepository;&#10;&#10;    @Autowired&#10;    private InteractionRepository interactionRepository;&#10;&#10;    @Autowired&#10;    private ObjectMapper objectMapper;&#10;&#10;    /**&#10;     * Listen for user profile update events from user-service&#10;     */&#10;    @KafkaListener(topics = &quot;user-profile-updated&quot;, groupId = &quot;post-service-group&quot;)&#10;    public void handleUserProfileUpdate(String message) {&#10;        try {&#10;            log.info(&quot;Received user profile update event: {}&quot;, message);&#10;            &#10;            // Parse the message to extract user information&#10;            Map&lt;String, Object&gt; userUpdate = objectMapper.readValue(message, Map.class);&#10;            String userId = (String) userUpdate.get(&quot;userId&quot;);&#10;            &#10;            if (userId == null) {&#10;                log.warn(&quot;User ID is null in profile update event&quot;);&#10;                return;&#10;            }&#10;&#10;            // Extract updated user information&#10;            AuthorInfo updatedAuthor = extractAuthorInfo(userUpdate);&#10;            &#10;            if (updatedAuthor != null) {&#10;                // Update author info in all related entities&#10;                updateAuthorInPosts(userId, updatedAuthor);&#10;                updateAuthorInComments(userId, updatedAuthor);&#10;                updateAuthorInInteractions(userId, updatedAuthor);&#10;                &#10;                log.info(&quot;Successfully updated author info for user: {}&quot;, userId);&#10;            } else {&#10;                log.warn(&quot;Could not extract author info from user update event&quot;);&#10;            }&#10;            &#10;        } catch (Exception e) {&#10;            log.error(&quot;Failed to process user profile update event: {}&quot;, e.getMessage(), e);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Update author information in all posts by this user&#10;     */&#10;    private void updateAuthorInPosts(String userId, AuthorInfo updatedAuthor) {&#10;        try {&#10;            List&lt;PostEntity&gt; userPosts = postRepository.findByAuthor_Id(userId);&#10;            &#10;            for (PostEntity post : userPosts) {&#10;                post.setAuthor(updatedAuthor);&#10;            }&#10;            &#10;            if (!userPosts.isEmpty()) {&#10;                postRepository.saveAll(userPosts);&#10;                log.info(&quot;Updated author info in {} posts for user: {}&quot;, userPosts.size(), userId);&#10;            }&#10;            &#10;        } catch (Exception e) {&#10;            log.error(&quot;Failed to update author info in posts for user {}: {}&quot;, userId, e.getMessage());&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Update author information in all comments by this user&#10;     */&#10;    private void updateAuthorInComments(String userId, AuthorInfo updatedAuthor) {&#10;        try {&#10;            List&lt;CommentEntity&gt; userComments = commentRepository.findByAuthor_Id(userId);&#10;            &#10;            for (CommentEntity comment : userComments) {&#10;                comment.setAuthor(updatedAuthor);&#10;            }&#10;            &#10;            if (!userComments.isEmpty()) {&#10;                commentRepository.saveAll(userComments);&#10;                log.info(&quot;Updated author info in {} comments for user: {}&quot;, userComments.size(), userId);&#10;            }&#10;            &#10;        } catch (Exception e) {&#10;            log.error(&quot;Failed to update author info in comments for user {}: {}&quot;, userId, e.getMessage());&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Update author information in all interactions by this user&#10;     */&#10;    private void updateAuthorInInteractions(String userId, AuthorInfo updatedAuthor) {&#10;        try {&#10;            List&lt;InteractionEntity&gt; userInteractions = interactionRepository.findByAuthor_Id(userId);&#10;            &#10;            for (InteractionEntity interaction : userInteractions) {&#10;                interaction.setAuthor(updatedAuthor);&#10;            }&#10;            &#10;            if (!userInteractions.isEmpty()) {&#10;                interactionRepository.saveAll(userInteractions);&#10;                log.info(&quot;Updated author info in {} interactions for user: {}&quot;, userInteractions.size(), userId);&#10;            }&#10;            &#10;        } catch (Exception e) {&#10;            log.error(&quot;Failed to update author info in interactions for user {}: {}&quot;, userId, e.getMessage());&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Extract AuthorInfo from user update event&#10;     */&#10;    private AuthorInfo extractAuthorInfo(Map&lt;String, Object&gt; userUpdate) {&#10;        try {&#10;            String userId = (String) userUpdate.get(&quot;userId&quot;);&#10;            String fullName = (String) userUpdate.get(&quot;fullName&quot;);&#10;            String email = (String) userUpdate.get(&quot;email&quot;);&#10;            String avatarUrl = (String) userUpdate.get(&quot;avatarUrl&quot;);&#10;            String role = (String) userUpdate.get(&quot;role&quot;);&#10;&#10;            // Handle nested user data structure if it exists&#10;            if (userUpdate.containsKey(&quot;userData&quot;)) {&#10;                Map&lt;String, Object&gt; userData = (Map&lt;String, Object&gt;) userUpdate.get(&quot;userData&quot;);&#10;                fullName = fullName != null ? fullName : (String) userData.get(&quot;fullName&quot;);&#10;                email = email != null ? email : (String) userData.get(&quot;email&quot;);&#10;                avatarUrl = avatarUrl != null ? avatarUrl : (String) userData.get(&quot;avatarUrl&quot;);&#10;                role = role != null ? role : (String) userData.get(&quot;role&quot;);&#10;            }&#10;&#10;            if (userId != null &amp;&amp; fullName != null) {&#10;                AuthorInfo authorInfo = new AuthorInfo();&#10;                authorInfo.setId(userId);&#10;                authorInfo.setFullName(fullName);&#10;                authorInfo.setEmail(email != null ? email : &quot;&quot;);&#10;                authorInfo.setAvatarUrl(avatarUrl != null ? avatarUrl : &quot;&quot;);&#10;                authorInfo.setRole(role != null ? role : &quot;USER&quot;);&#10;                &#10;                return authorInfo;&#10;            }&#10;            &#10;        } catch (Exception e) {&#10;            log.error(&quot;Failed to extract author info from user update: {}&quot;, e.getMessage());&#10;        }&#10;        &#10;        return null;&#10;    }&#10;&#10;    /**&#10;     * Manual sync method for testing or administrative purposes&#10;     */&#10;    public void manualSyncUserProfile(String userId, AuthorInfo updatedAuthor) {&#10;        log.info(&quot;Manual sync requested for user: {}&quot;, userId);&#10;        updateAuthorInPosts(userId, updatedAuthor);&#10;        updateAuthorInComments(userId, updatedAuthor);&#10;        updateAuthorInInteractions(userId, updatedAuthor);&#10;        log.info(&quot;Manual sync completed for user: {}&quot;, userId);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/post-service/src/main/resources/application-docker.properties">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/post-service/src/main/resources/application-docker.properties" />
              <option name="originalContent" value="# Docker-specific configuration for post-service&#10;spring.application.name=post-service&#10;server.port=8085&#10;&#10;# MongoDB Configuration - Docker service name&#10;spring.data.mongodb.database=post_db&#10;spring.data.mongodb.host=post_db&#10;spring.data.mongodb.port=27017&#10;&#10;# Redis Configuration - Docker service name&#10;spring.data.redis.host=redis&#10;spring.data.redis.port=6379&#10;spring.data.redis.timeout=60000ms&#10;spring.data.redis.lettuce.pool.max-active=8&#10;spring.data.redis.lettuce.pool.max-idle=8&#10;spring.data.redis.lettuce.pool.min-idle=0&#10;&#10;# Kafka Configuration - Docker service name&#10;spring.kafka.bootstrap-servers=kafka:9092&#10;spring.kafka.producer.key-serializer=org.apache.kafka.common.serialization.StringSerializer&#10;spring.kafka.producer.value-serializer=org.springframework.kafka.support.serializer.JsonSerializer&#10;&#10;spring.kafka.consumer.group-id=post-service-group&#10;spring.kafka.consumer.key-deserializer=org.apache.kafka.common.serialization.StringDeserializer&#10;spring.kafka.consumer.value-deserializer=org.springframework.kafka.support.serializer.JsonDeserializer&#10;spring.kafka.consumer.properties.spring.json.trusted.packages=*&#10;spring.kafka.consumer.auto-offset-reset=earliest&#10;spring.kafka.consumer.enable-auto-commit=true&#10;&#10;# Eureka Configuration - Docker service name&#10;eureka.client.service-url.defaultZone=http://eureka-server:8761/eureka/&#10;eureka.instance.prefer-ip-address=true&#10;eureka.instance.instance-id=${spring.application.name}:${server.port}&#10;&#10;# Media Service Configuration - Docker service name&#10;media-service.url=http://media-service:8084&#10;&#10;# File Upload Configuration&#10;spring.servlet.multipart.max-file-size=10MB&#10;spring.servlet.multipart.max-request-size=50MB&#10;&#10;# Actuator Configuration&#10;management.endpoints.web.exposure.include=health,info,metrics&#10;management.endpoint.health.show-details=always&#10;&#10;# Logging Configuration&#10;logging.level.com.ctuconnect=DEBUG&#10;logging.level.org.springframework.kafka=INFO&#10;logging.level.org.springframework.data.mongodb=INFO&#10;" />
              <option name="updatedContent" value="# Docker-specific configuration for post-service&#13;&#10;spring.application.name=post-service&#13;&#10;server.port=8085&#13;&#10;&#13;&#10;# MongoDB Configuration - Docker service name&#13;&#10;spring.data.mongodb.database=post_db&#13;&#10;spring.data.mongodb.host=post_db&#13;&#10;spring.data.mongodb.port=27017&#13;&#10;&#13;&#10;# Redis Configuration - Docker service name&#13;&#10;spring.data.redis.host=redis&#13;&#10;spring.data.redis.port=6379&#13;&#10;spring.data.redis.timeout=60000ms&#13;&#10;spring.data.redis.lettuce.pool.max-active=8&#13;&#10;spring.data.redis.lettuce.pool.min-idle=0&#13;&#10;&#13;&#10;# Kafka Configuration - Docker service name&#13;&#10;spring.kafka.bootstrap-servers=kafka:9092&#13;&#10;spring.kafka.producer.key-serializer=org.apache.kafka.common.serialization.StringSerializer&#13;&#10;spring.kafka.producer.value-serializer=org.springframework.kafka.support.serializer.JsonSerializer&#13;&#10;&#13;&#10;spring.kafka.consumer.group-id=post-service-group&#13;&#10;spring.kafka.consumer.key-deserializer=org.apache.kafka.common.serialization.StringDeserializer&#13;&#10;spring.kafka.consumer.value-deserializer=org.springframework.kafka.support.serializer.JsonDeserializer&#13;&#10;spring.kafka.consumer.properties.spring.json.trusted.packages=*&#13;&#10;spring.kafka.consumer.auto-offset-reset=earliest&#13;&#10;spring.kafka.consumer.enable-auto-commit=true&#13;&#10;&#13;&#10;# Eureka Configuration - Docker service name&#13;&#10;eureka.client.service-url.defaultZone=http://eureka-server:8761/eureka/&#13;&#10;eureka.instance.prefer-ip-address=true&#13;&#10;eureka.instance.instance-id=${spring.application.name}:${server.port}&#13;&#10;&#13;&#10;# User Service Configuration - Docker service name&#13;&#10;user-service.url=http://user-service:8081&#13;&#10;&#13;&#10;# Media Service Configuration - Docker service name&#13;&#10;media-service.url=http://media-service:8084&#13;&#10;&#13;&#10;# Feign Configuration&#13;&#10;feign.client.config.default.connect-timeout=10000&#13;&#10;feign.client.config.default.read-timeout=10000&#13;&#10;feign.client.config.default.logger-level=basic&#13;&#10;&#13;&#10;# File Upload Configuration&#13;&#10;spring.servlet.multipart.max-file-size=10MB&#13;&#10;spring.servlet.multipart.max-request-size=50MB&#13;&#10;&#13;&#10;# Actuator Configuration&#13;&#10;management.endpoints.web.exposure.include=health,info,metrics&#13;&#10;management.endpoint.health.show-details=always&#13;&#10;&#13;&#10;# Logging Configuration&#13;&#10;logging.level.com.ctuconnect=DEBUG&#13;&#10;logging.level.org.springframework.kafka=INFO&#13;&#10;logging.level.org.springframework.data.mongodb=INFO" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/post-service/src/main/resources/application.properties">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/post-service/src/main/resources/application.properties" />
              <option name="originalContent" value="spring.application.name=post-service&#10;server.port=8085&#10;&#10;# MongoDB Configuration&#10;spring.data.mongodb.database=post_db&#10;spring.data.mongodb.host=localhost&#10;spring.data.mongodb.port=27018&#10;&#10;# Kafka Configuration&#10;spring.kafka.bootstrap-servers=localhost:9092&#10;spring.kafka.producer.key-serializer=org.apache.kafka.common.serialization.StringSerializer&#10;spring.kafka.producer.value-serializer=org.springframework.kafka.support.serializer.JsonSerializer&#10;&#10;# Kafka Consumer Configuration - Fix missing group-id error&#10;spring.kafka.consumer.group-id=post-service-group&#10;spring.kafka.consumer.key-deserializer=org.apache.kafka.common.serialization.StringDeserializer&#10;spring.kafka.consumer.value-deserializer=org.springframework.kafka.support.serializer.JsonDeserializer&#10;spring.kafka.consumer.properties.spring.json.trusted.packages=*&#10;spring.kafka.consumer.auto-offset-reset=earliest&#10;spring.kafka.consumer.enable-auto-commit=true&#10;&#10;# Eureka Configuration&#10;eureka.client.service-url.defaultZone=http://localhost:8761/eureka/&#10;eureka.instance.prefer-ip-address=true&#10;eureka.instance.instance-id=${spring.application.name}:${server.port}&#10;&#10;# Redis Configuration - Fix for Docker container networking&#10;spring.data.redis.host=redis&#10;spring.data.redis.port=6379&#10;spring.data.redis.timeout=60000ms&#10;spring.data.redis.lettuce.pool.max-active=8&#10;spring.data.redis.lettuce.pool.max-idle=8&#10;spring.data.redis.lettuce.pool.min-idle=0&#10;&#10;# Media Service Configuration&#10;media-service.url=http://localhost:8084&#10;&#10;# File Upload Configuration&#10;spring.servlet.multipart.max-file-size=10MB&#10;spring.servlet.multipart.max-request-size=50MB&#10;&#10;# Actuator Configuration&#10;management.endpoints.web.exposure.include=health,info,metrics&#10;management.endpoint.health.show-details=always&#10;&#10;# Logging Configuration&#10;logging.level.vn.ctu.edu.postservice=DEBUG&#10;logging.level.org.springframework.kafka=INFO&#10;logging.level.org.springframework.data.mongodb=INFO&#10;" />
              <option name="updatedContent" value="spring.application.name=post-service&#10;server.port=8085&#10;&#10;# MongoDB Configuration&#10;spring.data.mongodb.database=post_db&#10;spring.data.mongodb.host=localhost&#10;spring.data.mongodb.port=27018&#10;&#10;# Kafka Configuration&#10;spring.kafka.bootstrap-servers=localhost:9092&#10;spring.kafka.producer.key-serializer=org.apache.kafka.common.serialization.StringSerializer&#10;spring.kafka.producer.value-serializer=org.springframework.kafka.support.serializer.JsonSerializer&#10;&#10;# Kafka Consumer Configuration - Fix missing group-id error&#10;spring.kafka.consumer.group-id=post-service-group&#10;spring.kafka.consumer.key-deserializer=org.apache.kafka.common.serialization.StringDeserializer&#10;spring.kafka.consumer.value-deserializer=org.springframework.kafka.support.serializer.JsonDeserializer&#10;spring.kafka.consumer.properties.spring.json.trusted.packages=*&#10;spring.kafka.consumer.auto-offset-reset=earliest&#10;spring.kafka.consumer.enable-auto-commit=true&#10;&#10;# Eureka Configuration&#10;eureka.client.service-url.defaultZone=http://localhost:8761/eureka/&#10;eureka.instance.prefer-ip-address=true&#10;eureka.instance.instance-id=${spring.application.name}:${server.port}&#10;&#10;# Redis Configuration - Fix for Docker container networking&#10;spring.data.redis.host=redis&#10;spring.data.redis.port=6379&#10;spring.data.redis.timeout=60000ms&#10;spring.data.redis.lettuce.pool.max-active=8&#10;spring.data.redis.lettuce.pool.max-idle=8&#10;spring.data.redis.lettuce.pool.min-idle=0&#10;&#10;# User Service Configuration&#10;user-service.url=http://localhost:8081&#10;&#10;# Media Service Configuration&#10;media-service.url=http://localhost:8084&#10;&#10;# Feign Configuration&#10;feign.client.config.default.connect-timeout=5000&#10;feign.client.config.default.read-timeout=5000&#10;feign.client.config.default.logger-level=basic&#10;&#10;# File Upload Configuration&#10;spring.servlet.multipart.max-file-size=10MB&#10;spring.servlet.multipart.max-request-size=50MB&#10;&#10;# Actuator Configuration&#10;management.endpoints.web.exposure.include=health,info,metrics&#10;management.endpoint.health.show-details=always&#10;&#10;# Logging Configuration&#10;logging.level.vn.ctu.edu.postservice=DEBUG&#10;logging.level.org.springframework.kafka=INFO&#10;logging.level.org.springframework.data.mongodb=INFO" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/user-service/src/main/java/com/ctuconnect/controller/UserSyncController.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/user-service/src/main/java/com/ctuconnect/controller/UserSyncController.java" />
              <option name="originalContent" value="package com.ctuconnect.controller;&#10;&#10;import com.ctuconnect.dto.AuthorDTO;&#10;import com.ctuconnect.dto.UserDTO;&#10;import com.ctuconnect.security.annotation.RequireAuth;&#10;import com.ctuconnect.service.UserSyncService;&#10;import com.ctuconnect.service.UserService;&#10;import org.springframework.beans.factory.annotation.Autowired;&#10;import org.springframework.http.ResponseEntity;&#10;import org.springframework.web.bind.annotation.*;&#10;&#10;import java.util.Set;&#10;&#10;/**&#10; * Controller để xử lý đồng bộ dữ liệu giữa auth-db và user-db&#10; * Các endpoint này được gọi từ auth-service hoặc các microservices khác&#10; */&#10;@RestController&#10;@RequestMapping(&quot;/api/users/sync&quot;)&#10;public class UserSyncController {&#10;&#10;    @Autowired&#10;    private UserSyncService userSyncService;&#10;&#10;    @Autowired&#10;    private UserService userService;&#10;&#10;    /**&#10;     * Tạo user profile trong user-db khi user được tạo ở auth-db&#10;     * Endpoint này được gọi từ auth-service&#10;     */&#10;    @PostMapping(&quot;/create&quot;)&#10;    @RequireAuth(roles = {&quot;SYSTEM&quot;, &quot;ADMIN&quot;}) // Chỉ system hoặc admin mới có thể gọi&#10;    public ResponseEntity&lt;UserDTO&gt; syncUserFromAuth(&#10;            @RequestParam String userId,&#10;            @RequestParam String email,&#10;            @RequestParam String role) {&#10;        UserDTO userDTO = userSyncService.syncUserFromAuth(userId, email, role);&#10;        return ResponseEntity.ok(userDTO);&#10;    }&#10;&#10;    /**&#10;     * Cập nhật thông tin user khi có thay đổi từ auth-db&#10;     */&#10;    @PutMapping(&quot;/update&quot;)&#10;    @RequireAuth(roles = {&quot;SYSTEM&quot;, &quot;ADMIN&quot;})&#10;    public ResponseEntity&lt;UserDTO&gt; updateUserFromAuth(&#10;            @RequestParam String userId,&#10;            @RequestParam String email,&#10;            @RequestParam String role) {&#10;        UserDTO userDTO = userSyncService.updateUserFromAuth(userId, email, role);&#10;        return ResponseEntity.ok(userDTO);&#10;    }&#10;&#10;    /**&#10;     * Xóa user khỏi user-db khi user bị xóa ở auth-db&#10;     */&#10;    @DeleteMapping(&quot;/delete&quot;)&#10;    @RequireAuth(roles = {&quot;SYSTEM&quot;, &quot;ADMIN&quot;})&#10;    public ResponseEntity&lt;String&gt; deleteUserFromAuth(@RequestParam String userId) {&#10;        userSyncService.deleteUserFromAuth(userId);&#10;        return ResponseEntity.ok(&quot;User deleted from user database successfully&quot;);&#10;    }&#10;&#10;    /**&#10;     * Kiểm tra tính nhất quán dữ liệu giữa auth-db và user-db&#10;     */&#10;    @GetMapping(&quot;/check&quot;)&#10;    @RequireAuth(roles = {&quot;SYSTEM&quot;, &quot;ADMIN&quot;})&#10;    public ResponseEntity&lt;Boolean&gt; checkUserSync(&#10;            @RequestParam String userId,&#10;            @RequestParam String email,&#10;            @RequestParam String role) {&#10;        boolean isSynced = userSyncService.isUserSynced(userId, email, role);&#10;        return ResponseEntity.ok(isSynced);&#10;    }&#10;&#10;    /**&#10;     * Lấy thông tin tác giả cho post-service&#10;     * Endpoint này được gọi từ post-service để lấy author info&#10;     */&#10;    @GetMapping(&quot;/authors/{id}&quot;)&#10;    public ResponseEntity&lt;AuthorDTO&gt; getAuthorInfo(@PathVariable(&quot;id&quot;) String authorId) {&#10;        AuthorDTO authorInfo = userSyncService.getAuthorInfo(authorId);&#10;        return ResponseEntity.ok(authorInfo);&#10;    }&#10;&#10;    /**&#10;     * Lấy danh sách ID bạn bè của user&#10;     * Endpoint này được gọi từ post-service cho news feed algorithm&#10;     */&#10;    @GetMapping(&quot;/{userId}/friends/ids&quot;)&#10;    public ResponseEntity&lt;Set&lt;String&gt;&gt; getFriendIds(@PathVariable(&quot;userId&quot;) String userId) {&#10;        Set&lt;String&gt; friendIds = userService.getFriendIds(userId);&#10;        return ResponseEntity.ok(friendIds);&#10;    }&#10;&#10;    /**&#10;     * Lấy danh sách user có tương tác gần với user&#10;     * Endpoint này được gọi từ post-service cho news feed algorithm&#10;     */&#10;    @GetMapping(&quot;/{userId}/close-interactions&quot;)&#10;    public ResponseEntity&lt;Set&lt;String&gt;&gt; getCloseInteractionIds(@PathVariable(&quot;userId&quot;) String userId) {&#10;        Set&lt;String&gt; closeInteractionIds = userService.getCloseInteractionIds(userId);&#10;        return ResponseEntity.ok(closeInteractionIds);&#10;    }&#10;&#10;    /**&#10;     * Lấy danh sách user cùng khoa&#10;     * Endpoint này được gọi từ post-service cho news feed algorithm&#10;     */&#10;    @GetMapping(&quot;/{userId}/same-faculty&quot;)&#10;    public ResponseEntity&lt;Set&lt;String&gt;&gt; getSameFacultyUserIds(@PathVariable(&quot;userId&quot;) String userId) {&#10;        Set&lt;String&gt; sameFacultyIds = userService.getSameFacultyUserIds(userId);&#10;        return ResponseEntity.ok(sameFacultyIds);&#10;    }&#10;&#10;    /**&#10;     * Lấy danh sách user cùng ngành&#10;     * Endpoint này được gọi từ post-service cho news feed algorithm&#10;     */&#10;    @GetMapping(&quot;/{userId}/same-major&quot;)&#10;    public ResponseEntity&lt;Set&lt;String&gt;&gt; getSameMajorUserIds(@PathVariable(&quot;userId&quot;) String userId) {&#10;        Set&lt;String&gt; sameMajorIds = userService.getSameMajorUserIds(userId);&#10;        return ResponseEntity.ok(sameMajorIds);&#10;    }&#10;&#10;    /**&#10;     * Lấy danh sách interest tags của user&#10;     * Endpoint này được gọi từ post-service cho content recommendation&#10;     */&#10;    @GetMapping(&quot;/{userId}/interest-tags&quot;)&#10;    public ResponseEntity&lt;Set&lt;String&gt;&gt; getUserInterestTags(@PathVariable(&quot;userId&quot;) String userId) {&#10;        Set&lt;String&gt; interestTags = userService.getUserInterestTags(userId);&#10;        return ResponseEntity.ok(interestTags);&#10;    }&#10;&#10;    /**&#10;     * Lấy danh sách preferred categories của user&#10;     * Endpoint này được gọi từ post-service cho content filtering&#10;     */&#10;    @GetMapping(&quot;/{userId}/preferred-categories&quot;)&#10;    public ResponseEntity&lt;Set&lt;String&gt;&gt; getUserPreferredCategories(@PathVariable(&quot;userId&quot;) String userId) {&#10;        Set&lt;String&gt; preferredCategories = userService.getUserPreferredCategories(userId);&#10;        return ResponseEntity.ok(preferredCategories);&#10;    }&#10;&#10;    /**&#10;     * Lấy faculty ID của user&#10;     * Endpoint này được gọi từ post-service cho group filtering&#10;     */&#10;    @GetMapping(&quot;/{userId}/faculty-id&quot;)&#10;    public ResponseEntity&lt;String&gt; getUserFacultyId(@PathVariable(&quot;userId&quot;) String userId) {&#10;        String facultyId = userService.getUserFacultyId(userId);&#10;        return ResponseEntity.ok(facultyId);&#10;    }&#10;&#10;    /**&#10;     * Lấy major ID của user&#10;     * Endpoint này được gọi từ post-service cho group filtering&#10;     */&#10;    @GetMapping(&quot;/{userId}/major-id&quot;)&#10;    public ResponseEntity&lt;String&gt; getUserMajorId(@PathVariable(&quot;userId&quot;) String userId) {&#10;        String majorId = userService.getUserMajorId(userId);&#10;        return ResponseEntity.ok(majorId);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.ctuconnect.controller;&#10;&#10;import com.ctuconnect.dto.AuthorDTO;&#10;import com.ctuconnect.dto.UserDTO;&#10;import com.ctuconnect.security.annotation.RequireAuth;&#10;import com.ctuconnect.service.UserSyncService;&#10;import com.ctuconnect.service.UserService;&#10;import org.springframework.beans.factory.annotation.Autowired;&#10;import org.springframework.http.ResponseEntity;&#10;import org.springframework.web.bind.annotation.*;&#10;&#10;import java.util.Set;&#10;&#10;/**&#10; * Controller để xử lý đồng bộ dữ liệu giữa auth-db và user-db&#10; * Các endpoint này được gọi từ auth-service hoặc các microservices khác&#10; */&#10;@RestController&#10;@RequestMapping(&quot;/api/users/sync&quot;)&#10;public class UserSyncController {&#10;&#10;    @Autowired&#10;    private UserSyncService userSyncService;&#10;&#10;    @Autowired&#10;    private UserService userService;&#10;&#10;    /**&#10;     * Tạo user profile trong user-db khi user được tạo ở auth-db&#10;     * Endpoint này được gọi từ auth-service&#10;     */&#10;    @PostMapping(&quot;/create&quot;)&#10;    @RequireAuth(roles = {&quot;SYSTEM&quot;, &quot;ADMIN&quot;}) // Chỉ system hoặc admin mới có thể gọi&#10;    public ResponseEntity&lt;UserDTO&gt; syncUserFromAuth(&#10;            @RequestParam String userId,&#10;            @RequestParam String email,&#10;            @RequestParam String role) {&#10;        UserDTO userDTO = userSyncService.syncUserFromAuth(userId, email, role);&#10;        return ResponseEntity.ok(userDTO);&#10;    }&#10;&#10;    /**&#10;     * Cập nhật thông tin user khi có thay đổi từ auth-db&#10;     */&#10;    @PutMapping(&quot;/update&quot;)&#10;    @RequireAuth(roles = {&quot;SYSTEM&quot;, &quot;ADMIN&quot;})&#10;    public ResponseEntity&lt;UserDTO&gt; updateUserFromAuth(&#10;            @RequestParam String userId,&#10;            @RequestParam String email,&#10;            @RequestParam String role) {&#10;        UserDTO userDTO = userSyncService.updateUserFromAuth(userId, email, role);&#10;        return ResponseEntity.ok(userDTO);&#10;    }&#10;&#10;    /**&#10;     * Xóa user khỏi user-db khi user bị xóa ở auth-db&#10;     */&#10;    @DeleteMapping(&quot;/delete&quot;)&#10;    @RequireAuth(roles = {&quot;SYSTEM&quot;, &quot;ADMIN&quot;})&#10;    public ResponseEntity&lt;String&gt; deleteUserFromAuth(@RequestParam String userId) {&#10;        userSyncService.deleteUserFromAuth(userId);&#10;        return ResponseEntity.ok(&quot;User deleted from user database successfully&quot;);&#10;    }&#10;&#10;    /**&#10;     * Kiểm tra tính nhất quán dữ liệu giữa auth-db và user-db&#10;     */&#10;    @GetMapping(&quot;/check&quot;)&#10;    @RequireAuth(roles = {&quot;SYSTEM&quot;, &quot;ADMIN&quot;})&#10;    public ResponseEntity&lt;Boolean&gt; checkUserSync(&#10;            @RequestParam String userId,&#10;            @RequestParam String email,&#10;            @RequestParam String role) {&#10;        boolean isSynced = userSyncService.isUserSynced(userId, email, role);&#10;        return ResponseEntity.ok(isSynced);&#10;    }&#10;&#10;    /**&#10;     * Lấy thông tin tác giả cho post-service&#10;     * Endpoint này được gọi từ post-service để lấy author info&#10;     * Không yêu cầu authentication vì đây là internal service call&#10;     */&#10;    @GetMapping(&quot;/authors/{id}&quot;)&#10;    public ResponseEntity&lt;AuthorDTO&gt; getAuthorInfo(@PathVariable(&quot;id&quot;) String authorId) {&#10;        AuthorDTO authorInfo = userSyncService.getAuthorInfo(authorId);&#10;        return ResponseEntity.ok(authorInfo);&#10;    }&#10;&#10;    /**&#10;     * Lấy danh sách ID bạn bè của user&#10;     * Endpoint này được gọi từ post-service cho news feed algorithm&#10;     * Không yêu cầu authentication vì đây là internal service call&#10;     */&#10;    @GetMapping(&quot;/{userId}/friends/ids&quot;)&#10;    public ResponseEntity&lt;Set&lt;String&gt;&gt; getFriendIds(@PathVariable(&quot;userId&quot;) String userId) {&#10;        Set&lt;String&gt; friendIds = userService.getFriendIds(userId);&#10;        return ResponseEntity.ok(friendIds);&#10;    }&#10;&#10;    /**&#10;     * Lấy danh sách user có tương tác gần với user&#10;     * Endpoint này được gọi từ post-service cho news feed algorithm&#10;     */&#10;    @GetMapping(&quot;/{userId}/close-interactions&quot;)&#10;    public ResponseEntity&lt;Set&lt;String&gt;&gt; getCloseInteractionIds(@PathVariable(&quot;userId&quot;) String userId) {&#10;        Set&lt;String&gt; closeInteractionIds = userService.getCloseInteractionIds(userId);&#10;        return ResponseEntity.ok(closeInteractionIds);&#10;    }&#10;&#10;    /**&#10;     * Lấy danh sách user cùng khoa&#10;     * Endpoint này được gọi từ post-service cho news feed algorithm&#10;     */&#10;    @GetMapping(&quot;/{userId}/same-faculty&quot;)&#10;    public ResponseEntity&lt;Set&lt;String&gt;&gt; getSameFacultyUserIds(@PathVariable(&quot;userId&quot;) String userId) {&#10;        Set&lt;String&gt; sameFacultyIds = userService.getSameFacultyUserIds(userId);&#10;        return ResponseEntity.ok(sameFacultyIds);&#10;    }&#10;&#10;    /**&#10;     * Lấy danh sách user cùng ngành&#10;     * Endpoint này được gọi từ post-service cho news feed algorithm&#10;     */&#10;    @GetMapping(&quot;/{userId}/same-major&quot;)&#10;    public ResponseEntity&lt;Set&lt;String&gt;&gt; getSameMajorUserIds(@PathVariable(&quot;userId&quot;) String userId) {&#10;        Set&lt;String&gt; sameMajorIds = userService.getSameMajorUserIds(userId);&#10;        return ResponseEntity.ok(sameMajorIds);&#10;    }&#10;&#10;    /**&#10;     * Lấy danh sách interest tags của user&#10;     * Endpoint này được gọi từ post-service cho content recommendation&#10;     */&#10;    @GetMapping(&quot;/{userId}/interest-tags&quot;)&#10;    public ResponseEntity&lt;Set&lt;String&gt;&gt; getUserInterestTags(@PathVariable(&quot;userId&quot;) String userId) {&#10;        Set&lt;String&gt; interestTags = userService.getUserInterestTags(userId);&#10;        return ResponseEntity.ok(interestTags);&#10;    }&#10;&#10;    /**&#10;     * Lấy danh sách preferred categories của user&#10;     * Endpoint này được gọi từ post-service cho content filtering&#10;     */&#10;    @GetMapping(&quot;/{userId}/preferred-categories&quot;)&#10;    public ResponseEntity&lt;Set&lt;String&gt;&gt; getUserPreferredCategories(@PathVariable(&quot;userId&quot;) String userId) {&#10;        Set&lt;String&gt; preferredCategories = userService.getUserPreferredCategories(userId);&#10;        return ResponseEntity.ok(preferredCategories);&#10;    }&#10;&#10;    /**&#10;     * Lấy faculty ID của user&#10;     * Endpoint này được gọi từ post-service cho group filtering&#10;     */&#10;    @GetMapping(&quot;/{userId}/faculty-id&quot;)&#10;    public ResponseEntity&lt;String&gt; getUserFacultyId(@PathVariable(&quot;userId&quot;) String userId) {&#10;        String facultyId = userService.getUserFacultyId(userId);&#10;        return ResponseEntity.ok(facultyId);&#10;    }&#10;&#10;    /**&#10;     * Lấy major ID của user&#10;     * Endpoint này được gọi từ post-service cho group filtering&#10;     */&#10;    @GetMapping(&quot;/{userId}/major-id&quot;)&#10;    public ResponseEntity&lt;String&gt; getUserMajorId(@PathVariable(&quot;userId&quot;) String userId) {&#10;        String majorId = userService.getUserMajorId(userId);&#10;        return ResponseEntity.ok(majorId);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/user-service/src/main/java/com/ctuconnect/dto/ActivityDTO.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/user-service/src/main/java/com/ctuconnect/dto/ActivityDTO.java" />
              <option name="originalContent" value="package com.ctuconnect.dto;&#10;&#10;import lombok.AllArgsConstructor;&#10;import lombok.Builder;&#10;import lombok.Data;&#10;import lombok.NoArgsConstructor;&#10;&#10;import java.time.LocalDateTime;&#10;&#10;@Data&#10;@Builder&#10;@NoArgsConstructor&#10;@AllArgsConstructor&#10;public class ActivityDTO {&#10;    private String id;&#10;    private String userId;&#10;    private String activityType; // POST_CREATED, POST_LIKED, COMMENT_ADDED, etc.&#10;    private String targetType; // POST, COMMENT, USER&#10;    private String targetId;&#10;    private String actorName;&#10;    private String actorAvatarUrl;&#10;&#10;    // For activity feed display&#10;    private String displayText;&#10;    private String actionUrl;&#10;    private boolean isRead;&#10;&#10;    public enum ActivityType {&#10;        POST_CREATED,&#10;        POST_LIKED,&#10;        POST_SHARED,&#10;        COMMENT_ADDED,&#10;        FRIEND_REQUEST_SENT,&#10;        FRIEND_REQUEST_ACCEPTED,&#10;        PROFILE_UPDATED&#10;    }&#10;&#10;    public enum TargetType {&#10;        POST,&#10;        COMMENT,&#10;        USER,&#10;        PROFILE&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.ctuconnect.dto;&#10;&#10;import lombok.AllArgsConstructor;&#10;import lombok.Builder;&#10;import lombok.Data;&#10;import lombok.NoArgsConstructor;&#10;&#10;import java.time.LocalDateTime;&#10;&#10;@Data&#10;@Builder&#10;@NoArgsConstructor&#10;@AllArgsConstructor&#10;public class ActivityDTO {&#10;    private String id;&#10;    private String userId;&#10;    private String activityType; // POST_CREATED, POST_LIKED, COMMENT_ADDED, etc.&#10;    private String targetType; // POST, COMMENT, USER&#10;    private String targetId;&#10;    private String entityType; // Add missing entityType field&#10;    private String entityId; // Add missing entityId field&#10;    private String description;&#10;    private LocalDateTime timestamp;&#10;    private String actorName;&#10;    private String actorAvatarUrl;&#10;&#10;    // For activity feed display&#10;    private String displayText;&#10;    private String actionUrl;&#10;    private boolean isRead;&#10;&#10;    public enum ActivityType {&#10;        POST_CREATED,&#10;        POST_LIKED,&#10;        POST_SHARED,&#10;        COMMENT_ADDED,&#10;        FRIEND_REQUEST_SENT,&#10;        FRIEND_REQUEST_ACCEPTED,&#10;        PROFILE_UPDATED&#10;    }&#10;&#10;    public enum TargetType {&#10;        POST,&#10;        COMMENT,&#10;        USER,&#10;        PROFILE&#10;    }&#10;&#10;    public enum EntityType {&#10;        POST,&#10;        COMMENT,&#10;        USER,&#10;        PROFILE&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/user-service/src/main/java/com/ctuconnect/dto/FriendSuggestionDTO.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/user-service/src/main/java/com/ctuconnect/dto/FriendSuggestionDTO.java" />
              <option name="updatedContent" value="package com.ctuconnect.dto;&#10;&#10;import lombok.AllArgsConstructor;&#10;import lombok.Builder;&#10;import lombok.Data;&#10;import lombok.NoArgsConstructor;&#10;&#10;@Data&#10;@AllArgsConstructor&#10;@NoArgsConstructor&#10;@Builder&#10;public class FriendSuggestionDTO {&#10;    private String userId;&#10;    private String username;&#10;    private String fullName;&#10;    private String avatarUrl;&#10;    private String bio;&#10;    &#10;    // Suggestion metadata&#10;    private int mutualFriendsCount;&#10;    private String suggestionReason;&#10;    private double relevanceScore;&#10;    private SuggestionType suggestionType;&#10;    &#10;    // Academic context&#10;    private String facultyName;&#10;    private String majorName;&#10;    private String batchYear;&#10;    &#10;    // Social context&#10;    private boolean sameCollege;&#10;    private boolean sameFaculty;&#10;    private boolean sameMajor;&#10;    private boolean sameBatch;&#10;    &#10;    public enum SuggestionType {&#10;        MUTUAL_FRIENDS,&#10;        ACADEMIC_CONNECTION,&#10;        FRIENDS_OF_FRIENDS,&#10;        PROFILE_VIEWER,&#10;        SIMILAR_INTERESTS,&#10;        LOCATION_BASED,&#10;        ACTIVITY_BASED&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/user-service/src/main/java/com/ctuconnect/event/UserEventPublisher.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/user-service/src/main/java/com/ctuconnect/event/UserEventPublisher.java" />
              <option name="updatedContent" value="package com.ctuconnect.event;&#10;&#10;import org.springframework.beans.factory.annotation.Autowired;&#10;import org.springframework.kafka.core.KafkaTemplate;&#10;import org.springframework.stereotype.Service;&#10;import com.fasterxml.jackson.databind.ObjectMapper;&#10;import lombok.extern.slf4j.Slf4j;&#10;&#10;import java.util.HashMap;&#10;import java.util.Map;&#10;&#10;/**&#10; * Service to publish user profile update events to Kafka&#10; * This notifies other services (like post-service) when user profiles are updated&#10; */&#10;@Service&#10;@Slf4j&#10;public class UserEventPublisher {&#10;&#10;    @Autowired&#10;    private KafkaTemplate&lt;String, String&gt; kafkaTemplate;&#10;&#10;    @Autowired&#10;    private ObjectMapper objectMapper;&#10;&#10;    private static final String USER_PROFILE_UPDATED_TOPIC = &quot;user-profile-updated&quot;;&#10;&#10;    /**&#10;     * Publish user profile update event&#10;     */&#10;    public void publishUserProfileUpdateEvent(String userId, String fullName, String email, String avatarUrl, String role) {&#10;        try {&#10;            Map&lt;String, Object&gt; eventData = new HashMap&lt;&gt;();&#10;            eventData.put(&quot;userId&quot;, userId);&#10;            eventData.put(&quot;fullName&quot;, fullName);&#10;            eventData.put(&quot;email&quot;, email);&#10;            eventData.put(&quot;avatarUrl&quot;, avatarUrl);&#10;            eventData.put(&quot;role&quot;, role);&#10;            eventData.put(&quot;eventType&quot;, &quot;USER_PROFILE_UPDATED&quot;);&#10;            eventData.put(&quot;timestamp&quot;, System.currentTimeMillis());&#10;&#10;            String eventMessage = objectMapper.writeValueAsString(eventData);&#10;            &#10;            kafkaTemplate.send(USER_PROFILE_UPDATED_TOPIC, userId, eventMessage);&#10;            log.info(&quot;Published user profile update event for user: {}&quot;, userId);&#10;            &#10;        } catch (Exception e) {&#10;            log.error(&quot;Failed to publish user profile update event for user {}: {}&quot;, userId, e.getMessage(), e);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Publish user profile update event with user entity data&#10;     */&#10;    public void publishUserProfileUpdateEvent(String userId, Map&lt;String, Object&gt; userData) {&#10;        try {&#10;            Map&lt;String, Object&gt; eventData = new HashMap&lt;&gt;();&#10;            eventData.put(&quot;userId&quot;, userId);&#10;            eventData.put(&quot;userData&quot;, userData);&#10;            eventData.put(&quot;eventType&quot;, &quot;USER_PROFILE_UPDATED&quot;);&#10;            eventData.put(&quot;timestamp&quot;, System.currentTimeMillis());&#10;&#10;            String eventMessage = objectMapper.writeValueAsString(eventData);&#10;            &#10;            kafkaTemplate.send(USER_PROFILE_UPDATED_TOPIC, userId, eventMessage);&#10;            log.info(&quot;Published user profile update event for user: {}&quot;, userId);&#10;            &#10;        } catch (Exception e) {&#10;            log.error(&quot;Failed to publish user profile update event for user {}: {}&quot;, userId, e.getMessage(), e);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/user-service/src/main/java/com/ctuconnect/repository/UserRepository.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/user-service/src/main/java/com/ctuconnect/repository/UserRepository.java" />
              <option name="originalContent" value="package com.ctuconnect.repository;&#10;&#10;import com.ctuconnect.entity.FacultyEntity;&#10;import com.ctuconnect.entity.UserEntity;&#10;import org.springframework.data.jpa.repository.Modifying;&#10;import org.springframework.data.neo4j.repository.Neo4jRepository;&#10;import org.springframework.data.neo4j.repository.query.Query;&#10;import org.springframework.data.repository.query.Param;&#10;&#10;import java.util.List;&#10;import java.util.Optional;&#10;&#10;public interface UserRepository extends Neo4jRepository&lt;UserEntity, String&gt; {&#10;&#10; // Tìm kiếm người dùng bằng email hoặc username&#10; Optional&lt;UserEntity&gt; findByEmail(String email);&#10;&#10; Optional&lt;UserEntity&gt; findByUsername(String username);&#10;&#10; boolean existsByEmail(String email);&#10;&#10; boolean existsByUsername(String username);&#10;&#10; @Query(&quot;MATCH (u:User) WHERE u.email = $identifier OR u.username = $identifier RETURN u&quot;)&#10; Optional&lt;UserEntity&gt; findByEmailOrUsername(@Param(&quot;identifier&quot;) String identifier);&#10;&#10; // Lấy user by id&#10; @Query(&quot;MATCH (u:User {id: $userId}) RETURN u&quot;)&#10; Optional&lt;UserEntity&gt; findUserWithAllRelations(@Param(&quot;userId&quot;) String userId);&#10;&#10; // Xóa quan hệ của profile học sinh (student)&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})&#10;        OPTIONAL MATCH (u)-[r]-&gt;()&#10;        WHERE type(r) IN ['ENROLLED_IN', 'WORKS_IN', 'BELONGS_TO', 'IN_BATCH', 'HAS_GENDER']&#10;        DELETE r&#10;        &quot;&quot;&quot;)&#10; void clearStudentRelationships(@Param(&quot;userId&quot;) String userId);&#10;&#10; // Xóa quan hệ của profile giảng viên (lecturer)&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})&#10;        OPTIONAL MATCH (u)-[r]-&gt;()&#10;        WHERE type(r) IN ['HAS_DEGREE', 'HAS_ACADEMIC', 'HAS_POSITION', 'WORKS_IN', 'BELONGS_TO', 'HAS_GENDER']&#10;        DELETE r&#10;        &quot;&quot;&quot;)&#10; void clearLecturerRelationships(@Param(&quot;userId&quot;) String userId);&#10;&#10; // Xóa quan hệ cụ thể theo danh sách quan hệ truyền vào&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})&#10;        OPTIONAL MATCH (u)-[r]-&gt;()&#10;        WHERE type(r) IN $relationshipTypes&#10;        DELETE r&#10;        &quot;&quot;&quot;)&#10; void clearSpecificRelationships(@Param(&quot;userId&quot;) String userId, @Param(&quot;relationshipTypes&quot;) List&lt;String&gt; relationshipTypes);&#10;&#10; // Xóa quan hệ đơn lẻ theo loại&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})-[r]-&gt;(n)&#10;        WHERE type(r) = $relationshipType&#10;        DELETE r&#10;        &quot;&quot;&quot;)&#10; void deleteRelationship(@Param(&quot;userId&quot;) String userId, @Param(&quot;relationshipType&quot;) String relationshipType);&#10;&#10; // Cập nhật các quan hệ profile&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})&#10;        OPTIONAL MATCH (u)-[r:ENROLLED_IN]-&gt;()&#10;        DELETE r&#10;        WITH u&#10;        MATCH (newMajor:Major {id: $majorId})&#10;        MERGE (u)-[:ENROLLED_IN]-&gt;(newMajor)&#10;        &quot;&quot;&quot;)&#10; void updateUserMajor(@Param(&quot;userId&quot;) String userId, @Param(&quot;majorId&quot;) String majorId);&#10;&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})&#10;        OPTIONAL MATCH (u)-[r:IN_BATCH]-&gt;()&#10;        DELETE r&#10;        WITH u&#10;        MATCH (newBatch:Batch {id: $batchId})&#10;        MERGE (u)-[:IN_BATCH]-&gt;(newBatch)&#10;        &quot;&quot;&quot;)&#10; void updateUserBatch(@Param(&quot;userId&quot;) String userId, @Param(&quot;batchId&quot;) String batchId);&#10;&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})&#10;        OPTIONAL MATCH (u)-[r:HAS_GENDER]-&gt;()&#10;        DELETE r&#10;        WITH u&#10;        MATCH (newGender:Gender {id: $genderId})&#10;        MERGE (u)-[:HAS_GENDER]-&gt;(newGender)&#10;        &quot;&quot;&quot;)&#10; void updateUserGender(@Param(&quot;userId&quot;) String userId, @Param(&quot;genderId&quot;) String genderId);&#10;&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})&#10;        OPTIONAL MATCH (u)-[r:BELONGS_TO]-&gt;()&#10;        DELETE r&#10;        WITH u&#10;        MATCH (newFaculty:Faculty {id: $facultyId})&#10;        MERGE (u)-[:BELONGS_TO]-&gt;(newFaculty)&#10;        &quot;&quot;&quot;)&#10; void updateUserFaculty(@Param(&quot;userId&quot;) String userId, @Param(&quot;facultyId&quot;) String facultyId);&#10;&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})&#10;        OPTIONAL MATCH (u)-[r:STUDIES_AT]-&gt;()&#10;        DELETE r&#10;        WITH u&#10;        MATCH (newCollege:College {id: $collegeId})&#10;        MERGE (u)-[:STUDIES_AT]-&gt;(newCollege)&#10;        &quot;&quot;&quot;)&#10; void updateUserCollege(@Param(&quot;userId&quot;) String userId, @Param(&quot;collegeId&quot;) String collegeId);&#10;&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})&#10;        OPTIONAL MATCH (u)-[r:WORKS_IN]-&gt;()&#10;        DELETE r&#10;        WITH u&#10;        MATCH (newFaculty:Faculty {id: $facultyId})&#10;        MERGE (u)-[:WORKS_IN]-&gt;(newFaculty)&#10;        &quot;&quot;&quot;)&#10; void updateUserWorkingFaculty(@Param(&quot;userId&quot;) String userId, @Param(&quot;facultyId&quot;) String facultyId);&#10;&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})&#10;        OPTIONAL MATCH (u)-[r:EMPLOYED_AT]-&gt;()&#10;        DELETE r&#10;        WITH u&#10;        MATCH (newCollege:College {id: $collegeId})&#10;        MERGE (u)-[:EMPLOYED_AT]-&gt;(newCollege)&#10;        &quot;&quot;&quot;)&#10; void updateUserWorkingCollege(@Param(&quot;userId&quot;) String userId, @Param(&quot;collegeId&quot;) String collegeId);&#10;&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})&#10;        OPTIONAL MATCH (u)-[r:HAS_DEGREE]-&gt;()&#10;        DELETE r&#10;        WITH u&#10;        MATCH (newDegree:Degree {id: $degreeId})&#10;        MERGE (u)-[:HAS_DEGREE]-&gt;(newDegree)&#10;        &quot;&quot;&quot;)&#10; void updateUserDegree(@Param(&quot;userId&quot;) String userId, @Param(&quot;degreeId&quot;) String degreeId);&#10;&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})&#10;        OPTIONAL MATCH (u)-[r:HAS_POSITION]-&gt;()&#10;        DELETE r&#10;        WITH u&#10;        MATCH (newPosition:Position {id: $positionId})&#10;        MERGE (u)-[:HAS_POSITION]-&gt;(newPosition)&#10;        &quot;&quot;&quot;)&#10; void updateUserPosition(@Param(&quot;userId&quot;) String userId, @Param(&quot;positionId&quot;) String positionId);&#10;&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})&#10;        OPTIONAL MATCH (u)-[r:HAS_ACADEMIC]-&gt;()&#10;        DELETE r&#10;        WITH u&#10;        MATCH (newAcademic:Academic {id: $academicId})&#10;        MERGE (u)-[:HAS_ACADEMIC]-&gt;(newAcademic)&#10;        &quot;&quot;&quot;)&#10; void updateUserAcademic(@Param(&quot;userId&quot;) String userId, @Param(&quot;academicId&quot;) String academicId);&#10;&#10; // ========================= FRIEND RELATIONSHIP QUERIES =========================&#10;&#10; // Kiểm tra xem 2 user có phải bạn bè không&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u1:User {id: $userId1})-[:FRIEND_WITH]-(u2:User {id: $userId2})&#10;        RETURN COUNT(*) &gt; 0&#10;        &quot;&quot;&quot;)&#10; boolean areFriends(@Param(&quot;userId1&quot;) String userId1, @Param(&quot;userId2&quot;) String userId2);&#10;&#10; // Kiểm tra có friend request pending không&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u1:User {id: $fromUserId})-[:FRIEND_REQUEST]-&gt;(u2:User {id: $toUserId})&#10;        RETURN COUNT(*) &gt; 0&#10;        &quot;&quot;&quot;)&#10; boolean hasPendingFriendRequest(@Param(&quot;fromUserId&quot;) String fromUserId, @Param(&quot;toUserId&quot;) String toUserId);&#10;&#10; // Gửi friend request&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u1:User {id: $fromUserId}), (u2:User {id: $toUserId})&#10;        MERGE (u1)-[:FRIEND_REQUEST]-&gt;(u2)&#10;        &quot;&quot;&quot;)&#10; void sendFriendRequest(@Param(&quot;fromUserId&quot;) String fromUserId, @Param(&quot;toUserId&quot;) String toUserId);&#10;&#10; // Chấp nhận friend request&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u1:User {id: $fromUserId})-[r:FRIEND_REQUEST]-&gt;(u2:User {id: $toUserId})&#10;        DELETE r&#10;        CREATE (u1)-[:FRIEND_WITH]-&gt;(u2)&#10;        CREATE (u2)-[:FRIEND_WITH]-&gt;(u1)&#10;        &quot;&quot;&quot;)&#10; void acceptFriendRequest(@Param(&quot;fromUserId&quot;) String fromUserId, @Param(&quot;toUserId&quot;) String toUserId);&#10;&#10; // Từ chối friend request&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u1:User {id: $fromUserId})-[r:FRIEND_REQUEST]-&gt;(u2:User {id: $toUserId})&#10;        DELETE r&#10;        &quot;&quot;&quot;)&#10; void rejectFriendRequest(@Param(&quot;fromUserId&quot;) String fromUserId, @Param(&quot;toUserId&quot;) String toUserId);&#10;&#10; // Xóa friendship&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u1:User {id: $userId1})-[r:FRIEND_WITH]-(u2:User {id: $userId2})&#10;        DELETE r&#10;        &quot;&quot;&quot;)&#10; void deleteFriendship(@Param(&quot;userId1&quot;) String userId1, @Param(&quot;userId2&quot;) String userId2);&#10;&#10; // Lấy danh sách bạn bè&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})-[:FRIEND_WITH]-(friend:User)&#10;        RETURN friend&#10;        &quot;&quot;&quot;)&#10; List&lt;UserEntity&gt; findFriends(@Param(&quot;userId&quot;) String userId);&#10;&#10; // Lấy friend requests nhận được&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (requester:User)-[:FRIEND_REQUEST]-&gt;(u:User {id: $userId})&#10;        RETURN requester&#10;        &quot;&quot;&quot;)&#10; List&lt;UserEntity&gt; findIncomingFriendRequests(@Param(&quot;userId&quot;) String userId);&#10;&#10; // Lấy friend requests đã gửi&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})-[:FRIEND_REQUEST]-&gt;(receiver:User)&#10;        RETURN receiver&#10;        &quot;&quot;&quot;)&#10; List&lt;UserEntity&gt; findOutgoingFriendRequests(@Param(&quot;userId&quot;) String userId);&#10;&#10; // Lấy bạn chung giữa 2 user&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u1:User {id: $userId1})-[:FRIEND_WITH]-(mutual:User)-[:FRIEND_WITH]-(u2:User {id: $userId2})&#10;        RETURN mutual&#10;        &quot;&quot;&quot;)&#10; List&lt;UserEntity&gt; findMutualFriends(@Param(&quot;userId1&quot;) String userId1, @Param(&quot;userId2&quot;) String userId2);&#10;&#10; // Gợi ý kết bạn dựa trên bạn chung và profile tương tự&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})&#10;        MATCH (u)-[:FRIEND_WITH]-(friend)-[:FRIEND_WITH]-(suggestion:User)&#10;        WHERE NOT (u)-[:FRIEND_WITH]-(suggestion) AND u.id &lt;&gt; suggestion.id&#10;        AND NOT (u)-[:FRIEND_REQUEST]-(suggestion)&#10;        RETURN suggestion, COUNT(*) as mutualFriends&#10;        ORDER BY mutualFriends DESC&#10;        LIMIT 20&#10;        &quot;&quot;&quot;)&#10; List&lt;UserEntity&gt; findFriendSuggestions(@Param(&quot;userId&quot;) String userId);&#10;&#10; // Lọc user theo tiêu chí (cùng college, faculty, major, batch)&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})&#10;        OPTIONAL MATCH (u)-[:STUDIES_AT|EMPLOYED_AT]-&gt;(college:College)&#10;        OPTIONAL MATCH (u)-[:BELONGS_TO|WORKS_IN]-&gt;(faculty:Faculty)&#10;        OPTIONAL MATCH (u)-[:ENROLLED_IN]-&gt;(major:Major)&#10;        OPTIONAL MATCH (u)-[:IN_BATCH]-&gt;(batch:Batch)&#10;        &#10;        MATCH (candidate:User)&#10;        WHERE candidate.id &lt;&gt; $userId&#10;        AND (NOT $sameCollege OR (candidate)-[:STUDIES_AT|EMPLOYED_AT]-&gt;(college))&#10;        AND (NOT $sameFaculty OR (candidate)-[:BELONGS_TO|WORKS_IN]-&gt;(faculty))&#10;        AND (NOT $sameMajor OR (candidate)-[:ENROLLED_IN]-&gt;(major))&#10;        AND (NOT $sameBatch OR (candidate)-[:IN_BATCH]-&gt;(batch))&#10;        &#10;        RETURN candidate&#10;        &quot;&quot;&quot;)&#10; List&lt;UserEntity&gt; findUsersWithFilters(&#10;         @Param(&quot;userId&quot;) String userId,&#10;         @Param(&quot;sameCollege&quot;) boolean sameCollege,&#10;         @Param(&quot;sameFaculty&quot;) boolean sameFaculty,&#10;         @Param(&quot;sameMajor&quot;) boolean sameMajor,&#10;         @Param(&quot;sameBatch&quot;) boolean sameBatch&#10; );&#10;&#10; /**&#10;  * Find users by faculty ID (for post-service news feed algorithm)&#10;  */&#10; @Query(&quot;MATCH (u:User)-[:WORKS_IN|BELONGS_TO]-&gt;(f:Faculty {id: $facultyId}) RETURN u&quot;)&#10; List&lt;UserEntity&gt; findUsersByFaculty(@Param(&quot;facultyId&quot;) String facultyId);&#10;&#10; /**&#10;  * Find users by major ID (for post-service news feed algorithm)&#10;  */&#10; @Query(&quot;MATCH (u:User)-[:ENROLLED_IN]-&gt;(m:Major {id: $majorId}) RETURN u&quot;)&#10; List&lt;UserEntity&gt; findUsersByMajor(@Param(&quot;majorId&quot;) String majorId);&#10;&#10; /**&#10;  * Find users by full name containing (for search functionality)&#10;  * Uses case-insensitive search with Neo4j CONTAINS operator&#10;  */&#10; @Query(&quot;MATCH (u:User) WHERE toLower(u.fullName) CONTAINS toLower($name) RETURN u&quot;)&#10; List&lt;UserEntity&gt; findByFullNameContainingIgnoreCase(@Param(&quot;name&quot;) String name);&#10;&#10;&#10; List&lt;UserEntity&gt; findByFacultyId(String facultyId);&#10;&#10; List&lt;UserEntity&gt; findByMajorId(String majorId);&#10;}&#10;" />
              <option name="updatedContent" value="package com.ctuconnect.repository;&#10;&#10;import com.ctuconnect.entity.FacultyEntity;&#10;import com.ctuconnect.entity.UserEntity;&#10;import org.springframework.data.jpa.repository.Modifying;&#10;import org.springframework.data.neo4j.repository.Neo4jRepository;&#10;import org.springframework.data.neo4j.repository.query.Query;&#10;import org.springframework.data.repository.query.Param;&#10;&#10;import java.util.List;&#10;import java.util.Optional;&#10;&#10;public interface UserRepository extends Neo4jRepository&lt;UserEntity, String&gt; {&#10;&#10; // Tìm kiếm người dùng bằng email hoặc username&#10; Optional&lt;UserEntity&gt; findByEmail(String email);&#10;&#10; Optional&lt;UserEntity&gt; findByUsername(String username);&#10;&#10; boolean existsByEmail(String email);&#10;&#10; boolean existsByUsername(String username);&#10;&#10; @Query(&quot;MATCH (u:User) WHERE u.email = $identifier OR u.username = $identifier RETURN u&quot;)&#10; Optional&lt;UserEntity&gt; findByEmailOrUsername(@Param(&quot;identifier&quot;) String identifier);&#10;&#10; // Lấy user by id&#10; @Query(&quot;MATCH (u:User {id: $userId}) RETURN u&quot;)&#10; Optional&lt;UserEntity&gt; findUserWithAllRelations(@Param(&quot;userId&quot;) String userId);&#10;&#10; // Xóa quan hệ của profile học sinh (student)&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})&#10;        OPTIONAL MATCH (u)-[r]-&gt;()&#10;        WHERE type(r) IN ['ENROLLED_IN', 'WORKS_IN', 'BELONGS_TO', 'IN_BATCH', 'HAS_GENDER']&#10;        DELETE r&#10;        &quot;&quot;&quot;)&#10; void clearStudentRelationships(@Param(&quot;userId&quot;) String userId);&#10;&#10; // Xóa quan hệ của profile giảng viên (lecturer)&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})&#10;        OPTIONAL MATCH (u)-[r]-&gt;()&#10;        WHERE type(r) IN ['HAS_DEGREE', 'HAS_ACADEMIC', 'HAS_POSITION', 'WORKS_IN', 'BELONGS_TO', 'HAS_GENDER']&#10;        DELETE r&#10;        &quot;&quot;&quot;)&#10; void clearLecturerRelationships(@Param(&quot;userId&quot;) String userId);&#10;&#10; // Xóa quan hệ cụ thể theo danh sách quan hệ truyền vào&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})&#10;        OPTIONAL MATCH (u)-[r]-&gt;()&#10;        WHERE type(r) IN $relationshipTypes&#10;        DELETE r&#10;        &quot;&quot;&quot;)&#10; void clearSpecificRelationships(@Param(&quot;userId&quot;) String userId, @Param(&quot;relationshipTypes&quot;) List&lt;String&gt; relationshipTypes);&#10;&#10; // Xóa quan hệ đơn lẻ theo loại&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})-[r]-&gt;(n)&#10;        WHERE type(r) = $relationshipType&#10;        DELETE r&#10;        &quot;&quot;&quot;)&#10; void deleteRelationship(@Param(&quot;userId&quot;) String userId, @Param(&quot;relationshipType&quot;) String relationshipType);&#10;&#10; // Cập nhật các quan hệ profile&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})&#10;        OPTIONAL MATCH (u)-[r:ENROLLED_IN]-&gt;()&#10;        DELETE r&#10;        WITH u&#10;        MATCH (newMajor:Major {id: $majorId})&#10;        MERGE (u)-[:ENROLLED_IN]-&gt;(newMajor)&#10;        &quot;&quot;&quot;)&#10; void updateUserMajor(@Param(&quot;userId&quot;) String userId, @Param(&quot;majorId&quot;) String majorId);&#10;&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})&#10;        OPTIONAL MATCH (u)-[r:IN_BATCH]-&gt;()&#10;        DELETE r&#10;        WITH u&#10;        MATCH (newBatch:Batch {id: $batchId})&#10;        MERGE (u)-[:IN_BATCH]-&gt;(newBatch)&#10;        &quot;&quot;&quot;)&#10; void updateUserBatch(@Param(&quot;userId&quot;) String userId, @Param(&quot;batchId&quot;) String batchId);&#10;&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})&#10;        OPTIONAL MATCH (u)-[r:HAS_GENDER]-&gt;()&#10;        DELETE r&#10;        WITH u&#10;        MATCH (newGender:Gender {id: $genderId})&#10;        MERGE (u)-[:HAS_GENDER]-&gt;(newGender)&#10;        &quot;&quot;&quot;)&#10; void updateUserGender(@Param(&quot;userId&quot;) String userId, @Param(&quot;genderId&quot;) String genderId);&#10;&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})&#10;        OPTIONAL MATCH (u)-[r:BELONGS_TO]-&gt;()&#10;        DELETE r&#10;        WITH u&#10;        MATCH (newFaculty:Faculty {id: $facultyId})&#10;        MERGE (u)-[:BELONGS_TO]-&gt;(newFaculty)&#10;        &quot;&quot;&quot;)&#10; void updateUserFaculty(@Param(&quot;userId&quot;) String userId, @Param(&quot;facultyId&quot;) String facultyId);&#10;&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})&#10;        OPTIONAL MATCH (u)-[r:STUDIES_AT]-&gt;()&#10;        DELETE r&#10;        WITH u&#10;        MATCH (newCollege:College {id: $collegeId})&#10;        MERGE (u)-[:STUDIES_AT]-&gt;(newCollege)&#10;        &quot;&quot;&quot;)&#10; void updateUserCollege(@Param(&quot;userId&quot;) String userId, @Param(&quot;collegeId&quot;) String collegeId);&#10;&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})&#10;        OPTIONAL MATCH (u)-[r:WORKS_IN]-&gt;()&#10;        DELETE r&#10;        WITH u&#10;        MATCH (newFaculty:Faculty {id: $facultyId})&#10;        MERGE (u)-[:WORKS_IN]-&gt;(newFaculty)&#10;        &quot;&quot;&quot;)&#10; void updateUserWorkingFaculty(@Param(&quot;userId&quot;) String userId, @Param(&quot;facultyId&quot;) String facultyId);&#10;&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})&#10;        OPTIONAL MATCH (u)-[r:EMPLOYED_AT]-&gt;()&#10;        DELETE r&#10;        WITH u&#10;        MATCH (newCollege:College {id: $collegeId})&#10;        MERGE (u)-[:EMPLOYED_AT]-&gt;(newCollege)&#10;        &quot;&quot;&quot;)&#10; void updateUserWorkingCollege(@Param(&quot;userId&quot;) String userId, @Param(&quot;collegeId&quot;) String collegeId);&#10;&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})&#10;        OPTIONAL MATCH (u)-[r:HAS_DEGREE]-&gt;()&#10;        DELETE r&#10;        WITH u&#10;        MATCH (newDegree:Degree {id: $degreeId})&#10;        MERGE (u)-[:HAS_DEGREE]-&gt;(newDegree)&#10;        &quot;&quot;&quot;)&#10; void updateUserDegree(@Param(&quot;userId&quot;) String userId, @Param(&quot;degreeId&quot;) String degreeId);&#10;&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})&#10;        OPTIONAL MATCH (u)-[r:HAS_POSITION]-&gt;()&#10;        DELETE r&#10;        WITH u&#10;        MATCH (newPosition:Position {id: $positionId})&#10;        MERGE (u)-[:HAS_POSITION]-&gt;(newPosition)&#10;        &quot;&quot;&quot;)&#10; void updateUserPosition(@Param(&quot;userId&quot;) String userId, @Param(&quot;positionId&quot;) String positionId);&#10;&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})&#10;        OPTIONAL MATCH (u)-[r:HAS_ACADEMIC]-&gt;()&#10;        DELETE r&#10;        WITH u&#10;        MATCH (newAcademic:Academic {id: $academicId})&#10;        MERGE (u)-[:HAS_ACADEMIC]-&gt;(newAcademic)&#10;        &quot;&quot;&quot;)&#10; void updateUserAcademic(@Param(&quot;userId&quot;) String userId, @Param(&quot;academicId&quot;) String academicId);&#10;&#10; // ========================= FRIEND RELATIONSHIP QUERIES =========================&#10;&#10; // Kiểm tra xem 2 user có phải bạn bè không&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u1:User {id: $userId1})-[:FRIEND_WITH]-(u2:User {id: $userId2})&#10;        RETURN COUNT(*) &gt; 0&#10;        &quot;&quot;&quot;)&#10; boolean areFriends(@Param(&quot;userId1&quot;) String userId1, @Param(&quot;userId2&quot;) String userId2);&#10;&#10; // Kiểm tra có friend request pending không&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u1:User {id: $fromUserId})-[:FRIEND_REQUEST]-&gt;(u2:User {id: $toUserId})&#10;        RETURN COUNT(*) &gt; 0&#10;        &quot;&quot;&quot;)&#10; boolean hasPendingFriendRequest(@Param(&quot;fromUserId&quot;) String fromUserId, @Param(&quot;toUserId&quot;) String toUserId);&#10;&#10; // Gửi friend request&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u1:User {id: $fromUserId}), (u2:User {id: $toUserId})&#10;        MERGE (u1)-[:FRIEND_REQUEST]-&gt;(u2)&#10;        &quot;&quot;&quot;)&#10; void sendFriendRequest(@Param(&quot;fromUserId&quot;) String fromUserId, @Param(&quot;toUserId&quot;) String toUserId);&#10;&#10; // Chấp nhận friend request&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u1:User {id: $fromUserId})-[r:FRIEND_REQUEST]-&gt;(u2:User {id: $toUserId})&#10;        DELETE r&#10;        CREATE (u1)-[:FRIEND_WITH]-&gt;(u2)&#10;        CREATE (u2)-[:FRIEND_WITH]-&gt;(u1)&#10;        &quot;&quot;&quot;)&#10; void acceptFriendRequest(@Param(&quot;fromUserId&quot;) String fromUserId, @Param(&quot;toUserId&quot;) String toUserId);&#10;&#10; // Từ chối friend request&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u1:User {id: $fromUserId})-[r:FRIEND_REQUEST]-&gt;(u2:User {id: $toUserId})&#10;        DELETE r&#10;        &quot;&quot;&quot;)&#10; void rejectFriendRequest(@Param(&quot;fromUserId&quot;) String fromUserId, @Param(&quot;toUserId&quot;) String toUserId);&#10;&#10; // Xóa friendship&#10; @Modifying&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u1:User {id: $userId1})-[r:FRIEND_WITH]-(u2:User {id: $userId2})&#10;        DELETE r&#10;        &quot;&quot;&quot;)&#10; void deleteFriendship(@Param(&quot;userId1&quot;) String userId1, @Param(&quot;userId2&quot;) String userId2);&#10;&#10; // Lấy danh sách bạn bè&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})-[:FRIEND_WITH]-(friend:User)&#10;        RETURN friend&#10;        &quot;&quot;&quot;)&#10; List&lt;UserEntity&gt; findFriends(@Param(&quot;userId&quot;) String userId);&#10;&#10; // Lấy friend requests nhận được&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (requester:User)-[:FRIEND_REQUEST]-&gt;(u:User {id: $userId})&#10;        RETURN requester&#10;        &quot;&quot;&quot;)&#10; List&lt;UserEntity&gt; findIncomingFriendRequests(@Param(&quot;userId&quot;) String userId);&#10;&#10; // Lấy friend requests đã gửi&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})-[:FRIEND_REQUEST]-&gt;(receiver:User)&#10;        RETURN receiver&#10;        &quot;&quot;&quot;)&#10; List&lt;UserEntity&gt; findOutgoingFriendRequests(@Param(&quot;userId&quot;) String userId);&#10;&#10; // Lấy bạn chung giữa 2 user&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u1:User {id: $userId1})-[:FRIEND_WITH]-(mutual:User)-[:FRIEND_WITH]-(u2:User {id: $userId2})&#10;        RETURN mutual&#10;        &quot;&quot;&quot;)&#10; List&lt;UserEntity&gt; findMutualFriends(@Param(&quot;userId1&quot;) String userId1, @Param(&quot;userId2&quot;) String userId2);&#10;&#10; // Gợi ý kết bạn dựa trên bạn chung và profile tương tự&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})&#10;        MATCH (u)-[:FRIEND_WITH]-(friend)-[:FRIEND_WITH]-(suggestion:User)&#10;        WHERE NOT (u)-[:FRIEND_WITH]-(suggestion) AND u.id &lt;&gt; suggestion.id&#10;        AND NOT (u)-[:FRIEND_REQUEST]-(suggestion)&#10;        RETURN suggestion, COUNT(*) as mutualFriends&#10;        ORDER BY mutualFriends DESC&#10;        LIMIT 20&#10;        &quot;&quot;&quot;)&#10; List&lt;UserEntity&gt; findFriendSuggestions(@Param(&quot;userId&quot;) String userId);&#10;&#10; // Lọc user theo tiêu chí (cùng college, faculty, major, batch)&#10; @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})&#10;        OPTIONAL MATCH (u)-[:STUDIES_AT|EMPLOYED_AT]-&gt;(college:College)&#10;        OPTIONAL MATCH (u)-[:BELONGS_TO|WORKS_IN]-&gt;(faculty:Faculty)&#10;        OPTIONAL MATCH (u)-[:ENROLLED_IN]-&gt;(major:Major)&#10;        OPTIONAL MATCH (u)-[:IN_BATCH]-&gt;(batch:Batch)&#10;        &#10;        MATCH (candidate:User)&#10;        WHERE candidate.id &lt;&gt; $userId&#10;        AND (NOT $sameCollege OR (candidate)-[:STUDIES_AT|EMPLOYED_AT]-&gt;(college))&#10;        AND (NOT $sameFaculty OR (candidate)-[:BELONGS_TO|WORKS_IN]-&gt;(faculty))&#10;        AND (NOT $sameMajor OR (candidate)-[:ENROLLED_IN]-&gt;(major))&#10;        AND (NOT $sameBatch OR (candidate)-[:IN_BATCH]-&gt;(batch))&#10;        &#10;        RETURN candidate&#10;        &quot;&quot;&quot;)&#10; List&lt;UserEntity&gt; findUsersWithFilters(&#10;         @Param(&quot;userId&quot;) String userId,&#10;         @Param(&quot;sameCollege&quot;) boolean sameCollege,&#10;         @Param(&quot;sameFaculty&quot;) boolean sameFaculty,&#10;         @Param(&quot;sameMajor&quot;) boolean sameMajor,&#10;         @Param(&quot;sameBatch&quot;) boolean sameBatch&#10; );&#10;&#10; /**&#10;  * Find users by faculty ID (for post-service news feed algorithm)&#10;  */&#10; @Query(&quot;MATCH (u:User)-[:WORKS_IN|BELONGS_TO]-&gt;(f:Faculty {id: $facultyId}) RETURN u&quot;)&#10; List&lt;UserEntity&gt; findUsersByFacultyId(@Param(&quot;facultyId&quot;) String facultyId);&#10;&#10; /**&#10;  * Find users by major ID (for post-service news feed algorithm)&#10;  */&#10; @Query(&quot;MATCH (u:User)-[:ENROLLED_IN]-&gt;(m:Major {id: $majorId}) RETURN u&quot;)&#10; List&lt;UserEntity&gt; findUsersByMajorId(@Param(&quot;majorId&quot;) String majorId);&#10;&#10; /**&#10;  * Find users by full name containing (for search functionality)&#10;  * Uses case-insensitive search with Neo4j CONTAINS operator&#10;  */&#10; @Query(&quot;MATCH (u:User) WHERE toLower(u.fullName) CONTAINS toLower($fullName) RETURN u&quot;)&#10; List&lt;UserEntity&gt; findByFullNameContainingIgnoreCase(@Param(&quot;fullName&quot;) String fullName);&#10;&#10; /**&#10;  * Find users by faculty name (for search functionality)&#10;  */&#10; @Query(&quot;MATCH (u:User)-[:BELONGS_TO|WORKS_IN]-&gt;(f:Faculty {name: $facultyName}) RETURN u&quot;)&#10; List&lt;UserEntity&gt; findUsersByFaculty(@Param(&quot;facultyName&quot;) String facultyName);&#10;&#10; /**&#10;  * Find users by major name (for search functionality)&#10;  */&#10; @Query(&quot;MATCH (u:User)-[:ENROLLED_IN]-&gt;(m:Major {name: $majorName}) RETURN u&quot;)&#10; List&lt;UserEntity&gt; findUsersByMajor(@Param(&quot;majorName&quot;) String majorName);&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/user-service/src/main/java/com/ctuconnect/service/UserEventPublisher.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/user-service/src/main/java/com/ctuconnect/service/UserEventPublisher.java" />
              <option name="originalContent" value="package com.ctuconnect.service;&#10;&#10;import com.ctuconnect.event.UserProfileUpdatedEvent;&#10;import com.ctuconnect.event.UserRelationshipChangedEvent;&#10;import lombok.RequiredArgsConstructor;&#10;import lombok.extern.slf4j.Slf4j;&#10;import org.springframework.kafka.core.KafkaTemplate;&#10;import org.springframework.stereotype.Service;&#10;&#10;import java.util.HashMap;&#10;import java.util.Map;&#10;&#10;@Service&#10;@RequiredArgsConstructor&#10;@Slf4j&#10;public class UserEventPublisher {&#10;&#10;    private final KafkaTemplate&lt;String, Object&gt; kafkaTemplate;&#10;&#10;    public void publishUserProfileUpdatedEvent(String userId, String email, String username,&#10;                                             String firstName, String lastName, String bio, String profilePicture) {&#10;        try {&#10;            Map&lt;String, Object&gt; event = new HashMap&lt;&gt;();&#10;            event.put(&quot;userId&quot;, userId);&#10;            event.put(&quot;email&quot;, email);&#10;            event.put(&quot;username&quot;, username);&#10;            event.put(&quot;firstName&quot;, firstName);&#10;            event.put(&quot;lastName&quot;, lastName);&#10;            event.put(&quot;bio&quot;, bio);&#10;            event.put(&quot;profilePicture&quot;, profilePicture);&#10;&#10;            kafkaTemplate.send(&quot;user-profile-updated&quot;, userId, event);&#10;            log.info(&quot;Published user profile updated event for user: {}&quot;, userId);&#10;&#10;        } catch (Exception e) {&#10;            log.error(&quot;Failed to publish user profile updated event for user: {}&quot;, userId, e);&#10;        }&#10;    }&#10;&#10;    public void publishUserRelationshipChangedEvent(String userId, String targetUserId,&#10;                                                  String relationshipType, String eventType) {&#10;        try {&#10;            Map&lt;String, Object&gt; event = new HashMap&lt;&gt;();&#10;            event.put(&quot;userId&quot;, userId);&#10;            event.put(&quot;targetUserId&quot;, targetUserId);&#10;            event.put(&quot;relationshipType&quot;, relationshipType);&#10;            event.put(&quot;eventType&quot;, eventType);&#10;&#10;            kafkaTemplate.send(&quot;user-relationship-changed&quot;, userId, event);&#10;            log.info(&quot;Published user relationship changed event: user {} -&gt; {}, type: {}&quot;,&#10;                    userId, targetUserId, relationshipType);&#10;&#10;        } catch (Exception e) {&#10;            log.error(&quot;Failed to publish user relationship changed event for user: {}&quot;, userId, e);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.ctuconnect.service;&#10;&#10;import com.ctuconnect.event.UserProfileUpdatedEvent;&#10;import com.ctuconnect.event.UserRelationshipChangedEvent;&#10;import lombok.RequiredArgsConstructor;&#10;import lombok.extern.slf4j.Slf4j;&#10;import org.springframework.kafka.core.KafkaTemplate;&#10;import org.springframework.stereotype.Service;&#10;&#10;import java.util.HashMap;&#10;import java.util.Map;&#10;&#10;@Service&#10;@RequiredArgsConstructor&#10;@Slf4j&#10;public class UserEventPublisher {&#10;&#10;    private final KafkaTemplate&lt;String, Object&gt; kafkaTemplate;&#10;&#10;    public void publishUserProfileUpdatedEvent(String userId, String email, String username,&#10;                                             String firstName, String lastName, String bio, String profilePicture) {&#10;        try {&#10;            Map&lt;String, Object&gt; event = new HashMap&lt;&gt;();&#10;            event.put(&quot;userId&quot;, userId);&#10;            event.put(&quot;email&quot;, email);&#10;            event.put(&quot;username&quot;, username);&#10;            event.put(&quot;firstName&quot;, firstName);&#10;            event.put(&quot;lastName&quot;, lastName);&#10;            event.put(&quot;bio&quot;, bio);&#10;            event.put(&quot;profilePicture&quot;, profilePicture);&#10;&#10;            kafkaTemplate.send(&quot;user-profile-updated&quot;, userId, event);&#10;            log.info(&quot;Published user profile updated event for user: {}&quot;, userId);&#10;&#10;        } catch (Exception e) {&#10;            log.error(&quot;Failed to publish user profile updated event for user: {}&quot;, userId, e);&#10;        }&#10;    }&#10;&#10;    public void publishUserRelationshipChangedEvent(String userId, String targetUserId,&#10;                                                  String relationshipType, String eventType) {&#10;        try {&#10;            Map&lt;String, Object&gt; event = new HashMap&lt;&gt;();&#10;            event.put(&quot;userId&quot;, userId);&#10;            event.put(&quot;targetUserId&quot;, targetUserId);&#10;            event.put(&quot;relationshipType&quot;, relationshipType);&#10;            event.put(&quot;eventType&quot;, eventType);&#10;&#10;            kafkaTemplate.send(&quot;user-relationship-changed&quot;, userId, event);&#10;            log.info(&quot;Published user relationship changed event: user {} -&gt; {}, type: {}&quot;,&#10;                    userId, targetUserId, relationshipType);&#10;&#10;        } catch (Exception e) {&#10;            log.error(&quot;Failed to publish user relationship changed event for user: {}&quot;, userId, e);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Enhanced method for post-service synchronization&#10;     * Publishes comprehensive user profile data including fullName and role&#10;     */&#10;    public void publishUserProfileUpdatedEventForPostService(String userId, String fullName, String email,&#10;                                                            String username, String avatarUrl, String role) {&#10;        try {&#10;            Map&lt;String, Object&gt; event = new HashMap&lt;&gt;();&#10;            event.put(&quot;userId&quot;, userId);&#10;            event.put(&quot;fullName&quot;, fullName);&#10;            event.put(&quot;email&quot;, email);&#10;            event.put(&quot;username&quot;, username);&#10;            event.put(&quot;avatarUrl&quot;, avatarUrl);&#10;            event.put(&quot;role&quot;, role);&#10;            event.put(&quot;eventType&quot;, &quot;USER_PROFILE_UPDATED&quot;);&#10;            event.put(&quot;timestamp&quot;, System.currentTimeMillis());&#10;&#10;            kafkaTemplate.send(&quot;user-profile-updated&quot;, userId, event);&#10;            log.info(&quot;Published user profile updated event for post-service sync: {}&quot;, userId);&#10;&#10;        } catch (Exception e) {&#10;            log.error(&quot;Failed to publish user profile updated event for post-service sync: {}&quot;, userId, e);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Generic method to publish profile updates with flexible user data&#10;     */&#10;    public void publishUserProfileUpdatedEvent(String userId, Map&lt;String, Object&gt; userData) {&#10;        try {&#10;            Map&lt;String, Object&gt; event = new HashMap&lt;&gt;();&#10;            event.put(&quot;userId&quot;, userId);&#10;            event.put(&quot;userData&quot;, userData);&#10;            event.put(&quot;eventType&quot;, &quot;USER_PROFILE_UPDATED&quot;);&#10;            event.put(&quot;timestamp&quot;, System.currentTimeMillis());&#10;&#10;            kafkaTemplate.send(&quot;user-profile-updated&quot;, userId, event);&#10;            log.info(&quot;Published user profile updated event with custom data for user: {}&quot;, userId);&#10;&#10;        } catch (Exception e) {&#10;            log.error(&quot;Failed to publish user profile updated event with custom data for user: {}&quot;, userId, e);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>