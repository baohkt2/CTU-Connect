<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/user-service/src/main/java/com/ctuconnect/repository/UserRepository.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/user-service/src/main/java/com/ctuconnect/repository/UserRepository.java" />
              <option name="originalContent" value="package com.ctuconnect.repository;&#10;&#10;import com.ctuconnect.entity.UserEntity;&#10;import org.springframework.data.neo4j.repository.Neo4jRepository;&#10;import org.springframework.data.neo4j.repository.query.Query;&#10;import org.springframework.data.repository.query.Param;&#10;&#10;import java.util.List;&#10;import java.util.Optional;&#10;&#10;public interface UserRepository extends Neo4jRepository&lt;UserEntity, String&gt; {&#10;&#10;    Optional&lt;UserEntity&gt; findByEmail(String email);&#10;&#10;    Optional&lt;UserEntity&gt; findByUsername(String username);&#10;&#10;    boolean existsByEmail(String email);&#10;&#10;    boolean existsByUsername(String username);&#10;&#10;    @Query(&quot;MATCH (u:User) WHERE u.email = $identifier OR u.username = $identifier RETURN u&quot;)&#10;    Optional&lt;UserEntity&gt; findByEmailOrUsername(@Param(&quot;identifier&quot;) String identifier);&#10;&#10;    @Query(&quot;&quot;&quot;&#10;    MATCH (u:User {id: $userId})&#10;    // Get direct relationships for a student&#10;    OPTIONAL MATCH (u)-[:ENROLLED_IN]-&gt;(m:Major)&#10;    OPTIONAL MATCH (u)-[:IN_BATCH]-&gt;(b:Batch)&#10;    OPTIONAL MATCH (u)-[:HAS_GENDER]-&gt;(g:Gender)&#10;    OPTIONAL MATCH (u)-[:ENROLLED_IN]-&gt;(f:Faculty)&#10;    OPTIONAL MATCH (u)-[:ENROLLED_IN]-&gt;(c:College)&#10;    // Get direct relationships for a lecturer/staff&#10;    OPTIONAL MATCH (u)-[:WORKS_IN]-&gt;(wf:Faculty)&#10;    OPTIONAL MATCH (u)-[:WORKS_IN]-&gt;(wc:College)&#10;    OPTIONAL MATCH (u)-[:HAS_DEGREE]-&gt;(d:Degree)&#10;    OPTIONAL MATCH (u)-[:HAS_POSITION]-&gt;(p:Position)&#10;    OPTIONAL MATCH (u)-[:HAS_ACADEMIC]-&gt;(a:Academic)&#10;    // Fix for handling friends relationship&#10;    OPTIONAL MATCH (u)-[:FRIEND]-(friend:User)&#10;    // Return all matched nodes to properly populate the entity&#10;    RETURN u, m, b, g, f, c, wf, wc, d, p, a, collect(friend) as friends&#10;&quot;&quot;&quot;)&#10;    Optional&lt;UserEntity&gt; findUserWithAllRelations(@Param(&quot;userId&quot;) String userId);&#10;&#10;&#10;    // ========================= FRIENDSHIPS =========================&#10;&#10;    @Query(&quot;&quot;&quot;&#10;                MATCH (u:User {id: $userId})-[:FRIEND]-(friend:User)&#10;                RETURN friend&#10;            &quot;&quot;&quot;)&#10;    List&lt;UserEntity&gt; findFriends(@Param(&quot;userId&quot;) String userId);&#10;&#10;    @Query(&quot;&quot;&quot;&#10;                MATCH (u1:User {id: $userId1})-[:FRIEND]-(friend:User),&#10;                      (u2:User {id: $userId2})-[:FRIEND]-(friend)&#10;                WHERE friend.id &lt;&gt; $userId1 AND friend.id &lt;&gt; $userId2&#10;                RETURN DISTINCT friend&#10;            &quot;&quot;&quot;)&#10;    List&lt;UserEntity&gt; findMutualFriends(@Param(&quot;userId1&quot;) String userId1, @Param(&quot;userId2&quot;) String userId2);&#10;&#10;    @Query(&quot;&quot;&quot;&#10;                MATCH (u1:User {id: $userId1}), (u2:User {id: $userId2})&#10;                WHERE u1.id &lt;&gt; u2.id&#10;                MERGE (u1)-[:FRIEND_REQUEST {createdAt: datetime(), status: 'PENDING'}]-&gt;(u2)&#10;            &quot;&quot;&quot;)&#10;    void sendFriendRequest(@Param(&quot;userId1&quot;) String userId1, @Param(&quot;userId2&quot;) String userId2);&#10;&#10;    @Query(&quot;&quot;&quot;&#10;                MATCH (u1:User {id: $userId1})-[r:FRIEND_REQUEST {status: 'PENDING'}]-&gt;(u2:User {id: $userId2})&#10;                DELETE r&#10;                MERGE (u1)-[:FRIEND {since: datetime()}]-(u2)&#10;            &quot;&quot;&quot;)&#10;    void acceptFriendRequest(@Param(&quot;userId1&quot;) String userId1, @Param(&quot;userId2&quot;) String userId2);&#10;&#10;    @Query(&quot;&quot;&quot;&#10;                MATCH (u1:User {id: $userId1})-[r:FRIEND_REQUEST]-&gt;(u2:User {id: $userId2})&#10;                DELETE r&#10;            &quot;&quot;&quot;)&#10;    void rejectFriendRequest(@Param(&quot;userId1&quot;) String userId1, @Param(&quot;userId2&quot;) String userId2);&#10;&#10;    @Query(&quot;&quot;&quot;&#10;                MATCH (u1:User {id: $userId1})-[r:FRIEND]-(u2:User {id: $userId2})&#10;                DELETE r&#10;            &quot;&quot;&quot;)&#10;    void deleteFriendship(@Param(&quot;userId1&quot;) String userId1, @Param(&quot;userId2&quot;) String userId2);&#10;&#10;    @Query(&quot;&quot;&quot;&#10;                MATCH (u1:User {id: $userId1})-[:FRIEND]-(u2:User {id: $userId2})&#10;                RETURN COUNT(*) &gt; 0&#10;            &quot;&quot;&quot;)&#10;    boolean areFriends(@Param(&quot;userId1&quot;) String userId1, @Param(&quot;userId2&quot;) String userId2);&#10;&#10;    @Query(&quot;&quot;&quot;&#10;                MATCH (u1:User {id: $userId1})-[:FRIEND_REQUEST {status: 'PENDING'}]-&gt;(u2:User {id: $userId2})&#10;                RETURN COUNT(*) &gt; 0&#10;            &quot;&quot;&quot;)&#10;    boolean hasPendingFriendRequest(@Param(&quot;userId1&quot;) String userId1, @Param(&quot;userId2&quot;) String userId2);&#10;&#10;    // Get friend requests sent TO this user&#10;    @Query(&quot;&quot;&quot;&#10;                MATCH (sender:User)-[:FRIEND_REQUEST {status: 'PENDING'}]-&gt;(u:User {id: $userId})&#10;                RETURN sender&#10;            &quot;&quot;&quot;)&#10;    List&lt;UserEntity&gt; findIncomingFriendRequests(@Param(&quot;userId&quot;) String userId);&#10;&#10;    // Get friend requests sent BY this user&#10;    @Query(&quot;&quot;&quot;&#10;                MATCH (u:User {id: $userId})-[:FRIEND_REQUEST {status: 'PENDING'}]-&gt;(receiver:User)&#10;                RETURN receiver&#10;            &quot;&quot;&quot;)&#10;    List&lt;UserEntity&gt; findOutgoingFriendRequests(@Param(&quot;userId&quot;) String userId);&#10;&#10;    // ========================= FILTER QUERIES =========================&#10;&#10;    @Query(&quot;MATCH (u:User)-[:ENROLLED_IN]-&gt;(m:Major {name: $major}) RETURN u&quot;)&#10;    List&lt;UserEntity&gt; findByMajor(@Param(&quot;major&quot;) String major);&#10;&#10;    @Query(&quot;MATCH (u:User)-[:IN_BATCH]-&gt;(b:Batch {year: $batch}) RETURN u&quot;)&#10;    List&lt;UserEntity&gt; findByBatch(@Param(&quot;batch&quot;) int batch);&#10;&#10;    @Query(&quot;&quot;&quot;&#10;                MATCH (u:User)-[:ENROLLED_IN]-&gt;(:Major)-[:BELONGS_TO]-&gt;(:Faculty {name: $faculty})&#10;                RETURN u&#10;            &quot;&quot;&quot;)&#10;    List&lt;UserEntity&gt; findByFaculty(@Param(&quot;faculty&quot;) String faculty);&#10;&#10;    @Query(&quot;&quot;&quot;&#10;                MATCH (u:User)-[:ENROLLED_IN]-&gt;(:Major)-[:BELONGS_TO]-&gt;(:Faculty)-[:PART_OF]-&gt;(:College {name: $college})&#10;                RETURN u&#10;            &quot;&quot;&quot;)&#10;    List&lt;UserEntity&gt; findByCollege(@Param(&quot;college&quot;) String college);&#10;&#10;    // ========================= SAME ATTRIBUTE QUERIES =========================&#10;&#10;    @Query(&quot;&quot;&quot;&#10;                MATCH (u:User {id: $userId})-[:ENROLLED_IN]-&gt;(m:Major)&lt;-[:ENROLLED_IN]-(other:User)&#10;                WHERE u.id &lt;&gt; other.id&#10;                RETURN other&#10;            &quot;&quot;&quot;)&#10;    List&lt;UserEntity&gt; findUsersWithSameMajor(@Param(&quot;userId&quot;) String userId);&#10;&#10;    @Query(&quot;&quot;&quot;&#10;                MATCH (u:User {id: $userId})-[:IN_BATCH]-&gt;(b:Batch)&lt;-[:IN_BATCH]-(other:User)&#10;                WHERE u.id &lt;&gt; other.id&#10;                RETURN other&#10;            &quot;&quot;&quot;)&#10;    List&lt;UserEntity&gt; findUsersWithSameBatch(@Param(&quot;userId&quot;) String userId);&#10;&#10;    @Query(&quot;&quot;&quot;&#10;                MATCH (u:User {id: $userId})-[:ENROLLED_IN]-&gt;(:Major)-[:BELONGS_TO]-&gt;(f:Faculty)&#10;                MATCH (other:User)-[:ENROLLED_IN]-&gt;(:Major)-[:BELONGS_TO]-&gt;(f)&#10;                WHERE other.id &lt;&gt; $userId&#10;                RETURN other&#10;            &quot;&quot;&quot;)&#10;    List&lt;UserEntity&gt; findUsersWithSameFaculty(@Param(&quot;userId&quot;) String userId);&#10;&#10;    @Query(&quot;&quot;&quot;&#10;                MATCH (u:User {id: $userId})-[:ENROLLED_IN]-&gt;(:Major)-[:BELONGS_TO]-&gt;(:Faculty)-[:PART_OF]-&gt;(c:College)&#10;                MATCH (other:User)-[:ENROLLED_IN]-&gt;(:Major)-[:BELONGS_TO]-&gt;(:Faculty)-[:PART_OF]-&gt;(c)&#10;                WHERE other.id &lt;&gt; $userId&#10;                RETURN other&#10;            &quot;&quot;&quot;)&#10;    List&lt;UserEntity&gt; findUsersWithSameCollege(@Param(&quot;userId&quot;) String userId);&#10;&#10;    // ========================= ADVANCED FILTERING =========================&#10;&#10;    @Query(&quot;&quot;&quot;&#10;                MATCH (u:User {id: $userId})&#10;                OPTIONAL MATCH (u)-[:ENROLLED_IN]-&gt;(uMajor:Major)&#10;                OPTIONAL MATCH (u)-[:IN_BATCH]-&gt;(uBatch:Batch)&#10;                OPTIONAL MATCH (uMajor)-[:BELONGS_TO]-&gt;(uFaculty:Faculty)&#10;                OPTIONAL MATCH (uFaculty)-[:PART_OF]-&gt;(uCollege:College)&#10;&#10;                MATCH (other:User)&#10;                OPTIONAL MATCH (other)-[:ENROLLED_IN]-&gt;(oMajor:Major)&#10;                OPTIONAL MATCH (other)-[:IN_BATCH]-&gt;(oBatch:Batch)&#10;                OPTIONAL MATCH (oMajor)-[:BELONGS_TO]-&gt;(oFaculty:Faculty)&#10;                OPTIONAL MATCH (oFaculty)-[:PART_OF]-&gt;(oCollege:College)&#10;&#10;                WHERE u.id &lt;&gt; other.id&#10;                  AND ($isSameMajor = false OR uMajor.name = oMajor.name)&#10;                  AND ($isSameBatch = false OR uBatch.year = oBatch.year)&#10;                  AND ($isSameFaculty = false OR uFaculty.name = oFaculty.name)&#10;                  AND ($isSameCollege = false OR uCollege.name = oCollege.name)&#10;&#10;                RETURN DISTINCT other&#10;            &quot;&quot;&quot;)&#10;    List&lt;UserEntity&gt; findUsersWithFilters(&#10;            @Param(&quot;userId&quot;) String userId,&#10;            @Param(&quot;isSameCollege&quot;) boolean isSameCollege,&#10;            @Param(&quot;isSameFaculty&quot;) boolean isSameFaculty,&#10;            @Param(&quot;isSameMajor&quot;) boolean isSameMajor,&#10;            @Param(&quot;isSameBatch&quot;) boolean isSameBatch&#10;    );&#10;&#10;    @Query(&quot;&quot;&quot;&#10;                MATCH (u:User {id: $userId})-[:FRIEND]-(friend:User)&#10;                OPTIONAL MATCH (u)-[:ENROLLED_IN]-&gt;(uMajor:Major)&#10;                OPTIONAL MATCH (friend)-[:ENROLLED_IN]-&gt;(fMajor:Major)&#10;                OPTIONAL MATCH (uMajor)-[:BELONGS_TO]-&gt;(uFaculty:Faculty)&#10;                OPTIONAL MATCH (fMajor)-[:BELONGS_TO]-&gt;(fFaculty:Faculty)&#10;                OPTIONAL MATCH (uFaculty)-[:PART_OF]-&gt;(uCollege:College)&#10;                OPTIONAL MATCH (fFaculty)-[:PART_OF]-&gt;(fCollege:College)&#10;                OPTIONAL MATCH (u)-[:IN_BATCH]-&gt;(uBatch:Batch)&#10;                OPTIONAL MATCH (friend)-[:IN_BATCH]-&gt;(fBatch:Batch)&#10;&#10;                WHERE ($isSameMajor = false OR uMajor.name = fMajor.name)&#10;                  AND ($isSameFaculty = false OR uFaculty.name = fFaculty.name)&#10;                  AND ($isSameCollege = false OR uCollege.name = fCollege.name)&#10;                  AND ($isSameBatch = false OR uBatch.year = fBatch.year)&#10;&#10;                RETURN DISTINCT friend&#10;            &quot;&quot;&quot;)&#10;    List&lt;UserEntity&gt; findFriendsWithFilters(&#10;            @Param(&quot;userId&quot;) String userId,&#10;            @Param(&quot;isSameCollege&quot;) boolean isSameCollege,&#10;            @Param(&quot;isSameFaculty&quot;) boolean isSameFaculty,&#10;            @Param(&quot;isSameMajor&quot;) boolean isSameMajor,&#10;            @Param(&quot;isSameBatch&quot;) boolean isSameBatch&#10;    );&#10;&#10;    // ========================= FRIEND SUGGESTIONS =========================&#10;&#10;    @Query(&quot;&quot;&quot;&#10;                MATCH (u:User {id: $userId})-[:FRIEND]-(friend:User)-[:FRIEND]-(suggestion:User)&#10;                WHERE u.id &lt;&gt; suggestion.id&#10;                  AND NOT (u)-[:FRIEND]-(suggestion)&#10;                  AND NOT (u)-[:FRIEND_REQUEST]-(suggestion)&#10;                RETURN suggestion, COUNT(*) AS mutualFriends&#10;                ORDER BY mutualFriends DESC&#10;                LIMIT 10&#10;            &quot;&quot;&quot;)&#10;    List&lt;UserEntity&gt; findFriendSuggestions(@Param(&quot;userId&quot;) String userId);&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package com.ctuconnect.repository;&#10;&#10;import com.ctuconnect.entity.UserEntity;&#10;import org.springframework.data.neo4j.repository.Neo4jRepository;&#10;import org.springframework.data.neo4j.repository.query.Query;&#10;import org.springframework.data.repository.query.Param;&#10;&#10;import java.util.List;&#10;import java.util.Optional;&#10;&#10;public interface UserRepository extends Neo4jRepository&lt;UserEntity, String&gt; {&#10;&#10;    Optional&lt;UserEntity&gt; findByEmail(String email);&#10;&#10;    Optional&lt;UserEntity&gt; findByUsername(String username);&#10;&#10;    boolean existsByEmail(String email);&#10;&#10;    boolean existsByUsername(String username);&#10;&#10;    @Query(&quot;MATCH (u:User) WHERE u.email = $identifier OR u.username = $identifier RETURN u&quot;)&#10;    Optional&lt;UserEntity&gt; findByEmailOrUsername(@Param(&quot;identifier&quot;) String identifier);&#10;&#10;    @Query(&quot;&quot;&quot;&#10;    MATCH (u:User {id: $userId})&#10;    OPTIONAL MATCH (u)-[:ENROLLED_IN]-&gt;(m:Major)&#10;    OPTIONAL MATCH (u)-[:IN_BATCH]-&gt;(b:Batch)&#10;    OPTIONAL MATCH (u)-[:HAS_GENDER]-&gt;(g:Gender)&#10;    OPTIONAL MATCH (u)-[:ENROLLED_IN]-&gt;(f:Faculty)&#10;    OPTIONAL MATCH (u)-[:ENROLLED_IN]-&gt;(c:College)&#10;    OPTIONAL MATCH (u)-[:WORKS_IN]-&gt;(wf:Faculty)&#10;    OPTIONAL MATCH (u)-[:WORKS_IN]-&gt;(wc:College)&#10;    OPTIONAL MATCH (u)-[:HAS_DEGREE]-&gt;(d:Degree)&#10;    OPTIONAL MATCH (u)-[:HAS_POSITION]-&gt;(p:Position)&#10;    OPTIONAL MATCH (u)-[:HAS_ACADEMIC]-&gt;(a:Academic)&#10;    OPTIONAL MATCH (u)-[:FRIEND]-(friend:User)&#10;    RETURN u, m, b, g, f, c, wf, wc, d, p, a, collect(friend) as friends&#10;&quot;&quot;&quot;)&#10;    Optional&lt;UserEntity&gt; findUserWithAllRelations(@Param(&quot;userId&quot;) String userId);&#10;&#10;&#10;    // ========================= RELATIONSHIP UPDATE METHODS =========================&#10;    &#10;    @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})&#10;        OPTIONAL MATCH (u)-[r:ENROLLED_IN]-&gt;(m:Major)&#10;        DELETE r&#10;        WITH u&#10;        MATCH (newMajor:Major {id: $majorId})&#10;        MERGE (u)-[:ENROLLED_IN]-&gt;(newMajor)&#10;        &quot;&quot;&quot;)&#10;    void updateUserMajor(@Param(&quot;userId&quot;) String userId, @Param(&quot;majorId&quot;) String majorId);&#10;&#10;    @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})&#10;        OPTIONAL MATCH (u)-[r:IN_BATCH]-&gt;(b:Batch)&#10;        DELETE r&#10;        WITH u&#10;        MATCH (newBatch:Batch {id: $batchId})&#10;        MERGE (u)-[:IN_BATCH]-&gt;(newBatch)&#10;        &quot;&quot;&quot;)&#10;    void updateUserBatch(@Param(&quot;userId&quot;) String userId, @Param(&quot;batchId&quot;) String batchId);&#10;&#10;    @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})&#10;        OPTIONAL MATCH (u)-[r:HAS_GENDER]-&gt;(g:Gender)&#10;        DELETE r&#10;        WITH u&#10;        MATCH (newGender:Gender {id: $genderId})&#10;        MERGE (u)-[:HAS_GENDER]-&gt;(newGender)&#10;        &quot;&quot;&quot;)&#10;    void updateUserGender(@Param(&quot;userId&quot;) String userId, @Param(&quot;genderId&quot;) String genderId);&#10;&#10;    @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})&#10;        OPTIONAL MATCH (u)-[r:ENROLLED_IN]-&gt;(f:Faculty)&#10;        DELETE r&#10;        WITH u&#10;        MATCH (newFaculty:Faculty {id: $facultyId})&#10;        MERGE (u)-[:ENROLLED_IN]-&gt;(newFaculty)&#10;        &quot;&quot;&quot;)&#10;    void updateUserFaculty(@Param(&quot;userId&quot;) String userId, @Param(&quot;facultyId&quot;) String facultyId);&#10;&#10;    @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})&#10;        OPTIONAL MATCH (u)-[r:ENROLLED_IN]-&gt;(c:College)&#10;        DELETE r&#10;        WITH u&#10;        MATCH (newCollege:College {id: $collegeId})&#10;        MERGE (u)-[:ENROLLED_IN]-&gt;(newCollege)&#10;        &quot;&quot;&quot;)&#10;    void updateUserCollege(@Param(&quot;userId&quot;) String userId, @Param(&quot;collegeId&quot;) String collegeId);&#10;&#10;    @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})&#10;        OPTIONAL MATCH (u)-[r:WORKS_IN]-&gt;(f:Faculty)&#10;        DELETE r&#10;        WITH u&#10;        MATCH (newFaculty:Faculty {id: $facultyId})&#10;        MERGE (u)-[:WORKS_IN]-&gt;(newFaculty)&#10;        &quot;&quot;&quot;)&#10;    void updateUserWorkingFaculty(@Param(&quot;userId&quot;) String userId, @Param(&quot;facultyId&quot;) String facultyId);&#10;&#10;    @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})&#10;        OPTIONAL MATCH (u)-[r:WORKS_IN]-&gt;(c:College)&#10;        DELETE r&#10;        WITH u&#10;        MATCH (newCollege:College {id: $collegeId})&#10;        MERGE (u)-[:WORKS_IN]-&gt;(newCollege)&#10;        &quot;&quot;&quot;)&#10;    void updateUserWorkingCollege(@Param(&quot;userId&quot;) String userId, @Param(&quot;collegeId&quot;) String collegeId);&#10;&#10;    @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})&#10;        OPTIONAL MATCH (u)-[r:HAS_DEGREE]-&gt;(d:Degree)&#10;        DELETE r&#10;        WITH u&#10;        MATCH (newDegree:Degree {id: $degreeId})&#10;        MERGE (u)-[:HAS_DEGREE]-&gt;(newDegree)&#10;        &quot;&quot;&quot;)&#10;    void updateUserDegree(@Param(&quot;userId&quot;) String userId, @Param(&quot;degreeId&quot;) String degreeId);&#10;&#10;    @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})&#10;        OPTIONAL MATCH (u)-[r:HAS_POSITION]-&gt;(p:Position)&#10;        DELETE r&#10;        WITH u&#10;        MATCH (newPosition:Position {id: $positionId})&#10;        MERGE (u)-[:HAS_POSITION]-&gt;(newPosition)&#10;        &quot;&quot;&quot;)&#10;    void updateUserPosition(@Param(&quot;userId&quot;) String userId, @Param(&quot;positionId&quot;) String positionId);&#10;&#10;    @Query(&quot;&quot;&quot;&#10;        MATCH (u:User {id: $userId})&#10;        OPTIONAL MATCH (u)-[r:HAS_ACADEMIC]-&gt;(a:Academic)&#10;        DELETE r&#10;        WITH u&#10;        MATCH (newAcademic:Academic {id: $academicId})&#10;        MERGE (u)-[:HAS_ACADEMIC]-&gt;(newAcademic)&#10;        &quot;&quot;&quot;)&#10;    void updateUserAcademic(@Param(&quot;userId&quot;) String userId, @Param(&quot;academicId&quot;) String academicId);&#10;&#10;    // ========================= FRIENDSHIPS =========================&#10;&#10;    @Query(&quot;&quot;&quot;&#10;                MATCH (u:User {id: $userId})-[:FRIEND]-(friend:User)&#10;                RETURN friend&#10;            &quot;&quot;&quot;)&#10;    List&lt;UserEntity&gt; findFriends(@Param(&quot;userId&quot;) String userId);&#10;&#10;    @Query(&quot;&quot;&quot;&#10;                MATCH (u1:User {id: $userId1})-[:FRIEND]-(friend:User),&#10;                      (u2:User {id: $userId2})-[:FRIEND]-(friend)&#10;                WHERE friend.id &lt;&gt; $userId1 AND friend.id &lt;&gt; $userId2&#10;                RETURN DISTINCT friend&#10;            &quot;&quot;&quot;)&#10;    List&lt;UserEntity&gt; findMutualFriends(@Param(&quot;userId1&quot;) String userId1, @Param(&quot;userId2&quot;) String userId2);&#10;&#10;    @Query(&quot;&quot;&quot;&#10;                MATCH (u1:User {id: $userId1}), (u2:User {id: $userId2})&#10;                WHERE u1.id &lt;&gt; u2.id&#10;                MERGE (u1)-[:FRIEND_REQUEST {createdAt: datetime(), status: 'PENDING'}]-&gt;(u2)&#10;            &quot;&quot;&quot;)&#10;    void sendFriendRequest(@Param(&quot;userId1&quot;) String userId1, @Param(&quot;userId2&quot;) String userId2);&#10;&#10;    @Query(&quot;&quot;&quot;&#10;                MATCH (u1:User {id: $userId1})-[r:FRIEND_REQUEST {status: 'PENDING'}]-&gt;(u2:User {id: $userId2})&#10;                DELETE r&#10;                MERGE (u1)-[:FRIEND {since: datetime()}]-(u2)&#10;            &quot;&quot;&quot;)&#10;    void acceptFriendRequest(@Param(&quot;userId1&quot;) String userId1, @Param(&quot;userId2&quot;) String userId2);&#10;&#10;    @Query(&quot;&quot;&quot;&#10;                MATCH (u1:User {id: $userId1})-[r:FRIEND_REQUEST]-&gt;(u2:User {id: $userId2})&#10;                DELETE r&#10;            &quot;&quot;&quot;)&#10;    void rejectFriendRequest(@Param(&quot;userId1&quot;) String userId1, @Param(&quot;userId2&quot;) String userId2);&#10;&#10;    @Query(&quot;&quot;&quot;&#10;                MATCH (u1:User {id: $userId1})-[r:FRIEND]-(u2:User {id: $userId2})&#10;                DELETE r&#10;            &quot;&quot;&quot;)&#10;    void deleteFriendship(@Param(&quot;userId1&quot;) String userId1, @Param(&quot;userId2&quot;) String userId2);&#10;&#10;    @Query(&quot;&quot;&quot;&#10;                MATCH (u1:User {id: $userId1})-[:FRIEND]-(u2:User {id: $userId2})&#10;                RETURN COUNT(*) &gt; 0&#10;            &quot;&quot;&quot;)&#10;    boolean areFriends(@Param(&quot;userId1&quot;) String userId1, @Param(&quot;userId2&quot;) String userId2);&#10;&#10;    @Query(&quot;&quot;&quot;&#10;                MATCH (u1:User {id: $userId1})-[:FRIEND_REQUEST {status: 'PENDING'}]-&gt;(u2:User {id: $userId2})&#10;                RETURN COUNT(*) &gt; 0&#10;            &quot;&quot;&quot;)&#10;    boolean hasPendingFriendRequest(@Param(&quot;userId1&quot;) String userId1, @Param(&quot;userId2&quot;) String userId2);&#10;&#10;    // Get friend requests sent TO this user&#10;    @Query(&quot;&quot;&quot;&#10;                MATCH (sender:User)-[:FRIEND_REQUEST {status: 'PENDING'}]-&gt;(u:User {id: $userId})&#10;                RETURN sender&#10;            &quot;&quot;&quot;)&#10;    List&lt;UserEntity&gt; findIncomingFriendRequests(@Param(&quot;userId&quot;) String userId);&#10;&#10;    // Get friend requests sent BY this user&#10;    @Query(&quot;&quot;&quot;&#10;                MATCH (u:User {id: $userId})-[:FRIEND_REQUEST {status: 'PENDING'}]-&gt;(receiver:User)&#10;                RETURN receiver&#10;            &quot;&quot;&quot;)&#10;    List&lt;UserEntity&gt; findOutgoingFriendRequests(@Param(&quot;userId&quot;) String userId);&#10;&#10;    // ========================= FILTER QUERIES =========================&#10;&#10;    @Query(&quot;MATCH (u:User)-[:ENROLLED_IN]-&gt;(m:Major {name: $major}) RETURN u&quot;)&#10;    List&lt;UserEntity&gt; findByMajor(@Param(&quot;major&quot;) String major);&#10;&#10;    @Query(&quot;MATCH (u:User)-[:IN_BATCH]-&gt;(b:Batch {year: $batch}) RETURN u&quot;)&#10;    List&lt;UserEntity&gt; findByBatch(@Param(&quot;batch&quot;) int batch);&#10;&#10;    @Query(&quot;&quot;&quot;&#10;                MATCH (u:User)-[:ENROLLED_IN]-&gt;(:Major)-[:BELONGS_TO]-&gt;(:Faculty {name: $faculty})&#10;                RETURN u&#10;            &quot;&quot;&quot;)&#10;    List&lt;UserEntity&gt; findByFaculty(@Param(&quot;faculty&quot;) String faculty);&#10;&#10;    @Query(&quot;&quot;&quot;&#10;                MATCH (u:User)-[:ENROLLED_IN]-&gt;(:Major)-[:BELONGS_TO]-&gt;(:Faculty)-[:PART_OF]-&gt;(:College {name: $college})&#10;                RETURN u&#10;            &quot;&quot;&quot;)&#10;    List&lt;UserEntity&gt; findByCollege(@Param(&quot;college&quot;) String college);&#10;&#10;    // ========================= SAME ATTRIBUTE QUERIES =========================&#10;&#10;    @Query(&quot;&quot;&quot;&#10;                MATCH (u:User {id: $userId})-[:ENROLLED_IN]-&gt;(m:Major)&lt;-[:ENROLLED_IN]-(other:User)&#10;                WHERE u.id &lt;&gt; other.id&#10;                RETURN other&#10;            &quot;&quot;&quot;)&#10;    List&lt;UserEntity&gt; findUsersWithSameMajor(@Param(&quot;userId&quot;) String userId);&#10;&#10;    @Query(&quot;&quot;&quot;&#10;                MATCH (u:User {id: $userId})-[:IN_BATCH]-&gt;(b:Batch)&lt;-[:IN_BATCH]-(other:User)&#10;                WHERE u.id &lt;&gt; other.id&#10;                RETURN other&#10;            &quot;&quot;&quot;)&#10;    List&lt;UserEntity&gt; findUsersWithSameBatch(@Param(&quot;userId&quot;) String userId);&#10;&#10;    @Query(&quot;&quot;&quot;&#10;                MATCH (u:User {id: $userId})-[:ENROLLED_IN]-&gt;(:Major)-[:BELONGS_TO]-&gt;(f:Faculty)&#10;                MATCH (other:User)-[:ENROLLED_IN]-&gt;(:Major)-[:BELONGS_TO]-&gt;(f)&#10;                WHERE other.id &lt;&gt; $userId&#10;                RETURN other&#10;            &quot;&quot;&quot;)&#10;    List&lt;UserEntity&gt; findUsersWithSameFaculty(@Param(&quot;userId&quot;) String userId);&#10;&#10;    @Query(&quot;&quot;&quot;&#10;                MATCH (u:User {id: $userId})-[:ENROLLED_IN]-&gt;(:Major)-[:BELONGS_TO]-&gt;(:Faculty)-[:PART_OF]-&gt;(c:College)&#10;                MATCH (other:User)-[:ENROLLED_IN]-&gt;(:Major)-[:BELONGS_TO]-&gt;(:Faculty)-[:PART_OF]-&gt;(c)&#10;                WHERE other.id &lt;&gt; $userId&#10;                RETURN other&#10;            &quot;&quot;&quot;)&#10;    List&lt;UserEntity&gt; findUsersWithSameCollege(@Param(&quot;userId&quot;) String userId);&#10;&#10;    // ========================= ADVANCED FILTERING =========================&#10;&#10;    @Query(&quot;&quot;&quot;&#10;                MATCH (u:User {id: $userId})&#10;                OPTIONAL MATCH (u)-[:ENROLLED_IN]-&gt;(uMajor:Major)&#10;                OPTIONAL MATCH (u)-[:IN_BATCH]-&gt;(uBatch:Batch)&#10;                OPTIONAL MATCH (uMajor)-[:BELONGS_TO]-&gt;(uFaculty:Faculty)&#10;                OPTIONAL MATCH (uFaculty)-[:PART_OF]-&gt;(uCollege:College)&#10;            &#10;                MATCH (other:User)&#10;                OPTIONAL MATCH (other)-[:ENROLLED_IN]-&gt;(oMajor:Major)&#10;                OPTIONAL MATCH (other)-[:IN_BATCH]-&gt;(oBatch:Batch)&#10;                OPTIONAL MATCH (oMajor)-[:BELONGS_TO]-&gt;(oFaculty:Faculty)&#10;                OPTIONAL MATCH (oFaculty)-[:PART_OF]-&gt;(oCollege:College)&#10;            &#10;                WHERE u.id &lt;&gt; other.id&#10;                  AND ($isSameMajor = false OR uMajor.name = oMajor.name)&#10;                  AND ($isSameBatch = false OR uBatch.year = oBatch.year)&#10;                  AND ($isSameFaculty = false OR uFaculty.name = oFaculty.name)&#10;                  AND ($isSameCollege = false OR uCollege.name = oCollege.name)&#10;            &#10;                RETURN DISTINCT other&#10;            &quot;&quot;&quot;)&#10;    List&lt;UserEntity&gt; findUsersWithFilters(&#10;            @Param(&quot;userId&quot;) String userId,&#10;            @Param(&quot;isSameCollege&quot;) boolean isSameCollege,&#10;            @Param(&quot;isSameFaculty&quot;) boolean isSameFaculty,&#10;            @Param(&quot;isSameMajor&quot;) boolean isSameMajor,&#10;            @Param(&quot;isSameBatch&quot;) boolean isSameBatch&#10;    );&#10;&#10;    @Query(&quot;&quot;&quot;&#10;                MATCH (u:User {id: $userId})-[:FRIEND]-(friend:User)&#10;                OPTIONAL MATCH (u)-[:ENROLLED_IN]-&gt;(uMajor:Major)&#10;                OPTIONAL MATCH (friend)-[:ENROLLED_IN]-&gt;(fMajor:Major)&#10;                OPTIONAL MATCH (uMajor)-[:BELONGS_TO]-&gt;(uFaculty:Faculty)&#10;                OPTIONAL MATCH (fMajor)-[:BELONGS_TO]-&gt;(fFaculty:Faculty)&#10;                OPTIONAL MATCH (uFaculty)-[:PART_OF]-&gt;(uCollege:College)&#10;                OPTIONAL MATCH (fFaculty)-[:PART_OF]-&gt;(fCollege:College)&#10;                OPTIONAL MATCH (u)-[:IN_BATCH]-&gt;(uBatch:Batch)&#10;                OPTIONAL MATCH (friend)-[:IN_BATCH]-&gt;(fBatch:Batch)&#10;            &#10;                WHERE ($isSameMajor = false OR uMajor.name = fMajor.name)&#10;                  AND ($isSameFaculty = false OR uFaculty.name = fFaculty.name)&#10;                  AND ($isSameCollege = false OR uCollege.name = fCollege.name)&#10;                  AND ($isSameBatch = false OR uBatch.year = fBatch.year)&#10;            &#10;                RETURN DISTINCT friend&#10;            &quot;&quot;&quot;)&#10;    List&lt;UserEntity&gt; findFriendsWithFilters(&#10;            @Param(&quot;userId&quot;) String userId,&#10;            @Param(&quot;isSameCollege&quot;) boolean isSameCollege,&#10;            @Param(&quot;isSameFaculty&quot;) boolean isSameFaculty,&#10;            @Param(&quot;isSameMajor&quot;) boolean isSameMajor,&#10;            @Param(&quot;isSameBatch&quot;) boolean isSameBatch&#10;    );&#10;&#10;    // ========================= FRIEND SUGGESTIONS =========================&#10;&#10;    @Query(&quot;&quot;&quot;&#10;                MATCH (u:User {id: $userId})-[:FRIEND]-(friend:User)-[:FRIEND]-(suggestion:User)&#10;                WHERE u.id &lt;&gt; suggestion.id &#10;                  AND NOT (u)-[:FRIEND]-(suggestion)&#10;                  AND NOT (u)-[:FRIEND_REQUEST]-(suggestion)&#10;                RETURN suggestion, COUNT(*) AS mutualFriends&#10;                ORDER BY mutualFriends DESC&#10;                LIMIT 10&#10;            &quot;&quot;&quot;)&#10;    List&lt;UserEntity&gt; findFriendSuggestions(@Param(&quot;userId&quot;) String userId);&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/user-service/src/main/java/com/ctuconnect/service/UserService.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/user-service/src/main/java/com/ctuconnect/service/UserService.java" />
              <option name="originalContent" value="package com.ctuconnect.service;&#10;&#10;import com.ctuconnect.dto.*;&#10;import com.ctuconnect.entity.UserEntity;&#10;import com.ctuconnect.enums.Role;&#10;import com.ctuconnect.repository.*;&#10;import com.fasterxml.jackson.databind.ObjectMapper;&#10;import jakarta.validation.constraints.NotBlank;&#10;import jakarta.validation.constraints.NotNull;&#10;import lombok.extern.slf4j.Slf4j;&#10;import org.springframework.beans.factory.annotation.Autowired;&#10;import org.springframework.stereotype.Service;&#10;import org.springframework.transaction.annotation.Transactional;&#10;&#10;import java.time.LocalDateTime;&#10;import java.util.List;&#10;import java.util.Objects;&#10;import java.util.Optional;&#10;import java.util.stream.Collectors;&#10;&#10;@Slf4j&#10;@Service&#10;public class UserService {&#10;&#10;    @Autowired&#10;    private UserRepository userRepository;&#10;&#10;    @Autowired&#10;    private UserEventPublisher userEventPublisher;&#10;&#10;    @Autowired&#10;    private MajorRepository majorRepository;&#10;&#10;    @Autowired&#10;    private FacultyRepository facultyRepository;&#10;&#10;    @Autowired&#10;    private BatchRepository batchRepository;&#10;&#10;    @Autowired&#10;    private GenderRepository genderRepository;&#10;&#10;    @Autowired&#10;    private DegreeRepository degreeRepository;&#10;&#10;    @Autowired&#10;    private AcademicRepository academicRepository;&#10;&#10;    @Autowired&#10;    private PositionRepository positionRepository;&#10;&#10;    @Autowired&#10;    private CollegeRepository collegeRepository;&#10;    /**&#10;     * Create a new user&#10;     */&#10;    public UserDTO createUser(UserDTO userDTO) {&#10;        UserEntity userEntity = mapToEntity(userDTO);&#10;        userEntity.setCreatedAt(LocalDateTime.now());&#10;        userEntity.setUpdatedAt(LocalDateTime.now());&#10;&#10;        UserEntity savedUser = userRepository.save(userEntity);&#10;        return mapToDTO(savedUser);&#10;    }&#10;&#10;    /**&#10;     * Get user profile by ID or email (fallback for compatibility)&#10;     */&#10;    public UserDTO getUserProfile(String userIdOrEmail) {&#10;        Optional&lt;UserEntity&gt; userEntity;&#10;&#10;        userEntity = userRepository.findUserWithAllRelations(userIdOrEmail);&#10;&#10;        if (userEntity.isEmpty()) {&#10;            throw new RuntimeException(&quot;User not found with id or email: &quot; + userIdOrEmail);&#10;        }&#10;&#10;        return mapToDTO(userEntity.get());&#10;    }&#10;&#10;&#10;    /**&#10;     * Update user profile by ID or email (fallback for compatibility)&#10;     */&#10;    public UserDTO updateUserProfile(String userIdOrEmail, UserDTO userDTO) {&#10;        Optional&lt;UserEntity&gt; userEntityOpt = userRepository.findById(userIdOrEmail);&#10;&#10;        // If not found by ID, try to find by email (fallback for compatibility)&#10;        if (userEntityOpt.isEmpty()) {&#10;            userEntityOpt = userRepository.findByEmail(userIdOrEmail);&#10;        }&#10;&#10;        if (userEntityOpt.isEmpty()) {&#10;            throw new RuntimeException(&quot;User not found with id or email: &quot; + userIdOrEmail);&#10;        }&#10;&#10;        UserEntity userEntity = userEntityOpt.get();&#10;&#10;        // Update basic profile fields&#10;        if (userDTO.getFullName() != null) userEntity.setFullName(userDTO.getFullName());&#10;        if (userDTO.getEmail() != null) userEntity.setEmail(userDTO.getEmail());&#10;        if (userDTO.getUsername() != null) userEntity.setUsername(userDTO.getUsername());&#10;        if (userDTO.getBio() != null) userEntity.setBio(userDTO.getBio());&#10;&#10;        // Update role safely&#10;        if (userDTO.getRole() != null) {&#10;            try {&#10;                userEntity.setRole(Role.valueOf(userDTO.getRole()));&#10;            } catch (IllegalArgumentException e) {&#10;                // Keep existing role if invalid role provided&#10;            }&#10;        }&#10;&#10;        // Update student-specific fields&#10;        if (userDTO.getStudentId() != null) userEntity.setStudentId(userDTO.getStudentId());&#10;&#10;        // Update faculty-specific fields&#10;        if (userDTO.getStaffCode() != null) userEntity.setStaffCode(userDTO.getStaffCode());&#10;&#10;&#10;        // Update media fields&#10;        if (userDTO.getAvatarUrl() != null) userEntity.setAvatarUrl(userDTO.getAvatarUrl());&#10;        if (userDTO.getBackgroundUrl() != null) userEntity.setBackgroundUrl(userDTO.getBackgroundUrl());&#10;&#10;        // Note: Academic relationships (major, batch, gender, faculty, college)&#10;        // should be handled through separate service methods that properly&#10;        // manage Neo4j relationships rather than direct field updates&#10;&#10;        userEntity.setUpdatedAt(LocalDateTime.now());&#10;        UserEntity updatedUser = userRepository.save(userEntity);&#10;&#10;        // Publish user profile updated event&#10;        userEventPublisher.publishUserProfileUpdatedEvent(&#10;                userIdOrEmail,&#10;                updatedUser.getEmail(),&#10;                updatedUser.getFullName(),&#10;                updatedUser.getFullName(), // firstName - using fullName as we don't have separate first/last names&#10;                &quot;&quot;, // lastName - empty as we're using fullName&#10;                updatedUser.getBio(),&#10;                updatedUser.getAvatarUrl() != null ? updatedUser.getAvatarUrl() : &quot;&quot;&#10;        );&#10;&#10;        return mapToDTO(updatedUser);&#10;    }&#10;    /**&#10;     * Send a friend request - GỬI LỜI MỜI KẾT BẠN&#10;     */&#10;    @Transactional&#10;    public void addFriend(String userId, String friendId) {&#10;        if (userId.equals(friendId)) {&#10;            throw new IllegalArgumentException(&quot;Cannot add yourself as a friend&quot;);&#10;        }&#10;&#10;        // Kiểm tra user tồn tại&#10;        UserEntity user = userRepository.findById(userId)&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;User not found with id: &quot; + userId));&#10;&#10;        UserEntity friend = userRepository.findById(friendId)&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;Friend not found with id: &quot; + friendId));&#10;&#10;        // Kiểm tra đã là bạn bè chưa&#10;        if (userRepository.areFriends(userId, friendId)) {&#10;            throw new IllegalStateException(&quot;Users are already friends&quot;);&#10;        }&#10;&#10;        // Kiểm tra đã có friend request chưa&#10;        if (userRepository.hasPendingFriendRequest(userId, friendId)) {&#10;            throw new IllegalStateException(&quot;Friend request already sent&quot;);&#10;        }&#10;&#10;        // Kiểm tra xem có friend request ngược lại không (để auto-accept)&#10;        if (userRepository.hasPendingFriendRequest(friendId, userId)) {&#10;            // Tự động chấp nhận nếu đã có request ngược lại&#10;            userRepository.acceptFriendRequest(friendId, userId);&#10;&#10;            // Publish friend accepted event&#10;            userEventPublisher.publishUserRelationshipChangedEvent(&#10;                    userId,&#10;                    friendId,&#10;                    &quot;FRIEND_ACCEPTED&quot;,&#10;                    &quot;UPDATED&quot;&#10;            );&#10;        } else {&#10;            // Gửi friend request mới&#10;            userRepository.sendFriendRequest(userId, friendId);&#10;&#10;            // Publish friend request event&#10;            userEventPublisher.publishUserRelationshipChangedEvent(&#10;                    userId,&#10;                    friendId,&#10;                    &quot;FRIEND_REQUEST&quot;,&#10;                    &quot;CREATED&quot;&#10;            );&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get friend requests received by this user - LỜI MỜI KẾT BẠN NHẬN ĐƯỢC&#10;     */&#10;    public List&lt;UserDTO&gt; getFriendRequests(String userId) {&#10;        UserEntity user = userRepository.findById(userId)&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;User not found with id: &quot; + userId));&#10;&#10;        List&lt;UserEntity&gt; incomingRequests = userRepository.findIncomingFriendRequests(userId);&#10;        return incomingRequests.stream()&#10;                .map(this::mapToDTO)&#10;                .collect(Collectors.toList());&#10;    }&#10;&#10;    /**&#10;     * Get friend requests sent by this user - LỜI MỜI KẾT BẠN ĐÃ GỬI&#10;     */&#10;    public List&lt;UserDTO&gt; getFriendRequested(String userId) {&#10;        UserEntity user = userRepository.findById(userId)&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;User not found with id: &quot; + userId));&#10;&#10;        List&lt;UserEntity&gt; outgoingRequests = userRepository.findOutgoingFriendRequests(userId);&#10;        return outgoingRequests.stream()&#10;                .map(this::mapToDTO)&#10;                .collect(Collectors.toList());&#10;    }&#10;&#10;    /**&#10;     * Accept a friend request - CHẤP NHẬN LỜI MỜI KẾT BẠN&#10;     */&#10;    @Transactional&#10;    public void acceptFriendInvite(String userId, String friendId) {&#10;        UserEntity user = userRepository.findById(userId)&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;User not found with id: &quot; + userId));&#10;&#10;        UserEntity friend = userRepository.findById(friendId)&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;Friend not found with id: &quot; + friendId));&#10;&#10;        // Kiểm tra có friend request từ friendId đến userId không&#10;        if (!userRepository.hasPendingFriendRequest(friendId, userId)) {&#10;            throw new IllegalStateException(&quot;No pending friend request from &quot; + friendId);&#10;        }&#10;&#10;        // Chấp nhận friend request&#10;        userRepository.acceptFriendRequest(friendId, userId);&#10;&#10;        // Publish friend accepted event&#10;        userEventPublisher.publishUserRelationshipChangedEvent(&#10;                userId,&#10;                friendId,&#10;                &quot;FRIEND_ACCEPTED&quot;,&#10;                &quot;UPDATED&quot;&#10;        );&#10;    }&#10;&#10;    /**&#10;     * Reject a friend request - TỪ CHỐI LỜI MỜI KẾT BẠN&#10;     */&#10;    @Transactional&#10;    public void rejectFriendInvite(String userId, String friendId) {&#10;        UserEntity user = userRepository.findById(userId)&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;User not found with id: &quot; + userId));&#10;&#10;        UserEntity friend = userRepository.findById(friendId)&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;Friend not found with id: &quot; + friendId));&#10;&#10;        // Kiểm tra có friend request từ friendId đến userId không&#10;        if (!userRepository.hasPendingFriendRequest(friendId, userId)) {&#10;            throw new IllegalStateException(&quot;No pending friend request from &quot; + friendId);&#10;        }&#10;&#10;        // Từ chối friend request&#10;        userRepository.rejectFriendRequest(friendId, userId);&#10;&#10;        // Publish friend rejected event&#10;        userEventPublisher.publishUserRelationshipChangedEvent(&#10;                userId,&#10;                friendId,&#10;                &quot;FRIEND_REQUEST&quot;,&#10;                &quot;REJECTED&quot;&#10;        );&#10;    }&#10;&#10;    /**&#10;     * Remove a friend (unfriend) - HỦY KẾT BẠN&#10;     */&#10;    @Transactional&#10;    public void removeFriend(String userId, String friendId) {&#10;        UserEntity user = userRepository.findById(userId)&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;User not found with id: &quot; + userId));&#10;&#10;        UserEntity friend = userRepository.findById(friendId)&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;Friend not found with id: &quot; + friendId));&#10;&#10;        // Kiểm tra có phải bạn bè không&#10;        if (!userRepository.areFriends(userId, friendId)) {&#10;            throw new IllegalStateException(&quot;Users are not friends&quot;);&#10;        }&#10;&#10;        // Xóa friendship&#10;        userRepository.deleteFriendship(userId, friendId);&#10;&#10;        // Publish friend removed event&#10;        userEventPublisher.publishUserRelationshipChangedEvent(&#10;                userId,&#10;                friendId,&#10;                &quot;FRIEND_REMOVED&quot;,&#10;                &quot;DELETED&quot;&#10;        );&#10;    }&#10;&#10;    /**&#10;     * Get all friends of a user - LẤY DANH SÁCH BẠN BÈ&#10;     */&#10;    public FriendsDTO getFriends(String userId) {&#10;        UserEntity user = userRepository.findById(userId)&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;User not found with id: &quot; + userId));&#10;&#10;        List&lt;UserEntity&gt; friends = userRepository.findFriends(userId);&#10;        List&lt;UserDTO&gt; friendDTOs = friends.stream()&#10;                .map(this::mapToDTO)&#10;                .collect(Collectors.toList());&#10;&#10;        return new FriendsDTO(friendDTOs);&#10;    }&#10;&#10;    /**&#10;     * Get mutual friends between two users - LẤY BẠN CHUNG&#10;     */&#10;    public FriendsDTO getMutualFriends(String userId, String otherUserId) {&#10;        UserEntity user = userRepository.findById(userId)&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;User not found with id: &quot; + userId));&#10;&#10;        UserEntity otherUser = userRepository.findById(otherUserId)&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;Other user not found with id: &quot; + otherUserId));&#10;&#10;        List&lt;UserEntity&gt; mutualFriends = userRepository.findMutualFriends(userId, otherUserId);&#10;        List&lt;UserDTO&gt; mutualFriendDTOs = mutualFriends.stream()&#10;                .map(this::mapToDTO)&#10;                .collect(Collectors.toList());&#10;&#10;        return FriendsDTO.ofMutualFriends(mutualFriendDTOs);&#10;    }&#10;&#10;    /**&#10;     * Get friend suggestions - GỢI Ý KẾT BẠN&#10;     */&#10;    public FriendsDTO getFriendSuggestions(String userId) {&#10;        UserEntity user = userRepository.findById(userId)&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;User not found with id: &quot; + userId));&#10;&#10;        List&lt;UserEntity&gt; suggestions = userRepository.findFriendSuggestions(userId);&#10;        List&lt;UserDTO&gt; suggestionDTOs = suggestions.stream()&#10;                .map(u -&gt; {&#10;                    UserDTO dto = mapToDTO(u);&#10;                    // Calculate mutual friends count&#10;                    List&lt;UserEntity&gt; mutualFriends = userRepository.findMutualFriends(userId, u.getId());&#10;                    dto.setMutualFriendsCount(mutualFriends.size());&#10;&#10;                    // Calculate similarity&#10;                    calculateSimilarityScore(user, u, dto);&#10;                    return dto;&#10;                })&#10;                .collect(Collectors.toList());&#10;&#10;        return FriendsDTO.ofSuggestions(suggestionDTOs);&#10;    }&#10;&#10;    /**&#10;     * Filter users by relationship criteria - LỌC NGƯỜI DÙNG THEO TIÊU CHÍ&#10;     */&#10;    public List&lt;UserDTO&gt; getUsersByRelationshipFilters(String userId, RelationshipFilterDTO filters) {&#10;        UserEntity user = userRepository.findById(userId)&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;User not found with id: &quot; + userId));&#10;&#10;        List&lt;UserEntity&gt; filteredUsers;&#10;&#10;        // Sử dụng Neo4j query để filter hiệu quả&#10;        if (filters.getCollege() != null || filters.getFaculty() != null ||&#10;                filters.getMajor() != null || filters.getBatch() != null) {&#10;&#10;            // Convert filters to boolean flags for Neo4j query&#10;            boolean isSameCollege = filters.getCollege() != null;&#10;            boolean isSameFaculty = filters.getFaculty() != null;&#10;            boolean isSameMajor = filters.getMajor() != null;&#10;            boolean isSameBatch = filters.getBatch() != null;&#10;&#10;            filteredUsers = userRepository.findUsersWithFilters(userId, isSameCollege, isSameFaculty, isSameMajor, isSameBatch);&#10;        } else {&#10;            // If no specific filters, get all users except self&#10;            filteredUsers = userRepository.findAll().stream()&#10;                    .filter(u -&gt; !u.getId().equals(userId))&#10;                    .collect(Collectors.toList());&#10;        }&#10;&#10;        return filteredUsers.stream()&#10;                .filter(u -&gt; matchesFilters(user, u, filters))&#10;                .map(this::mapToDTO)&#10;                .collect(Collectors.toList());&#10;    }&#10;&#10;    /**&#10;     * Get all users (Admin only)&#10;     */&#10;    public List&lt;UserDTO&gt; getAllUsers() {&#10;        return userRepository.findAll().stream()&#10;                .map(this::mapToDTO)&#10;                .collect(Collectors.toList());&#10;    }&#10;&#10;    /**&#10;     * Delete user (Admin only)&#10;     */&#10;    @Transactional&#10;    public void deleteUser(String userId) {&#10;        UserEntity user = userRepository.findById(userId)&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;User not found with id: &quot; + userId));&#10;&#10;        // Xóa tất cả friend relationships và friend requests&#10;        List&lt;UserEntity&gt; friends = userRepository.findFriends(userId);&#10;        for (UserEntity friend : friends) {&#10;            userRepository.deleteFriendship(userId, friend.getId());&#10;        }&#10;&#10;        // Xóa tất cả friend requests (incoming và outgoing)&#10;        List&lt;UserEntity&gt; incomingRequests = userRepository.findIncomingFriendRequests(userId);&#10;        for (UserEntity requester : incomingRequests) {&#10;            userRepository.rejectFriendRequest(requester.getId(), userId);&#10;        }&#10;&#10;        List&lt;UserEntity&gt; outgoingRequests = userRepository.findOutgoingFriendRequests(userId);&#10;        for (UserEntity receiver : outgoingRequests) {&#10;            userRepository.rejectFriendRequest(userId, receiver.getId());&#10;        }&#10;&#10;        // Delete the user&#10;        userRepository.deleteById(userId);&#10;    }&#10;&#10;    /**&#10;     * Calculate similarity score for friend suggestions&#10;     */&#10;    private void calculateSimilarityScore(UserEntity user, UserEntity candidate, UserDTO candidateDTO) {&#10;        // Check similarity attributes using proper getter methods&#10;        candidateDTO.setSameCollege(Objects.equals(user.getCollegeName(), candidate.getCollegeName()));&#10;        candidateDTO.setSameFaculty(Objects.equals(user.getFacultyName(), candidate.getFacultyName()));&#10;        candidateDTO.setSameMajor(Objects.equals(user.getMajorName(), candidate.getMajorName()));&#10;        candidateDTO.setSameBatch(Objects.equals(user.getBatchYear(), candidate.getBatchYear()));&#10;    }&#10;&#10;    /**&#10;     * Check if user matches relationship filters&#10;     */&#10;    private boolean matchesFilters(UserEntity user, UserEntity candidate, RelationshipFilterDTO filters) {&#10;        if (filters.getCollege() != null &amp;&amp; !filters.getCollege().equals(candidate.getCollegeName())) {&#10;            return false;&#10;        }&#10;        if (filters.getFaculty() != null &amp;&amp; !filters.getFaculty().equals(candidate.getFacultyName())) {&#10;            return false;&#10;        }&#10;        if (filters.getMajor() != null &amp;&amp; !filters.getMajor().equals(candidate.getMajorName())) {&#10;            return false;&#10;        }&#10;        if (filters.getBatch() != null &amp;&amp; !filters.getBatch().equals(candidate.getBatchYear())) {&#10;            return false;&#10;        }&#10;        return filters.getGender() == null || filters.getGender().equals(candidate.getGenderName());&#10;    }&#10;&#10;    /**&#10;     * Map UserEntity to UserDTO&#10;     */&#10;    private UserDTO mapToDTO(UserEntity entity) {&#10;        UserDTO dto = new UserDTO();&#10;        dto.setId(entity.getId());&#10;        dto.setEmail(entity.getEmail());&#10;        dto.setUsername(entity.getUsername());&#10;        dto.setFullName(entity.getFullName());&#10;        dto.setRole(entity.getRole() != null ? entity.getRole().toString() : null);&#10;        dto.setBio(entity.getBio());&#10;        dto.setIsActive(entity.getIsActive());&#10;        dto.setIsProfileCompleted(entity.getIsProfileCompleted());&#10;        dto.setCreatedAt(entity.getCreatedAt());&#10;        dto.setUpdatedAt(entity.getUpdatedAt());&#10;&#10;        // Student fields&#10;        dto.setStudentId(entity.getStudentId());&#10;        dto.setMajor(entity.getMajor());&#10;        dto.setBatch(entity.getBatch());&#10;        // Lecturer fields&#10;        dto.setStaffCode(entity.getStaffCode());&#10;        dto.setAcademic(entity.getAcademic());&#10;        dto.setDegree(entity.getDegree());&#10;        dto.setPosition(entity.getPosition());&#10;&#10;        // Common fields&#10;        dto.setFaculty(entity.getFaculty());&#10;        dto.setCollege(entity.getCollege());&#10;        dto.setGender(entity.getGender());&#10;&#10;        // Media fields&#10;        dto.setAvatarUrl(entity.getAvatarUrl());&#10;        dto.setBackgroundUrl(entity.getBackgroundUrl());&#10;&#10;        // Friends mapping&#10;        if (entity.getFriends() != null) {&#10;            dto.setFriendIds(&#10;                    entity.getFriends().stream()&#10;                            .map(UserEntity::getId)&#10;                            .collect(Collectors.toSet())&#10;            );&#10;        }&#10;&#10;        return dto;&#10;    }&#10;&#10;&#10;    /**&#10;     * Map UserDTO to UserEntity&#10;     */&#10;    private UserEntity mapToEntity(UserDTO dto) {&#10;        UserEntity entity = new UserEntity();&#10;        entity.setId(dto.getId());&#10;        entity.setEmail(dto.getEmail());&#10;        entity.setUsername(dto.getUsername());&#10;        entity.setFullName(dto.getFullName());&#10;&#10;        // Handle role conversion safely&#10;        if (dto.getRole() != null) {&#10;            try {&#10;                entity.setRole(Role.valueOf(dto.getRole()));&#10;            } catch (IllegalArgumentException e) {&#10;                entity.setRole(Role.USER); // Default fallback&#10;            }&#10;        }&#10;&#10;        entity.setBio(dto.getBio());&#10;        entity.setIsActive(dto.getIsActive());&#10;&#10;        // Student fields&#10;        entity.setStudentId(dto.getStudentId());&#10;&#10;        // Faculty fields&#10;        entity.setStaffCode(dto.getStaffCode());&#10;&#10;        // Media fields&#10;        entity.setAvatarUrl(dto.getAvatarUrl());&#10;        entity.setBackgroundUrl(dto.getBackgroundUrl());&#10;&#10;        // Note: Relationship mappings (major, batch, gender, etc.) should be handled&#10;        // separately as they require database lookups to establish Neo4j relationships&#10;        // This method only handles direct field mappings&#10;&#10;        return entity;&#10;    }&#10;&#10;    public Boolean checkProfile(String currentUserId) {&#10;        UserEntity userEntity = userRepository.findById(currentUserId)&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;User not found with id: &quot; + currentUserId));&#10;&#10;        // Map to DTO&#10;        UserDTO userDTO = mapToDTO(userEntity);&#10;&#10;        return userDTO.getIsProfileCompleted();&#10;    }&#10;&#10;    /**&#10;     * Update student profile with proper relationship mapping&#10;     */&#10;    @Transactional&#10;    public UserDTO updateStudentProfile(String userId, Object profileRequestObj) {&#10;        try {&#10;            // Convert Object to StudentProfileUpdateRequest&#10;            ObjectMapper mapper = new ObjectMapper();&#10;            StudentProfileUpdateRequest request = mapper.convertValue(profileRequestObj, StudentProfileUpdateRequest.class);&#10;&#10;            UserEntity userEntity = userRepository.findById(userId)&#10;                    .orElseThrow(() -&gt; new RuntimeException(&quot;User not found with id: &quot; + userId));&#10;&#10;            // Update basic fields&#10;            userEntity.setFullName(request.getFullName());&#10;            userEntity.setBio(request.getBio());&#10;            userEntity.setStudentId(request.getStudentId());&#10;            userEntity.setAvatarUrl(request.getAvatarUrl());&#10;            userEntity.setBackgroundUrl(request.getBackgroundUrl());&#10;&#10;            // Update relationships&#10;            updateStudentRelationships(userEntity, request.getMajorCode(), request.getFacultyCode(), request.getCollegeCode(), request.getBatchYear(), request.getGenderCode());&#10;&#10;            userEntity.setIsProfileCompleted(true);&#10;            userEntity.updateTimestamp();&#10;&#10;            UserEntity savedUser = userRepository.save(userEntity);&#10;&#10;            // Publish user updated event&#10;//            userEventPublisher.publishUserUpdatedEvent(savedUser);&#10;&#10;            return mapToDTO(savedUser);&#10;        } catch (Exception e) {&#10;            throw new RuntimeException(&quot;Error updating student profile: &quot; + e.getMessage(), e);&#10;        }&#10;    }&#10;&#10;    private void updateStudentRelationships(UserEntity userEntity, @NotBlank(message = &quot;Major is required&quot;) String majorCode, @NotBlank(message = &quot;Faculty is required&quot;) String facultyCode, @NotBlank(message = &quot;College is required&quot;) String collegeCode, @NotNull(message = &quot;Batch year is required&quot;) String batchYear, @NotBlank(message = &quot;Gender code is required&quot;) String genderCode) {&#10;&#10;        // Reset relationships to prevent duplicates - setting to null will cause Neo4j to delete the relationship&#10;        userEntity.setMajor(null);&#10;        userEntity.setFaculty(null);&#10;        userEntity.setCollege(null);&#10;        userEntity.setBatch(null);&#10;        userEntity.setGender(null);&#10;&#10;        // Save entity to delete existing relationships before creating new ones&#10;        userRepository.save(userEntity);&#10;&#10;        // Update major relationship&#10;        if (majorCode != null &amp;&amp; !majorCode.isEmpty()) {&#10;            majorRepository.findById(majorCode).ifPresentOrElse(&#10;                    userEntity::setMajor,&#10;                    () -&gt; {&#10;                        throw new RuntimeException(&quot;Major not found: &quot; + majorCode);&#10;                    }&#10;            );&#10;        }&#10;&#10;        // Update faculty relationship&#10;        if (facultyCode != null &amp;&amp; !facultyCode.isEmpty()) {&#10;            facultyRepository.findById(facultyCode).ifPresentOrElse(&#10;                    userEntity::setFaculty,&#10;                    () -&gt; {&#10;                        throw new RuntimeException(&quot;Faculty not found: &quot; + facultyCode);&#10;                    }&#10;            );&#10;        }&#10;&#10;        // Update college relationship&#10;        if (collegeCode != null &amp;&amp; !collegeCode.isEmpty()) {&#10;            collegeRepository.findById(collegeCode).ifPresentOrElse(&#10;                    userEntity::setCollege,&#10;                    () -&gt; {&#10;                        throw new RuntimeException(&quot;College not found: &quot; + collegeCode);&#10;                    }&#10;            );&#10;        }&#10;&#10;        // Update batch relationship&#10;        if (batchYear != null) {&#10;            batchRepository.findByYear(batchYear).ifPresentOrElse(&#10;                    userEntity::setBatch,&#10;                    () -&gt; {&#10;                        throw new RuntimeException(&quot;Batch not found: &quot; + batchYear);&#10;                    }&#10;            );&#10;        }&#10;&#10;        // Update gender relationship&#10;        if (genderCode != null &amp;&amp; !genderCode.isEmpty()) {&#10;            genderRepository.findById(genderCode).ifPresentOrElse(&#10;                    userEntity::setGender,&#10;                    () -&gt; {&#10;                        throw new RuntimeException(&quot;Gender not found: &quot; + genderCode);&#10;                    }&#10;            );&#10;        }&#10;&#10;        // Update&#10;    }&#10;&#10;&#10;    /**&#10;     * Update faculty profile with proper relationship mapping&#10;     */&#10;    @Transactional&#10;    public UserDTO updateLecturerProfile(String userId, Object profileRequestObj) {&#10;        try {&#10;            // Convert Object to FacultyProfileUpdateRequest&#10;            ObjectMapper mapper = new ObjectMapper();&#10;            LecturerProfileUpdateRequest request = mapper.convertValue(profileRequestObj, LecturerProfileUpdateRequest.class);&#10;&#10;            UserEntity userEntity = userRepository.findById(userId)&#10;                    .orElseThrow(() -&gt; new RuntimeException(&quot;User not found with id: &quot; + userId));&#10;&#10;            // Update basic fields&#10;            userEntity.setFullName(request.getFullName());&#10;            userEntity.setBio(request.getBio());&#10;            userEntity.setStaffCode(request.getStaffCode());&#10;            userEntity.setAvatarUrl(request.getAvatarUrl());&#10;            userEntity.setBackgroundUrl(request.getBackgroundUrl());&#10;&#10;            // Update relationships&#10;&#10;            updateLecturerRelationships(userEntity, request.getDegreeCode(), request.getAcademicCode(), request.getPositionCode(), request.getFacultyCode(), request.getCollegeCode(), request.getGenderCode());&#10;&#10;            userEntity.setIsProfileCompleted(true);&#10;            userEntity.updateTimestamp();&#10;&#10;            UserEntity savedUser = userRepository.save(userEntity);&#10;&#10;            // Publish user updated event&#10;//            userEventPublisher.publishUserUpdatedEvent(savedUser);&#10;&#10;            return mapToDTO(savedUser);&#10;        } catch (Exception e) {&#10;            throw new RuntimeException(&quot;Error updating faculty profile: &quot; + e.getMessage(), e);&#10;        }&#10;    }&#10;&#10;    private void updateLecturerRelationships(UserEntity userEntity, String degreeCode, String academicCode, @NotBlank(message = &quot;Position is required&quot;) String positionCode, @NotBlank(message = &quot;Working faculty name is required&quot;) String facultyCode, @NotBlank(message = &quot;Working college name is required&quot;) String collegeCode,@NotBlank(message = &quot;Gender code is required&quot;) String genderCode) {&#10;&#10;        // Reset relationships to prevent duplicates - setting to null will cause Neo4j to delete the relationship&#10;        userEntity.setDegree(null);&#10;        userEntity.setAcademic(null);&#10;        userEntity.setPosition(null);&#10;        userEntity.setWorkingFaculty(null);&#10;        userEntity.setWorkingCollege(null);&#10;        userEntity.setGender(null);&#10;&#10;        // Save entity to delete existing relationships before creating new ones&#10;        userRepository.save(userEntity);&#10;&#10;        // Update degree relationship&#10;        if (degreeCode != null &amp;&amp; !degreeCode.isEmpty()) {&#10;            degreeRepository.findById(degreeCode).ifPresentOrElse(&#10;                    userEntity::setDegree,&#10;                    () -&gt; {&#10;                        throw new RuntimeException(&quot;Degree not found: &quot; + degreeCode);&#10;                    }&#10;            );&#10;        }&#10;&#10;        // Update academic relationship&#10;        if (academicCode != null &amp;&amp; !academicCode.isEmpty()) {&#10;            academicRepository.findById(academicCode).ifPresentOrElse(&#10;                    userEntity::setAcademic,&#10;                    () -&gt; {&#10;                        throw new RuntimeException(&quot;Academic not found: &quot; + academicCode);&#10;                    }&#10;            );&#10;        }&#10;&#10;        // Update position relationship&#10;        if (positionCode != null &amp;&amp; !positionCode.isEmpty()) {&#10;            positionRepository.findById(positionCode).ifPresentOrElse(&#10;                    userEntity::setPosition,&#10;                    () -&gt; {&#10;                        throw new RuntimeException(&quot;Position not found: &quot; + positionCode);&#10;                    }&#10;            );&#10;        }&#10;&#10;        // Update faculty relationship&#10;        if (facultyCode != null &amp;&amp; !facultyCode.isEmpty()) {&#10;            facultyRepository.findById(facultyCode).ifPresentOrElse(&#10;                    userEntity::setWorkingFaculty,&#10;                    () -&gt; {&#10;                        throw new RuntimeException(&quot;Faculty not found: &quot; + facultyCode);&#10;                    }&#10;            );&#10;        }&#10;&#10;        // Update college relationship&#10;        if (collegeCode != null &amp;&amp; !collegeCode.isEmpty()) {&#10;            collegeRepository.findById(collegeCode).ifPresentOrElse(&#10;                    userEntity::setWorkingCollege,&#10;                    () -&gt; {&#10;                        throw new RuntimeException(&quot;College not found: &quot; + collegeCode);&#10;                    }&#10;            );&#10;        }&#10;&#10;        // Update gender relationship&#10;        if (genderCode != null &amp;&amp; !genderCode.isEmpty()) {&#10;            genderRepository.findById(genderCode).ifPresentOrElse(&#10;                    userEntity::setGender,&#10;                    () -&gt; {&#10;                        throw new RuntimeException(&quot;Gender not found: &quot; + genderCode);&#10;                    }&#10;            );&#10;        }&#10;&#10;        // Update&#10;    }&#10;&#10;&#10;&#10;}&#10;" />
              <option name="updatedContent" value="package com.ctuconnect.service;&#13;&#10;&#13;&#10;import com.ctuconnect.dto.*;&#13;&#10;import com.ctuconnect.entity.UserEntity;&#13;&#10;import com.ctuconnect.enums.Role;&#13;&#10;import com.ctuconnect.repository.*;&#13;&#10;import com.fasterxml.jackson.databind.ObjectMapper;&#13;&#10;import jakarta.validation.constraints.NotBlank;&#13;&#10;import jakarta.validation.constraints.NotNull;&#13;&#10;import lombok.extern.slf4j.Slf4j;&#13;&#10;import org.springframework.beans.factory.annotation.Autowired;&#13;&#10;import org.springframework.stereotype.Service;&#13;&#10;import org.springframework.transaction.annotation.Transactional;&#13;&#10;&#13;&#10;import java.time.LocalDateTime;&#13;&#10;import java.util.List;&#13;&#10;import java.util.Objects;&#13;&#10;import java.util.Optional;&#13;&#10;import java.util.stream.Collectors;&#13;&#10;&#13;&#10;@Slf4j&#13;&#10;@Service&#13;&#10;public class UserService {&#13;&#10;&#13;&#10;    @Autowired&#13;&#10;    private UserRepository userRepository;&#13;&#10;&#13;&#10;    @Autowired&#13;&#10;    private UserEventPublisher userEventPublisher;&#13;&#10;&#13;&#10;    @Autowired&#13;&#10;    private MajorRepository majorRepository;&#13;&#10;&#13;&#10;    @Autowired&#13;&#10;    private FacultyRepository facultyRepository;&#13;&#10;&#13;&#10;    @Autowired&#13;&#10;    private BatchRepository batchRepository;&#13;&#10;&#13;&#10;    @Autowired&#13;&#10;    private GenderRepository genderRepository;&#13;&#10;&#13;&#10;    @Autowired&#13;&#10;    private DegreeRepository degreeRepository;&#13;&#10;&#13;&#10;    @Autowired&#13;&#10;    private AcademicRepository academicRepository;&#13;&#10;&#13;&#10;    @Autowired&#13;&#10;    private PositionRepository positionRepository;&#13;&#10;&#13;&#10;    @Autowired&#13;&#10;    private CollegeRepository collegeRepository;&#13;&#10;    /**&#13;&#10;     * Create a new user&#13;&#10;     */&#13;&#10;    public UserDTO createUser(UserDTO userDTO) {&#13;&#10;        UserEntity userEntity = mapToEntity(userDTO);&#13;&#10;        userEntity.setCreatedAt(LocalDateTime.now());&#13;&#10;        userEntity.setUpdatedAt(LocalDateTime.now());&#13;&#10;&#13;&#10;        UserEntity savedUser = userRepository.save(userEntity);&#13;&#10;        return mapToDTO(savedUser);&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Get user profile by ID or email (fallback for compatibility)&#13;&#10;     */&#13;&#10;    public UserDTO getUserProfile(String userIdOrEmail) {&#13;&#10;        Optional&lt;UserEntity&gt; userEntity;&#13;&#10;&#13;&#10;        userEntity = userRepository.findUserWithAllRelations(userIdOrEmail);&#13;&#10;&#13;&#10;        if (userEntity.isEmpty()) {&#13;&#10;            throw new RuntimeException(&quot;User not found with id or email: &quot; + userIdOrEmail);&#13;&#10;        }&#13;&#10;&#13;&#10;        return mapToDTO(userEntity.get());&#13;&#10;    }&#13;&#10;&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Update user profile by ID or email (fallback for compatibility)&#13;&#10;     */&#13;&#10;    @Transactional&#13;&#10;    public UserDTO updateUserProfile(String userIdOrEmail, UserDTO userDTO) {&#13;&#10;        Optional&lt;UserEntity&gt; userEntityOpt = userRepository.findById(userIdOrEmail);&#13;&#10;&#13;&#10;        // If not found by ID, try to find by email (fallback for compatibility)&#13;&#10;        if (userEntityOpt.isEmpty()) {&#13;&#10;            userEntityOpt = userRepository.findByEmail(userIdOrEmail);&#13;&#10;        }&#13;&#10;&#13;&#10;        if (userEntityOpt.isEmpty()) {&#13;&#10;            throw new RuntimeException(&quot;User not found with id or email: &quot; + userIdOrEmail);&#13;&#10;        }&#13;&#10;&#13;&#10;        UserEntity userEntity = userEntityOpt.get();&#13;&#10;        String userId = userEntity.getId();&#13;&#10;&#13;&#10;        // Update basic profile fields&#13;&#10;        if (userDTO.getFullName() != null) userEntity.setFullName(userDTO.getFullName());&#13;&#10;        if (userDTO.getEmail() != null) userEntity.setEmail(userDTO.getEmail());&#13;&#10;        if (userDTO.getUsername() != null) userEntity.setUsername(userDTO.getUsername());&#13;&#10;        if (userDTO.getBio() != null) userEntity.setBio(userDTO.getBio());&#13;&#10;&#13;&#10;        // Update role safely&#13;&#10;        if (userDTO.getRole() != null) {&#13;&#10;            try {&#13;&#10;                userEntity.setRole(Role.valueOf(userDTO.getRole()));&#13;&#10;            } catch (IllegalArgumentException e) {&#13;&#10;                // Keep existing role if invalid role provided&#13;&#10;            }&#13;&#10;        }&#13;&#10;&#13;&#10;        // Update student-specific fields&#13;&#10;        if (userDTO.getStudentId() != null) userEntity.setStudentId(userDTO.getStudentId());&#13;&#10;&#13;&#10;        // Update faculty-specific fields&#13;&#10;        if (userDTO.getStaffCode() != null) userEntity.setStaffCode(userDTO.getStaffCode());&#13;&#10;&#13;&#10;        // Update media fields&#13;&#10;        if (userDTO.getAvatarUrl() != null) userEntity.setAvatarUrl(userDTO.getAvatarUrl());&#13;&#10;        if (userDTO.getBackgroundUrl() != null) userEntity.setBackgroundUrl(userDTO.getBackgroundUrl());&#13;&#10;&#13;&#10;        // Update relationships - this fixes the duplicate relationship issue&#13;&#10;        if (userDTO.getMajorId() != null) {&#13;&#10;            updateUserMajor(userId, userDTO.getMajorId());&#13;&#10;        }&#13;&#10;        &#13;&#10;        if (userDTO.getBatchId() != null) {&#13;&#10;            updateUserBatch(userId, userDTO.getBatchId());&#13;&#10;        }&#13;&#10;        &#13;&#10;        if (userDTO.getGenderId() != null) {&#13;&#10;            updateUserGender(userId, userDTO.getGenderId());&#13;&#10;        }&#13;&#10;        &#13;&#10;        if (userDTO.getFacultyId() != null) {&#13;&#10;            if (userEntity.isStudent()) {&#13;&#10;                updateUserFaculty(userId, userDTO.getFacultyId());&#13;&#10;            } else {&#13;&#10;                updateUserWorkingFaculty(userId, userDTO.getFacultyId());&#13;&#10;            }&#13;&#10;        }&#13;&#10;        &#13;&#10;        if (userDTO.getCollegeId() != null) {&#13;&#10;            if (userEntity.isStudent()) {&#13;&#10;                updateUserCollege(userId, userDTO.getCollegeId());&#13;&#10;            } else {&#13;&#10;                updateUserWorkingCollege(userId, userDTO.getCollegeId());&#13;&#10;            }&#13;&#10;        }&#13;&#10;        &#13;&#10;        if (userDTO.getDegreeId() != null) {&#13;&#10;            updateUserDegree(userId, userDTO.getDegreeId());&#13;&#10;        }&#13;&#10;        &#13;&#10;        if (userDTO.getPositionId() != null) {&#13;&#10;            updateUserPosition(userId, userDTO.getPositionId());&#13;&#10;        }&#13;&#10;        &#13;&#10;        if (userDTO.getAcademicId() != null) {&#13;&#10;            updateUserAcademic(userId, userDTO.getAcademicId());&#13;&#10;        }&#13;&#10;&#13;&#10;        userEntity.setUpdatedAt(LocalDateTime.now());&#13;&#10;        UserEntity updatedUser = userRepository.save(userEntity);&#13;&#10;&#13;&#10;        // Publish user profile updated event&#13;&#10;        userEventPublisher.publishUserProfileUpdatedEvent(&#13;&#10;                userIdOrEmail,&#13;&#10;                updatedUser.getEmail(),&#13;&#10;                updatedUser.getFullName(),&#13;&#10;                updatedUser.getFullName(), // firstName - using fullName as we don't have separate first/last names&#13;&#10;                &quot;&quot;, // lastName - empty as we're using fullName&#13;&#10;                updatedUser.getBio(),&#13;&#10;                updatedUser.getAvatarUrl() != null ? updatedUser.getAvatarUrl() : &quot;&quot;&#13;&#10;        );&#13;&#10;&#13;&#10;        return mapToDTO(updatedUser);&#13;&#10;    }&#13;&#10;&#13;&#10;    // ========================= RELATIONSHIP UPDATE METHODS =========================&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Update user's major relationship (for students)&#13;&#10;     */&#13;&#10;    @Transactional&#13;&#10;    public void updateUserMajor(String userId, String majorId) {&#13;&#10;        // Verify user exists&#13;&#10;        userRepository.findById(userId)&#13;&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;User not found with id: &quot; + userId));&#13;&#10;        &#13;&#10;        // Verify major exists&#13;&#10;        majorRepository.findById(majorId)&#13;&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;Major not found with id: &quot; + majorId));&#13;&#10;        &#13;&#10;        // Update relationship - this will delete old relationship and create new one&#13;&#10;        userRepository.updateUserMajor(userId, majorId);&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Update user's batch relationship&#13;&#10;     */&#13;&#10;    @Transactional&#13;&#10;    public void updateUserBatch(String userId, String batchId) {&#13;&#10;        userRepository.findById(userId)&#13;&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;User not found with id: &quot; + userId));&#13;&#10;        &#13;&#10;        batchRepository.findById(batchId)&#13;&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;Batch not found with id: &quot; + batchId));&#13;&#10;        &#13;&#10;        userRepository.updateUserBatch(userId, batchId);&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Update user's gender relationship&#13;&#10;     */&#13;&#10;    @Transactional&#13;&#10;    public void updateUserGender(String userId, String genderId) {&#13;&#10;        userRepository.findById(userId)&#13;&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;User not found with id: &quot; + userId));&#13;&#10;        &#13;&#10;        genderRepository.findById(genderId)&#13;&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;Gender not found with id: &quot; + genderId));&#13;&#10;        &#13;&#10;        userRepository.updateUserGender(userId, genderId);&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Update user's faculty relationship (for students)&#13;&#10;     */&#13;&#10;    @Transactional&#13;&#10;    public void updateUserFaculty(String userId, String facultyId) {&#13;&#10;        userRepository.findById(userId)&#13;&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;User not found with id: &quot; + userId));&#13;&#10;        &#13;&#10;        facultyRepository.findById(facultyId)&#13;&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;Faculty not found with id: &quot; + facultyId));&#13;&#10;        &#13;&#10;        userRepository.updateUserFaculty(userId, facultyId);&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Update user's college relationship (for students)&#13;&#10;     */&#13;&#10;    @Transactional&#13;&#10;    public void updateUserCollege(String userId, String collegeId) {&#13;&#10;        userRepository.findById(userId)&#13;&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;User not found with id: &quot; + userId));&#13;&#10;        &#13;&#10;        collegeRepository.findById(collegeId)&#13;&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;College not found with id: &quot; + collegeId));&#13;&#10;        &#13;&#10;        userRepository.updateUserCollege(userId, collegeId);&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Update user's working faculty relationship (for staff)&#13;&#10;     */&#13;&#10;    @Transactional&#13;&#10;    public void updateUserWorkingFaculty(String userId, String facultyId) {&#13;&#10;        userRepository.findById(userId)&#13;&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;User not found with id: &quot; + userId));&#13;&#10;        &#13;&#10;        facultyRepository.findById(facultyId)&#13;&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;Faculty not found with id: &quot; + facultyId));&#13;&#10;        &#13;&#10;        userRepository.updateUserWorkingFaculty(userId, facultyId);&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Update user's working college relationship (for staff)&#13;&#10;     */&#13;&#10;    @Transactional&#13;&#10;    public void updateUserWorkingCollege(String userId, String collegeId) {&#13;&#10;        userRepository.findById(userId)&#13;&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;User not found with id: &quot; + userId));&#13;&#10;        &#13;&#10;        collegeRepository.findById(collegeId)&#13;&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;College not found with id: &quot; + collegeId));&#13;&#10;        &#13;&#10;        userRepository.updateUserWorkingCollege(userId, collegeId);&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Update user's degree relationship&#13;&#10;     */&#13;&#10;    @Transactional&#13;&#10;    public void updateUserDegree(String userId, String degreeId) {&#13;&#10;        userRepository.findById(userId)&#13;&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;User not found with id: &quot; + userId));&#13;&#10;        &#13;&#10;        degreeRepository.findById(degreeId)&#13;&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;Degree not found with id: &quot; + degreeId));&#13;&#10;        &#13;&#10;        userRepository.updateUserDegree(userId, degreeId);&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Update user's position relationship&#13;&#10;     */&#13;&#10;    @Transactional&#13;&#10;    public void updateUserPosition(String userId, String positionId) {&#13;&#10;        userRepository.findById(userId)&#13;&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;User not found with id: &quot; + userId));&#13;&#10;        &#13;&#10;        positionRepository.findById(positionId)&#13;&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;Position not found with id: &quot; + positionId));&#13;&#10;        &#13;&#10;        userRepository.updateUserPosition(userId, positionId);&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Update user's academic relationship&#13;&#10;     */&#13;&#10;    @Transactional&#13;&#10;    public void updateUserAcademic(String userId, String academicId) {&#13;&#10;        userRepository.findById(userId)&#13;&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;User not found with id: &quot; + userId));&#13;&#10;        &#13;&#10;        academicRepository.findById(academicId)&#13;&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;Academic not found with id: &quot; + academicId));&#13;&#10;        &#13;&#10;        userRepository.updateUserAcademic(userId, academicId);&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Send a friend request - GỬI LỜI MỜI KẾT BẠN&#13;&#10;     */&#13;&#10;    @Transactional&#13;&#10;    public void addFriend(String userId, String friendId) {&#13;&#10;        if (userId.equals(friendId)) {&#13;&#10;            throw new IllegalArgumentException(&quot;Cannot add yourself as a friend&quot;);&#13;&#10;        }&#13;&#10;&#13;&#10;        // Kiểm tra user tồn tại&#13;&#10;        UserEntity user = userRepository.findById(userId)&#13;&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;User not found with id: &quot; + userId));&#13;&#10;&#13;&#10;        UserEntity friend = userRepository.findById(friendId)&#13;&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;Friend not found with id: &quot; + friendId));&#13;&#10;&#13;&#10;        // Kiểm tra đã là bạn bè chưa&#13;&#10;        if (userRepository.areFriends(userId, friendId)) {&#13;&#10;            throw new IllegalStateException(&quot;Users are already friends&quot;);&#13;&#10;        }&#13;&#10;&#13;&#10;        // Kiểm tra đã có friend request chưa&#13;&#10;        if (userRepository.hasPendingFriendRequest(userId, friendId)) {&#13;&#10;            throw new IllegalStateException(&quot;Friend request already sent&quot;);&#13;&#10;        }&#13;&#10;&#13;&#10;        // Kiểm tra xem có friend request ngược lại không (để auto-accept)&#13;&#10;        if (userRepository.hasPendingFriendRequest(friendId, userId)) {&#13;&#10;            // Tự động chấp nhận nếu đã có request ngược lại&#13;&#10;            userRepository.acceptFriendRequest(friendId, userId);&#13;&#10;&#13;&#10;            // Publish friend accepted event&#13;&#10;            userEventPublisher.publishUserRelationshipChangedEvent(&#13;&#10;                    userId,&#13;&#10;                    friendId,&#13;&#10;                    &quot;FRIEND_ACCEPTED&quot;,&#13;&#10;                    &quot;UPDATED&quot;&#13;&#10;            );&#13;&#10;        } else {&#13;&#10;            // Gửi friend request mới&#13;&#10;            userRepository.sendFriendRequest(userId, friendId);&#13;&#10;&#13;&#10;            // Publish friend request event&#13;&#10;            userEventPublisher.publishUserRelationshipChangedEvent(&#13;&#10;                    userId,&#13;&#10;                    friendId,&#13;&#10;                    &quot;FRIEND_REQUEST&quot;,&#13;&#10;                    &quot;CREATED&quot;&#13;&#10;            );&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Get friend requests received by this user - LỜI MỜI KẾT BẠN NHẬN ĐƯỢC&#13;&#10;     */&#13;&#10;    public List&lt;UserDTO&gt; getFriendRequests(String userId) {&#13;&#10;        UserEntity user = userRepository.findById(userId)&#13;&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;User not found with id: &quot; + userId));&#13;&#10;&#13;&#10;        List&lt;UserEntity&gt; incomingRequests = userRepository.findIncomingFriendRequests(userId);&#13;&#10;        return incomingRequests.stream()&#13;&#10;                .map(this::mapToDTO)&#13;&#10;                .collect(Collectors.toList());&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Get friend requests sent by this user - LỜI MỜI KẾT BẠN ĐÃ GỬI&#13;&#10;     */&#13;&#10;    public List&lt;UserDTO&gt; getFriendRequested(String userId) {&#13;&#10;        UserEntity user = userRepository.findById(userId)&#13;&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;User not found with id: &quot; + userId));&#13;&#10;&#13;&#10;        List&lt;UserEntity&gt; outgoingRequests = userRepository.findOutgoingFriendRequests(userId);&#13;&#10;        return outgoingRequests.stream()&#13;&#10;                .map(this::mapToDTO)&#13;&#10;                .collect(Collectors.toList());&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Accept a friend request - CHẤP NHẬN LỜI MỜI KẾT BẠN&#13;&#10;     */&#13;&#10;    @Transactional&#13;&#10;    public void acceptFriendInvite(String userId, String friendId) {&#13;&#10;        UserEntity user = userRepository.findById(userId)&#13;&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;User not found with id: &quot; + userId));&#13;&#10;&#13;&#10;        UserEntity friend = userRepository.findById(friendId)&#13;&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;Friend not found with id: &quot; + friendId));&#13;&#10;&#13;&#10;        // Kiểm tra có friend request từ friendId đến userId không&#13;&#10;        if (!userRepository.hasPendingFriendRequest(friendId, userId)) {&#13;&#10;            throw new IllegalStateException(&quot;No pending friend request from &quot; + friendId);&#13;&#10;        }&#13;&#10;&#13;&#10;        // Chấp nhận friend request&#13;&#10;        userRepository.acceptFriendRequest(friendId, userId);&#13;&#10;&#13;&#10;        // Publish friend accepted event&#13;&#10;        userEventPublisher.publishUserRelationshipChangedEvent(&#13;&#10;                userId,&#13;&#10;                friendId,&#13;&#10;                &quot;FRIEND_ACCEPTED&quot;,&#13;&#10;                &quot;UPDATED&quot;&#13;&#10;        );&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Reject a friend request - TỪ CHỐI LỜI MỜI KẾT BẠN&#13;&#10;     */&#13;&#10;    @Transactional&#13;&#10;    public void rejectFriendInvite(String userId, String friendId) {&#13;&#10;        UserEntity user = userRepository.findById(userId)&#13;&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;User not found with id: &quot; + userId));&#13;&#10;&#13;&#10;        UserEntity friend = userRepository.findById(friendId)&#13;&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;Friend not found with id: &quot; + friendId));&#13;&#10;&#13;&#10;        // Kiểm tra có friend request từ friendId đến userId không&#13;&#10;        if (!userRepository.hasPendingFriendRequest(friendId, userId)) {&#13;&#10;            throw new IllegalStateException(&quot;No pending friend request from &quot; + friendId);&#13;&#10;        }&#13;&#10;&#13;&#10;        // Từ chối friend request&#13;&#10;        userRepository.rejectFriendRequest(friendId, userId);&#13;&#10;&#13;&#10;        // Publish friend rejected event&#13;&#10;        userEventPublisher.publishUserRelationshipChangedEvent(&#13;&#10;                userId,&#13;&#10;                friendId,&#13;&#10;                &quot;FRIEND_REQUEST&quot;,&#13;&#10;                &quot;REJECTED&quot;&#13;&#10;        );&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Remove a friend (unfriend) - HỦY KẾT BẠN&#13;&#10;     */&#13;&#10;    @Transactional&#13;&#10;    public void removeFriend(String userId, String friendId) {&#13;&#10;        UserEntity user = userRepository.findById(userId)&#13;&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;User not found with id: &quot; + userId));&#13;&#10;&#13;&#10;        UserEntity friend = userRepository.findById(friendId)&#13;&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;Friend not found with id: &quot; + friendId));&#13;&#10;&#13;&#10;        // Kiểm tra có phải bạn bè không&#13;&#10;        if (!userRepository.areFriends(userId, friendId)) {&#13;&#10;            throw new IllegalStateException(&quot;Users are not friends&quot;);&#13;&#10;        }&#13;&#10;&#13;&#10;        // Xóa friendship&#13;&#10;        userRepository.deleteFriendship(userId, friendId);&#13;&#10;&#13;&#10;        // Publish friend removed event&#13;&#10;        userEventPublisher.publishUserRelationshipChangedEvent(&#13;&#10;                userId,&#13;&#10;                friendId,&#13;&#10;                &quot;FRIEND_REMOVED&quot;,&#13;&#10;                &quot;DELETED&quot;&#13;&#10;        );&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Get all friends of a user - LẤY DANH SÁCH BẠN BÈ&#13;&#10;     */&#13;&#10;    public FriendsDTO getFriends(String userId) {&#13;&#10;        UserEntity user = userRepository.findById(userId)&#13;&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;User not found with id: &quot; + userId));&#13;&#10;&#13;&#10;        List&lt;UserEntity&gt; friends = userRepository.findFriends(userId);&#13;&#10;        List&lt;UserDTO&gt; friendDTOs = friends.stream()&#13;&#10;                .map(this::mapToDTO)&#13;&#10;                .collect(Collectors.toList());&#13;&#10;&#13;&#10;        return new FriendsDTO(friendDTOs);&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Get mutual friends between two users - LẤY BẠN CHUNG&#13;&#10;     */&#13;&#10;    public FriendsDTO getMutualFriends(String userId, String otherUserId) {&#13;&#10;        UserEntity user = userRepository.findById(userId)&#13;&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;User not found with id: &quot; + userId));&#13;&#10;&#13;&#10;        UserEntity otherUser = userRepository.findById(otherUserId)&#13;&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;Other user not found with id: &quot; + otherUserId));&#13;&#10;&#13;&#10;        List&lt;UserEntity&gt; mutualFriends = userRepository.findMutualFriends(userId, otherUserId);&#13;&#10;        List&lt;UserDTO&gt; mutualFriendDTOs = mutualFriends.stream()&#13;&#10;                .map(this::mapToDTO)&#13;&#10;                .collect(Collectors.toList());&#13;&#10;&#13;&#10;        return FriendsDTO.ofMutualFriends(mutualFriendDTOs);&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Get friend suggestions - GỢI Ý KẾT BẠN&#13;&#10;     */&#13;&#10;    public FriendsDTO getFriendSuggestions(String userId) {&#13;&#10;        UserEntity user = userRepository.findById(userId)&#13;&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;User not found with id: &quot; + userId));&#13;&#10;&#13;&#10;        List&lt;UserEntity&gt; suggestions = userRepository.findFriendSuggestions(userId);&#13;&#10;        List&lt;UserDTO&gt; suggestionDTOs = suggestions.stream()&#13;&#10;                .map(u -&gt; {&#13;&#10;                    UserDTO dto = mapToDTO(u);&#13;&#10;                    // Calculate mutual friends count&#13;&#10;                    List&lt;UserEntity&gt; mutualFriends = userRepository.findMutualFriends(userId, u.getId());&#13;&#10;                    dto.setMutualFriendsCount(mutualFriends.size());&#13;&#10;&#13;&#10;                    // Calculate similarity&#13;&#10;                    calculateSimilarityScore(user, u, dto);&#13;&#10;                    return dto;&#13;&#10;                })&#13;&#10;                .collect(Collectors.toList());&#13;&#10;&#13;&#10;        return FriendsDTO.ofSuggestions(suggestionDTOs);&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Filter users by relationship criteria - LỌC NGƯỜI DÙNG THEO TIÊU CHÍ&#13;&#10;     */&#13;&#10;    public List&lt;UserDTO&gt; getUsersByRelationshipFilters(String userId, RelationshipFilterDTO filters) {&#13;&#10;        UserEntity user = userRepository.findById(userId)&#13;&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;User not found with id: &quot; + userId));&#13;&#10;&#13;&#10;        List&lt;UserEntity&gt; filteredUsers;&#13;&#10;&#13;&#10;        // Sử dụng Neo4j query để filter hiệu quả&#13;&#10;        if (filters.getCollege() != null || filters.getFaculty() != null ||&#13;&#10;                filters.getMajor() != null || filters.getBatch() != null) {&#13;&#10;&#13;&#10;            // Convert filters to boolean flags for Neo4j query&#13;&#10;            boolean isSameCollege = filters.getCollege() != null;&#13;&#10;            boolean isSameFaculty = filters.getFaculty() != null;&#13;&#10;            boolean isSameMajor = filters.getMajor() != null;&#13;&#10;            boolean isSameBatch = filters.getBatch() != null;&#13;&#10;&#13;&#10;            filteredUsers = userRepository.findUsersWithFilters(userId, isSameCollege, isSameFaculty, isSameMajor, isSameBatch);&#13;&#10;        } else {&#13;&#10;            // If no specific filters, get all users except self&#13;&#10;            filteredUsers = userRepository.findAll().stream()&#13;&#10;                    .filter(u -&gt; !u.getId().equals(userId))&#13;&#10;                    .collect(Collectors.toList());&#13;&#10;        }&#13;&#10;&#13;&#10;        return filteredUsers.stream()&#13;&#10;                .filter(u -&gt; matchesFilters(user, u, filters))&#13;&#10;                .map(this::mapToDTO)&#13;&#10;                .collect(Collectors.toList());&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Get all users (Admin only)&#13;&#10;     */&#13;&#10;    public List&lt;UserDTO&gt; getAllUsers() {&#13;&#10;        return userRepository.findAll().stream()&#13;&#10;                .map(this::mapToDTO)&#13;&#10;                .collect(Collectors.toList());&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Delete user (Admin only)&#13;&#10;     */&#13;&#10;    @Transactional&#13;&#10;    public void deleteUser(String userId) {&#13;&#10;        UserEntity user = userRepository.findById(userId)&#13;&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;User not found with id: &quot; + userId));&#13;&#10;&#13;&#10;        // Xóa tất cả friend relationships và friend requests&#13;&#10;        List&lt;UserEntity&gt; friends = userRepository.findFriends(userId);&#13;&#10;        for (UserEntity friend : friends) {&#13;&#10;            userRepository.deleteFriendship(userId, friend.getId());&#13;&#10;        }&#13;&#10;&#13;&#10;        // Xóa tất cả friend requests (incoming và outgoing)&#13;&#10;        List&lt;UserEntity&gt; incomingRequests = userRepository.findIncomingFriendRequests(userId);&#13;&#10;        for (UserEntity requester : incomingRequests) {&#13;&#10;            userRepository.rejectFriendRequest(requester.getId(), userId);&#13;&#10;        }&#13;&#10;&#13;&#10;        List&lt;UserEntity&gt; outgoingRequests = userRepository.findOutgoingFriendRequests(userId);&#13;&#10;        for (UserEntity receiver : outgoingRequests) {&#13;&#10;            userRepository.rejectFriendRequest(userId, receiver.getId());&#13;&#10;        }&#13;&#10;&#13;&#10;        // Delete the user&#13;&#10;        userRepository.deleteById(userId);&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Calculate similarity score for friend suggestions&#13;&#10;     */&#13;&#10;    private void calculateSimilarityScore(UserEntity user, UserEntity candidate, UserDTO candidateDTO) {&#13;&#10;        // Check similarity attributes using proper getter methods&#13;&#10;        candidateDTO.setSameCollege(Objects.equals(user.getCollegeName(), candidate.getCollegeName()));&#13;&#10;        candidateDTO.setSameFaculty(Objects.equals(user.getFacultyName(), candidate.getFacultyName()));&#13;&#10;        candidateDTO.setSameMajor(Objects.equals(user.getMajorName(), candidate.getMajorName()));&#13;&#10;        candidateDTO.setSameBatch(Objects.equals(user.getBatchYear(), candidate.getBatchYear()));&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Check if user matches relationship filters&#13;&#10;     */&#13;&#10;    private boolean matchesFilters(UserEntity user, UserEntity candidate, RelationshipFilterDTO filters) {&#13;&#10;        if (filters.getCollege() != null &amp;&amp; !filters.getCollege().equals(candidate.getCollegeName())) {&#13;&#10;            return false;&#13;&#10;        }&#13;&#10;        if (filters.getFaculty() != null &amp;&amp; !filters.getFaculty().equals(candidate.getFacultyName())) {&#13;&#10;            return false;&#13;&#10;        }&#13;&#10;        if (filters.getMajor() != null &amp;&amp; !filters.getMajor().equals(candidate.getMajorName())) {&#13;&#10;            return false;&#13;&#10;        }&#13;&#10;        if (filters.getBatch() != null &amp;&amp; !filters.getBatch().equals(candidate.getBatchYear())) {&#13;&#10;            return false;&#13;&#10;        }&#13;&#10;        return filters.getGender() == null || filters.getGender().equals(candidate.getGenderName());&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Map UserEntity to UserDTO&#13;&#10;     */&#13;&#10;    private UserDTO mapToDTO(UserEntity entity) {&#13;&#10;        UserDTO dto = new UserDTO();&#13;&#10;        dto.setId(entity.getId());&#13;&#10;        dto.setEmail(entity.getEmail());&#13;&#10;        dto.setUsername(entity.getUsername());&#13;&#10;        dto.setFullName(entity.getFullName());&#13;&#10;        dto.setRole(entity.getRole() != null ? entity.getRole().toString() : null);&#13;&#10;        dto.setBio(entity.getBio());&#13;&#10;        dto.setIsActive(entity.getIsActive());&#13;&#10;        dto.setIsProfileCompleted(entity.getIsProfileCompleted());&#13;&#10;        dto.setCreatedAt(entity.getCreatedAt());&#13;&#10;        dto.setUpdatedAt(entity.getUpdatedAt());&#13;&#10;&#13;&#10;        // Student fields&#13;&#10;        dto.setStudentId(entity.getStudentId());&#13;&#10;        dto.setMajor(entity.getMajor());&#13;&#10;        dto.setBatch(entity.getBatch());&#13;&#10;        // Lecturer fields&#13;&#10;        dto.setStaffCode(entity.getStaffCode());&#13;&#10;        dto.setAcademic(entity.getAcademic());&#13;&#10;        dto.setDegree(entity.getDegree());&#13;&#10;        dto.setPosition(entity.getPosition());&#13;&#10;&#13;&#10;        // Common fields&#13;&#10;        dto.setFaculty(entity.getFaculty());&#13;&#10;        dto.setCollege(entity.getCollege());&#13;&#10;        dto.setGender(entity.getGender());&#13;&#10;&#13;&#10;        // Media fields&#13;&#10;        dto.setAvatarUrl(entity.getAvatarUrl());&#13;&#10;        dto.setBackgroundUrl(entity.getBackgroundUrl());&#13;&#10;&#13;&#10;        // Friends mapping&#13;&#10;        if (entity.getFriends() != null) {&#13;&#10;            dto.setFriendIds(&#13;&#10;                    entity.getFriends().stream()&#13;&#10;                            .map(UserEntity::getId)&#13;&#10;                            .collect(Collectors.toSet())&#13;&#10;            );&#13;&#10;        }&#13;&#10;&#13;&#10;        return dto;&#13;&#10;    }&#13;&#10;&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Map UserDTO to UserEntity&#13;&#10;     */&#13;&#10;    private UserEntity mapToEntity(UserDTO dto) {&#13;&#10;        UserEntity entity = new UserEntity();&#13;&#10;        entity.setId(dto.getId());&#13;&#10;        entity.setEmail(dto.getEmail());&#13;&#10;        entity.setUsername(dto.getUsername());&#13;&#10;        entity.setFullName(dto.getFullName());&#13;&#10;&#13;&#10;        // Handle role conversion safely&#13;&#10;        if (dto.getRole() != null) {&#13;&#10;            try {&#13;&#10;                entity.setRole(Role.valueOf(dto.getRole()));&#13;&#10;            } catch (IllegalArgumentException e) {&#13;&#10;                entity.setRole(Role.USER); // Default fallback&#13;&#10;            }&#13;&#10;        }&#13;&#10;&#13;&#10;        entity.setBio(dto.getBio());&#13;&#10;        entity.setIsActive(dto.getIsActive());&#13;&#10;&#13;&#10;        // Student fields&#13;&#10;        entity.setStudentId(dto.getStudentId());&#13;&#10;&#13;&#10;        // Faculty fields&#13;&#10;        entity.setStaffCode(dto.getStaffCode());&#13;&#10;&#13;&#10;        // Media fields&#13;&#10;        entity.setAvatarUrl(dto.getAvatarUrl());&#13;&#10;        entity.setBackgroundUrl(dto.getBackgroundUrl());&#13;&#10;&#13;&#10;        // Note: Relationship mappings (major, batch, gender, etc.) should be handled&#13;&#10;        // separately as they require database lookups to establish Neo4j relationships&#13;&#10;        // This method only handles direct field mappings&#13;&#10;&#13;&#10;        return entity;&#13;&#10;    }&#13;&#10;&#13;&#10;    public Boolean checkProfile(String currentUserId) {&#13;&#10;        UserEntity userEntity = userRepository.findById(currentUserId)&#13;&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;User not found with id: &quot; + currentUserId));&#13;&#10;&#13;&#10;        // Map to DTO&#13;&#10;        UserDTO userDTO = mapToDTO(userEntity);&#13;&#10;&#13;&#10;        return userDTO.getIsProfileCompleted();&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Update student profile with proper relationship mapping&#13;&#10;     */&#13;&#10;    @Transactional&#13;&#10;    public UserDTO updateStudentProfile(String userId, Object profileRequestObj) {&#13;&#10;        try {&#13;&#10;            // Convert Object to StudentProfileUpdateRequest&#13;&#10;            ObjectMapper mapper = new ObjectMapper();&#13;&#10;            StudentProfileUpdateRequest request = mapper.convertValue(profileRequestObj, StudentProfileUpdateRequest.class);&#13;&#10;&#13;&#10;            UserEntity userEntity = userRepository.findById(userId)&#13;&#10;                    .orElseThrow(() -&gt; new RuntimeException(&quot;User not found with id: &quot; + userId));&#13;&#10;&#13;&#10;            // Update basic fields&#13;&#10;            userEntity.setFullName(request.getFullName());&#13;&#10;            userEntity.setBio(request.getBio());&#13;&#10;            userEntity.setStudentId(request.getStudentId());&#13;&#10;            userEntity.setAvatarUrl(request.getAvatarUrl());&#13;&#10;            userEntity.setBackgroundUrl(request.getBackgroundUrl());&#13;&#10;&#13;&#10;            // Update relationships&#13;&#10;            updateStudentRelationships(userEntity, request.getMajorCode(), request.getFacultyCode(), request.getCollegeCode(), request.getBatchYear(), request.getGenderCode());&#13;&#10;&#13;&#10;            userEntity.setIsProfileCompleted(true);&#13;&#10;            userEntity.updateTimestamp();&#13;&#10;&#13;&#10;            UserEntity savedUser = userRepository.save(userEntity);&#13;&#10;&#13;&#10;            // Publish user updated event&#13;&#10;//            userEventPublisher.publishUserUpdatedEvent(savedUser);&#13;&#10;&#13;&#10;            return mapToDTO(savedUser);&#13;&#10;        } catch (Exception e) {&#13;&#10;            throw new RuntimeException(&quot;Error updating student profile: &quot; + e.getMessage(), e);&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    private void updateStudentRelationships(UserEntity userEntity, @NotBlank(message = &quot;Major is required&quot;) String majorCode, @NotBlank(message = &quot;Faculty is required&quot;) String facultyCode, @NotBlank(message = &quot;College is required&quot;) String collegeCode, @NotNull(message = &quot;Batch year is required&quot;) String batchYear, @NotBlank(message = &quot;Gender code is required&quot;) String genderCode) {&#13;&#10;&#13;&#10;        // Reset relationships to prevent duplicates - setting to null will cause Neo4j to delete the relationship&#13;&#10;        userEntity.setMajor(null);&#13;&#10;        userEntity.setFaculty(null);&#13;&#10;        userEntity.setCollege(null);&#13;&#10;        userEntity.setBatch(null);&#13;&#10;        userEntity.setGender(null);&#13;&#10;&#13;&#10;        // Save entity to delete existing relationships before creating new ones&#13;&#10;        userRepository.save(userEntity);&#13;&#10;&#13;&#10;        // Update major relationship&#13;&#10;        if (majorCode != null &amp;&amp; !majorCode.isEmpty()) {&#13;&#10;            majorRepository.findById(majorCode).ifPresentOrElse(&#13;&#10;                    userEntity::setMajor,&#13;&#10;                    () -&gt; {&#13;&#10;                        throw new RuntimeException(&quot;Major not found: &quot; + majorCode);&#13;&#10;                    }&#13;&#10;            );&#13;&#10;        }&#13;&#10;&#13;&#10;        // Update faculty relationship&#13;&#10;        if (facultyCode != null &amp;&amp; !facultyCode.isEmpty()) {&#13;&#10;            facultyRepository.findById(facultyCode).ifPresentOrElse(&#13;&#10;                    userEntity::setFaculty,&#13;&#10;                    () -&gt; {&#13;&#10;                        throw new RuntimeException(&quot;Faculty not found: &quot; + facultyCode);&#13;&#10;                    }&#13;&#10;            );&#13;&#10;        }&#13;&#10;&#13;&#10;        // Update college relationship&#13;&#10;        if (collegeCode != null &amp;&amp; !collegeCode.isEmpty()) {&#13;&#10;            collegeRepository.findById(collegeCode).ifPresentOrElse(&#13;&#10;                    userEntity::setCollege,&#13;&#10;                    () -&gt; {&#13;&#10;                        throw new RuntimeException(&quot;College not found: &quot; + collegeCode);&#13;&#10;                    }&#13;&#10;            );&#13;&#10;        }&#13;&#10;&#13;&#10;        // Update batch relationship&#13;&#10;        if (batchYear != null) {&#13;&#10;            batchRepository.findByYear(batchYear).ifPresentOrElse(&#13;&#10;                    userEntity::setBatch,&#13;&#10;                    () -&gt; {&#13;&#10;                        throw new RuntimeException(&quot;Batch not found: &quot; + batchYear);&#13;&#10;                    }&#13;&#10;            );&#13;&#10;        }&#13;&#10;&#13;&#10;        // Update gender relationship&#13;&#10;        if (genderCode != null &amp;&amp; !genderCode.isEmpty()) {&#13;&#10;            genderRepository.findById(genderCode).ifPresentOrElse(&#13;&#10;                    userEntity::setGender,&#13;&#10;                    () -&gt; {&#13;&#10;                        throw new RuntimeException(&quot;Gender not found: &quot; + genderCode);&#13;&#10;                    }&#13;&#10;            );&#13;&#10;        }&#13;&#10;&#13;&#10;        // Update&#13;&#10;    }&#13;&#10;&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Update faculty profile with proper relationship mapping&#13;&#10;     */&#13;&#10;    @Transactional&#13;&#10;    public UserDTO updateLecturerProfile(String userId, Object profileRequestObj) {&#13;&#10;        try {&#13;&#10;            // Convert Object to FacultyProfileUpdateRequest&#13;&#10;            ObjectMapper mapper = new ObjectMapper();&#13;&#10;            LecturerProfileUpdateRequest request = mapper.convertValue(profileRequestObj, LecturerProfileUpdateRequest.class);&#13;&#10;&#13;&#10;            UserEntity userEntity = userRepository.findById(userId)&#13;&#10;                    .orElseThrow(() -&gt; new RuntimeException(&quot;User not found with id: &quot; + userId));&#13;&#10;&#13;&#10;            // Update basic fields&#13;&#10;            userEntity.setFullName(request.getFullName());&#13;&#10;            userEntity.setBio(request.getBio());&#13;&#10;            userEntity.setStaffCode(request.getStaffCode());&#13;&#10;            userEntity.setAvatarUrl(request.getAvatarUrl());&#13;&#10;            userEntity.setBackgroundUrl(request.getBackgroundUrl());&#13;&#10;&#13;&#10;            // Update relationships&#13;&#10;&#13;&#10;            updateLecturerRelationships(userEntity, request.getDegreeCode(), request.getAcademicCode(), request.getPositionCode(), request.getFacultyCode(), request.getCollegeCode(), request.getGenderCode());&#13;&#10;&#13;&#10;            userEntity.setIsProfileCompleted(true);&#13;&#10;            userEntity.updateTimestamp();&#13;&#10;&#13;&#10;            UserEntity savedUser = userRepository.save(userEntity);&#13;&#10;&#13;&#10;            // Publish user updated event&#13;&#10;//            userEventPublisher.publishUserUpdatedEvent(savedUser);&#13;&#10;&#13;&#10;            return mapToDTO(savedUser);&#13;&#10;        } catch (Exception e) {&#13;&#10;            throw new RuntimeException(&quot;Error updating faculty profile: &quot; + e.getMessage(), e);&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    private void updateLecturerRelationships(UserEntity userEntity, String degreeCode, String academicCode, @NotBlank(message = &quot;Position is required&quot;) String positionCode, @NotBlank(message = &quot;Working faculty name is required&quot;) String facultyCode, @NotBlank(message = &quot;Working college name is required&quot;) String collegeCode,@NotBlank(message = &quot;Gender code is required&quot;) String genderCode) {&#13;&#10;&#13;&#10;        // Reset relationships to prevent duplicates - setting to null will cause Neo4j to delete the relationship&#13;&#10;        userEntity.setDegree(null);&#13;&#10;        userEntity.setAcademic(null);&#13;&#10;        userEntity.setPosition(null);&#13;&#10;        userEntity.setWorkingFaculty(null);&#13;&#10;        userEntity.setWorkingCollege(null);&#13;&#10;        userEntity.setGender(null);&#13;&#10;&#13;&#10;        // Save entity to delete existing relationships before creating new ones&#13;&#10;        userRepository.save(userEntity);&#13;&#10;&#13;&#10;        // Update degree relationship&#13;&#10;        if (degreeCode != null &amp;&amp; !degreeCode.isEmpty()) {&#13;&#10;            degreeRepository.findById(degreeCode).ifPresentOrElse(&#13;&#10;                    userEntity::setDegree,&#13;&#10;                    () -&gt; {&#13;&#10;                        throw new RuntimeException(&quot;Degree not found: &quot; + degreeCode);&#13;&#10;                    }&#13;&#10;            );&#13;&#10;        }&#13;&#10;&#13;&#10;        // Update academic relationship&#13;&#10;        if (academicCode != null &amp;&amp; !academicCode.isEmpty()) {&#13;&#10;            academicRepository.findById(academicCode).ifPresentOrElse(&#13;&#10;                    userEntity::setAcademic,&#13;&#10;                    () -&gt; {&#13;&#10;                        throw new RuntimeException(&quot;Academic not found: &quot; + academicCode);&#13;&#10;                    }&#13;&#10;            );&#13;&#10;        }&#13;&#10;&#13;&#10;        // Update position relationship&#13;&#10;        if (positionCode != null &amp;&amp; !positionCode.isEmpty()) {&#13;&#10;            positionRepository.findById(positionCode).ifPresentOrElse(&#13;&#10;                    userEntity::setPosition,&#13;&#10;                    () -&gt; {&#13;&#10;                        throw new RuntimeException(&quot;Position not found: &quot; + positionCode);&#13;&#10;                    }&#13;&#10;            );&#13;&#10;        }&#13;&#10;&#13;&#10;        // Update faculty relationship&#13;&#10;        if (facultyCode != null &amp;&amp; !facultyCode.isEmpty()) {&#13;&#10;            facultyRepository.findById(facultyCode).ifPresentOrElse(&#13;&#10;                    userEntity::setWorkingFaculty,&#13;&#10;                    () -&gt; {&#13;&#10;                        throw new RuntimeException(&quot;Faculty not found: &quot; + facultyCode);&#13;&#10;                    }&#13;&#10;            );&#13;&#10;        }&#13;&#10;&#13;&#10;        // Update college relationship&#13;&#10;        if (collegeCode != null &amp;&amp; !collegeCode.isEmpty()) {&#13;&#10;            collegeRepository.findById(collegeCode).ifPresentOrElse(&#13;&#10;                    userEntity::setWorkingCollege,&#13;&#10;                    () -&gt; {&#13;&#10;                        throw new RuntimeException(&quot;College not found: &quot; + collegeCode);&#13;&#10;                    }&#13;&#10;            );&#13;&#10;        }&#13;&#10;&#13;&#10;        // Update gender relationship&#13;&#10;        if (genderCode != null &amp;&amp; !genderCode.isEmpty()) {&#13;&#10;            genderRepository.findById(genderCode).ifPresentOrElse(&#13;&#10;                    userEntity::setGender,&#13;&#10;                    () -&gt; {&#13;&#10;                        throw new RuntimeException(&quot;Gender not found: &quot; + genderCode);&#13;&#10;                    }&#13;&#10;            );&#13;&#10;        }&#13;&#10;&#13;&#10;        // Update&#13;&#10;    }&#13;&#10;&#13;&#10;&#13;&#10;&#13;&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>